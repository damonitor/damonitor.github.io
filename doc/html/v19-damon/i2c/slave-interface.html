

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux I2C slave interface description &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Linux I2C slave interface description</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/i2c/slave-interface.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-i2c-slave-interface-description">
<h1>Linux I2C slave interface description<a class="headerlink" href="#linux-i2c-slave-interface-description" title="Permalink to this headline">¶</a></h1>
<p>by Wolfram Sang &lt;<a class="reference external" href="mailto:wsa&#37;&#52;&#48;sang-engineering&#46;com">wsa<span>&#64;</span>sang-engineering<span>&#46;</span>com</a>&gt; in 2014-15</p>
<p>Linux can also be an I2C slave if the I2C controller in use has slave
functionality. For that to work, one needs slave support in the bus driver plus
a hardware independent software backend providing the actual functionality. An
example for the latter is the slave-eeprom driver, which acts as a dual memory
driver. While another I2C master on the bus can access it like a regular
EEPROM, the Linux I2C slave can access the content via sysfs and handle data as
needed. The backend driver and the I2C bus driver communicate via events. Here
is a small graph visualizing the data flow and the means by which data is
transported. The dotted line marks only one example. The backend could also
use a character device, be in-kernel only, or something completely different:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            e.g. sysfs        I2C slave events        I/O registers
+-----------+   v    +---------+     v     +--------+  v  +------------+
| Userspace +........+ Backend +-----------+ Driver +-----+ Controller |
+-----------+        +---------+           +--------+     +------------+
                                                              | |
----------------------------------------------------------------+--  I2C
--------------------------------------------------------------+----  Bus
</pre></div>
</div>
<p>Note: Technically, there is also the I2C core between the backend and the
driver. However, at this time of writing, the layer is transparent.</p>
<div class="section" id="user-manual">
<h2>User manual<a class="headerlink" href="#user-manual" title="Permalink to this headline">¶</a></h2>
<p>I2C slave backends behave like standard I2C clients. So, you can instantiate
them as described in the document ‘instantiating-devices’. The only difference
is that i2c slave backends have their own address space. So, you have to add
0x1000 to the address you would originally request. An example for
instantiating the slave-eeprom driver from userspace at the 7 bit address 0x64
on bus 1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo slave-24c02 0x1064 &gt; /sys/bus/i2c/devices/i2c-1/new_device
</pre></div>
</div>
<p>Each backend should come with separate documentation to describe its specific
behaviour and setup.</p>
</div>
<div class="section" id="developer-manual">
<h2>Developer manual<a class="headerlink" href="#developer-manual" title="Permalink to this headline">¶</a></h2>
<p>First, the events which are used by the bus driver and the backend will be
described in detail. After that, some implementation hints for extending bus
drivers and writing backends will be given.</p>
<div class="section" id="i2c-slave-events">
<h3>I2C slave events<a class="headerlink" href="#i2c-slave-events" title="Permalink to this headline">¶</a></h3>
<p>The bus driver sends an event to the backend using the following function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ret = i2c_slave_event(client, event, &amp;val)
</pre></div>
</div>
<p>‘client’ describes the I2C slave device. ‘event’ is one of the special event
types described hereafter. ‘val’ holds an u8 value for the data byte to be
read/written and is thus bidirectional. The pointer to val must always be
provided even if val is not used for an event, i.e. don’t use NULL here. ‘ret’
is the return value from the backend. Mandatory events must be provided by the
bus drivers and must be checked for by backend drivers.</p>
<p>Event types:</p>
<ul>
<li><p class="first">I2C_SLAVE_WRITE_REQUESTED (mandatory)</p>
<p>‘val’: unused</p>
<p>‘ret’: always 0</p>
</li>
</ul>
<p>Another I2C master wants to write data to us. This event should be sent once
our own address and the write bit was detected. The data did not arrive yet, so
there is nothing to process or return. Wakeup or initialization probably needs
to be done, though.</p>
<ul>
<li><p class="first">I2C_SLAVE_READ_REQUESTED (mandatory)</p>
<p>‘val’: backend returns first byte to be sent</p>
<p>‘ret’: always 0</p>
</li>
</ul>
<p>Another I2C master wants to read data from us. This event should be sent once
our own address and the read bit was detected. After returning, the bus driver
should transmit the first byte.</p>
<ul>
<li><p class="first">I2C_SLAVE_WRITE_RECEIVED (mandatory)</p>
<p>‘val’: bus driver delivers received byte</p>
<p>‘ret’: 0 if the byte should be acked, some errno if the byte should be nacked</p>
</li>
</ul>
<p>Another I2C master has sent a byte to us which needs to be set in ‘val’. If ‘ret’
is zero, the bus driver should ack this byte. If ‘ret’ is an errno, then the byte
should be nacked.</p>
<ul>
<li><p class="first">I2C_SLAVE_READ_PROCESSED (mandatory)</p>
<p>‘val’: backend returns next byte to be sent</p>
<p>‘ret’: always 0</p>
</li>
</ul>
<p>The bus driver requests the next byte to be sent to another I2C master in
‘val’. Important: This does not mean that the previous byte has been acked, it
only means that the previous byte is shifted out to the bus! To ensure seamless
transmission, most hardware requests the next byte when the previous one is
still shifted out. If the master sends NACK and stops reading after the byte
currently shifted out, this byte requested here is never used. It very likely
needs to be sent again on the next I2C_SLAVE_READ_REQUEST, depending a bit on
your backend, though.</p>
<ul>
<li><p class="first">I2C_SLAVE_STOP (mandatory)</p>
<p>‘val’: unused</p>
<p>‘ret’: always 0</p>
</li>
</ul>
<p>A stop condition was received. This can happen anytime and the backend should
reset its state machine for I2C transfers to be able to receive new requests.</p>
</div>
<div class="section" id="software-backends">
<h3>Software backends<a class="headerlink" href="#software-backends" title="Permalink to this headline">¶</a></h3>
<p>If you want to write a software backend:</p>
<ul class="simple">
<li>use a standard i2c_driver and its matching mechanisms</li>
<li>write the slave_callback which handles the above slave events
(best using a state machine)</li>
<li>register this callback via i2c_slave_register()</li>
</ul>
<p>Check the i2c-slave-eeprom driver as an example.</p>
</div>
<div class="section" id="bus-driver-support">
<h3>Bus driver support<a class="headerlink" href="#bus-driver-support" title="Permalink to this headline">¶</a></h3>
<p>If you want to add slave support to the bus driver:</p>
<ul class="simple">
<li>implement calls to register/unregister the slave and add those to the
struct i2c_algorithm. When registering, you probably need to set the I2C
slave address and enable slave specific interrupts. If you use runtime pm, you
should use pm_runtime_get_sync() because your device usually needs to be
powered on always to be able to detect its slave address. When unregistering,
do the inverse of the above.</li>
<li>Catch the slave interrupts and send appropriate i2c_slave_events to the backend.</li>
</ul>
<p>Note that most hardware supports being master _and_ slave on the same bus. So,
if you extend a bus driver, please make sure that the driver supports that as
well. In almost all cases, slave support does not need to disable the master
functionality.</p>
<p>Check the i2c-rcar driver as an example.</p>
</div>
<div class="section" id="about-ack-nack">
<h3>About ACK/NACK<a class="headerlink" href="#about-ack-nack" title="Permalink to this headline">¶</a></h3>
<p>It is good behaviour to always ACK the address phase, so the master knows if a
device is basically present or if it mysteriously disappeared. Using NACK to
state being busy is troublesome. SMBus demands to always ACK the address phase,
while the I2C specification is more loose on that. Most I2C controllers also
automatically ACK when detecting their slave addresses, so there is no option
to NACK them. For those reasons, this API does not support NACK in the address
phase.</p>
<p>Currently, there is no slave event to report if the master did ACK or NACK a
byte when it reads from us. We could make this an optional event if the need
arises. However, cases should be extremely rare because the master is expected
to send STOP after that and we have an event for that. Also, keep in mind not
all I2C controllers have the possibility to report that event.</p>
</div>
<div class="section" id="about-buffers">
<h3>About buffers<a class="headerlink" href="#about-buffers" title="Permalink to this headline">¶</a></h3>
<p>During development of this API, the question of using buffers instead of just
bytes came up. Such an extension might be possible, usefulness is unclear at
this time of writing. Some points to keep in mind when using buffers:</p>
<ul class="simple">
<li>Buffers should be opt-in and backend drivers will always have to support
byte-based transactions as the ultimate fallback anyhow because this is how
the majority of HW works.</li>
<li>For backends simulating hardware registers, buffers are largely not helpful
because after each byte written an action should be immediately triggered.
For reads, the data kept in the buffer might get stale if the backend just
updated a register because of internal processing.</li>
<li>A master can send STOP at any time. For partially transferred buffers, this
means additional code to handle this exception. Such code tends to be
error-prone.</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>