

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux Drivers for Baycom Modems &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Linux Drivers for Baycom Modems</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/baycom.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-drivers-for-baycom-modems">
<h1>Linux Drivers for Baycom Modems<a class="headerlink" href="#linux-drivers-for-baycom-modems" title="Permalink to this headline">¶</a></h1>
<p>Thomas M. Sailer, HB9JNX/AE4WA, &lt;<a class="reference external" href="mailto:sailer&#37;&#52;&#48;ife&#46;ee&#46;ethz&#46;ch">sailer<span>&#64;</span>ife<span>&#46;</span>ee<span>&#46;</span>ethz<span>&#46;</span>ch</a>&gt;</p>
<p>The drivers for the baycom modems have been split into
separate drivers as they did not share any code, and the driver
and device names have changed.</p>
<p>This document describes the Linux Kernel Drivers for simple Baycom style
amateur radio modems.</p>
<div class="section" id="the-following-drivers-are-available">
<h2>The following drivers are available:<a class="headerlink" href="#the-following-drivers-are-available" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>baycom_ser_fdx:</dt>
<dd>This driver supports the SER12 modems either full or half duplex.
Its baud rate may be changed via the <code class="docutils literal notranslate"><span class="pre">baud</span></code> module parameter,
therefore it supports just about every bit bang modem on a
serial port. Its devices are called bcsf0 through bcsf3.
This is the recommended driver for SER12 type modems,
however if you have a broken UART clone that does not have working
delta status bits, you may try baycom_ser_hdx.</dd>
<dt>baycom_ser_hdx:</dt>
<dd>This is an alternative driver for SER12 type modems.
It only supports half duplex, and only 1200 baud. Its devices
are called bcsh0 through bcsh3. Use this driver only if baycom_ser_fdx
does not work with your UART.</dd>
<dt>baycom_par:</dt>
<dd>This driver supports the par96 and picpar modems.
Its devices are called bcp0 through bcp3.</dd>
<dt>baycom_epp:</dt>
<dd>This driver supports the EPP modem.
Its devices are called bce0 through bce3.
This driver is work-in-progress.</dd>
</dl>
<p>The following modems are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ser12</td>
<td>This is a very simple 1200 baud AFSK modem. The modem consists only
of a modulator/demodulator chip, usually a TI TCM3105. The computer
is responsible for regenerating the receiver bit clock, as well as
for handling the HDLC protocol. The modem connects to a serial port,
hence the name. Since the serial port is not used as an async serial
port, the kernel driver for serial ports cannot be used, and this
driver only supports standard serial hardware (8250, 16450, 16550)</td>
</tr>
<tr class="row-even"><td>par96</td>
<td>This is a modem for 9600 baud FSK compatible to the G3RUH standard.
The modem does all the filtering and regenerates the receiver clock.
Data is transferred from and to the PC via a shift register.
The shift register is filled with 16 bits and an interrupt is signalled.
The PC then empties the shift register in a burst. This modem connects
to the parallel port, hence the name. The modem leaves the
implementation of the HDLC protocol and the scrambler polynomial to
the PC.</td>
</tr>
<tr class="row-odd"><td>picpar</td>
<td>This is a redesign of the par96 modem by Henning Rech, DF9IC. The modem
is protocol compatible to par96, but uses only three low power ICs
and can therefore be fed from the parallel port and does not require
an additional power supply. Furthermore, it incorporates a carrier
detect circuitry.</td>
</tr>
<tr class="row-even"><td>EPP</td>
<td><p class="first">This is a high-speed modem adaptor that connects to an enhanced parallel
port.</p>
<p class="last">Its target audience is users working over a high speed hub (76.8kbit/s).</p>
</td>
</tr>
<tr class="row-odd"><td>eppfpga</td>
<td>This is a redesign of the EPP adaptor.</td>
</tr>
</tbody>
</table>
<p>All of the above modems only support half duplex communications. However,
the driver supports the KISS (see below) fullduplex command. It then simply
starts to send as soon as there’s a packet to transmit and does not care
about DCD, i.e. it starts to send even if there’s someone else on the channel.
This command is required by some implementations of the DAMA channel
access protocol.</p>
</div>
<div class="section" id="the-interface-of-the-drivers">
<h2>The Interface of the drivers<a class="headerlink" href="#the-interface-of-the-drivers" title="Permalink to this headline">¶</a></h2>
<p>Unlike previous drivers, these drivers are no longer character devices,
but they are now true kernel network interfaces. Installation is therefore
simple. Once installed, four interfaces named bc{sf,sh,p,e}[0-3] are available.
sethdlc from the ax25 utilities may be used to set driver states etc.
Users of userland AX.25 stacks may use the net2kiss utility (also available
in the ax25 utilities package) to convert packets of a network interface
to a KISS stream on a pseudo tty. There’s also a patch available from
me for WAMPES which allows attaching a kernel network interface directly.</p>
</div>
<div class="section" id="configuring-the-driver">
<h2>Configuring the driver<a class="headerlink" href="#configuring-the-driver" title="Permalink to this headline">¶</a></h2>
<p>Every time a driver is inserted into the kernel, it has to know which
modems it should access at which ports. This can be done with the setbaycom
utility. If you are only using one modem, you can also configure the
driver from the insmod command line (or by means of an option line in
<code class="docutils literal notranslate"><span class="pre">/etc/modprobe.d/*.conf</span></code>).</p>
<p>Examples:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>modprobe baycom_ser_fdx mode=&quot;ser12*&quot; iobase=0x3f8 irq=4
sethdlc -i bcsf0 -p mode &quot;ser12*&quot; io 0x3f8 irq 4
</pre></div>
</div>
<p>Both lines configure the first port to drive a ser12 modem at the first
serial port (COM1 under DOS). The * in the mode parameter instructs the driver
to use the software DCD algorithm (see below):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>insmod baycom_par mode=&quot;picpar&quot; iobase=0x378
sethdlc -i bcp0 -p mode &quot;picpar&quot; io 0x378
</pre></div>
</div>
<p>Both lines configure the first port to drive a picpar modem at the
first parallel port (LPT1 under DOS). (Note: picpar implies
hardware DCD, par96 implies software DCD).</p>
<p>The channel access parameters can be set with sethdlc -a or kissparms.
Note that both utilities interpret the values slightly differently.</p>
</div>
<div class="section" id="hardware-dcd-versus-software-dcd">
<h2>Hardware DCD versus Software DCD<a class="headerlink" href="#hardware-dcd-versus-software-dcd" title="Permalink to this headline">¶</a></h2>
<p>To avoid collisions on the air, the driver must know when the channel is
busy. This is the task of the DCD circuitry/software. The driver may either
utilise a software DCD algorithm (options=1) or use a DCD signal from
the hardware (options=0).</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ser12</td>
<td>if software DCD is utilised, the radio’s squelch should always be
open. It is highly recommended to use the software DCD algorithm,
as it is much faster than most hardware squelch circuitry. The
disadvantage is a slightly higher load on the system.</td>
</tr>
<tr class="row-even"><td>par96</td>
<td>the software DCD algorithm for this type of modem is rather poor.
The modem simply does not provide enough information to implement
a reasonable DCD algorithm in software. Therefore, if your radio
feeds the DCD input of the PAR96 modem, the use of the hardware
DCD circuitry is recommended.</td>
</tr>
<tr class="row-odd"><td>picpar</td>
<td>the picpar modem features a builtin DCD hardware, which is highly
recommended.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="compatibility-with-the-rest-of-the-linux-kernel">
<h2>Compatibility with the rest of the Linux kernel<a class="headerlink" href="#compatibility-with-the-rest-of-the-linux-kernel" title="Permalink to this headline">¶</a></h2>
<p>The serial driver and the baycom serial drivers compete
for the same hardware resources. Of course only one driver can access a given
interface at a time. The serial driver grabs all interfaces it can find at
startup time. Therefore the baycom drivers subsequently won’t be able to
access a serial port. You might therefore find it necessary to release
a port owned by the serial driver with ‘setserial /dev/ttyS# uart none’, where
# is the number of the interface. The baycom drivers do not reserve any
ports at startup, unless one is specified on the ‘insmod’ command line. Another
method to solve the problem is to compile all drivers as modules and
leave it to kmod to load the correct driver depending on the application.</p>
<p>The parallel port drivers (baycom_par, baycom_epp) now use the parport subsystem
to arbitrate the ports between different client drivers.</p>
<p>vy 73s de</p>
<p>Tom Sailer, <a class="reference external" href="mailto:sailer&#37;&#52;&#48;ife&#46;ee&#46;ethz&#46;ch">sailer<span>&#64;</span>ife<span>&#46;</span>ee<span>&#46;</span>ethz<span>&#46;</span>ch</a></p>
<p>hb9jnx &#64; hb9w.ampr.org</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>