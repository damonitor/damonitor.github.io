

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>CAIF SPI porting &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>CAIF SPI porting</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/networking/caif/spi_porting.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="caif-spi-porting">
<h1>CAIF SPI porting<a class="headerlink" href="#caif-spi-porting" title="Permalink to this headline">¶</a></h1>
<div class="section" id="caif-spi-basics">
<h2>CAIF SPI basics<a class="headerlink" href="#caif-spi-basics" title="Permalink to this headline">¶</a></h2>
<p>Running CAIF over SPI needs some extra setup, owing to the nature of SPI.
Two extra GPIOs have been added in order to negotiate the transfers
between the master and the slave. The minimum requirement for running
CAIF over SPI is a SPI slave chip and two GPIOs (more details below).
Please note that running as a slave implies that you need to keep up
with the master clock. An overrun or underrun event is fatal.</p>
</div>
<div class="section" id="caif-spi-framework">
<h2>CAIF SPI framework<a class="headerlink" href="#caif-spi-framework" title="Permalink to this headline">¶</a></h2>
<p>To make porting as easy as possible, the CAIF SPI has been divided in
two parts. The first part (called the interface part) deals with all
generic functionality such as length framing, SPI frame negotiation
and SPI frame delivery and transmission. The other part is the CAIF
SPI slave device part, which is the module that you have to write if
you want to run SPI CAIF on a new hardware. This part takes care of
the physical hardware, both with regard to SPI and to GPIOs.</p>
<ul>
<li><p class="first">Implementing a CAIF SPI device:</p>
<blockquote>
<div><ul class="simple">
<li>Functionality provided by the CAIF SPI slave device:</li>
</ul>
<p>In order to implement a SPI device you will, as a minimum,
need to implement the following
functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*init_xfer) (struct cfspi_xfer * xfer, struct cfspi_dev *dev):
</pre></div>
</div>
<p>This function is called by the CAIF SPI interface to give
you a chance to set up your hardware to be ready to receive
a stream of data from the master. The xfer structure contains
both physical and logical addresses, as well as the total length
of the transfer in both directions.The dev parameter can be used
to map to different CAIF SPI slave devices.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*sig_xfer) (bool xfer, struct cfspi_dev *dev):
</pre></div>
</div>
<p>This function is called by the CAIF SPI interface when the output
(SPI_INT) GPIO needs to change state. The boolean value of the xfer
variable indicates whether the GPIO should be asserted (HIGH) or
deasserted (LOW). The dev parameter can be used to map to different CAIF
SPI slave devices.</p>
<ul class="simple">
<li>Functionality provided by the CAIF SPI interface:</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*ss_cb) (bool assert, struct cfspi_ifc *ifc);
</pre></div>
</div>
<p>This function is called by the CAIF SPI slave device in order to
signal a change of state of the input GPIO (SS) to the interface.
Only active edges are mandatory to be reported.
This function can be called from IRQ context (recommended in order
not to introduce latency). The ifc parameter should be the pointer
returned from the platform probe function in the SPI device structure.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*xfer_done_cb) (struct cfspi_ifc *ifc);
</pre></div>
</div>
<p>This function is called by the CAIF SPI slave device in order to
report that a transfer is completed. This function should only be
called once both the transmission and the reception are completed.
This function can be called from IRQ context (recommended in order
not to introduce latency). The ifc parameter should be the pointer
returned from the platform probe function in the SPI device structure.</p>
<ul>
<li><p class="first">Connecting the bits and pieces:</p>
<blockquote>
<div><ul>
<li><p class="first">Filling in the SPI slave device structure:</p>
<p>Connect the necessary callback functions.</p>
<p>Indicate clock speed (used to calculate toggle delays).</p>
<p>Chose a suitable name (helps debugging if you use several CAIF
SPI slave devices).</p>
<p>Assign your private data (can be used to map to your
structure).</p>
</li>
<li><p class="first">Filling in the SPI slave platform device structure:</p>
<p>Add name of driver to connect to (“cfspi_sspi”).</p>
<p>Assign the SPI slave device structure as platform data.</p>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="padding">
<h2>Padding<a class="headerlink" href="#padding" title="Permalink to this headline">¶</a></h2>
<p>In order to optimize throughput, a number of SPI padding options are provided.
Padding can be enabled independently for uplink and downlink transfers.
Padding can be enabled for the head, the tail and for the total frame size.
The padding needs to be correctly configured on both sides of the link.
The padding can be changed via module parameters in cfspi_sspi.c or via
the sysfs directory of the cfspi_sspi driver (before device registration).</p>
<ul>
<li><p class="first">CAIF SPI device template:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
*   Copyright (C) ST-Ericsson AB 2010
*   Author: Daniel Martensson / Daniel.Martensson@stericsson.com
*   License terms: GNU General Public License (GPL), version 2.
*
*/

#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/wait.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/dma-mapping.h&gt;
#include &lt;net/caif/caif_spi.h&gt;

MODULE_LICENSE(&quot;GPL&quot;);

struct sspi_struct {
        struct cfspi_dev sdev;
        struct cfspi_xfer *xfer;
};

static struct sspi_struct slave;
static struct platform_device slave_device;

static irqreturn_t sspi_irq(int irq, void *arg)
{
        /* You only need to trigger on an edge to the active state of the
        * SS signal. Once a edge is detected, the ss_cb() function should be
        * called with the parameter assert set to true. It is OK
        * (and even advised) to call the ss_cb() function in IRQ context in
        * order not to add any delay. */

        return IRQ_HANDLED;
}

static void sspi_complete(void *context)
{
        /* Normally the DMA or the SPI framework will call you back
        * in something similar to this. The only thing you need to
        * do is to call the xfer_done_cb() function, providing the pointer
        * to the CAIF SPI interface. It is OK to call this function
        * from IRQ context. */
}

static int sspi_init_xfer(struct cfspi_xfer *xfer, struct cfspi_dev *dev)
{
        /* Store transfer info. For a normal implementation you should
        * set up your DMA here and make sure that you are ready to
        * receive the data from the master SPI. */

        struct sspi_struct *sspi = (struct sspi_struct *)dev-&gt;priv;

        sspi-&gt;xfer = xfer;

        return 0;
}

void sspi_sig_xfer(bool xfer, struct cfspi_dev *dev)
{
        /* If xfer is true then you should assert the SPI_INT to indicate to
        * the master that you are ready to receive the data from the master
        * SPI. If xfer is false then you should de-assert SPI_INT to indicate
        * that the transfer is done.
        */

        struct sspi_struct *sspi = (struct sspi_struct *)dev-&gt;priv;
}

static void sspi_release(struct device *dev)
{
        /*
        * Here you should release your SPI device resources.
        */
}

static int __init sspi_init(void)
{
        /* Here you should initialize your SPI device by providing the
        * necessary functions, clock speed, name and private data. Once
        * done, you can register your device with the
        * platform_device_register() function. This function will return
        * with the CAIF SPI interface initialized. This is probably also
        * the place where you should set up your GPIOs, interrupts and SPI
        * resources. */

        int res = 0;

        /* Initialize slave device. */
        slave.sdev.init_xfer = sspi_init_xfer;
        slave.sdev.sig_xfer = sspi_sig_xfer;
        slave.sdev.clk_mhz = 13;
        slave.sdev.priv = &amp;slave;
        slave.sdev.name = &quot;spi_sspi&quot;;
        slave_device.dev.release = sspi_release;

        /* Initialize platform device. */
        slave_device.name = &quot;cfspi_sspi&quot;;
        slave_device.dev.platform_data = &amp;slave.sdev;

        /* Register platform device. */
        res = platform_device_register(&amp;slave_device);
        if (res) {
                printk(KERN_WARNING &quot;sspi_init: failed to register dev.\n&quot;);
                return -ENODEV;
        }

        return res;
}

static void __exit sspi_exit(void)
{
        platform_device_del(&amp;slave_device);
}

module_init(sspi_init);
module_exit(sspi_exit);
</pre></div>
</div>
</li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>