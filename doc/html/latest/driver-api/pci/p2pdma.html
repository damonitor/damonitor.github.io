

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PCI Peer-to-Peer DMA Support &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Serial Peripheral Interface (SPI)" href="../spi.html" />
    <link rel="prev" title="PCI Support Library" href="pci.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">The Linux PCI driver implementer’s API guide</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">PCI Peer-to-Peer DMA Support</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#driver-writer-s-guide">Driver Writer’s Guide</a></li>
<li class="toctree-l4"><a class="reference internal" href="#p2p-dma-support-library">P2P DMA Support Library</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edid.html">EDID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lightnvm-pblk.html">pblk: Physical Block Device Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pti_intel_mid.html">Intel MID PTI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../smsc_ece1099.html">Msc Keyboard Scan Expansion/GPIO Expansion device</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">The Linux PCI driver implementer’s API guide</a> &raquo;</li>
        
      <li>PCI Peer-to-Peer DMA Support</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/pci/p2pdma.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pci-peer-to-peer-dma-support">
<h1>PCI Peer-to-Peer DMA Support<a class="headerlink" href="#pci-peer-to-peer-dma-support" title="Permalink to this headline">¶</a></h1>
<p>The PCI bus has pretty decent support for performing DMA transfers
between two devices on the bus. This type of transaction is henceforth
called Peer-to-Peer (or P2P). However, there are a number of issues that
make P2P transactions tricky to do in a perfectly safe way.</p>
<p>One of the biggest issues is that PCI doesn’t require forwarding
transactions between hierarchy domains, and in PCIe, each Root Port
defines a separate hierarchy domain. To make things worse, there is no
simple way to determine if a given Root Complex supports this or not.
(See PCIe r4.0, sec 1.3.1). Therefore, as of this writing, the kernel
only supports doing P2P when the endpoints involved are all behind the
same PCI bridge, as such devices are all in the same PCI hierarchy
domain, and the spec guarantees that all transactions within the
hierarchy will be routable, but it does not require routing
between hierarchies.</p>
<p>The second issue is that to make use of existing interfaces in Linux,
memory that is used for P2P transactions needs to be backed by struct
pages. However, PCI BARs are not typically cache coherent so there are
a few corner case gotchas with these pages so developers need to
be careful about what they do with them.</p>
<div class="section" id="driver-writer-s-guide">
<h2>Driver Writer’s Guide<a class="headerlink" href="#driver-writer-s-guide" title="Permalink to this headline">¶</a></h2>
<p>In a given P2P implementation there may be three or more different
types of kernel drivers in play:</p>
<ul class="simple">
<li>Provider - A driver which provides or publishes P2P resources like
memory or doorbell registers to other drivers.</li>
<li>Client - A driver which makes use of a resource by setting up a
DMA transaction to or from it.</li>
<li>Orchestrator - A driver which orchestrates the flow of data between
clients and providers.</li>
</ul>
<p>In many cases there could be overlap between these three types (i.e.,
it may be typical for a driver to be both a provider and a client).</p>
<p>For example, in the NVMe Target Copy Offload implementation:</p>
<ul class="simple">
<li>The NVMe PCI driver is both a client, provider and orchestrator
in that it exposes any CMB (Controller Memory Buffer) as a P2P memory
resource (provider), it accepts P2P memory pages as buffers in requests
to be used directly (client) and it can also make use of the CMB as
submission queue entries (orchestrator).</li>
<li>The RDMA driver is a client in this arrangement so that an RNIC
can DMA directly to the memory exposed by the NVMe device.</li>
<li>The NVMe Target driver (nvmet) can orchestrate the data from the RNIC
to the P2P memory (CMB) and then to the NVMe device (and vice versa).</li>
</ul>
<p>This is currently the only arrangement supported by the kernel but
one could imagine slight tweaks to this that would allow for the same
functionality. For example, if a specific RNIC added a BAR with some
memory behind it, its driver could add support as a P2P provider and
then the NVMe Target could use the RNIC’s memory instead of the CMB
in cases where the NVMe cards in use do not have CMB support.</p>
<div class="section" id="provider-drivers">
<h3>Provider Drivers<a class="headerlink" href="#provider-drivers" title="Permalink to this headline">¶</a></h3>
<p>A provider simply needs to register a BAR (or a portion of a BAR)
as a P2P DMA resource using <a class="reference internal" href="#c.pci_p2pdma_add_resource" title="pci_p2pdma_add_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_add_resource()</span></code></a>.
This will register struct pages for all the specified memory.</p>
<p>After that it may optionally publish all of its resources as
P2P memory using <a class="reference internal" href="#c.pci_p2pmem_publish" title="pci_p2pmem_publish"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_publish()</span></code></a>. This will allow
any orchestrator drivers to find and use the memory. When marked in
this way, the resource must be regular memory with no side effects.</p>
<p>For the time being this is fairly rudimentary in that all resources
are typically going to be P2P memory. Future work will likely expand
this to include other types of resources like doorbells.</p>
</div>
<div class="section" id="client-drivers">
<h3>Client Drivers<a class="headerlink" href="#client-drivers" title="Permalink to this headline">¶</a></h3>
<p>A client driver typically only has to conditionally change its DMA map
routine to use the mapping function <code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_map_sg()</span></code> instead
of the usual <code class="xref c c-func docutils literal notranslate"><span class="pre">dma_map_sg()</span></code> function. Memory mapped in this
way does not need to be unmapped.</p>
<p>The client may also, optionally, make use of
<code class="xref c c-func docutils literal notranslate"><span class="pre">is_pci_p2pdma_page()</span></code> to determine when to use the P2P mapping
functions and when to use the regular mapping functions. In some
situations, it may be more appropriate to use a flag to indicate a
given request is P2P memory and map appropriately. It is important to
ensure that struct pages that back P2P memory stay out of code that
does not have support for them as other code may treat the pages as
regular memory which may not be appropriate.</p>
</div>
<div class="section" id="orchestrator-drivers">
<h3>Orchestrator Drivers<a class="headerlink" href="#orchestrator-drivers" title="Permalink to this headline">¶</a></h3>
<p>The first task an orchestrator driver must do is compile a list of
all client devices that will be involved in a given transaction. For
example, the NVMe Target driver creates a list including the namespace
block device and the RNIC in use. If the orchestrator has access to
a specific P2P provider to use it may check compatibility using
<code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_distance()</span></code> otherwise it may find a memory provider
that’s compatible with all clients using  <code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_find()</span></code>.
If more than one provider is supported, the one nearest to all the clients will
be chosen first. If more than one provider is an equal distance away, the
one returned will be chosen at random (it is not an arbitrary but
truly random). This function returns the PCI device to use for the provider
with a reference taken and therefore when it’s no longer needed it should be
returned with <a class="reference internal" href="pci.html#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_dev_put()</span></code></a>.</p>
<p>Once a provider is selected, the orchestrator can then use
<a class="reference internal" href="#c.pci_alloc_p2pmem" title="pci_alloc_p2pmem"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_p2pmem()</span></code></a> and <a class="reference internal" href="#c.pci_free_p2pmem" title="pci_free_p2pmem"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_free_p2pmem()</span></code></a> to
allocate P2P memory from the provider. <a class="reference internal" href="#c.pci_p2pmem_alloc_sgl" title="pci_p2pmem_alloc_sgl"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_alloc_sgl()</span></code></a>
and <a class="reference internal" href="#c.pci_p2pmem_free_sgl" title="pci_p2pmem_free_sgl"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_free_sgl()</span></code></a> are convenience functions for
allocating scatter-gather lists with P2P memory.</p>
</div>
<div class="section" id="struct-page-caveats">
<h3>Struct Page Caveats<a class="headerlink" href="#struct-page-caveats" title="Permalink to this headline">¶</a></h3>
<p>Driver writers should be very careful about not passing these special
struct pages to code that isn’t prepared for it. At this time, the kernel
interfaces do not have any checks for ensuring this. This obviously
precludes passing these pages to userspace.</p>
<p>P2P memory is also technically IO memory but should never have any side
effects behind it. Thus, the order of loads and stores should not be important
and ioreadX(), iowriteX() and friends should not be necessary.</p>
</div>
</div>
<div class="section" id="p2p-dma-support-library">
<h2>P2P DMA Support Library<a class="headerlink" href="#p2p-dma-support-library" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.pci_p2pdma_add_resource">
int <code class="descname">pci_p2pdma_add_resource</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, int<em>&nbsp;bar</em>, size_t<em>&nbsp;size</em>, u64<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_add_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>add memory for use as p2p memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device to add the memory to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar</span></code></dt>
<dd>PCI BAR to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the memory to add, may be zero to use the whole BAR</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">offset</span></code></dt>
<dd>offset into the PCI BAR</dd>
</dl>
<p><strong>Description</strong></p>
<p>The memory will be given ZONE_DEVICE struct pages so that it may
be used with any DMA request.</p>
<dl class="function">
<dt id="c.pci_p2pdma_distance_many">
int <code class="descname">pci_p2pdma_distance_many</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;provider</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> **<em>&nbsp;clients</em>, int<em>&nbsp;num_clients</em>, bool<em>&nbsp;verbose</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_distance_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the cumulative distance between a p2pdma provider and the clients in use.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">provider</span></code></dt>
<dd>p2pdma provider to check against the client list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">**</span> <span class="pre">clients</span></code></dt>
<dd>array of devices to check (NULL-terminated)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clients</span></code></dt>
<dd>number of clients in the array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">verbose</span></code></dt>
<dd>if true, print warnings for devices when we return -1</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -1 if any of the clients are not compatible, otherwise returns a
positive number where a lower number is the preferable choice. (If there’s
one client that’s the same as the provider it will return 0, which is best
choice).</p>
<p>“compatible” means the provider and the clients are either all behind
the same PCI root port or the host bridges connected to each of the devices
are listed in the ‘pci_p2pdma_whitelist’.</p>
<dl class="function">
<dt id="c.pci_has_p2pmem">
bool <code class="descname">pci_has_p2pmem</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_has_p2pmem" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given PCI device has published any p2pmem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device to check</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pmem_find_many">
struct pci_dev * <code class="descname">pci_p2pmem_find_many</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> **<em>&nbsp;clients</em>, int<em>&nbsp;num_clients</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_find_many" title="Permalink to this definition">¶</a></dt>
<dd><p>find a peer-to-peer DMA memory device compatible with the specified list of clients and shortest distance (as determined by pci_p2pmem_dma())</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">**</span> <span class="pre">clients</span></code></dt>
<dd>array of devices to check (NULL-terminated)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clients</span></code></dt>
<dd>number of client devices in the list</dd>
</dl>
<p><strong>Description</strong></p>
<p>If multiple devices are behind the same switch, the one “closest” to the
client devices in use will be chosen first. (So if one of the providers is
the same as one of the clients, that provider will be used ahead of any
other providers that are unrelated). If multiple providers are an equal
distance away, one will be chosen at random.</p>
<p>Returns a pointer to the PCI device with a reference taken (use pci_dev_put
to return the reference) or NULL if no compatible device is found. The
found provider will also be assigned to the client list.</p>
<dl class="function">
<dt id="c.pci_alloc_p2pmem">
void * <code class="descname">pci_alloc_p2pmem</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_alloc_p2pmem" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate peer-to-peer DMA memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device to allocate memory from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>number of bytes to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the allocated memory or NULL on error.</p>
<dl class="function">
<dt id="c.pci_free_p2pmem">
void <code class="descname">pci_free_p2pmem</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, void *<em>&nbsp;addr</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_free_p2pmem" title="Permalink to this definition">¶</a></dt>
<dd><p>free peer-to-peer DMA memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device the memory was allocated from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>address of the memory that was allocated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>number of bytes that were allocated</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pmem_virt_to_bus">
pci_bus_addr_t <code class="descname">pci_p2pmem_virt_to_bus</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_virt_to_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>return the PCI bus address for a given virtual address obtained with <a class="reference internal" href="#c.pci_alloc_p2pmem" title="pci_alloc_p2pmem"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_p2pmem()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device the memory was allocated from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>address of the memory that was allocated</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pmem_alloc_sgl">
struct scatterlist * <code class="descname">pci_p2pmem_alloc_sgl</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, unsigned int *<em>&nbsp;nents</em>, u32<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_alloc_sgl" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate peer-to-peer DMA memory in a scatterlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device to allocate memory from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">nents</span></code></dt>
<dd>the number of SG entries in the list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">length</span></code></dt>
<dd>number of bytes to allocate</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error or <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span></code> pointer and <strong>nents</strong> on success</p>
<dl class="function">
<dt id="c.pci_p2pmem_free_sgl">
void <code class="descname">pci_p2pmem_free_sgl</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, struct scatterlist *<em>&nbsp;sgl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_free_sgl" title="Permalink to this definition">¶</a></dt>
<dd><p>free a scatterlist allocated by <a class="reference internal" href="#c.pci_p2pmem_alloc_sgl" title="pci_p2pmem_alloc_sgl"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_alloc_sgl()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device to allocate memory from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sgl</span></code></dt>
<dd>the allocated scatterlist</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pmem_publish">
void <code class="descname">pci_p2pmem_publish</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, bool<em>&nbsp;publish</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_publish" title="Permalink to this definition">¶</a></dt>
<dd><p>publish the peer-to-peer DMA memory for use by other devices with pci_p2pmem_find()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device with peer-to-peer DMA memory to publish</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">publish</span></code></dt>
<dd>set to true to publish the memory, false to unpublish it</dd>
</dl>
<p><strong>Description</strong></p>
<p>Published memory can be used by other PCI device drivers for
peer-2-peer DMA operations. Non-published memory is reserved for
exclusive use of the device driver that registers the peer-to-peer
memory.</p>
<dl class="function">
<dt id="c.pci_p2pdma_map_sg_attrs">
int <code class="descname">pci_p2pdma_map_sg_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct scatterlist *<em>&nbsp;sg</em>, int<em>&nbsp;nents</em>, enum dma_data_direction<em>&nbsp;dir</em>, unsigned long<em>&nbsp;attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_map_sg_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>map a PCI peer-to-peer scatterlist for DMA</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device doing the DMA request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>scatter list to map</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nents</span></code></dt>
<dd>elements in the scatterlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA direction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt>
<dd>DMA attributes passed to dma_map_sg() (if called)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scatterlists mapped with this function should be unmapped using
<a class="reference internal" href="#c.pci_p2pdma_unmap_sg_attrs" title="pci_p2pdma_unmap_sg_attrs"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_unmap_sg_attrs()</span></code></a>.</p>
<p>Returns the number of SG entries mapped or 0 on error.</p>
<dl class="function">
<dt id="c.pci_p2pdma_unmap_sg_attrs">
void <code class="descname">pci_p2pdma_unmap_sg_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct scatterlist *<em>&nbsp;sg</em>, int<em>&nbsp;nents</em>, enum dma_data_direction<em>&nbsp;dir</em>, unsigned long<em>&nbsp;attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_unmap_sg_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap a PCI peer-to-peer scatterlist that was mapped with pci_p2pdma_map_sg()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device doing the DMA request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>scatter list to map</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nents</span></code></dt>
<dd>number of elements returned by pci_p2pdma_map_sg()</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA direction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt>
<dd>DMA attributes passed to dma_unmap_sg() (if called)</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pdma_enable_store">
int <code class="descname">pci_p2pdma_enable_store</code><span class="sig-paren">(</span>const char *<em>&nbsp;page</em>, struct pci_dev **<em>&nbsp;p2p_dev</em>, bool *<em>&nbsp;use_p2pdma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_enable_store" title="Permalink to this definition">¶</a></dt>
<dd><p>parse a configfs/sysfs attribute store to enable p2pdma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>contents of the value to be stored</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">**</span> <span class="pre">p2p_dev</span></code></dt>
<dd>returns the PCI device that was selected to be used
(if one was specified in the stored value)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">use_p2pdma</span></code></dt>
<dd>returns whether to enable p2pdma or not</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses an attribute value to decide whether to enable p2pdma.
The value can select a PCI device (using its full BDF device
name) or a boolean (in any format strtobool() accepts). A false
value disables p2pdma, a true value expects the caller
to automatically find a compatible device and specifying a PCI device
expects the caller to use the specific provider.</p>
<p><a class="reference internal" href="#c.pci_p2pdma_enable_show" title="pci_p2pdma_enable_show"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_enable_show()</span></code></a> should be used as the show operation for
the attribute.</p>
<p>Returns 0 on success</p>
<dl class="function">
<dt id="c.pci_p2pdma_enable_show">
ssize_t <code class="descname">pci_p2pdma_enable_show</code><span class="sig-paren">(</span>char *<em>&nbsp;page</em>, struct pci_dev *<em>&nbsp;p2p_dev</em>, bool<em>&nbsp;use_p2pdma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_enable_show" title="Permalink to this definition">¶</a></dt>
<dd><p>show a configfs/sysfs attribute indicating whether p2pdma is enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>contents of the stored value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">p2p_dev</span></code></dt>
<dd>the selected p2p device (NULL if no device is selected)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_p2pdma</span></code></dt>
<dd>whether p2pdma has been enabled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attributes that use <a class="reference internal" href="#c.pci_p2pdma_enable_store" title="pci_p2pdma_enable_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_enable_store()</span></code></a> should use this function
to show the value of the attribute.</p>
<p>Returns 0 on success</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../spi.html" class="btn btn-neutral float-right" title="Serial Peripheral Interface (SPI)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pci.html" class="btn btn-neutral float-left" title="PCI Support Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>