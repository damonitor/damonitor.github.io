

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux for S/390 and zSeries &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Linux for S/390 and zSeries</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/s390/cds.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-for-s-390-and-zseries">
<h1>Linux for S/390 and zSeries<a class="headerlink" href="#linux-for-s-390-and-zseries" title="Permalink to this headline">¶</a></h1>
<p>Common Device Support (CDS)
Device Driver I/O Support Routines</p>
<dl class="docutils">
<dt>Authors:</dt>
<dd><ul class="first last simple">
<li>Ingo Adlung</li>
<li>Cornelia Huck</li>
</ul>
</dd>
</dl>
<p>Copyright, IBM Corp. 1999-2002</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes the common device support routines for Linux/390.
Different than other hardware architectures, ESA/390 has defined a unified
I/O access method. This gives relief to the device drivers as they don’t
have to deal with different bus types, polling versus interrupt
processing, shared versus non-shared interrupt processing, DMA versus port
I/O (PIO), and other hardware features more. However, this implies that
either every single device driver needs to implement the hardware I/O
attachment functionality itself, or the operating system provides for a
unified method to access the hardware, providing all the functionality that
every single device driver would have to provide itself.</p>
<p>The document does not intend to explain the ESA/390 hardware architecture in
every detail.This information can be obtained from the ESA/390 Principles of
Operation manual (IBM Form. No. SA22-7201).</p>
<p>In order to build common device support for ESA/390 I/O interfaces, a
functional layer was introduced that provides generic I/O access methods to
the hardware.</p>
<p>The common device support layer comprises the I/O support routines defined
below. Some of them implement common Linux device driver interfaces, while
some of them are ESA/390 platform specific.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>In order to write a driver for S/390, you also need to look into the interface
described in Documentation/s390/driver-model.rst.</dd>
</dl>
<p>Note for porting drivers from 2.4:</p>
<p>The major changes are:</p>
<ul class="simple">
<li>The functions use a ccw_device instead of an irq (subchannel).</li>
<li>All drivers must define a ccw_driver (see driver-model.txt) and the associated
functions.</li>
<li><a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_irq()</span></code></a> are no longer done by the driver.</li>
<li>The oper_handler is (kindof) replaced by the probe() and set_online() functions
of the ccw_driver.</li>
<li>The not_oper_handler is (kindof) replaced by the remove() and set_offline()
functions of the ccw_driver.</li>
<li>The channel device layer is gone.</li>
<li>The interrupt handlers must be adapted to use a ccw_device as argument.
Moreover, they don’t return a devstat, but an irb.</li>
<li>Before initiating an io, the options must be set via <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_set_options" title="ccw_device_set_options"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_set_options()</span></code></a>.</li>
<li>Instead of calling read_dev_chars()/read_conf_data(), the driver issues
the channel program and handles the interrupt itself.</li>
</ul>
<dl class="docutils">
<dt>ccw_device_get_ciw()</dt>
<dd>get commands from extended sense data.</dd>
<dt>ccw_device_start(), ccw_device_start_timeout(), ccw_device_start_key(), ccw_device_start_key_timeout()</dt>
<dd>initiate an I/O request.</dd>
<dt>ccw_device_resume()</dt>
<dd>resume channel program execution.</dd>
<dt>ccw_device_halt()</dt>
<dd>terminate the current I/O request processed on the device.</dd>
<dt>do_IRQ()</dt>
<dd>generic interrupt routine. This function is called by the interrupt entry
routine whenever an I/O interrupt is presented to the system. The do_IRQ()
routine determines the interrupt status and calls the device specific
interrupt handler according to the rules (flags) defined during I/O request
initiation with do_IO().</dd>
</dl>
<p>The next chapters describe the functions other than do_IRQ() in more details.
The do_IRQ() interface is not described, as it is called from the Linux/390
first level interrupt handler only and does not comprise a device driver
callable interface. Instead, the functional description of do_IO() also
describes the input to the device specific interrupt handler.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>All explanations apply also to the 64 bit architecture s390x.</dd>
</dl>
</div>
<div class="section" id="common-device-support-cds-for-linux-390-device-drivers">
<h2>Common Device Support (CDS) for Linux/390 Device Drivers<a class="headerlink" href="#common-device-support-cds-for-linux-390-device-drivers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general-information">
<h3>General Information<a class="headerlink" href="#general-information" title="Permalink to this headline">¶</a></h3>
<p>The following chapters describe the I/O related interface routines the
Linux/390 common device support (CDS) provides to allow for device specific
driver implementations on the IBM ESA/390 hardware platform. Those interfaces
intend to provide the functionality required by every device driver
implementation to allow to drive a specific hardware device on the ESA/390
platform. Some of the interface routines are specific to Linux/390 and some
of them can be found on other Linux platforms implementations too.
Miscellaneous function prototypes, data declarations, and macro definitions
can be found in the architecture specific C header file
linux/arch/s390/include/asm/irq.h.</p>
</div>
<div class="section" id="overview-of-cds-interface-concepts">
<h3>Overview of CDS interface concepts<a class="headerlink" href="#overview-of-cds-interface-concepts" title="Permalink to this headline">¶</a></h3>
<p>Different to other hardware platforms, the ESA/390 architecture doesn’t define
interrupt lines managed by a specific interrupt controller and bus systems
that may or may not allow for shared interrupts, DMA processing, etc.. Instead,
the ESA/390 architecture has implemented a so called channel subsystem, that
provides a unified view of the devices physically attached to the systems.
Though the ESA/390 hardware platform knows about a huge variety of different
peripheral attachments like disk devices (aka. DASDs), tapes, communication
controllers, etc. they can all be accessed by a well defined access method and
they are presenting I/O completion a unified way : I/O interruptions. Every
single device is uniquely identified to the system by a so called subchannel,
where the ESA/390 architecture allows for 64k devices be attached.</p>
<p>Linux, however, was first built on the Intel PC architecture, with its two
cascaded 8259 programmable interrupt controllers (PICs), that allow for a
maximum of 15 different interrupt lines. All devices attached to such a system
share those 15 interrupt levels. Devices attached to the ISA bus system must
not share interrupt levels (aka. IRQs), as the ISA bus bases on edge triggered
interrupts. MCA, EISA, PCI and other bus systems base on level triggered
interrupts, and therewith allow for shared IRQs. However, if multiple devices
present their hardware status by the same (shared) IRQ, the operating system
has to call every single device driver registered on this IRQ in order to
determine the device driver owning the device that raised the interrupt.</p>
<p>Up to kernel 2.4, Linux/390 used to provide interfaces via the IRQ (subchannel).
For internal use of the common I/O layer, these are still there. However,
device drivers should use the new calling interface via the ccw_device only.</p>
<p>During its startup the Linux/390 system checks for peripheral devices. Each
of those devices is uniquely defined by a so called subchannel by the ESA/390
channel subsystem. While the subchannel numbers are system generated, each
subchannel also takes a user defined attribute, the so called device number.
Both subchannel number and device number cannot exceed 65535. During sysfs
initialisation, the information about control unit type and device types that
imply specific I/O commands (channel command words - CCWs) in order to operate
the device are gathered. Device drivers can retrieve this set of hardware
information during their initialization step to recognize the devices they
support using the information saved in the struct ccw_device given to them.
This methods implies that Linux/390 doesn’t require to probe for free (not
armed) interrupt request lines (IRQs) to drive its devices with. Where
applicable, the device drivers can use issue the READ DEVICE CHARACTERISTICS
ccw to retrieve device characteristics in its online routine.</p>
<p>In order to allow for easy I/O initiation the CDS layer provides a
<a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> interface that takes a device specific channel program (one
or more CCWs) as input sets up the required architecture specific control blocks
and initiates an I/O request on behalf of the device driver. The
<a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> routine allows to specify whether it expects the CDS layer
to notify the device driver for every interrupt it observes, or with final status
only. See <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> for more details. A device driver must never issue
ESA/390 I/O commands itself, but must use the Linux/390 CDS interfaces instead.</p>
<p>For long running I/O request to be canceled, the CDS layer provides the
<a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a> function. Some devices require to initially issue a HALT
SUBCHANNEL (HSCH) command without having pending I/O requests. This function is
also covered by <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a>.</p>
<p>get_ciw() - get command information word</p>
<p>This call enables a device driver to get information about supported commands
from the extended SenseID data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ciw *
ccw_device_get_ciw(struct ccw_device *cdev, __u32 cmd);
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>cdev</td>
<td>The ccw_device for which the command is to be retrieved.</td>
</tr>
<tr class="row-even"><td>cmd</td>
<td>The command type to be retrieved.</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_get_ciw" title="ccw_device_get_ciw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_get_ciw()</span></code></a> returns:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>NULL</td>
<td>No extended data available, invalid device or command not found.</td>
</tr>
<tr class="row-even"><td>!NULL</td>
<td>The command requested.</td>
</tr>
</tbody>
</table>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ccw_device_start() - Initiate I/O Request
</pre></div>
</div>
<p>The <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> routines is the I/O request front-end processor. All
device driver I/O requests must be issued using this routine. A device driver
must not issue ESA/390 I/O commands itself. Instead the <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a>
routine provides all interfaces required to drive arbitrary devices.</p>
<p>This description also covers the status information passed to the device
driver’s interrupt handler as this is related to the rules (flags) defined
with the associated I/O request when calling <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ccw_device_start(struct ccw_device *cdev,
                     struct ccw1 *cpa,
                     unsigned long intparm,
                     __u8 lpm,
                     unsigned long flags);
int ccw_device_start_timeout(struct ccw_device *cdev,
                             struct ccw1 *cpa,
                             unsigned long intparm,
                             __u8 lpm,
                             unsigned long flags,
                             int expires);
int ccw_device_start_key(struct ccw_device *cdev,
                         struct ccw1 *cpa,
                         unsigned long intparm,
                         __u8 lpm,
                         __u8 key,
                         unsigned long flags);
int ccw_device_start_key_timeout(struct ccw_device *cdev,
                                 struct ccw1 *cpa,
                                 unsigned long intparm,
                                 __u8 lpm,
                                 __u8 key,
                                 unsigned long flags,
                                 int expires);
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>cdev</td>
<td>ccw_device the I/O is destined for</td>
</tr>
<tr class="row-even"><td>cpa</td>
<td>logical start address of channel program</td>
</tr>
<tr class="row-odd"><td>user_intparm</td>
<td>user specific interrupt information; will be presented
back to the device driver’s interrupt handler. Allows a
device driver to associate the interrupt with a
particular I/O request.</td>
</tr>
<tr class="row-even"><td>lpm</td>
<td>defines the channel path to be used for a specific I/O
request. A value of 0 will make cio use the opm.</td>
</tr>
<tr class="row-odd"><td>key</td>
<td>the storage key to use for the I/O (useful for operating on a
storage with a storage key != default key)</td>
</tr>
<tr class="row-even"><td>flag</td>
<td>defines the action to be performed for I/O processing</td>
</tr>
<tr class="row-odd"><td>expires</td>
<td>timeout value in jiffies. The common I/O layer will terminate
the running program after this and call the interrupt handler
with ERR_PTR(-ETIMEDOUT) as irb.</td>
</tr>
</tbody>
</table>
<p>Possible flag values are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>DOIO_ALLOW_SUSPEND</td>
<td>channel program may become suspended</td>
</tr>
<tr class="row-even"><td>DOIO_DENY_PREFETCH</td>
<td>don’t allow for CCW prefetch; usually
this implies the channel program might
become modified</td>
</tr>
<tr class="row-odd"><td>DOIO_SUPPRESS_INTER</td>
<td>don’t call the handler on intermediate status</td>
</tr>
</tbody>
</table>
<p>The cpa parameter points to the first format 1 CCW of a channel program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ccw1 {
      __u8  cmd_code;/* command code */
      __u8  flags;   /* flags, like IDA addressing, etc. */
      __u16 count;   /* byte count */
      __u32 cda;     /* data address */
} __attribute__ ((packed,aligned(8)));
</pre></div>
</div>
<p>with the following CCW flags values defined:</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>CCW_FLAG_DC</td>
<td>data chaining</td>
</tr>
<tr class="row-even"><td>CCW_FLAG_CC</td>
<td>command chaining</td>
</tr>
<tr class="row-odd"><td>CCW_FLAG_SLI</td>
<td>suppress incorrect length</td>
</tr>
<tr class="row-even"><td>CCW_FLAG_SKIP</td>
<td>skip</td>
</tr>
<tr class="row-odd"><td>CCW_FLAG_PCI</td>
<td>PCI</td>
</tr>
<tr class="row-even"><td>CCW_FLAG_IDA</td>
<td>indirect addressing</td>
</tr>
<tr class="row-odd"><td>CCW_FLAG_SUSPEND</td>
<td>suspend</td>
</tr>
</tbody>
</table>
<p>Via <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_set_options" title="ccw_device_set_options"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_set_options()</span></code></a>, the device driver may specify the following
options for the device:</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>DOIO_EARLY_NOTIFICATION</td>
<td>allow for early interrupt notification</td>
</tr>
<tr class="row-even"><td>DOIO_REPORT_ALL</td>
<td>report all interrupt conditions</td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> function returns:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>successful completion or request successfully initiated</td>
</tr>
<tr class="row-even"><td>-EBUSY</td>
<td>The device is currently processing a previous I/O request, or there is
a status pending at the device.</td>
</tr>
<tr class="row-odd"><td>-ENODEV</td>
<td>cdev is invalid, the device is not operational or the ccw_device is
not online.</td>
</tr>
</tbody>
</table>
<p>When the I/O request completes, the CDS first level interrupt handler will
accumulate the status in a struct irb and then call the device interrupt handler.
The intparm field will contain the value the device driver has associated with a
particular I/O request. If a pending device status was recognized,
intparm will be set to 0 (zero). This may happen during I/O initiation or delayed
by an alert status notification. In any case this status is not related to the
current (last) I/O request. In case of a delayed status notification no special
interrupt will be presented to indicate I/O completion as the I/O request was
never started, even though <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> returned with successful completion.</p>
<p>The irb may contain an error value, and the device driver should check for this
first:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>-ETIMEDOUT</td>
<td>the common I/O layer terminated the request after the specified
timeout value</td>
</tr>
<tr class="row-even"><td>-EIO</td>
<td>the common I/O layer terminated the request due to an error state</td>
</tr>
</tbody>
</table>
<p>If the concurrent sense flag in the extended status word (esw) in the irb is
set, the field erw.scnt in the esw describes the number of device specific
sense bytes available in the extended control word irb-&gt;scsw.ecw[]. No device
sensing by the device driver itself is required.</p>
<p>The device interrupt handler can use the following definitions to investigate
the primary unit check source coded in sense byte 0 :</p>
<table border="1" class="docutils">
<colgroup>
<col width="85%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>SNS0_CMD_REJECT</td>
<td>0x80</td>
</tr>
<tr class="row-even"><td>SNS0_INTERVENTION_REQ</td>
<td>0x40</td>
</tr>
<tr class="row-odd"><td>SNS0_BUS_OUT_CHECK</td>
<td>0x20</td>
</tr>
<tr class="row-even"><td>SNS0_EQUIPMENT_CHECK</td>
<td>0x10</td>
</tr>
<tr class="row-odd"><td>SNS0_DATA_CHECK</td>
<td>0x08</td>
</tr>
<tr class="row-even"><td>SNS0_OVERRUN</td>
<td>0x04</td>
</tr>
<tr class="row-odd"><td>SNS0_INCOMPL_DOMAIN</td>
<td>0x01</td>
</tr>
</tbody>
</table>
<p>Depending on the device status, multiple of those values may be set together.
Please refer to the device specific documentation for details.</p>
<p>The irb-&gt;scsw.cstat field provides the (accumulated) subchannel status :</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>SCHN_STAT_PCI</td>
<td>program controlled interrupt</td>
</tr>
<tr class="row-even"><td>SCHN_STAT_INCORR_LEN</td>
<td>incorrect length</td>
</tr>
<tr class="row-odd"><td>SCHN_STAT_PROG_CHECK</td>
<td>program check</td>
</tr>
<tr class="row-even"><td>SCHN_STAT_PROT_CHECK</td>
<td>protection check</td>
</tr>
<tr class="row-odd"><td>SCHN_STAT_CHN_DATA_CHK</td>
<td>channel data check</td>
</tr>
<tr class="row-even"><td>SCHN_STAT_CHN_CTRL_CHK</td>
<td>channel control check</td>
</tr>
<tr class="row-odd"><td>SCHN_STAT_INTF_CTRL_CHK</td>
<td>interface control check</td>
</tr>
<tr class="row-even"><td>SCHN_STAT_CHAIN_CHECK</td>
<td>chaining check</td>
</tr>
</tbody>
</table>
<p>The irb-&gt;scsw.dstat field provides the (accumulated) device status :</p>
<table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="45%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>DEV_STAT_ATTENTION</td>
<td>attention</td>
</tr>
<tr class="row-even"><td>DEV_STAT_STAT_MOD</td>
<td>status modifier</td>
</tr>
<tr class="row-odd"><td>DEV_STAT_CU_END</td>
<td>control unit end</td>
</tr>
<tr class="row-even"><td>DEV_STAT_BUSY</td>
<td>busy</td>
</tr>
<tr class="row-odd"><td>DEV_STAT_CHN_END</td>
<td>channel end</td>
</tr>
<tr class="row-even"><td>DEV_STAT_DEV_END</td>
<td>device end</td>
</tr>
<tr class="row-odd"><td>DEV_STAT_UNIT_CHECK</td>
<td>unit check</td>
</tr>
<tr class="row-even"><td>DEV_STAT_UNIT_EXCEP</td>
<td>unit exception</td>
</tr>
</tbody>
</table>
<p>Please see the ESA/390 Principles of Operation manual for details on the
individual flag meanings.</p>
<p>Usage Notes:</p>
<p><a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> must be called disabled and with the ccw device lock held.</p>
<p>The device driver is allowed to issue the next <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> call from
within its interrupt handler already. It is not required to schedule a
bottom-half, unless a non deterministically long running error recovery procedure
or similar needs to be scheduled. During I/O processing the Linux/390 generic
I/O device driver support has already obtained the IRQ lock, i.e. the handler
must not try to obtain it again when calling <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> or we end in a
deadlock situation!</p>
<p>If a device driver relies on an I/O request to be completed prior to start the
next it can reduce I/O processing overhead by chaining a NoOp I/O command
CCW_CMD_NOOP to the end of the submitted CCW chain. This will force Channel-End
and Device-End status to be presented together, with a single interrupt.
However, this should be used with care as it implies the channel will remain
busy, not being able to process I/O requests for other devices on the same
channel. Therefore e.g. read commands should never use this technique, as the
result will be presented by a single interrupt anyway.</p>
<p>In order to minimize I/O overhead, a device driver should use the
DOIO_REPORT_ALL  only if the device can report intermediate interrupt
information prior to device-end the device driver urgently relies on. In this
case all I/O interruptions are presented to the device driver until final
status is recognized.</p>
<p>If a device is able to recover from asynchronously presented I/O errors, it can
perform overlapping I/O using the DOIO_EARLY_NOTIFICATION flag. While some
devices always report channel-end and device-end together, with a single
interrupt, others present primary status (channel-end) when the channel is
ready for the next I/O request and secondary status (device-end) when the data
transmission has been completed at the device.</p>
<p>Above flag allows to exploit this feature, e.g. for communication devices that
can handle lost data on the network to allow for enhanced I/O processing.</p>
<p>Unless the channel subsystem at any time presents a secondary status interrupt,
exploiting this feature will cause only primary status interrupts to be
presented to the device driver while overlapping I/O is performed. When a
secondary status without error (alert status) is presented, this indicates
successful completion for all overlapping <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> requests that have
been issued since the last secondary (final) status.</p>
<p>Channel programs that intend to set the suspend flag on a channel command word
(CCW)  must start the I/O operation with the DOIO_ALLOW_SUSPEND option or the
suspend flag will cause a channel program check. At the time the channel program
becomes suspended an intermediate interrupt will be generated by the channel
subsystem.</p>
<p><a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_resume" title="ccw_device_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_resume()</span></code></a> - Resume Channel Program Execution</p>
<p>If a device driver chooses to suspend the current channel program execution by
setting the CCW suspend flag on a particular CCW, the channel program execution
is suspended. In order to resume channel program execution the CIO layer
provides the <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_resume" title="ccw_device_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_resume()</span></code></a> routine.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ccw_device_resume(struct ccw_device *cdev);
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>cdev</td>
<td>ccw_device the resume operation is requested for</td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_resume" title="ccw_device_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_resume()</span></code></a> function returns:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>suspended channel program is resumed</td>
</tr>
<tr class="row-even"><td>-EBUSY</td>
<td>status pending</td>
</tr>
<tr class="row-odd"><td>-ENODEV</td>
<td>cdev invalid or not-operational subchannel</td>
</tr>
<tr class="row-even"><td>-EINVAL</td>
<td>resume function not applicable</td>
</tr>
<tr class="row-odd"><td>-ENOTCONN</td>
<td>there is no I/O request pending for completion</td>
</tr>
</tbody>
</table>
<p>Usage Notes:</p>
<p>Please have a look at the <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_start" title="ccw_device_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_start()</span></code></a> usage notes for more details on
suspended channel programs.</p>
<p><a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a> - Halt I/O Request Processing</p>
<p>Sometimes a device driver might need a possibility to stop the processing of
a long-running channel program or the device might require to initially issue
a halt subchannel (HSCH) I/O command. For those purposes the <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a>
command is provided.</p>
<p><a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a> must be called disabled and with the ccw device lock held.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ccw_device_halt(struct ccw_device *cdev,
                    unsigned long intparm);
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>cdev</td>
<td>ccw_device the halt operation is requested for</td>
</tr>
<tr class="row-even"><td>intparm</td>
<td>interruption parameter; value is only used if no I/O
is outstanding, otherwise the intparm associated with
the I/O request is returned</td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a> function returns:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>request successfully initiated</td>
</tr>
<tr class="row-even"><td>-EBUSY</td>
<td>the device is currently busy, or status pending.</td>
</tr>
<tr class="row-odd"><td>-ENODEV</td>
<td>cdev invalid.</td>
</tr>
<tr class="row-even"><td>-EINVAL</td>
<td>The device is not operational or the ccw device is not online.</td>
</tr>
</tbody>
</table>
<p>Usage Notes:</p>
<p>A device driver may write a never-ending channel program by writing a channel
program that at its end loops back to its beginning by means of a transfer in
channel (TIC)   command (CCW_CMD_TIC). Usually this is performed by network
device drivers by setting the PCI CCW flag (CCW_FLAG_PCI). Once this CCW is
executed a program controlled interrupt (PCI) is generated. The device driver
can then perform an appropriate action. Prior to interrupt of an outstanding
read to a network device (with or without PCI flag) a <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a>
is required to end the pending operation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ccw_device_clear() - Terminage I/O Request Processing
</pre></div>
</div>
<p>In order to terminate all I/O processing at the subchannel, the clear subchannel
(CSCH) command is used. It can be issued via <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_clear" title="ccw_device_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_clear()</span></code></a>.</p>
<p><a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_clear" title="ccw_device_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_clear()</span></code></a> must be called disabled and with the ccw device lock held.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ccw_device_clear(struct ccw_device *cdev, unsigned long intparm);
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>cdev</td>
<td>ccw_device the clear operation is requested for</td>
</tr>
<tr class="row-even"><td>intparm</td>
<td>interruption parameter (see <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_halt" title="ccw_device_halt"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_halt()</span></code></a>)</td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="../driver-api/s390-drivers.html#c.ccw_device_clear" title="ccw_device_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">ccw_device_clear()</span></code></a> function returns:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>request successfully initiated</td>
</tr>
<tr class="row-even"><td>-ENODEV</td>
<td>cdev invalid</td>
</tr>
<tr class="row-odd"><td>-EINVAL</td>
<td>The device is not operational or the ccw device is not online.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="miscellaneous-support-routines">
<h3>Miscellaneous Support Routines<a class="headerlink" href="#miscellaneous-support-routines" title="Permalink to this headline">¶</a></h3>
<p>This chapter describes various routines to be used in a Linux/390 device
driver programming environment.</p>
<p>get_ccwdev_lock()</p>
<p>Get the address of the device specific lock. This is then used in
spin_lock() / spin_unlock() calls.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u8 ccw_device_get_path_mask(struct ccw_device *cdev);
</pre></div>
</div>
<p>Get the mask of the path currently available for cdev.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>