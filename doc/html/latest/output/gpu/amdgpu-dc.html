

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>drm/amd/display - Display Core (DC) &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>drm/amd/display - Display Core (DC)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/amdgpu-dc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="drm-amd-display-display-core-dc">
<h1>drm/amd/display - Display Core (DC)<a class="headerlink" href="#drm-amd-display-display-core-dc" title="Permalink to this headline">¶</a></h1>
<p><em>placeholder - general description of supported platforms, what dc is, etc.</em></p>
<p>Because it is partially shared with other operating systems, the Display Core
Driver is divided in two pieces.</p>
<ol class="arabic simple">
<li><strong>Display Core (DC)</strong> contains the OS-agnostic components. Things like
hardware programming and resource management are handled here.</li>
<li><strong>Display Manager (DM)</strong> contains the OS-dependent components. Hooks to the
amdgpu base driver and DRM are implemented here.</li>
</ol>
<p>It doesn’t help that the entire package is frequently referred to as DC. But
with the context in mind, it should be clear.</p>
<p>When CONFIG_DRM_AMD_DC is enabled, DC will be initialized by default for
supported ASICs. To force disable, set <cite>amdgpu.dc=0</cite> on kernel command line.
Likewise, to force enable on unsupported ASICs, set <cite>amdgpu.dc=1</cite>.</p>
<p>To determine if DC is loaded, search dmesg for the following entry:</p>
<p><code class="docutils literal notranslate"><span class="pre">Display</span> <span class="pre">Core</span> <span class="pre">initialized</span> <span class="pre">with</span> <span class="pre">&lt;version</span> <span class="pre">number</span> <span class="pre">here&gt;</span></code></p>
<div class="section" id="amdgpu-display-manager">
<h2>AMDgpu Display Manager<a class="headerlink" href="#amdgpu-display-manager" title="Permalink to this headline">¶</a></h2>
<p>The AMDgpu display manager, <strong>amdgpu_dm</strong> (or even simpler,
<strong>dm</strong>) sits between DRM and DC. It acts as a liason, converting DRM
requests into DC requests, and DC responses into DRM responses.</p>
<p>The root control structure is <a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_display_manager</span></code></a>.</p>
<dl class="type">
<dt id="c.irq_list_head">
struct <code class="descname">irq_list_head</code><a class="headerlink" href="#c.irq_list_head" title="Permalink to this definition">¶</a></dt>
<dd><p>Linked-list for low context IRQ handlers.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_list_head {
  struct list_head head;
  struct work_struct work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt>
<dd>The list_head within <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">handler_data</span></code></dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt>
<dd>A work_struct containing the deferred handler work</dd>
</dl>
<dl class="type">
<dt id="c.dm_comressor_info">
struct <code class="descname">dm_comressor_info</code><a class="headerlink" href="#c.dm_comressor_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Buffer info used by frame buffer compression</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dm_comressor_info {
  void *cpu_addr;
  struct amdgpu_bo *bo_ptr;
  uint64_t gpu_addr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">cpu_addr</span></code></dt>
<dd>MMIO cpu addr</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bo_ptr</span></code></dt>
<dd>Pointer to the buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpu_addr</span></code></dt>
<dd>MMIO gpu addr</dd>
</dl>
<dl class="type">
<dt id="c.amdgpu_dm_backlight_caps">
struct <code class="descname">amdgpu_dm_backlight_caps</code><a class="headerlink" href="#c.amdgpu_dm_backlight_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>Usable range of backlight values from ACPI</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_dm_backlight_caps {
  int min_input_signal;
  int max_input_signal;
  bool caps_valid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">min_input_signal</span></code></dt>
<dd>minimum possible input in range 0-255</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_input_signal</span></code></dt>
<dd>maximum possible input in range 0-255</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caps_valid</span></code></dt>
<dd>true if these values are from the ACPI interface</dd>
</dl>
<dl class="type">
<dt id="c.amdgpu_display_manager">
struct <code class="descname">amdgpu_display_manager</code><a class="headerlink" href="#c.amdgpu_display_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Central amdgpu display manager device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_display_manager {
  struct dc *dc;
  struct dmub_srv *dmub_srv;
  struct dmub_srv_fb_info *dmub_fb_info;
  const struct firmware *dmub_fw;
  struct amdgpu_bo *dmub_bo;
  u64 dmub_bo_gpu_addr;
  void *dmub_bo_cpu_addr;
  uint32_t dmcub_fw_version;
  struct cgs_device *cgs_device;
  struct amdgpu_device *adev;
  struct drm_device *ddev;
  u16 display_indexes_num;
  struct drm_private_obj atomic_obj;
  struct mutex dc_lock;
  struct mutex audio_lock;
  struct drm_audio_component *audio_component;
  bool audio_registered;
  struct irq_list_head irq_handler_list_low_tab[DAL_IRQ_SOURCES_NUMBER];
  struct list_head irq_handler_list_high_tab[DAL_IRQ_SOURCES_NUMBER];
  struct common_irq_params pflip_params[DC_IRQ_SOURCE_PFLIP_LAST - DC_IRQ_SOURCE_PFLIP_FIRST + 1];
  struct common_irq_params vblank_params[DC_IRQ_SOURCE_VBLANK6 - DC_IRQ_SOURCE_VBLANK1 + 1];
  struct common_irq_params vupdate_params[DC_IRQ_SOURCE_VUPDATE6 - DC_IRQ_SOURCE_VUPDATE1 + 1];
  spinlock_t irq_handler_list_table_lock;
  struct backlight_device *backlight_dev;
  const struct dc_link *backlight_link;
  struct amdgpu_dm_backlight_caps backlight_caps;
  struct mod_freesync *freesync_module;
#ifdef CONFIG_DRM_AMD_DC_HDCP;
  struct hdcp_workqueue *hdcp_workqueue;
#endif;
  struct drm_atomic_state *cached_state;
  struct dm_comressor_info compressor;
  const struct firmware *fw_dmcu;
  uint32_t dmcu_fw_version;
  const struct gpu_info_soc_bounding_box_v1_0 *soc_bounding_box;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dc</span></code></dt>
<dd>Display Core control structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_srv</span></code></dt>
<dd>DMUB service, used for controlling the DMUB on hardware
that supports it. The pointer to the dmub_srv will be
NULL on hardware that does not support it.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_fb_info</span></code></dt>
<dd>Framebuffer regions for the DMUB.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_fw</span></code></dt>
<dd>DMUB firmware, required on hardware that has DMUB support.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_bo</span></code></dt>
<dd>Buffer object for the DMUB.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_bo_gpu_addr</span></code></dt>
<dd>GPU virtual address for the DMUB buffer object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_bo_cpu_addr</span></code></dt>
<dd>CPU address for the DMUB buffer object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmcub_fw_version</span></code></dt>
<dd>DMCUB firmware version.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cgs_device</span></code></dt>
<dd>The Common Graphics Services device. It provides an interface for
accessing registers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adev</span></code></dt>
<dd>AMDGPU base driver structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ddev</span></code></dt>
<dd>DRM base driver structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">display_indexes_num</span></code></dt>
<dd>Max number of display streams supported</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_obj</span></code></dt>
<dd>In combination with <code class="xref c c-type docutils literal notranslate"><span class="pre">dm_atomic_state</span></code> it helps manage
global atomic state that doesn’t map cleanly into existing
drm resources, like <code class="xref c c-type docutils literal notranslate"><span class="pre">dc_context</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dc_lock</span></code></dt>
<dd>Guards access to DC functions that can issue register write
sequences.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio_lock</span></code></dt>
<dd>Guards access to audio instance changes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio_component</span></code></dt>
<dd>Used to notify ELD changes to sound driver.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio_registered</span></code></dt>
<dd>True if the audio component has been registered
successfully, false otherwise.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_list_low_tab</span></code></dt>
<dd><p class="first">Low priority IRQ handler table.</p>
<p>It is a n*m table consisting of n IRQ sources, and m handlers per IRQ
source. Low priority IRQ handlers are deferred to a workqueue to be
processed. Hence, they can sleep.</p>
<p class="last">Note that handlers are called in the same order as they were
registered (FIFO).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_list_high_tab</span></code></dt>
<dd><p class="first">High priority IRQ handler table.</p>
<p class="last">It is a n*m table, same as <code class="xref c c-type docutils literal notranslate"><span class="pre">irq_handler_list_low_tab</span></code>. However,
handlers in this table are not deferred and are called immediately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pflip_params</span></code></dt>
<dd>Page flip IRQ parameters, passed to registered handlers when
triggered.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vblank_params</span></code></dt>
<dd>Vertical blanking IRQ parameters, passed to registered handlers when
triggered.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vupdate_params</span></code></dt>
<dd>Vertical update IRQ parameters, passed to registered handlers when
triggered.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_list_table_lock</span></code></dt>
<dd>Synchronizes access to IRQ tables</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight_dev</span></code></dt>
<dd>Backlight control device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight_link</span></code></dt>
<dd>Link on which to control backlight</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight_caps</span></code></dt>
<dd>Capabilities of the backlight device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freesync_module</span></code></dt>
<dd>Module handling freesync calculations</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cached_state</span></code></dt>
<dd>Caches device atomic state for suspend/resume</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compressor</span></code></dt>
<dd>Frame buffer compression buffer. See <a class="reference internal" href="#c.dm_comressor_info" title="dm_comressor_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dm_comressor_info</span></code></a></dd>
<dt><code class="docutils literal notranslate"><span class="pre">fw_dmcu</span></code></dt>
<dd>Reference to DMCU firmware</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmcu_fw_version</span></code></dt>
<dd>Version of the DMCU firmware</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soc_bounding_box</span></code></dt>
<dd>gpu_info FW provided soc bounding box struct or 0 if not
available in FW</dd>
</dl>
<div class="section" id="lifecycle">
<h3>Lifecycle<a class="headerlink" href="#lifecycle" title="Permalink to this headline">¶</a></h3>
<p>DM (and consequently DC) is registered in the amdgpu base driver as a IP
block. When CONFIG_DRM_AMD_DC is enabled, the DM device IP block is added to
the base driver’s device list to be initialized and torn down accordingly.</p>
<p>The functions to do so are provided as hooks in <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amd_ip_funcs</span></code>.</p>
<dl class="function">
<dt id="c.dm_hw_init">
int <code class="descname">dm_hw_init</code><span class="sig-paren">(</span>void *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_hw_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize DC device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>The base driver device containing the amdgpu_dm device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the <a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_display_manager</span></code></a> device. This involves calling
the initializers of each DM component, then populating the struct with them.</p>
<p>Although the function implies hardware initialization, both hardware and
software are initialized here. Splitting them out to their relevant init
hooks is a future TODO item.</p>
<p>Some notable things that are initialized here:</p>
<ul class="simple">
<li>Display Core, both software and hardware</li>
<li>DC modules that we need (freesync and color management)</li>
<li>DRM software states</li>
<li>Interrupt sources and handlers</li>
<li>Vblank support</li>
<li>Debug FS entries, if enabled</li>
</ul>
<dl class="function">
<dt id="c.dm_hw_fini">
int <code class="descname">dm_hw_fini</code><span class="sig-paren">(</span>void *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_hw_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>Teardown DC device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>The base driver device containing the amdgpu_dm device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Teardown components within <a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_display_manager</span></code></a> that require
cleanup. This involves cleaning up the DRM device, DC, and any modules that
were loaded. Also flush IRQ workqueues and disable them.</p>
</div>
<div class="section" id="interrupts">
<h3>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">¶</a></h3>
<p>DM provides another layer of IRQ management on top of what the base driver
already provides. This is something that could be cleaned up, and is a
future TODO item.</p>
<p>The base driver provides IRQ source registration with DRM, handler
registration into the base driver’s IRQ table, and a handler callback
<a class="reference internal" href="amdgpu.html#c.amdgpu_irq_handler" title="amdgpu_irq_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_irq_handler()</span></code></a>, with which DRM calls on interrupts. This generic
handler looks up the IRQ table, and calls the respective
<code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_irq_src_funcs.process</span></code> hookups.</p>
<p>What DM provides on top are two IRQ tables specifically for top-half and
bottom-half IRQ handling, with the bottom-half implementing workqueues:</p>
<ul class="simple">
<li><a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_display_manager.irq_handler_list_high_tab</span></code></a></li>
<li><a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_display_manager.irq_handler_list_low_tab</span></code></a></li>
</ul>
<p>They override the base driver’s IRQ table, and the effect can be seen
in the hooks that DM provides for <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_irq_src_funcs.process</span></code>. They
are all set to the DM generic handler <a class="reference internal" href="#c.amdgpu_dm_irq_handler" title="amdgpu_dm_irq_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_dm_irq_handler()</span></code></a>, which looks up
DM’s IRQ tables. However, in order for base driver to recognize this hook, DM
still needs to register the IRQ with the base driver. See
dce110_register_irq_handlers() and dcn10_register_irq_handlers().</p>
<p>To expose DC’s hardware interrupt toggle to the base driver, DM implements
<code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_irq_src_funcs.set</span></code> hooks. Base driver calls it through
<a class="reference internal" href="amdgpu.html#c.amdgpu_irq_update" title="amdgpu_irq_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_irq_update()</span></code></a> to enable or disable the interrupt.</p>
<dl class="type">
<dt id="c.amdgpu_dm_irq_handler_data">
struct <code class="descname">amdgpu_dm_irq_handler_data</code><a class="headerlink" href="#c.amdgpu_dm_irq_handler_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data for DM interrupt handlers.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_dm_irq_handler_data {
  struct list_head list;
  interrupt_handler handler;
  void *handler_arg;
  struct amdgpu_display_manager *dm;
  enum dc_irq_source irq_source;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>Linked list entry referencing the next/previous handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt>
<dd>Handler function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler_arg</span></code></dt>
<dd>Argument passed to the handler when triggered</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dm</span></code></dt>
<dd>DM which this handler belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_source</span></code></dt>
<dd>DC interrupt source that this handler is registered for</dd>
</dl>
<dl class="function">
<dt id="c.dm_irq_work_func">
void <code class="descname">dm_irq_work_func</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_irq_work_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle an IRQ outside of the interrupt handler proper.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work struct</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_dm_irq_register_interrupt">
void * <code class="descname">amdgpu_dm_irq_register_interrupt</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct dc_interrupt_params *<em>&nbsp;int_params</em>, void (*ih) (void<em>&nbsp;*</em>, void *<em>&nbsp;handler_args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_register_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a handler within DM.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>The base driver device containing the DM device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_interrupt_params</span> <span class="pre">*</span> <span class="pre">int_params</span></code></dt>
<dd>Interrupt parameters containing the source, and handler context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*)</span> <span class="pre">ih</span></code></dt>
<dd>Function pointer to the interrupt handler to register</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">handler_args</span></code></dt>
<dd>Arguments passed to the handler when the interrupt occurs</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register an interrupt handler for the given IRQ source, under the given
context. The context can either be high or low. High context handlers are
executed directly within ISR context, while low context is executed within a
workqueue, thereby allowing operations that sleep.</p>
<p>Registered handlers are called in a FIFO manner, i.e. the most recently
registered handler will be called first.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Handler data <a class="reference internal" href="#c.amdgpu_dm_irq_handler_data" title="amdgpu_dm_irq_handler_data"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_dm_irq_handler_data</span></code></a> containing the IRQ</dt>
<dd>source, handler function, and args</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_dm_irq_unregister_interrupt">
void <code class="descname">amdgpu_dm_irq_unregister_interrupt</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, enum dc_irq_source<em>&nbsp;irq_source</em>, void *<em>&nbsp;ih</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_unregister_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a handler from the DM IRQ table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>The base driver device containing the DM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dc_irq_source</span> <span class="pre">irq_source</span></code></dt>
<dd>IRQ source to remove the given handler from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ih</span></code></dt>
<dd>Function pointer to the interrupt handler to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Go through both low and high context IRQ tables, and find the given handler
for the given irq source. If found, remove it. Otherwise, do nothing.</p>
<dl class="function">
<dt id="c.amdgpu_dm_irq_init">
int <code class="descname">amdgpu_dm_irq_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize DM IRQ management</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>The base driver device containing the DM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize DM’s high and low context IRQ tables.</p>
<p>The N by M table contains N IRQ sources, with M
<a class="reference internal" href="#c.amdgpu_dm_irq_handler_data" title="amdgpu_dm_irq_handler_data"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_dm_irq_handler_data</span></code></a> hooked together in a linked list. The
list_heads are initialized here. When an interrupt n is triggered, all m
handlers are called in sequence, FIFO according to registration order.</p>
<p>The low context table requires special steps to initialize, since handlers
will be deferred to a workqueue. See <a class="reference internal" href="#c.irq_list_head" title="irq_list_head"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_list_head</span></code></a>.</p>
<dl class="function">
<dt id="c.amdgpu_dm_irq_fini">
void <code class="descname">amdgpu_dm_irq_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>Tear down DM IRQ management</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>The base driver device containing the DM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush all work within the low context IRQ table.</p>
<dl class="function">
<dt id="c.amdgpu_dm_irq_handler">
int <code class="descname">amdgpu_dm_irq_handler</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_irq_src *<em>&nbsp;source</em>, struct amdgpu_iv_entry *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic DM IRQ handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu base driver device containing the DM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">source</span></code></dt>
<dd>Unused</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_iv_entry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>Data about the triggered interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls all registered high irq work immediately, and schedules work for low
irq. The DM IRQ table is used to find the corresponding handlers.</p>
<dl class="function">
<dt id="c.amdgpu_dm_hpd_init">
void <code class="descname">amdgpu_dm_hpd_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_hpd_init" title="Permalink to this definition">¶</a></dt>
<dd><p>hpd setup callback.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the hpd pins used by the card (evergreen+).
Enable the pin, set the polarity, and enable the hpd interrupts.</p>
<dl class="function">
<dt id="c.amdgpu_dm_hpd_fini">
void <code class="descname">amdgpu_dm_hpd_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_hpd_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>hpd tear down callback.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down the hpd pins used by the card (evergreen+).
Disable the hpd interrupts.</p>
<dl class="function">
<dt id="c.dm_pflip_high_irq">
void <code class="descname">dm_pflip_high_irq</code><span class="sig-paren">(</span>void *<em>&nbsp;interrupt_params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_pflip_high_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle pageflip interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">interrupt_params</span></code></dt>
<dd>ignored</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handles the pageflip interrupt by notifying all interested parties
that the pageflip has been completed.</p>
<dl class="function">
<dt id="c.dm_crtc_high_irq">
void <code class="descname">dm_crtc_high_irq</code><span class="sig-paren">(</span>void *<em>&nbsp;interrupt_params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_crtc_high_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles CRTC interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">interrupt_params</span></code></dt>
<dd>ignored</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handles the CRTC/VSYNC interrupt by notfying DRM’s VBLANK
event handler.</p>
</div>
<div class="section" id="atomic-implementation">
<h3>Atomic Implementation<a class="headerlink" href="#atomic-implementation" title="Permalink to this headline">¶</a></h3>
<p><em>WIP</em></p>
<dl class="function">
<dt id="c.amdgpu_dm_atomic_commit_tail">
void <code class="descname">amdgpu_dm_atomic_commit_tail</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_atomic_commit_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>AMDgpu DM’s commit tail implementation.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>The atomic state to commit</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will tell DC to commit the constructed DC state from atomic_check,
programming the hardware. Any failures here implies a hardware failure, since
atomic check should have filtered anything non-kosher.</p>
<dl class="function">
<dt id="c.amdgpu_dm_atomic_check">
int <code class="descname">amdgpu_dm_atomic_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_atomic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic check implementation for AMDgpu DM.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The DRM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>The atomic state to commit</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validate that the given atomic state is programmable by DC into hardware.
This involves constructing a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_state</span></code> reflecting the new hardware
state we wish to commit, then querying DC to see if it is programmable. It’s
important not to modify the existing DC state. Otherwise, atomic_check
may unexpectedly commit hardware changes.</p>
<p>When validating the DC state, it’s important that the right locks are
acquired. For full updates case which removes/adds/updates streams on one
CRTC while flipping on another CRTC, acquiring global lock will guarantee
that any such full update commit will wait for completion of any outstanding
flip using DRMs synchronization events. See
dm_determine_update_type_for_commit()</p>
<p>Note that DM adds the affected connectors for all CRTCs in state, when that
might not seem necessary. This is because DC stream creation requires the
DC sink, which is tied to the DRM connector state. Cleaning this up should
be possible but non-trivial - a possible TODO item.</p>
<p><strong>Return</strong></p>
<p>-Error code if validation failed.</p>
</div>
</div>
<div class="section" id="display-core">
<h2>Display Core<a class="headerlink" href="#display-core" title="Permalink to this headline">¶</a></h2>
<p><strong>WIP</strong></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>