

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Checksum Offloads &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Checksum Offloads</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/checksum-offloads.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="checksum-offloads">
<h1>Checksum Offloads<a class="headerlink" href="#checksum-offloads" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes a set of techniques in the Linux networking stack to
take advantage of checksum offload capabilities of various NICs.</p>
<p>The following technologies are described:</p>
<ul class="simple">
<li>TX Checksum Offload</li>
<li>LCO: Local Checksum Offload</li>
<li>RCO: Remote Checksum Offload</li>
</ul>
<p>Things that should be documented here but aren’t yet:</p>
<ul class="simple">
<li>RX Checksum Offload</li>
<li>CHECKSUM_UNNECESSARY conversion</li>
</ul>
</div>
<div class="section" id="tx-checksum-offload">
<h2>TX Checksum Offload<a class="headerlink" href="#tx-checksum-offload" title="Permalink to this headline">¶</a></h2>
<p>The interface for offloading a transmit checksum to a device is explained in
detail in comments near the top of include/linux/skbuff.h.</p>
<p>In brief, it allows to request the device fill in a single ones-complement
checksum defined by the sk_buff fields skb-&gt;csum_start and skb-&gt;csum_offset.
The device should compute the 16-bit ones-complement checksum (i.e. the
‘IP-style’ checksum) from csum_start to the end of the packet, and fill in the
result at (csum_start + csum_offset).</p>
<p>Because csum_offset cannot be negative, this ensures that the previous value of
the checksum field is included in the checksum computation, thus it can be used
to supply any needed corrections to the checksum (such as the sum of the
pseudo-header for UDP or TCP).</p>
<p>This interface only allows a single checksum to be offloaded.  Where
encapsulation is used, the packet may have multiple checksum fields in
different header layers, and the rest will have to be handled by another
mechanism such as LCO or RCO.</p>
<p>CRC32c can also be offloaded using this interface, by means of filling
skb-&gt;csum_start and skb-&gt;csum_offset as described above, and setting
skb-&gt;csum_not_inet: see skbuff.h comment (section ‘D’) for more details.</p>
<p>No offloading of the IP header checksum is performed; it is always done in
software.  This is OK because when we build the IP header, we obviously have it
in cache, so summing it isn’t expensive.  It’s also rather short.</p>
<p>The requirements for GSO are more complicated, because when segmenting an
encapsulated packet both the inner and outer checksums may need to be edited or
recomputed for each resulting segment.  See the skbuff.h comment (section ‘E’)
for more details.</p>
<p>A driver declares its offload capabilities in netdev-&gt;hw_features; see
Documentation/networking/netdev-features.txt for more.  Note that a device
which only advertises NETIF_F_IP[V6]_CSUM must still obey the csum_start and
csum_offset given in the SKB; if it tries to deduce these itself in hardware
(as some NICs do) the driver should check that the values in the SKB match
those which the hardware will deduce, and if not, fall back to checksumming in
software instead (with skb_csum_hwoffload_help() or one of the
skb_checksum_help() / skb_crc32c_csum_help functions, as mentioned in
include/linux/skbuff.h).</p>
<p>The stack should, for the most part, assume that checksum offload is supported
by the underlying device.  The only place that should check is
validate_xmit_skb(), and the functions it calls directly or indirectly.  That
function compares the offload features requested by the SKB (which may include
other offloads besides TX Checksum Offload) and, if they are not supported or
enabled on the device (determined by netdev-&gt;features), performs the
corresponding offload in software.  In the case of TX Checksum Offload, that
means calling skb_csum_hwoffload_help(skb, features).</p>
</div>
<div class="section" id="lco-local-checksum-offload">
<h2>LCO: Local Checksum Offload<a class="headerlink" href="#lco-local-checksum-offload" title="Permalink to this headline">¶</a></h2>
<p>LCO is a technique for efficiently computing the outer checksum of an
encapsulated datagram when the inner checksum is due to be offloaded.</p>
<p>The ones-complement sum of a correctly checksummed TCP or UDP packet is equal
to the complement of the sum of the pseudo header, because everything else gets
‘cancelled out’ by the checksum field.  This is because the sum was
complemented before being written to the checksum field.</p>
<p>More generally, this holds in any case where the ‘IP-style’ ones complement
checksum is used, and thus any checksum that TX Checksum Offload supports.</p>
<p>That is, if we have set up TX Checksum Offload with a start/offset pair, we
know that after the device has filled in that checksum, the ones complement sum
from csum_start to the end of the packet will be equal to the complement of
whatever value we put in the checksum field beforehand.  This allows us to
compute the outer checksum without looking at the payload: we simply stop
summing when we get to csum_start, then add the complement of the 16-bit word
at (csum_start + csum_offset).</p>
<p>Then, when the true inner checksum is filled in (either by hardware or by
skb_checksum_help()), the outer checksum will become correct by virtue of the
arithmetic.</p>
<p>LCO is performed by the stack when constructing an outer UDP header for an
encapsulation such as VXLAN or GENEVE, in udp_set_csum().  Similarly for the
IPv6 equivalents, in udp6_set_csum().</p>
<p>It is also performed when constructing an IPv4 GRE header, in
net/ipv4/ip_gre.c:build_header().  It is <em>not</em> currently performed when
constructing an IPv6 GRE header; the GRE checksum is computed over the whole
packet in net/ipv6/ip6_gre.c:ip6gre_xmit2(), but it should be possible to use
LCO here as IPv6 GRE still uses an IP-style checksum.</p>
<p>All of the LCO implementations use a helper function lco_csum(), in
include/linux/skbuff.h.</p>
<p>LCO can safely be used for nested encapsulations; in this case, the outer
encapsulation layer will sum over both its own header and the ‘middle’ header.
This does mean that the ‘middle’ header will get summed multiple times, but
there doesn’t seem to be a way to avoid that without incurring bigger costs
(e.g. in SKB bloat).</p>
</div>
<div class="section" id="rco-remote-checksum-offload">
<h2>RCO: Remote Checksum Offload<a class="headerlink" href="#rco-remote-checksum-offload" title="Permalink to this headline">¶</a></h2>
<p>RCO is a technique for eliding the inner checksum of an encapsulated datagram,
allowing the outer checksum to be offloaded.  It does, however, involve a
change to the encapsulation protocols, which the receiver must also support.
For this reason, it is disabled by default.</p>
<p>RCO is detailed in the following Internet-Drafts:</p>
<ul class="simple">
<li><a class="reference external" href="https://tools.ietf.org/html/draft-herbert-remotecsumoffload-00">https://tools.ietf.org/html/draft-herbert-remotecsumoffload-00</a></li>
<li><a class="reference external" href="https://tools.ietf.org/html/draft-herbert-vxlan-rco-00">https://tools.ietf.org/html/draft-herbert-vxlan-rco-00</a></li>
</ul>
<p>In Linux, RCO is implemented individually in each encapsulation protocol, and
most tunnel types have flags controlling its use.  For instance, VXLAN has the
flag VXLAN_F_REMCSUM_TX (per struct vxlan_rdst) to indicate that RCO should be
used when transmitting to a given remote destination.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>