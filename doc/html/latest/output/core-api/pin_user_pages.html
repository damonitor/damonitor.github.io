

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pin_user_pages() and related calls &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>pin_user_pages() and related calls</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/core-api/pin_user_pages.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pin-user-pages-and-related-calls">
<h1>pin_user_pages() and related calls<a class="headerlink" href="#pin-user-pages-and-related-calls" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id1">Overview</a></li>
<li><a class="reference internal" href="#basic-description-of-foll-pin" id="id2">Basic description of FOLL_PIN</a></li>
<li><a class="reference internal" href="#which-flags-are-set-by-each-wrapper" id="id3">Which flags are set by each wrapper</a></li>
<li><a class="reference internal" href="#tracking-dma-pinned-pages" id="id4">Tracking dma-pinned pages</a></li>
<li><a class="reference internal" href="#foll-pin-foll-get-foll-longterm-when-to-use-which-flags" id="id5">FOLL_PIN, FOLL_GET, FOLL_LONGTERM: when to use which flags</a><ul>
<li><a class="reference internal" href="#case-1-direct-io-dio" id="id6">CASE 1: Direct IO (DIO)</a></li>
<li><a class="reference internal" href="#case-2-rdma" id="id7">CASE 2: RDMA</a></li>
<li><a class="reference internal" href="#case-3-hardware-with-page-faulting-support" id="id8">CASE 3: Hardware with page faulting support</a></li>
<li><a class="reference internal" href="#case-4-pinning-for-struct-page-manipulation-only" id="id9">CASE 4: Pinning for struct page manipulation only</a></li>
</ul>
</li>
<li><a class="reference internal" href="#page-dma-pinned-the-whole-point-of-pinning" id="id10">page_dma_pinned(): the whole point of pinning</a></li>
<li><a class="reference internal" href="#another-way-of-thinking-about-foll-get-foll-pin-and-foll-longterm" id="id11">Another way of thinking about FOLL_GET, FOLL_PIN, and FOLL_LONGTERM</a></li>
<li><a class="reference internal" href="#unit-testing" id="id12">Unit testing</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id1">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This document describes the following functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pin_user_pages()
pin_user_pages_fast()
pin_user_pages_remote()
</pre></div>
</div>
</div>
<div class="section" id="basic-description-of-foll-pin">
<h2><a class="toc-backref" href="#id2">Basic description of FOLL_PIN</a><a class="headerlink" href="#basic-description-of-foll-pin" title="Permalink to this headline">¶</a></h2>
<p>FOLL_PIN and FOLL_LONGTERM are flags that can be passed to the get_user_pages*()
(“gup”) family of functions. FOLL_PIN has significant interactions and
interdependencies with FOLL_LONGTERM, so both are covered here.</p>
<p>FOLL_PIN is internal to gup, meaning that it should not appear at the gup call
sites. This allows the associated wrapper functions  (pin_user_pages*() and
others) to set the correct combination of these flags, and to check for problems
as well.</p>
<p>FOLL_LONGTERM, on the other hand, <em>is</em> allowed to be set at the gup call sites.
This is in order to avoid creating a large number of wrapper functions to cover
all combinations of get*(), pin*(), FOLL_LONGTERM, and more. Also, the
pin_user_pages*() APIs are clearly distinct from the get_user_pages*() APIs, so
that’s a natural dividing line, and a good point to make separate wrapper calls.
In other words, use pin_user_pages*() for DMA-pinned pages, and
get_user_pages*() for other cases. There are four cases described later on in
this document, to further clarify that concept.</p>
<p>FOLL_PIN and FOLL_GET are mutually exclusive for a given gup call. However,
multiple threads and call sites are free to pin the same struct pages, via both
FOLL_PIN and FOLL_GET. It’s just the call site that needs to choose one or the
other, not the struct page(s).</p>
<p>The FOLL_PIN implementation is nearly the same as FOLL_GET, except that FOLL_PIN
uses a different reference counting technique.</p>
<p>FOLL_PIN is a prerequisite to FOLL_LONGTERM. Another way of saying that is,
FOLL_LONGTERM is a specific case, more restrictive case of FOLL_PIN.</p>
</div>
<div class="section" id="which-flags-are-set-by-each-wrapper">
<h2><a class="toc-backref" href="#id3">Which flags are set by each wrapper</a><a class="headerlink" href="#which-flags-are-set-by-each-wrapper" title="Permalink to this headline">¶</a></h2>
<p>For these pin_user_pages*() functions, FOLL_PIN is OR’d in with whatever gup
flags the caller provides. The caller is required to pass in a non-null struct
pages* array, and the function then pin pages by incrementing each by a special
value. For now, that value is +1, just like get_user_pages*().:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Function
--------
pin_user_pages          FOLL_PIN is always set internally by this function.
pin_user_pages_fast     FOLL_PIN is always set internally by this function.
pin_user_pages_remote   FOLL_PIN is always set internally by this function.
</pre></div>
</div>
<p>For these get_user_pages*() functions, FOLL_GET might not even be specified.
Behavior is a little more complex than above. If FOLL_GET was <em>not</em> specified,
but the caller passed in a non-null struct pages* array, then the function
sets FOLL_GET for you, and proceeds to pin pages by incrementing the refcount
of each page by +1.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Function
--------
get_user_pages           FOLL_GET is sometimes set internally by this function.
get_user_pages_fast      FOLL_GET is sometimes set internally by this function.
get_user_pages_remote    FOLL_GET is sometimes set internally by this function.
</pre></div>
</div>
</div>
<div class="section" id="tracking-dma-pinned-pages">
<h2><a class="toc-backref" href="#id4">Tracking dma-pinned pages</a><a class="headerlink" href="#tracking-dma-pinned-pages" title="Permalink to this headline">¶</a></h2>
<p>Some of the key design constraints, and solutions, for tracking dma-pinned
pages:</p>
<ul class="simple">
<li>An actual reference count, per struct page, is required. This is because
multiple processes may pin and unpin a page.</li>
<li>False positives (reporting that a page is dma-pinned, when in fact it is not)
are acceptable, but false negatives are not.</li>
<li>struct page may not be increased in size for this, and all fields are already
used.</li>
<li>Given the above, we can overload the page-&gt;_refcount field by using, sort of,
the upper bits in that field for a dma-pinned count. “Sort of”, means that,
rather than dividing page-&gt;_refcount into bit fields, we simple add a medium-
large value (GUP_PIN_COUNTING_BIAS, initially chosen to be 1024: 10 bits) to
page-&gt;_refcount. This provides fuzzy behavior: if a page has get_page() called
on it 1024 times, then it will appear to have a single dma-pinned count.
And again, that’s acceptable.</li>
</ul>
<p>This also leads to limitations: there are only 31-10==21 bits available for a
counter that increments 10 bits at a time.</p>
<p>TODO: for 1GB and larger huge pages, this is cutting it close. That’s because
when pin_user_pages() follows such pages, it increments the head page by “1”
(where “1” used to mean “+1” for get_user_pages(), but now means “+1024” for
pin_user_pages()) for each tail page. So if you have a 1GB huge page:</p>
<ul class="simple">
<li>There are 256K (18 bits) worth of 4 KB tail pages.</li>
<li>There are 21 bits available to count up via GUP_PIN_COUNTING_BIAS (that is,
10 bits at a time)</li>
<li>There are 21 - 18 == 3 bits available to count. Except that there aren’t,
because you need to allow for a few normal get_page() calls on the head page,
as well. Fortunately, the approach of using addition, rather than “hard”
bitfields, within page-&gt;_refcount, allows for sharing these bits gracefully.
But we’re still looking at about 8 references.</li>
</ul>
<p>This, however, is a missing feature more than anything else, because it’s easily
solved by addressing an obvious inefficiency in the original get_user_pages()
approach of retrieving pages: stop treating all the pages as if they were
PAGE_SIZE. Retrieve huge pages as huge pages. The callers need to be aware of
this, so some work is required. Once that’s in place, this limitation mostly
disappears from view, because there will be ample refcounting range available.</p>
<ul class="simple">
<li>Callers must specifically request “dma-pinned tracking of pages”. In other
words, just calling get_user_pages() will not suffice; a new set of functions,
pin_user_page() and related, must be used.</li>
</ul>
</div>
<div class="section" id="foll-pin-foll-get-foll-longterm-when-to-use-which-flags">
<h2><a class="toc-backref" href="#id5">FOLL_PIN, FOLL_GET, FOLL_LONGTERM: when to use which flags</a><a class="headerlink" href="#foll-pin-foll-get-foll-longterm-when-to-use-which-flags" title="Permalink to this headline">¶</a></h2>
<p>Thanks to Jan Kara, Vlastimil Babka and several other -mm people, for describing
these categories:</p>
<div class="section" id="case-1-direct-io-dio">
<h3><a class="toc-backref" href="#id6">CASE 1: Direct IO (DIO)</a><a class="headerlink" href="#case-1-direct-io-dio" title="Permalink to this headline">¶</a></h3>
<p>There are GUP references to pages that are serving
as DIO buffers. These buffers are needed for a relatively short time (so they
are not “long term”). No special synchronization with page_mkclean() or
munmap() is provided. Therefore, flags to set at the call site are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FOLL_PIN
</pre></div>
</div>
<p>…but rather than setting FOLL_PIN directly, call sites should use one of
the pin_user_pages*() routines that set FOLL_PIN.</p>
</div>
<div class="section" id="case-2-rdma">
<h3><a class="toc-backref" href="#id7">CASE 2: RDMA</a><a class="headerlink" href="#case-2-rdma" title="Permalink to this headline">¶</a></h3>
<p>There are GUP references to pages that are serving as DMA
buffers. These buffers are needed for a long time (“long term”). No special
synchronization with page_mkclean() or munmap() is provided. Therefore, flags
to set at the call site are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FOLL_PIN | FOLL_LONGTERM
</pre></div>
</div>
<p>NOTE: Some pages, such as DAX pages, cannot be pinned with longterm pins. That’s
because DAX pages do not have a separate page cache, and so “pinning” implies
locking down file system blocks, which is not (yet) supported in that way.</p>
</div>
<div class="section" id="case-3-hardware-with-page-faulting-support">
<h3><a class="toc-backref" href="#id8">CASE 3: Hardware with page faulting support</a><a class="headerlink" href="#case-3-hardware-with-page-faulting-support" title="Permalink to this headline">¶</a></h3>
<p>Here, a well-written driver doesn’t normally need to pin pages at all. However,
if the driver does choose to do so, it can register MMU notifiers for the range,
and will be called back upon invalidation. Either way (avoiding page pinning, or
using MMU notifiers to unpin upon request), there is proper synchronization with
both filesystem and mm (page_mkclean(), munmap(), etc).</p>
<p>Therefore, neither flag needs to be set.</p>
<p>In this case, ideally, neither get_user_pages() nor pin_user_pages() should be
called. Instead, the software should be written so that it does not pin pages.
This allows mm and filesystems to operate more efficiently and reliably.</p>
</div>
<div class="section" id="case-4-pinning-for-struct-page-manipulation-only">
<h3><a class="toc-backref" href="#id9">CASE 4: Pinning for struct page manipulation only</a><a class="headerlink" href="#case-4-pinning-for-struct-page-manipulation-only" title="Permalink to this headline">¶</a></h3>
<p>Here, normal GUP calls are sufficient, so neither flag needs to be set.</p>
</div>
</div>
<div class="section" id="page-dma-pinned-the-whole-point-of-pinning">
<h2><a class="toc-backref" href="#id10">page_dma_pinned(): the whole point of pinning</a><a class="headerlink" href="#page-dma-pinned-the-whole-point-of-pinning" title="Permalink to this headline">¶</a></h2>
<p>The whole point of marking pages as “DMA-pinned” or “gup-pinned” is to be able
to query, “is this page DMA-pinned?” That allows code such as page_mkclean()
(and file system writeback code in general) to make informed decisions about
what to do when a page cannot be unmapped due to such pins.</p>
<p>What to do in those cases is the subject of a years-long series of discussions
and debates (see the References at the end of this document). It’s a TODO item
here: fill in the details once that’s worked out. Meanwhile, it’s safe to say
that having this available:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline bool page_dma_pinned(struct page *page)
</pre></div>
</div>
<p>…is a prerequisite to solving the long-running gup+DMA problem.</p>
</div>
<div class="section" id="another-way-of-thinking-about-foll-get-foll-pin-and-foll-longterm">
<h2><a class="toc-backref" href="#id11">Another way of thinking about FOLL_GET, FOLL_PIN, and FOLL_LONGTERM</a><a class="headerlink" href="#another-way-of-thinking-about-foll-get-foll-pin-and-foll-longterm" title="Permalink to this headline">¶</a></h2>
<p>Another way of thinking about these flags is as a progression of restrictions:
FOLL_GET is for struct page manipulation, without affecting the data that the
struct page refers to. FOLL_PIN is a <em>replacement</em> for FOLL_GET, and is for
short term pins on pages whose data <em>will</em> get accessed. As such, FOLL_PIN is
a “more severe” form of pinning. And finally, FOLL_LONGTERM is an even more
restrictive case that has FOLL_PIN as a prerequisite: this is for pages that
will be pinned longterm, and whose data will be accessed.</p>
</div>
<div class="section" id="unit-testing">
<h2><a class="toc-backref" href="#id12">Unit testing</a><a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h2>
<p>This file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tools/testing/selftests/vm/gup_benchmark.c
</pre></div>
</div>
<p>has the following new calls to exercise the new pin*() wrapper functions:</p>
<ul class="simple">
<li>PIN_FAST_BENCHMARK (./gup_benchmark -a)</li>
<li>PIN_BENCHMARK (./gup_benchmark -b)</li>
</ul>
<p>You can monitor how many total dma-pinned pages have been acquired and released
since the system was booted, via two new /proc/vmstat entries:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/proc/vmstat/nr_foll_pin_requested
/proc/vmstat/nr_foll_pin_requested
</pre></div>
</div>
<p>Those are both going to show zero, unless CONFIG_DEBUG_VM is set. This is
because there is a noticeable performance drop in unpin_user_page(), when they
are activated.</p>
</div>
<div class="section" id="references">
<h2><a class="toc-backref" href="#id13">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://lwn.net/Articles/784574/">Some slow progress on get_user_pages() (Apr 2, 2019)</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/774411/">DMA and get_user_pages() (LPC: Dec 12, 2018)</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/753027/">The trouble with get_user_pages() (Apr 30, 2018)</a></li>
</ul>
<p>John Hubbard, October, 2019</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>