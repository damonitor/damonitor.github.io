

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ID Allocation &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>ID Allocation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/core-api/idr.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id-allocation">
<h1>ID Allocation<a class="headerlink" href="#id-allocation" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Matthew Wilcox</td>
</tr>
</tbody>
</table>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>A common problem to solve is allocating identifiers (IDs); generally
small numbers which identify a thing.  Examples include file descriptors,
process IDs, packet identifiers in networking protocols, SCSI tags
and device instance numbers.  The IDR and the IDA provide a reasonable
solution to the problem to avoid everybody inventing their own.  The IDR
provides the ability to map an ID to a pointer, while the IDA provides
only ID allocation, and as a result is much more memory-efficient.</p>
</div>
<div class="section" id="idr-usage">
<h2>IDR usage<a class="headerlink" href="#idr-usage" title="Permalink to this headline">¶</a></h2>
<p>Start by initialising an IDR, either with <a class="reference internal" href="#c.DEFINE_IDR" title="DEFINE_IDR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_IDR()</span></code></a>
for statically allocated IDRs or <a class="reference internal" href="#c.idr_init" title="idr_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_init()</span></code></a> for dynamically
allocated IDRs.</p>
<p>You can call <a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc()</span></code></a> to allocate an unused ID.  Look up
the pointer you associated with the ID by calling <a class="reference internal" href="#c.idr_find" title="idr_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_find()</span></code></a>
and free the ID by calling <a class="reference internal" href="#c.idr_remove" title="idr_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_remove()</span></code></a>.</p>
<p>If you need to change the pointer associated with an ID, you can call
<a class="reference internal" href="#c.idr_replace" title="idr_replace"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_replace()</span></code></a>.  One common reason to do this is to reserve an
ID by passing a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer to the allocation function; initialise the
object with the reserved ID and finally insert the initialised object
into the IDR.</p>
<p>Some users need to allocate IDs larger than <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>.  So far all of
these users have been content with a <code class="docutils literal notranslate"><span class="pre">UINT_MAX</span></code> limit, and they use
<a class="reference internal" href="#c.idr_alloc_u32" title="idr_alloc_u32"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc_u32()</span></code></a>.  If you need IDs that will not fit in a u32,
we will work with you to address your needs.</p>
<p>If you need to allocate IDs sequentially, you can use
<a class="reference internal" href="#c.idr_alloc_cyclic" title="idr_alloc_cyclic"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc_cyclic()</span></code></a>.  The IDR becomes less efficient when dealing
with larger IDs, so using this function comes at a slight cost.</p>
<p>To perform an action on all pointers used by the IDR, you can
either use the callback-based <a class="reference internal" href="#c.idr_for_each" title="idr_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_for_each()</span></code></a> or the
iterator-style <a class="reference internal" href="#c.idr_for_each_entry" title="idr_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_for_each_entry()</span></code></a>.  You may need to use
<a class="reference internal" href="#c.idr_for_each_entry_continue" title="idr_for_each_entry_continue"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_for_each_entry_continue()</span></code></a> to continue an iteration.  You can
also use <a class="reference internal" href="#c.idr_get_next" title="idr_get_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_get_next()</span></code></a> if the iterator doesn’t fit your needs.</p>
<p>When you have finished using an IDR, you can call <code class="xref c c-func docutils literal notranslate"><span class="pre">idr_destroy()</span></code>
to release the memory used by the IDR.  This will not free the objects
pointed to from the IDR; if you want to do that, use one of the iterators
to do it.</p>
<p>You can use <a class="reference internal" href="#c.idr_is_empty" title="idr_is_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_is_empty()</span></code></a> to find out whether there are any
IDs currently allocated.</p>
<p>If you need to take a lock while allocating a new ID from the IDR,
you may need to pass a restrictive set of GFP flags, which can lead
to the IDR being unable to allocate memory.  To work around this,
you can call <code class="xref c c-func docutils literal notranslate"><span class="pre">idr_preload()</span></code> before taking the lock, and then
<a class="reference internal" href="#c.idr_preload_end" title="idr_preload_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_preload_end()</span></code></a> after the allocation.</p>
<p>idr synchronization (stolen from radix-tree.h)</p>
<p><a class="reference internal" href="#c.idr_find" title="idr_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_find()</span></code></a> is able to be called locklessly, using RCU. The caller must
ensure calls to this function are made within <a class="reference internal" href="kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> regions.
Other readers (lock-free or otherwise) and modifications may be running
concurrently.</p>
<p>It is still required that the caller manage the synchronization and
lifetimes of the items. So if RCU lock-free lookups are used, typically
this would mean that the items have their own locks, or are amenable to
lock-free access; and that the items are freed by RCU (or only freed after
having been deleted from the idr tree <em>and</em> a <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> grace
period).</p>
</div>
<div class="section" id="ida-usage">
<h2>IDA usage<a class="headerlink" href="#ida-usage" title="Permalink to this headline">¶</a></h2>
<p>The IDA is an ID allocator which does not provide the ability to
associate an ID with a pointer.  As such, it only needs to store one
bit per ID, and so is more space efficient than an IDR.  To use an IDA,
define it using DEFINE_IDA() (or embed a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span></code> in a data structure,
then initialise it using ida_init()).  To allocate a new ID, call
<a class="reference internal" href="#c.ida_alloc" title="ida_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_alloc()</span></code></a>, <a class="reference internal" href="#c.ida_alloc_min" title="ida_alloc_min"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_alloc_min()</span></code></a>, <a class="reference internal" href="#c.ida_alloc_max" title="ida_alloc_max"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_alloc_max()</span></code></a> or <a class="reference internal" href="#c.ida_alloc_range" title="ida_alloc_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_alloc_range()</span></code></a>.
To free an ID, call <a class="reference internal" href="#c.ida_free" title="ida_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_free()</span></code></a>.</p>
<p><a class="reference internal" href="#c.ida_destroy" title="ida_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_destroy()</span></code></a> can be used to dispose of an IDA without needing to
free the individual IDs in it.  You can use ida_is_empty() to find
out whether the IDA has any IDs currently allocated.</p>
<p>The IDA handles its own locking.  It is safe to call any of the IDA
functions without synchronisation in your code.</p>
<p>IDs are currently limited to the range [0-INT_MAX].  If this is an awkward
limitation, it should be quite straightforward to raise the maximum.</p>
</div>
<div class="section" id="functions-and-structures">
<h2>Functions and structures<a class="headerlink" href="#functions-and-structures" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.IDR_INIT">
<code class="descname">IDR_INIT</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.IDR_INIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise an IDR.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>Name of IDR.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A freshly-initialised IDR contains no IDs.</p>
<dl class="function">
<dt id="c.DEFINE_IDR">
<code class="descname">DEFINE_IDR</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_IDR" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a statically-allocated IDR.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>Name of IDR.</dd>
</dl>
<p><strong>Description</strong></p>
<p>An IDR defined using this macro is ready for use with no additional
initialisation required.  It contains no IDs.</p>
<dl class="function">
<dt id="c.idr_get_cursor">
unsigned int <code class="descname">idr_get_cursor</code><span class="sig-paren">(</span>const struct idr *<em>&nbsp;idr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_get_cursor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current position of the cyclic allocator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>The value returned is the value that will be next returned from
<a class="reference internal" href="#c.idr_alloc_cyclic" title="idr_alloc_cyclic"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc_cyclic()</span></code></a> if it is free (otherwise the search will start from
this position).</p>
<dl class="function">
<dt id="c.idr_set_cursor">
void <code class="descname">idr_set_cursor</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, unsigned int<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_set_cursor" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current position of the cyclic allocator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt>
<dd>new position</dd>
</dl>
<p><strong>Description</strong></p>
<p>The next call to <a class="reference internal" href="#c.idr_alloc_cyclic" title="idr_alloc_cyclic"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc_cyclic()</span></code></a> will return <strong>val</strong> if it is free
(otherwise the search will start from this position).</p>
<dl class="function">
<dt id="c.idr_init_base">
void <code class="descname">idr_init_base</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_init_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise an IDR.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The base value for the IDR.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variation of <a class="reference internal" href="#c.idr_init" title="idr_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_init()</span></code></a> creates an IDR which will allocate IDs
starting at <code class="docutils literal notranslate"><span class="pre">base</span></code>.</p>
<dl class="function">
<dt id="c.idr_init">
void <code class="descname">idr_init</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise an IDR.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialise a dynamically allocated IDR.  To initialise a
statically allocated IDR, use <a class="reference internal" href="#c.DEFINE_IDR" title="DEFINE_IDR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_IDR()</span></code></a>.</p>
<dl class="function">
<dt id="c.idr_is_empty">
bool <code class="descname">idr_is_empty</code><span class="sig-paren">(</span>const struct idr *<em>&nbsp;idr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Are there any IDs allocated?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if any IDs have been allocated from this IDR.</p>
<dl class="function">
<dt id="c.idr_preload_end">
void <code class="descname">idr_preload_end</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.idr_preload_end" title="Permalink to this definition">¶</a></dt>
<dd><p>end preload section started with idr_preload()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each idr_preload() should be matched with an invocation of this
function.  See idr_preload() for details.</p>
<dl class="function">
<dt id="c.idr_for_each_entry">
<code class="descname">idr_for_each_entry</code><span class="sig-paren">(</span><em>idr</em>, <em>entry</em>, <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over an IDR’s elements of a given type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd>The type * to use as cursor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>Entry ID.</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>entry</strong> and <strong>id</strong> do not need to be initialized before the loop, and
after normal termination <strong>entry</strong> is left with the value NULL.  This
is convenient for a “not found” value.</p>
<dl class="function">
<dt id="c.idr_for_each_entry_ul">
<code class="descname">idr_for_each_entry_ul</code><span class="sig-paren">(</span><em>idr</em>, <em>entry</em>, <em>tmp</em>, <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_for_each_entry_ul" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over an IDR’s elements of a given type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd>The type * to use as cursor.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tmp</span></code></dt>
<dd>A temporary placeholder for ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>Entry ID.</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>entry</strong> and <strong>id</strong> do not need to be initialized before the loop, and
after normal termination <strong>entry</strong> is left with the value NULL.  This
is convenient for a “not found” value.</p>
<dl class="function">
<dt id="c.idr_for_each_entry_continue">
<code class="descname">idr_for_each_entry_continue</code><span class="sig-paren">(</span><em>idr</em>, <em>entry</em>, <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_for_each_entry_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>Continue iteration over an IDR’s elements of a given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd>The type * to use as a cursor.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>Entry ID.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over entries, continuing after the current position.</p>
<dl class="function">
<dt id="c.idr_for_each_entry_continue_ul">
<code class="descname">idr_for_each_entry_continue_ul</code><span class="sig-paren">(</span><em>idr</em>, <em>entry</em>, <em>tmp</em>, <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_for_each_entry_continue_ul" title="Permalink to this definition">¶</a></dt>
<dd><p>Continue iteration over an IDR’s elements of a given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd>The type * to use as a cursor.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tmp</span></code></dt>
<dd>A temporary placeholder for ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>Entry ID.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over entries, continuing after the current position.</p>
<dl class="function">
<dt id="c.ida_alloc">
int <code class="descname">ida_alloc</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an unused ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>IDA handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Memory allocation flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ID between 0 and <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>, inclusive.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>The allocated ID, or <code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if memory could not be allocated,
or <code class="docutils literal notranslate"><span class="pre">-ENOSPC</span></code> if there are no free IDs.</p>
<dl class="function">
<dt id="c.ida_alloc_min">
int <code class="descname">ida_alloc_min</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, unsigned int<em>&nbsp;min</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_alloc_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an unused ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>IDA handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>Lowest ID to allocate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Memory allocation flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ID between <strong>min</strong> and <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>, inclusive.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>The allocated ID, or <code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if memory could not be allocated,
or <code class="docutils literal notranslate"><span class="pre">-ENOSPC</span></code> if there are no free IDs.</p>
<dl class="function">
<dt id="c.ida_alloc_max">
int <code class="descname">ida_alloc_max</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, unsigned int<em>&nbsp;max</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_alloc_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an unused ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>IDA handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt>
<dd>Highest ID to allocate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Memory allocation flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ID between 0 and <strong>max</strong>, inclusive.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>The allocated ID, or <code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if memory could not be allocated,
or <code class="docutils literal notranslate"><span class="pre">-ENOSPC</span></code> if there are no free IDs.</p>
<dl class="function">
<dt id="c.idr_alloc_u32">
int <code class="descname">idr_alloc_u32</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, void *<em>&nbsp;ptr</em>, u32 *<em>&nbsp;nextid</em>, unsigned long<em>&nbsp;max</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_alloc_u32" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>Pointer to be associated with the new ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">nextid</span></code></dt>
<dd>Pointer to an ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt>
<dd>The maximum ID to allocate (inclusive).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Memory allocation flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an unused ID in the range specified by <strong>nextid</strong> and <strong>max</strong>.
Note that <strong>max</strong> is inclusive whereas the <strong>end</strong> parameter to <a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc()</span></code></a>
is exclusive.  The new ID is assigned to <strong>nextid</strong> before the pointer
is inserted into the IDR, so if <strong>nextid</strong> points into the object pointed
to by <strong>ptr</strong>, a concurrent lookup will not find an uninitialised ID.</p>
<p>The caller should provide their own locking to ensure that two
concurrent modifications to the IDR are not possible.  Read-only
accesses to the IDR may be done under the RCU read lock or may
exclude simultaneous writers.</p>
<p><strong>Return</strong></p>
<p>0 if an ID was allocated, -ENOMEM if memory allocation failed,
or -ENOSPC if no free IDs could be found.  If an error occurred,
<strong>nextid</strong> is unchanged.</p>
<dl class="function">
<dt id="c.idr_alloc">
int <code class="descname">idr_alloc</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, void *<em>&nbsp;ptr</em>, int<em>&nbsp;start</em>, int<em>&nbsp;end</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>Pointer to be associated with the new ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>The minimum ID (inclusive).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">end</span></code></dt>
<dd>The maximum ID (exclusive).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Memory allocation flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an unused ID in the range specified by <strong>start</strong> and <strong>end</strong>.  If
<strong>end</strong> is &lt;= 0, it is treated as one larger than <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>.  This allows
callers to use <strong>start</strong> + N as <strong>end</strong> as long as N is within integer range.</p>
<p>The caller should provide their own locking to ensure that two
concurrent modifications to the IDR are not possible.  Read-only
accesses to the IDR may be done under the RCU read lock or may
exclude simultaneous writers.</p>
<p><strong>Return</strong></p>
<p>The newly allocated ID, -ENOMEM if memory allocation failed,
or -ENOSPC if no free IDs could be found.</p>
<dl class="function">
<dt id="c.idr_alloc_cyclic">
int <code class="descname">idr_alloc_cyclic</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, void *<em>&nbsp;ptr</em>, int<em>&nbsp;start</em>, int<em>&nbsp;end</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_alloc_cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an ID cyclically.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>Pointer to be associated with the new ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>The minimum ID (inclusive).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">end</span></code></dt>
<dd>The maximum ID (exclusive).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Memory allocation flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an unused ID in the range specified by <strong>nextid</strong> and <strong>end</strong>.  If
<strong>end</strong> is &lt;= 0, it is treated as one larger than <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>.  This allows
callers to use <strong>start</strong> + N as <strong>end</strong> as long as N is within integer range.
The search for an unused ID will start at the last ID allocated and will
wrap around to <strong>start</strong> if no free IDs are found before reaching <strong>end</strong>.</p>
<p>The caller should provide their own locking to ensure that two
concurrent modifications to the IDR are not possible.  Read-only
accesses to the IDR may be done under the RCU read lock or may
exclude simultaneous writers.</p>
<p><strong>Return</strong></p>
<p>The newly allocated ID, -ENOMEM if memory allocation failed,
or -ENOSPC if no free IDs could be found.</p>
<dl class="function">
<dt id="c.idr_remove">
void * <code class="descname">idr_remove</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, unsigned long<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an ID from the IDR.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">id</span></code></dt>
<dd>Pointer ID.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes this ID from the IDR.  If the ID was not previously in the IDR,
this function returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Since this function modifies the IDR, the caller should provide their
own locking to ensure that concurrent modification of the same IDR is
not possible.</p>
<p><strong>Return</strong></p>
<p>The pointer formerly associated with this ID.</p>
<dl class="function">
<dt id="c.idr_find">
void * <code class="descname">idr_find</code><span class="sig-paren">(</span>const struct idr *<em>&nbsp;idr</em>, unsigned long<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_find" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pointer for given ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">id</span></code></dt>
<dd>Pointer ID.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the pointer associated with this ID.  A <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer may
indicate that <strong>id</strong> is not allocated or that the <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer was
associated with this ID.</p>
<p>This function can be called under <a class="reference internal" href="kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>, given that the leaf
pointers lifetimes are correctly managed.</p>
<p><strong>Return</strong></p>
<p>The pointer associated with this ID.</p>
<dl class="function">
<dt id="c.idr_for_each">
int <code class="descname">idr_for_each</code><span class="sig-paren">(</span>const struct idr *<em>&nbsp;idr</em>, int (*fn) (int<em>&nbsp;id</em>, void<em>&nbsp;*p</em>, void<em>&nbsp;*data</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through all stored pointers.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(int</span> <span class="pre">id,</span> <span class="pre">void</span> <span class="pre">*p,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">fn</span></code></dt>
<dd>Function to be called for each pointer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data passed to callback function.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be called for each entry in <strong>idr</strong>, passing
the ID, the entry and <strong>data</strong>.</p>
<p>If <strong>fn</strong> returns anything other than <code class="docutils literal notranslate"><span class="pre">0</span></code>, the iteration stops and that
value is returned from this function.</p>
<p><a class="reference internal" href="#c.idr_for_each" title="idr_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_for_each()</span></code></a> can be called concurrently with <a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc()</span></code></a> and
<a class="reference internal" href="#c.idr_remove" title="idr_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_remove()</span></code></a> if protected by RCU.  Newly added entries may not be
seen and deleted entries may be seen, but adding and removing entries
will not cause other entries to be skipped, nor spurious ones to be seen.</p>
<dl class="function">
<dt id="c.idr_get_next_ul">
void * <code class="descname">idr_get_next_ul</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, unsigned long *<em>&nbsp;nextid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_get_next_ul" title="Permalink to this definition">¶</a></dt>
<dd><p>Find next populated entry.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">nextid</span></code></dt>
<dd>Pointer to an ID.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next populated entry in the tree with an ID greater than
or equal to the value pointed to by <strong>nextid</strong>.  On exit, <strong>nextid</strong> is updated
to the ID of the found value.  To use in a loop, the value pointed to by
nextid must be incremented by the user.</p>
<dl class="function">
<dt id="c.idr_get_next">
void * <code class="descname">idr_get_next</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, int *<em>&nbsp;nextid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_get_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Find next populated entry.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">nextid</span></code></dt>
<dd>Pointer to an ID.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next populated entry in the tree with an ID greater than
or equal to the value pointed to by <strong>nextid</strong>.  On exit, <strong>nextid</strong> is updated
to the ID of the found value.  To use in a loop, the value pointed to by
nextid must be incremented by the user.</p>
<dl class="function">
<dt id="c.idr_replace">
void * <code class="descname">idr_replace</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, void *<em>&nbsp;ptr</em>, unsigned long<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace pointer for given ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>IDR handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>New pointer to associate with the ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">id</span></code></dt>
<dd>ID to change.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace the pointer registered with an ID and return the old value.
This function can be called under the RCU read lock concurrently with
<a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc()</span></code></a> and <a class="reference internal" href="#c.idr_remove" title="idr_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_remove()</span></code></a> (as long as the ID being removed is not
the one being replaced!).</p>
<p><strong>Return</strong></p>
<p>the old value on success.  <code class="docutils literal notranslate"><span class="pre">-ENOENT</span></code> indicates that <strong>id</strong> was not
found.  <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> indicates that <strong>ptr</strong> was not valid.</p>
<dl class="function">
<dt id="c.ida_alloc_range">
int <code class="descname">ida_alloc_range</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, unsigned int<em>&nbsp;min</em>, unsigned int<em>&nbsp;max</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_alloc_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an unused ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>IDA handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>Lowest ID to allocate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt>
<dd>Highest ID to allocate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Memory allocation flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ID between <strong>min</strong> and <strong>max</strong>, inclusive.  The allocated ID will
not exceed <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>, even if <strong>max</strong> is larger.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>The allocated ID, or <code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if memory could not be allocated,
or <code class="docutils literal notranslate"><span class="pre">-ENOSPC</span></code> if there are no free IDs.</p>
<dl class="function">
<dt id="c.ida_free">
void <code class="descname">ida_free</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, unsigned int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Release an allocated ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>IDA handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>Previously allocated ID.</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
<dl class="function">
<dt id="c.ida_destroy">
void <code class="descname">ida_destroy</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Free all IDs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>IDA handle.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function frees all IDs and releases all resources used
by an IDA.  When this call returns, the IDA is empty and can be reused
or freed.  If the IDA is already empty, there is no need to call this
function.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>