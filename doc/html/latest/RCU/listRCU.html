

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Using RCU to Protect Read-Mostly Linked Lists &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Using RCU to Protect Dynamic NMI Handlers" href="NMI-RCU.html" />
    <link rel="prev" title="RCU Concepts" href="rcu.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../core-api/index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../core-api/kernel-api.html">The Linux Kernel API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/atomic_ops.html">Semantics and Behavior of Atomic and Bitmask Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/cachetlb.html">Cache and TLB Flushing Under Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/refcount-vs-atomic.html">refcount_t API compared to atomic_t</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/cpu_hotplug.html">CPU hotplug in the Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/idr.html">ID Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/xarray.html">XArray</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/librs.html">Reed-Solomon Library Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/genalloc.html">The genalloc/genpool subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/errseq.html">The errseq_t datatype</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/packing.html">Generic bitfield packing and unpacking functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/printk-formats.html">How to get printk format specifiers right</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/circular-buffers.html">Circular Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/generic-radix-tree.html">Generic radix trees/sparse arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/memory-allocation.html">Memory Allocation Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/mm-api.html">Memory Management APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/pin_user_pages.html">pin_user_pages() and related calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/gfp_mask-from-fs-io.html">GFP masks used from FS/IO context</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/timekeeping.html">ktime accessors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/boot-time-mm.html">Boot time memory management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/memory-hotplug.html">Memory hotplug</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/protection-keys.html">Memory Protection Keys</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">RCU concepts</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="arrayRCU.html">Using RCU to Protect Read-Mostly Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="rcubarrier.html">RCU and Unloadable Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="rcu_dereference.html">PROPER CARE AND FEEDING OF RETURN VALUES FROM rcu_dereference()</a></li>
<li class="toctree-l4"><a class="reference internal" href="whatisRCU.html">What is RCU?  –  “Read, Copy, Update”</a></li>
<li class="toctree-l4"><a class="reference internal" href="rcu.html">RCU Concepts</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Using RCU to Protect Read-Mostly Linked Lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="NMI-RCU.html">Using RCU to Protect Dynamic NMI Handlers</a></li>
<li class="toctree-l4"><a class="reference internal" href="UP.html">RCU on Uniprocessor Systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="Design/Memory-Ordering/Tree-RCU-Memory-Ordering.html">A Tour Through TREE_RCU’s Grace-Period Memory Ordering</a></li>
<li class="toctree-l4"><a class="reference internal" href="Design/Expedited-Grace-Periods/Expedited-Grace-Periods.html">A Tour Through TREE_RCU’s Expedited Grace Periods</a></li>
<li class="toctree-l4"><a class="reference internal" href="Design/Requirements/Requirements.html">A Tour Through RCU’s Requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="Design/Data-Structures/Data-Structures.html">A Tour Through TREE_RCU’s Data Structures [LWN.net]</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/gcc-plugins.html">GCC plugin infrastructure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/symbol-namespaces.html">Symbol Namespaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/padata.html">The padata parallel execution mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/ioctl.html">ioctl based interfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../core-api/index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../core-api/index.html">Core API Documentation</a> &raquo;</li>
        
          <li><a href="index.html">RCU concepts</a> &raquo;</li>
        
      <li>Using RCU to Protect Read-Mostly Linked Lists</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/RCU/listRCU.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="using-rcu-to-protect-read-mostly-linked-lists">
<span id="list-rcu-doc"></span><h1>Using RCU to Protect Read-Mostly Linked Lists<a class="headerlink" href="#using-rcu-to-protect-read-mostly-linked-lists" title="Permalink to this headline">¶</a></h1>
<p>One of the best applications of RCU is to protect read-mostly linked lists
(“struct list_head” in list.h).  One big advantage of this approach
is that all of the required memory barriers are included for you in
the list macros.  This document describes several applications of RCU,
with the best fits first.</p>
<div class="section" id="example-1-read-side-action-taken-outside-of-lock-no-in-place-updates">
<h2>Example 1: Read-Side Action Taken Outside of Lock, No In-Place Updates<a class="headerlink" href="#example-1-read-side-action-taken-outside-of-lock-no-in-place-updates" title="Permalink to this headline">¶</a></h2>
<p>The best applications are cases where, if reader-writer locking were
used, the read-side lock would be dropped before taking any action
based on the results of the search.  The most celebrated example is
the routing table.  Because the routing table is tracking the state of
equipment outside of the computer, it will at times contain stale data.
Therefore, once the route has been computed, there is no need to hold
the routing table static during transmission of the packet.  After all,
you can hold the routing table static all you want, but that won’t keep
the external Internet from changing, and it is the state of the external
Internet that really matters.  In addition, routing entries are typically
added or deleted, rather than being modified in place.</p>
<p>A straightforward example of this use of RCU may be found in the
system-call auditing support.  For example, a reader-writer locked
implementation of audit_filter_task() might be as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static enum audit_state audit_filter_task(struct task_struct *tsk)
{
        struct audit_entry *e;
        enum audit_state   state;

        read_lock(&amp;auditsc_lock);
        /* Note: audit_netlink_sem held by caller. */
        list_for_each_entry(e, &amp;audit_tsklist, list) {
                if (audit_filter_rules(tsk, &amp;e-&gt;rule, NULL, &amp;state)) {
                        read_unlock(&amp;auditsc_lock);
                        return state;
                }
        }
        read_unlock(&amp;auditsc_lock);
        return AUDIT_BUILD_CONTEXT;
}
</pre></div>
</div>
<p>Here the list is searched under the lock, but the lock is dropped before
the corresponding value is returned.  By the time that this value is acted
on, the list may well have been modified.  This makes sense, since if
you are turning auditing off, it is OK to audit a few extra system calls.</p>
<p>This means that RCU can be easily applied to the read side, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static enum audit_state audit_filter_task(struct task_struct *tsk)
{
        struct audit_entry *e;
        enum audit_state   state;

        rcu_read_lock();
        /* Note: audit_netlink_sem held by caller. */
        list_for_each_entry_rcu(e, &amp;audit_tsklist, list) {
                if (audit_filter_rules(tsk, &amp;e-&gt;rule, NULL, &amp;state)) {
                        rcu_read_unlock();
                        return state;
                }
        }
        rcu_read_unlock();
        return AUDIT_BUILD_CONTEXT;
}
</pre></div>
</div>
<p>The read_lock() and read_unlock() calls have become <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>
and <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>, respectively, and the <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_entry" title="list_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry()</span></code></a> has
become <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>.  The _rcu() list-traversal primitives
insert the read-side memory barriers that are required on DEC Alpha CPUs.</p>
<p>The changes to the update side are also straightforward.  A reader-writer
lock might be used as follows for deletion and insertion:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline int audit_del_rule(struct audit_rule *rule,
                                 struct list_head *list)
{
        struct audit_entry  *e;

        write_lock(&amp;auditsc_lock);
        list_for_each_entry(e, list, list) {
                if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {
                        list_del(&amp;e-&gt;list);
                        write_unlock(&amp;auditsc_lock);
                        return 0;
                }
        }
        write_unlock(&amp;auditsc_lock);
        return -EFAULT;         /* No matching rule */
}

static inline int audit_add_rule(struct audit_entry *entry,
                                 struct list_head *list)
{
        write_lock(&amp;auditsc_lock);
        if (entry-&gt;rule.flags &amp; AUDIT_PREPEND) {
                entry-&gt;rule.flags &amp;= ~AUDIT_PREPEND;
                list_add(&amp;entry-&gt;list, list);
        } else {
                list_add_tail(&amp;entry-&gt;list, list);
        }
        write_unlock(&amp;auditsc_lock);
        return 0;
}
</pre></div>
</div>
<p>Following are the RCU equivalents for these two functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline int audit_del_rule(struct audit_rule *rule,
                                 struct list_head *list)
{
        struct audit_entry  *e;

        /* Do not use the _rcu iterator here, since this is the only
         * deletion routine. */
        list_for_each_entry(e, list, list) {
                if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {
                        list_del_rcu(&amp;e-&gt;list);
                        call_rcu(&amp;e-&gt;rcu, audit_free_rule);
                        return 0;
                }
        }
        return -EFAULT;         /* No matching rule */
}

static inline int audit_add_rule(struct audit_entry *entry,
                                 struct list_head *list)
{
        if (entry-&gt;rule.flags &amp; AUDIT_PREPEND) {
                entry-&gt;rule.flags &amp;= ~AUDIT_PREPEND;
                list_add_rcu(&amp;entry-&gt;list, list);
        } else {
                list_add_tail_rcu(&amp;entry-&gt;list, list);
        }
        return 0;
}
</pre></div>
</div>
<p>Normally, the write_lock() and write_unlock() would be replaced by
a spin_lock() and a spin_unlock(), but in this case, all callers hold
audit_netlink_sem, so no additional locking is required.  The auditsc_lock
can therefore be eliminated, since use of RCU eliminates the need for
writers to exclude readers.  Normally, the write_lock() calls would
be converted into spin_lock() calls.</p>
<p>The <a class="reference internal" href="../core-api/kernel-api.html#c.list_del" title="list_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.list_add" title="list_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add()</span></code></a>, and <a class="reference internal" href="../core-api/kernel-api.html#c.list_add_tail" title="list_add_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_tail()</span></code></a> primitives have been
replaced by <a class="reference internal" href="../core-api/kernel-api.html#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>, and <a class="reference internal" href="../core-api/kernel-api.html#c.list_add_tail_rcu" title="list_add_tail_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_tail_rcu()</span></code></a>.
The _rcu() list-manipulation primitives add memory barriers that are
needed on weakly ordered CPUs (most of them!).  The <a class="reference internal" href="../core-api/kernel-api.html#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>
primitive omits the pointer poisoning debug-assist code that would
otherwise cause concurrent readers to fail spectacularly.</p>
<p>So, when readers can tolerate stale data and when entries are either added
or deleted, without in-place modification, it is very easy to use RCU!</p>
</div>
<div class="section" id="example-2-handling-in-place-updates">
<h2>Example 2: Handling In-Place Updates<a class="headerlink" href="#example-2-handling-in-place-updates" title="Permalink to this headline">¶</a></h2>
<p>The system-call auditing code does not update auditing rules in place.
However, if it did, reader-writer-locked code to do so might look as
follows (presumably, the field_count is only permitted to decrease,
otherwise, the added fields would need to be filled in):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline int audit_upd_rule(struct audit_rule *rule,
                                 struct list_head *list,
                                 __u32 newaction,
                                 __u32 newfield_count)
{
        struct audit_entry  *e;
        struct audit_newentry *ne;

        write_lock(&amp;auditsc_lock);
        /* Note: audit_netlink_sem held by caller. */
        list_for_each_entry(e, list, list) {
                if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {
                        e-&gt;rule.action = newaction;
                        e-&gt;rule.file_count = newfield_count;
                        write_unlock(&amp;auditsc_lock);
                        return 0;
                }
        }
        write_unlock(&amp;auditsc_lock);
        return -EFAULT;         /* No matching rule */
}
</pre></div>
</div>
<p>The RCU version creates a copy, updates the copy, then replaces the old
entry with the newly updated entry.  This sequence of actions, allowing
concurrent reads while doing a copy to perform an update, is what gives
RCU (“read-copy update”) its name.  The RCU code is as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline int audit_upd_rule(struct audit_rule *rule,
                                 struct list_head *list,
                                 __u32 newaction,
                                 __u32 newfield_count)
{
        struct audit_entry  *e;
        struct audit_newentry *ne;

        list_for_each_entry(e, list, list) {
                if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {
                        ne = kmalloc(sizeof(*entry), GFP_ATOMIC);
                        if (ne == NULL)
                                return -ENOMEM;
                        audit_copy_rule(&amp;ne-&gt;rule, &amp;e-&gt;rule);
                        ne-&gt;rule.action = newaction;
                        ne-&gt;rule.file_count = newfield_count;
                        list_replace_rcu(&amp;e-&gt;list, &amp;ne-&gt;list);
                        call_rcu(&amp;e-&gt;rcu, audit_free_rule);
                        return 0;
                }
        }
        return -EFAULT;         /* No matching rule */
}
</pre></div>
</div>
<p>Again, this assumes that the caller holds audit_netlink_sem.  Normally,
the reader-writer lock would become a spinlock in this sort of code.</p>
</div>
<div class="section" id="example-3-eliminating-stale-data">
<h2>Example 3: Eliminating Stale Data<a class="headerlink" href="#example-3-eliminating-stale-data" title="Permalink to this headline">¶</a></h2>
<p>The auditing examples above tolerate stale data, as do most algorithms
that are tracking external state.  Because there is a delay from the
time the external state changes before Linux becomes aware of the change,
additional RCU-induced staleness is normally not a problem.</p>
<p>However, there are many examples where stale data cannot be tolerated.
One example in the Linux kernel is the System V IPC (see the ipc_lock()
function in ipc/util.c).  This code checks a “deleted” flag under a
per-entry spinlock, and, if the “deleted” flag is set, pretends that the
entry does not exist.  For this to be helpful, the search function must
return holding the per-entry spinlock, as ipc_lock() does in fact do.</p>
<dl class="docutils">
<dt>Quick Quiz:</dt>
<dd>Why does the search function need to return holding the per-entry lock for
this deleted-flag technique to be helpful?</dd>
</dl>
<p><a class="reference internal" href="#answer-quick-quiz-list"><span class="std std-ref">Answer to Quick Quiz</span></a></p>
<p>If the system-call audit module were to ever need to reject stale data,
one way to accomplish this would be to add a “deleted” flag and a “lock”
spinlock to the audit_entry structure, and modify audit_filter_task()
as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static enum audit_state audit_filter_task(struct task_struct *tsk)
{
        struct audit_entry *e;
        enum audit_state   state;

        rcu_read_lock();
        list_for_each_entry_rcu(e, &amp;audit_tsklist, list) {
                if (audit_filter_rules(tsk, &amp;e-&gt;rule, NULL, &amp;state)) {
                        spin_lock(&amp;e-&gt;lock);
                        if (e-&gt;deleted) {
                                spin_unlock(&amp;e-&gt;lock);
                                rcu_read_unlock();
                                return AUDIT_BUILD_CONTEXT;
                        }
                        rcu_read_unlock();
                        return state;
                }
        }
        rcu_read_unlock();
        return AUDIT_BUILD_CONTEXT;
}
</pre></div>
</div>
<p>Note that this example assumes that entries are only added and deleted.
Additional mechanism is required to deal correctly with the
update-in-place performed by audit_upd_rule().  For one thing,
audit_upd_rule() would need additional memory barriers to ensure
that the <a class="reference internal" href="../core-api/kernel-api.html#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a> was really executed before the <a class="reference internal" href="../core-api/kernel-api.html#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>.</p>
<p>The audit_del_rule() function would need to set the “deleted”
flag under the spinlock as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline int audit_del_rule(struct audit_rule *rule,
                                 struct list_head *list)
{
        struct audit_entry  *e;

        /* Do not need to use the _rcu iterator here, since this
         * is the only deletion routine. */
        list_for_each_entry(e, list, list) {
                if (!audit_compare_rule(rule, &amp;e-&gt;rule)) {
                        spin_lock(&amp;e-&gt;lock);
                        list_del_rcu(&amp;e-&gt;list);
                        e-&gt;deleted = 1;
                        spin_unlock(&amp;e-&gt;lock);
                        call_rcu(&amp;e-&gt;rcu, audit_free_rule);
                        return 0;
                }
        }
        return -EFAULT;         /* No matching rule */
}
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Read-mostly list-based data structures that can tolerate stale data are
the most amenable to use of RCU.  The simplest case is where entries are
either added or deleted from the data structure (or atomically modified
in place), but non-atomic in-place modifications can be handled by making
a copy, updating the copy, then replacing the original with the copy.
If stale data cannot be tolerated, then a “deleted” flag may be used
in conjunction with a per-entry spinlock in order to allow the search
function to reject newly deleted data.</p>
<dl class="docutils" id="answer-quick-quiz-list">
<dt>Answer to Quick Quiz:</dt>
<dd><p class="first">Why does the search function need to return holding the per-entry
lock for this deleted-flag technique to be helpful?</p>
<p class="last">If the search function drops the per-entry lock before returning,
then the caller will be processing stale data in any case.  If it
is really OK to be processing stale data, then you don’t need a
“deleted” flag.  If processing stale data really is a problem,
then you need to hold the per-entry lock across all of the code
that uses the value that was returned.</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="NMI-RCU.html" class="btn btn-neutral float-right" title="Using RCU to Protect Dynamic NMI Handlers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rcu.html" class="btn btn-neutral float-left" title="RCU Concepts" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>