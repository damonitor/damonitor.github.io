

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Linux WatchDog Timer Driver Core kernel API &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="WatchDog Module Parameters" href="watchdog-parameters.html" />
    <link rel="prev" title="The Linux Watchdog driver API" href="watchdog-api.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Watchdog Support</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="hpwdt.html">HPE iLO NMI Watchdog Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="mlx-wdt.html">Mellanox watchdog drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="pcwd-watchdog.html">Berkshire Products PC Watchdog Card</a></li>
<li class="toctree-l2"><a class="reference internal" href="watchdog-api.html">The Linux Watchdog driver API</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">The Linux WatchDog Timer Driver Core kernel API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-api">The API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="watchdog-parameters.html">WatchDog Module Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="watchdog-pm.html">The Linux WatchDog Timer Power Management Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="wdt.html">WDT Watchdog Timer Interfaces For The Linux Operating System</a></li>
<li class="toctree-l2"><a class="reference internal" href="convert_drivers_to_kernel_api.html">Converting old watchdog drivers to the watchdog framework</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Watchdog Support</a> &raquo;</li>
        
      <li>The Linux WatchDog Timer Driver Core kernel API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/watchdog/watchdog-kernel-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-linux-watchdog-timer-driver-core-kernel-api">
<h1>The Linux WatchDog Timer Driver Core kernel API<a class="headerlink" href="#the-linux-watchdog-timer-driver-core-kernel-api" title="Permalink to this headline">¶</a></h1>
<p>Last reviewed: 12-Feb-2013</p>
<p>Wim Van Sebroeck &lt;<a class="reference external" href="mailto:wim&#37;&#52;&#48;iguana&#46;be">wim<span>&#64;</span>iguana<span>&#46;</span>be</a>&gt;</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document does not describe what a WatchDog Timer (WDT) Driver or Device is.
It also does not describe the API which can be used by user space to communicate
with a WatchDog Timer. If you want to know this then please read the following
file: Documentation/watchdog/watchdog-api.rst .</p>
<p>So what does this document describe? It describes the API that can be used by
WatchDog Timer Drivers that want to use the WatchDog Timer Driver Core
Framework. This framework provides all interfacing towards user space so that
the same code does not have to be reproduced each time. This also means that
a watchdog timer driver then only needs to provide the different routines
(operations) that control the watchdog timer (WDT).</p>
</div>
<div class="section" id="the-api">
<h2>The API<a class="headerlink" href="#the-api" title="Permalink to this headline">¶</a></h2>
<p>Each watchdog timer driver that wants to use the WatchDog Timer Driver Core
must #include &lt;linux/watchdog.h&gt; (you would have to do this anyway when
writing a watchdog device driver). This include file contains following
register/unregister routines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>extern int watchdog_register_device(struct watchdog_device *);
extern void watchdog_unregister_device(struct watchdog_device *);
</pre></div>
</div>
<p>The watchdog_register_device routine registers a watchdog timer device.
The parameter of this routine is a pointer to a watchdog_device structure.
This routine returns zero on success and a negative errno code for failure.</p>
<p>The watchdog_unregister_device routine deregisters a registered watchdog timer
device. The parameter of this routine is the pointer to the registered
watchdog_device structure.</p>
<p>The watchdog subsystem includes an registration deferral mechanism,
which allows you to register an watchdog as early as you wish during
the boot process.</p>
<p>The watchdog device structure looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct watchdog_device {
      int id;
      struct device *parent;
      const struct attribute_group **groups;
      const struct watchdog_info *info;
      const struct watchdog_ops *ops;
      const struct watchdog_governor *gov;
      unsigned int bootstatus;
      unsigned int timeout;
      unsigned int pretimeout;
      unsigned int min_timeout;
      unsigned int max_timeout;
      unsigned int min_hw_heartbeat_ms;
      unsigned int max_hw_heartbeat_ms;
      struct notifier_block reboot_nb;
      struct notifier_block restart_nb;
      void *driver_data;
      struct watchdog_core_data *wd_data;
      unsigned long status;
      struct list_head deferred;
};
</pre></div>
</div>
<p>It contains following fields:</p>
<ul class="simple">
<li>id: set by watchdog_register_device, id 0 is special. It has both a
/dev/watchdog0 cdev (dynamic major, minor 0) as well as the old
/dev/watchdog miscdev. The id is set automatically when calling
watchdog_register_device.</li>
<li>parent: set this to the parent device (or NULL) before calling
watchdog_register_device.</li>
<li>groups: List of sysfs attribute groups to create when creating the watchdog
device.</li>
<li>info: a pointer to a watchdog_info structure. This structure gives some
additional information about the watchdog timer itself. (Like it’s unique name)</li>
<li>ops: a pointer to the list of watchdog operations that the watchdog supports.</li>
<li>gov: a pointer to the assigned watchdog device pretimeout governor or NULL.</li>
<li>timeout: the watchdog timer’s timeout value (in seconds).
This is the time after which the system will reboot if user space does
not send a heartbeat request if WDOG_ACTIVE is set.</li>
<li>pretimeout: the watchdog timer’s pretimeout value (in seconds).</li>
<li>min_timeout: the watchdog timer’s minimum timeout value (in seconds).
If set, the minimum configurable value for ‘timeout’.</li>
<li>max_timeout: the watchdog timer’s maximum timeout value (in seconds),
as seen from userspace. If set, the maximum configurable value for
‘timeout’. Not used if max_hw_heartbeat_ms is non-zero.</li>
<li>min_hw_heartbeat_ms: Hardware limit for minimum time between heartbeats,
in milli-seconds. This value is normally 0; it should only be provided
if the hardware can not tolerate lower intervals between heartbeats.</li>
<li>max_hw_heartbeat_ms: Maximum hardware heartbeat, in milli-seconds.
If set, the infrastructure will send heartbeats to the watchdog driver
if ‘timeout’ is larger than max_hw_heartbeat_ms, unless WDOG_ACTIVE
is set and userspace failed to send a heartbeat for at least ‘timeout’
seconds. max_hw_heartbeat_ms must be set if a driver does not implement
the stop function.</li>
<li>reboot_nb: notifier block that is registered for reboot notifications, for
internal use only. If the driver calls watchdog_stop_on_reboot, watchdog core
will stop the watchdog on such notifications.</li>
<li>restart_nb: notifier block that is registered for machine restart, for
internal use only. If a watchdog is capable of restarting the machine, it
should define ops-&gt;restart. Priority can be changed through
watchdog_set_restart_priority.</li>
<li>bootstatus: status of the device after booting (reported with watchdog
WDIOF_* status bits).</li>
<li>driver_data: a pointer to the drivers private data of a watchdog device.
This data should only be accessed via the watchdog_set_drvdata and
watchdog_get_drvdata routines.</li>
<li>wd_data: a pointer to watchdog core internal data.</li>
<li>status: this field contains a number of status bits that give extra
information about the status of the device (Like: is the watchdog timer
running/active, or is the nowayout bit set).</li>
<li>deferred: entry in wtd_deferred_reg_list which is used to
register early initialized watchdogs.</li>
</ul>
<p>The list of watchdog operations is defined as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct watchdog_ops {
      struct module *owner;
      /* mandatory operations */
      int (*start)(struct watchdog_device *);
      int (*stop)(struct watchdog_device *);
      /* optional operations */
      int (*ping)(struct watchdog_device *);
      unsigned int (*status)(struct watchdog_device *);
      int (*set_timeout)(struct watchdog_device *, unsigned int);
      int (*set_pretimeout)(struct watchdog_device *, unsigned int);
      unsigned int (*get_timeleft)(struct watchdog_device *);
      int (*restart)(struct watchdog_device *);
      long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
};
</pre></div>
</div>
<p>It is important that you first define the module owner of the watchdog timer
driver’s operations. This module owner will be used to lock the module when
the watchdog is active. (This to avoid a system crash when you unload the
module and /dev/watchdog is still open).</p>
<p>Some operations are mandatory and some are optional. The mandatory operations
are:</p>
<ul class="simple">
<li>start: this is a pointer to the routine that starts the watchdog timer
device.
The routine needs a pointer to the watchdog timer device structure as a
parameter. It returns zero on success or a negative errno code for failure.</li>
</ul>
<p>Not all watchdog timer hardware supports the same functionality. That’s why
all other routines/operations are optional. They only need to be provided if
they are supported. These optional routines/operations are:</p>
<ul>
<li><p class="first">stop: with this routine the watchdog timer device is being stopped.</p>
<p>The routine needs a pointer to the watchdog timer device structure as a
parameter. It returns zero on success or a negative errno code for failure.
Some watchdog timer hardware can only be started and not be stopped. A
driver supporting such hardware does not have to implement the stop routine.</p>
<p>If a driver has no stop function, the watchdog core will set WDOG_HW_RUNNING
and start calling the driver’s keepalive pings function after the watchdog
device is closed.</p>
<p>If a watchdog driver does not implement the stop function, it must set
max_hw_heartbeat_ms.</p>
</li>
<li><p class="first">ping: this is the routine that sends a keepalive ping to the watchdog timer
hardware.</p>
<p>The routine needs a pointer to the watchdog timer device structure as a
parameter. It returns zero on success or a negative errno code for failure.</p>
<p>Most hardware that does not support this as a separate function uses the
start function to restart the watchdog timer hardware. And that’s also what
the watchdog timer driver core does: to send a keepalive ping to the watchdog
timer hardware it will either use the ping operation (when available) or the
start operation (when the ping operation is not available).</p>
<p>(Note: the WDIOC_KEEPALIVE ioctl call will only be active when the
WDIOF_KEEPALIVEPING bit has been set in the option field on the watchdog’s
info structure).</p>
</li>
<li><p class="first">status: this routine checks the status of the watchdog timer device. The
status of the device is reported with watchdog WDIOF_* status flags/bits.</p>
<p>WDIOF_MAGICCLOSE and WDIOF_KEEPALIVEPING are reported by the watchdog core;
it is not necessary to report those bits from the driver. Also, if no status
function is provided by the driver, the watchdog core reports the status bits
provided in the bootstatus variable of struct watchdog_device.</p>
</li>
<li><p class="first">set_timeout: this routine checks and changes the timeout of the watchdog
timer device. It returns 0 on success, -EINVAL for “parameter out of range”
and -EIO for “could not write value to the watchdog”. On success this
routine should set the timeout value of the watchdog_device to the
achieved timeout value (which may be different from the requested one
because the watchdog does not necessarily have a 1 second resolution).</p>
<p>Drivers implementing max_hw_heartbeat_ms set the hardware watchdog heartbeat
to the minimum of timeout and max_hw_heartbeat_ms. Those drivers set the
timeout value of the watchdog_device either to the requested timeout value
(if it is larger than max_hw_heartbeat_ms), or to the achieved timeout value.
(Note: the WDIOF_SETTIMEOUT needs to be set in the options field of the
watchdog’s info structure).</p>
<p>If the watchdog driver does not have to perform any action but setting the
watchdog_device.timeout, this callback can be omitted.</p>
<p>If set_timeout is not provided but, WDIOF_SETTIMEOUT is set, the watchdog
infrastructure updates the timeout value of the watchdog_device internally
to the requested value.</p>
<p>If the pretimeout feature is used (WDIOF_PRETIMEOUT), then set_timeout must
also take care of checking if pretimeout is still valid and set up the timer
accordingly. This can’t be done in the core without races, so it is the
duty of the driver.</p>
</li>
<li><p class="first">set_pretimeout: this routine checks and changes the pretimeout value of
the watchdog. It is optional because not all watchdogs support pretimeout
notification. The timeout value is not an absolute time, but the number of
seconds before the actual timeout would happen. It returns 0 on success,
-EINVAL for “parameter out of range” and -EIO for “could not write value to
the watchdog”. A value of 0 disables pretimeout notification.</p>
<p>(Note: the WDIOF_PRETIMEOUT needs to be set in the options field of the
watchdog’s info structure).</p>
<p>If the watchdog driver does not have to perform any action but setting the
watchdog_device.pretimeout, this callback can be omitted. That means if
set_pretimeout is not provided but WDIOF_PRETIMEOUT is set, the watchdog
infrastructure updates the pretimeout value of the watchdog_device internally
to the requested value.</p>
</li>
<li><p class="first">get_timeleft: this routines returns the time that’s left before a reset.</p>
</li>
<li><p class="first">restart: this routine restarts the machine. It returns 0 on success or a
negative errno code for failure.</p>
</li>
<li><p class="first">ioctl: if this routine is present then it will be called first before we do
our own internal ioctl call handling. This routine should return -ENOIOCTLCMD
if a command is not supported. The parameters that are passed to the ioctl
call are: watchdog_device, cmd and arg.</p>
</li>
</ul>
<p>The status bits should (preferably) be set with the set_bit and clear_bit alike
bit-operations. The status bits that are defined are:</p>
<ul>
<li><p class="first">WDOG_ACTIVE: this status bit indicates whether or not a watchdog timer device
is active or not from user perspective. User space is expected to send
heartbeat requests to the driver while this flag is set.</p>
</li>
<li><p class="first">WDOG_NO_WAY_OUT: this bit stores the nowayout setting for the watchdog.
If this bit is set then the watchdog timer will not be able to stop.</p>
</li>
<li><p class="first">WDOG_HW_RUNNING: Set by the watchdog driver if the hardware watchdog is
running. The bit must be set if the watchdog timer hardware can not be
stopped. The bit may also be set if the watchdog timer is running after
booting, before the watchdog device is opened. If set, the watchdog
infrastructure will send keepalives to the watchdog hardware while
WDOG_ACTIVE is not set.
Note: when you register the watchdog timer device with this bit set,
then opening /dev/watchdog will skip the start operation but send a keepalive
request instead.</p>
<p>To set the WDOG_NO_WAY_OUT status bit (before registering your watchdog
timer device) you can either:</p>
<ul>
<li><p class="first">set it statically in your watchdog_device struct with</p>
<blockquote>
<div><p>.status = WATCHDOG_NOWAYOUT_INIT_STATUS,</p>
</div></blockquote>
<p>(this will set the value the same as CONFIG_WATCHDOG_NOWAYOUT) or</p>
</li>
<li><p class="first">use the following helper function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline void watchdog_set_nowayout(struct watchdog_device *wdd,
                                         int nowayout)
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<dl class="docutils">
<dt>Note:</dt>
<dd>The WatchDog Timer Driver Core supports the magic close feature and
the nowayout feature. To use the magic close feature you must set the
WDIOF_MAGICCLOSE bit in the options field of the watchdog’s info structure.</dd>
</dl>
<p>The nowayout feature will overrule the magic close feature.</p>
<p>To get or set driver specific data the following two helper functions should be
used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline void watchdog_set_drvdata(struct watchdog_device *wdd,
                                        void *data)
static inline void *watchdog_get_drvdata(struct watchdog_device *wdd)
</pre></div>
</div>
<p>The watchdog_set_drvdata function allows you to add driver specific data. The
arguments of this function are the watchdog device where you want to add the
driver specific data to and a pointer to the data itself.</p>
<p>The watchdog_get_drvdata function allows you to retrieve driver specific data.
The argument of this function is the watchdog device where you want to retrieve
data from. The function returns the pointer to the driver specific data.</p>
<p>To initialize the timeout field, the following function can be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>extern int watchdog_init_timeout(struct watchdog_device *wdd,
                                 unsigned int timeout_parm,
                                 struct device *dev);
</pre></div>
</div>
<p>The watchdog_init_timeout function allows you to initialize the timeout field
using the module timeout parameter or by retrieving the timeout-sec property from
the device tree (if the module timeout parameter is invalid). Best practice is
to set the default timeout value as timeout value in the watchdog_device and
then use this function to set the user “preferred” timeout value.
This routine returns zero on success and a negative errno code for failure.</p>
<p>To disable the watchdog on reboot, the user must call the following helper:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline void watchdog_stop_on_reboot(struct watchdog_device *wdd);
</pre></div>
</div>
<p>To disable the watchdog when unregistering the watchdog, the user must call
the following helper. Note that this will only stop the watchdog if the
nowayout flag is not set.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline void watchdog_stop_on_unregister(struct watchdog_device *wdd);
</pre></div>
</div>
<p>To change the priority of the restart handler the following helper should be
used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void watchdog_set_restart_priority(struct watchdog_device *wdd, int priority);
</pre></div>
</div>
<p>User should follow the following guidelines for setting the priority:</p>
<ul class="simple">
<li>0: should be called in last resort, has limited restart capabilities</li>
<li>128: default restart handler, use if no other handler is expected to be
available, and/or if restart is sufficient to restart the entire system</li>
<li>255: highest priority, will preempt all other restart handlers</li>
</ul>
<p>To raise a pretimeout notification, the following function should be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void watchdog_notify_pretimeout(struct watchdog_device *wdd)
</pre></div>
</div>
<p>The function can be called in the interrupt context. If watchdog pretimeout
governor framework (kbuild CONFIG_WATCHDOG_PRETIMEOUT_GOV symbol) is enabled,
an action is taken by a preconfigured pretimeout governor preassigned to
the watchdog device. If watchdog pretimeout governor framework is not
enabled, watchdog_notify_pretimeout() prints a notification message to
the kernel log buffer.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="watchdog-parameters.html" class="btn btn-neutral float-right" title="WatchDog Module Parameters" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="watchdog-api.html" class="btn btn-neutral float-left" title="The Linux Watchdog driver API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>