

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SNMP counter &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Checksum Offloads" href="checksum-offloads.html" />
    <link rel="prev" title="Ethernet Bridging" href="bridge.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Networking Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="netdev-FAQ.html">netdev FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="af_xdp.html">AF_XDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="batman-adv.html">batman-adv</a></li>
<li class="toctree-l2"><a class="reference internal" href="can.html">SocketCAN - Controller Area Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="can_ucan_protocol.html">The UCAN Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_drivers/index.html">Vendor Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dsa/index.html">Distributed Switch Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="devlink/index.html">Linux Devlink Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ethtool-netlink.html">Netlink interface for ethtool</a></li>
<li class="toctree-l2"><a class="reference internal" href="ieee802154.html">IEEE 802.15.4 Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="j1939.html">J1939 Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="kapi.html">Linux Networking and Network Devices APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="z8530book.html">Z8530 Programming Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="msg_zerocopy.html">MSG_ZEROCOPY</a></li>
<li class="toctree-l2"><a class="reference internal" href="failover.html">FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="net_failover.html">NET_FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy.html">PHY Abstraction Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfp-phylink.html">phylink</a></li>
<li class="toctree-l2"><a class="reference internal" href="alias.html">IP-Aliasing</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge.html">Ethernet Bridging</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SNMP counter</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-ipv4-counters">General IPv4 counters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#icmp-counters">ICMP counters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#relationship-of-the-icmp-counters">relationship of the ICMP counters</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#general-tcp-counters">General TCP counters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-fast-open">TCP Fast Open</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-fast-path">TCP Fast Path</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-abort">TCP abort</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-hybrid-slow-start">TCP Hybrid Slow Start</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-retransmission-and-congestion-control">TCP retransmission and congestion control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dsack">DSACK</a></li>
<li class="toctree-l3"><a class="reference internal" href="#invalid-sack-and-dsack">invalid SACK and DSACK</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sack-shift">SACK shift</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-out-of-order">TCP out of order</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-paws">TCP PAWS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-ack-skip">TCP ACK skip</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-receive-window">TCP receive window</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delayed-ack">Delayed ACK</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tail-loss-probe-tlp">Tail Loss Probe (TLP)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">TCP Fast Open</a></li>
<li class="toctree-l3"><a class="reference internal" href="#syn-cookies">SYN cookies</a></li>
<li class="toctree-l3"><a class="reference internal" href="#challenge-ack">Challenge ACK</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prune">prune</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples">examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ping-test">ping test</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcp-3-way-handshake">tcp 3-way handshake</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcp-normal-traffic">TCP normal traffic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcpexttcpabortonclose">TcpExtTCPAbortOnClose</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcpexttcpabortonmemory-and-tcpexttcpabortontimeout">TcpExtTCPAbortOnMemory and TcpExtTCPAbortOnTimeout</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcpexttcpabortonlinger">TcpExtTCPAbortOnLinger</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcpexttcprcvcoalesce">TcpExtTCPRcvCoalesce</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcpextlistenoverflows-and-tcpextlistendrops">TcpExtListenOverflows and TcpExtListenDrops</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ipinaddrerrors-ipextinnoroutes-and-ipoutnoroutes">IpInAddrErrors, IpExtInNoRoutes and IpOutNoRoutes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcpexttcpackskippedsynrecv">TcpExtTCPACKSkippedSynRecv</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcpexttcpackskippedpaws">TcpExtTCPACKSkippedPAWS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcpexttcpackskippedseq">TcpExtTCPACKSkippedSeq</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="checksum-offloads.html">Checksum Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="segmentation-offloads.html">Segmentation Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="scaling.html">Scaling in the Linux Networking Stack</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls.html">Kernel TLS</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls-offload.html">Kernel TLS offload</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc.html">Linux NFC subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Networking Documentation</a> &raquo;</li>
        
      <li>SNMP counter</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/snmp_counter.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="snmp-counter">
<h1>SNMP counter<a class="headerlink" href="#snmp-counter" title="Permalink to this headline">¶</a></h1>
<p>This document explains the meaning of SNMP counters.</p>
<div class="section" id="general-ipv4-counters">
<h2>General IPv4 counters<a class="headerlink" href="#general-ipv4-counters" title="Permalink to this headline">¶</a></h2>
<p>All layer 4 packets and ICMP packets will change these counters, but
these counters won’t be changed by layer 2 packets (such as STP) or
ARP packets.</p>
<ul class="simple">
<li>IpInReceives</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-26">RFC1213 ipInReceives</a></p>
<p>The number of packets received by the IP layer. It gets increasing at the
beginning of ip_rcv function, always be updated together with
IpExtInOctets. It will be increased even if the packet is dropped
later (e.g. due to the IP header is invalid or the checksum is wrong
and so on).  It indicates the number of aggregated segments after
GRO/LRO.</p>
<ul class="simple">
<li>IpInDelivers</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-28">RFC1213 ipInDelivers</a></p>
<p>The number of packets delivers to the upper layer protocols. E.g. TCP, UDP,
ICMP and so on. If no one listens on a raw socket, only kernel
supported protocols will be delivered, if someone listens on the raw
socket, all valid IP packets will be delivered.</p>
<ul class="simple">
<li>IpOutRequests</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-28">RFC1213 ipOutRequests</a></p>
<p>The number of packets sent via IP layer, for both single cast and
multicast packets, and would always be updated together with
IpExtOutOctets.</p>
<ul class="simple">
<li>IpExtInOctets and IpExtOutOctets</li>
</ul>
<p>They are Linux kernel extensions, no RFC definitions. Please note,
RFC1213 indeed defines ifInOctets  and ifOutOctets, but they
are different things. The ifInOctets and ifOutOctets include the MAC
layer header size but IpExtInOctets and IpExtOutOctets don’t, they
only include the IP layer header and the IP layer data.</p>
<ul class="simple">
<li>IpExtInNoECTPkts, IpExtInECT1Pkts, IpExtInECT0Pkts, IpExtInCEPkts</li>
</ul>
<p>They indicate the number of four kinds of ECN IP packets, please refer
<a class="reference external" href="https://tools.ietf.org/html/rfc3168#page-6">Explicit Congestion Notification</a> for more details.</p>
<p>These 4 counters calculate how many packets received per ECN
status. They count the real frame number regardless the LRO/GRO. So
for the same packet, you might find that IpInReceives count 1, but
IpExtInNoECTPkts counts 2 or more.</p>
<ul class="simple">
<li>IpInHdrErrors</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-27">RFC1213 ipInHdrErrors</a>. It indicates the packet is
dropped due to the IP header error. It might happen in both IP input
and IP forward paths.</p>
<ul class="simple">
<li>IpInAddrErrors</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-27">RFC1213 ipInAddrErrors</a>. It will be increased in two
scenarios: (1) The IP address is invalid. (2) The destination IP
address is not a local address and IP forwarding is not enabled</p>
<ul class="simple">
<li>IpExtInNoRoutes</li>
</ul>
<p>This counter means the packet is dropped when the IP stack receives a
packet and can’t find a route for it from the route table. It might
happen when IP forwarding is enabled and the destination IP address is
not a local address and there is no route for the destination IP
address.</p>
<ul class="simple">
<li>IpInUnknownProtos</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-27">RFC1213 ipInUnknownProtos</a>. It will be increased if the
layer 4 protocol is unsupported by kernel. If an application is using
raw socket, kernel will always deliver the packet to the raw socket
and this counter won’t be increased.</p>
<ul class="simple">
<li>IpExtInTruncatedPkts</li>
</ul>
<p>For IPv4 packet, it means the actual data size is smaller than the
“Total Length” field in the IPv4 header.</p>
<ul class="simple">
<li>IpInDiscards</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-28">RFC1213 ipInDiscards</a>. It indicates the packet is dropped
in the IP receiving path and due to kernel internal reasons (e.g. no
enough memory).</p>
<ul class="simple">
<li>IpOutDiscards</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-28">RFC1213 ipOutDiscards</a>. It indicates the packet is
dropped in the IP sending path and due to kernel internal reasons.</p>
<ul class="simple">
<li>IpOutNoRoutes</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-29">RFC1213 ipOutNoRoutes</a>. It indicates the packet is
dropped in the IP sending path and no route is found for it.</p>
</div>
<div class="section" id="icmp-counters">
<h2>ICMP counters<a class="headerlink" href="#icmp-counters" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>IcmpInMsgs and IcmpOutMsgs</li>
</ul>
<p>Defined by <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-41">RFC1213 icmpInMsgs</a> and <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-43">RFC1213 icmpOutMsgs</a></p>
<p>As mentioned in the RFC1213, these two counters include errors, they
would be increased even if the ICMP packet has an invalid type. The
ICMP output path will check the header of a raw socket, so the
IcmpOutMsgs would still be updated if the IP header is constructed by
a userspace program.</p>
<ul class="simple">
<li>ICMP named types</li>
</ul>
<div class="line-block">
<div class="line">These counters include most of common ICMP types, they are:</div>
<div class="line">IcmpInDestUnreachs: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-41">RFC1213 icmpInDestUnreachs</a></div>
<div class="line">IcmpInTimeExcds: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-41">RFC1213 icmpInTimeExcds</a></div>
<div class="line">IcmpInParmProbs: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-42">RFC1213 icmpInParmProbs</a></div>
<div class="line">IcmpInSrcQuenchs: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-42">RFC1213 icmpInSrcQuenchs</a></div>
<div class="line">IcmpInRedirects: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-42">RFC1213 icmpInRedirects</a></div>
<div class="line">IcmpInEchos: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-42">RFC1213 icmpInEchos</a></div>
<div class="line">IcmpInEchoReps: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-42">RFC1213 icmpInEchoReps</a></div>
<div class="line">IcmpInTimestamps: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-42">RFC1213 icmpInTimestamps</a></div>
<div class="line">IcmpInTimestampReps: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-43">RFC1213 icmpInTimestampReps</a></div>
<div class="line">IcmpInAddrMasks: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-43">RFC1213 icmpInAddrMasks</a></div>
<div class="line">IcmpInAddrMaskReps: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-43">RFC1213 icmpInAddrMaskReps</a></div>
<div class="line">IcmpOutDestUnreachs: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-44">RFC1213 icmpOutDestUnreachs</a></div>
<div class="line">IcmpOutTimeExcds: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-44">RFC1213 icmpOutTimeExcds</a></div>
<div class="line">IcmpOutParmProbs: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-44">RFC1213 icmpOutParmProbs</a></div>
<div class="line">IcmpOutSrcQuenchs: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-44">RFC1213 icmpOutSrcQuenchs</a></div>
<div class="line">IcmpOutRedirects: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-44">RFC1213 icmpOutRedirects</a></div>
<div class="line">IcmpOutEchos: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-45">RFC1213 icmpOutEchos</a></div>
<div class="line">IcmpOutEchoReps: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-45">RFC1213 icmpOutEchoReps</a></div>
<div class="line">IcmpOutTimestamps: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-45">RFC1213 icmpOutTimestamps</a></div>
<div class="line">IcmpOutTimestampReps: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-45">RFC1213 icmpOutTimestampReps</a></div>
<div class="line">IcmpOutAddrMasks: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-45">RFC1213 icmpOutAddrMasks</a></div>
<div class="line">IcmpOutAddrMaskReps: <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-46">RFC1213 icmpOutAddrMaskReps</a></div>
</div>
<p>Every ICMP type has two counters: ‘In’ and ‘Out’. E.g., for the ICMP
Echo packet, they are IcmpInEchos and IcmpOutEchos. Their meanings are
straightforward. The ‘In’ counter means kernel receives such a packet
and the ‘Out’ counter means kernel sends such a packet.</p>
<ul class="simple">
<li>ICMP numeric types</li>
</ul>
<p>They are IcmpMsgInType[N] and IcmpMsgOutType[N], the [N] indicates the
ICMP type number. These counters track all kinds of ICMP packets. The
ICMP type number definition could be found in the <a class="reference external" href="https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml">ICMP parameters</a>
document.</p>
<p>For example, if the Linux kernel sends an ICMP Echo packet, the
IcmpMsgOutType8 would increase 1. And if kernel gets an ICMP Echo Reply
packet, IcmpMsgInType0 would increase 1.</p>
<ul class="simple">
<li>IcmpInCsumErrors</li>
</ul>
<p>This counter indicates the checksum of the ICMP packet is
wrong. Kernel verifies the checksum after updating the IcmpInMsgs and
before updating IcmpMsgInType[N]. If a packet has bad checksum, the
IcmpInMsgs would be updated but none of IcmpMsgInType[N] would be updated.</p>
<ul class="simple">
<li>IcmpInErrors and IcmpOutErrors</li>
</ul>
<p>Defined by <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-41">RFC1213 icmpInErrors</a> and <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-43">RFC1213 icmpOutErrors</a></p>
<p>When an error occurs in the ICMP packet handler path, these two
counters would be updated. The receiving packet path use IcmpInErrors
and the sending packet path use IcmpOutErrors. When IcmpInCsumErrors
is increased, IcmpInErrors would always be increased too.</p>
<div class="section" id="relationship-of-the-icmp-counters">
<h3>relationship of the ICMP counters<a class="headerlink" href="#relationship-of-the-icmp-counters" title="Permalink to this headline">¶</a></h3>
<p>The sum of IcmpMsgOutType[N] is always equal to IcmpOutMsgs, as they
are updated at the same time. The sum of IcmpMsgInType[N] plus
IcmpInErrors should be equal or larger than IcmpInMsgs. When kernel
receives an ICMP packet, kernel follows below logic:</p>
<ol class="arabic simple">
<li>increase IcmpInMsgs</li>
<li>if has any error, update IcmpInErrors and finish the process</li>
<li>update IcmpMsgOutType[N]</li>
<li>handle the packet depending on the type, if has any error, update
IcmpInErrors and finish the process</li>
</ol>
<p>So if all errors occur in step (2), IcmpInMsgs should be equal to the
sum of IcmpMsgOutType[N] plus IcmpInErrors. If all errors occur in
step (4), IcmpInMsgs should be equal to the sum of
IcmpMsgOutType[N]. If the errors occur in both step (2) and step (4),
IcmpInMsgs should be less than the sum of IcmpMsgOutType[N] plus
IcmpInErrors.</p>
</div>
</div>
<div class="section" id="general-tcp-counters">
<h2>General TCP counters<a class="headerlink" href="#general-tcp-counters" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>TcpInSegs</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-48">RFC1213 tcpInSegs</a></p>
<p>The number of packets received by the TCP layer. As mentioned in
RFC1213, it includes the packets received in error, such as checksum
error, invalid TCP header and so on. Only one error won’t be included:
if the layer 2 destination address is not the NIC’s layer 2
address. It might happen if the packet is a multicast or broadcast
packet, or the NIC is in promiscuous mode. In these situations, the
packets would be delivered to the TCP layer, but the TCP layer will discard
these packets before increasing TcpInSegs. The TcpInSegs counter
isn’t aware of GRO. So if two packets are merged by GRO, the TcpInSegs
counter would only increase 1.</p>
<ul class="simple">
<li>TcpOutSegs</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-48">RFC1213 tcpOutSegs</a></p>
<p>The number of packets sent by the TCP layer. As mentioned in RFC1213,
it excludes the retransmitted packets. But it includes the SYN, ACK
and RST packets. Doesn’t like TcpInSegs, the TcpOutSegs is aware of
GSO, so if a packet would be split to 2 by GSO, TcpOutSegs will
increase 2.</p>
<ul class="simple">
<li>TcpActiveOpens</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-47">RFC1213 tcpActiveOpens</a></p>
<p>It means the TCP layer sends a SYN, and come into the SYN-SENT
state. Every time TcpActiveOpens increases 1, TcpOutSegs should always
increase 1.</p>
<ul class="simple">
<li>TcpPassiveOpens</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-47">RFC1213 tcpPassiveOpens</a></p>
<p>It means the TCP layer receives a SYN, replies a SYN+ACK, come into
the SYN-RCVD state.</p>
<ul class="simple">
<li>TcpExtTCPRcvCoalesce</li>
</ul>
<p>When packets are received by the TCP layer and are not be read by the
application, the TCP layer will try to merge them. This counter
indicate how many packets are merged in such situation. If GRO is
enabled, lots of packets would be merged by GRO, these packets
wouldn’t be counted to TcpExtTCPRcvCoalesce.</p>
<ul class="simple">
<li>TcpExtTCPAutoCorking</li>
</ul>
<p>When sending packets, the TCP layer will try to merge small packets to
a bigger one. This counter increase 1 for every packet merged in such
situation. Please refer to the LWN article for more details:
<a class="reference external" href="https://lwn.net/Articles/576263/">https://lwn.net/Articles/576263/</a></p>
<ul class="simple">
<li>TcpExtTCPOrigDataSent</li>
</ul>
<p>This counter is explained by <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f19c29e3e391a66a273e9afebaf01917245148cd">kernel commit f19c29e3e391</a>, I pasted the
explaination below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TCPOrigDataSent: number of outgoing packets with original data (excluding
retransmission but including data-in-SYN). This counter is different from
TcpOutSegs because TcpOutSegs also tracks pure ACKs. TCPOrigDataSent is
more useful to track the TCP retransmission rate.
</pre></div>
</div>
<ul class="simple">
<li>TCPSynRetrans</li>
</ul>
<p>This counter is explained by <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f19c29e3e391a66a273e9afebaf01917245148cd">kernel commit f19c29e3e391</a>, I pasted the
explaination below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TCPSynRetrans: number of SYN and SYN/ACK retransmits to break down
retransmissions into SYN, fast-retransmits, timeout retransmits, etc.
</pre></div>
</div>
<ul class="simple">
<li>TCPFastOpenActiveFail</li>
</ul>
<p>This counter is explained by <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f19c29e3e391a66a273e9afebaf01917245148cd">kernel commit f19c29e3e391</a>, I pasted the
explaination below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TCPFastOpenActiveFail: Fast Open attempts (SYN/data) failed because
the remote does not accept it or the attempts timed out.
</pre></div>
</div>
<ul class="simple">
<li>TcpExtListenOverflows and TcpExtListenDrops</li>
</ul>
<p>When kernel receives a SYN from a client, and if the TCP accept queue
is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows.
At the same time kernel will also add 1 to TcpExtListenDrops. When a
TCP socket is in LISTEN state, and kernel need to drop a packet,
kernel would always add 1 to TcpExtListenDrops. So increase
TcpExtListenOverflows would let TcpExtListenDrops increasing at the
same time, but TcpExtListenDrops would also increase without
TcpExtListenOverflows increasing, e.g. a memory allocation fail would
also let TcpExtListenDrops increase.</p>
<p>Note: The above explanation is based on kernel 4.10 or above version, on
an old kernel, the TCP stack has different behavior when TCP accept
queue is full. On the old kernel, TCP stack won’t drop the SYN, it
would complete the 3-way handshake. As the accept queue is full, TCP
stack will keep the socket in the TCP half-open queue. As it is in the
half open queue, TCP stack will send SYN+ACK on an exponential backoff
timer, after client replies ACK, TCP stack checks whether the accept
queue is still full, if it is not full, moves the socket to the accept
queue, if it is full, keeps the socket in the half-open queue, at next
time client replies ACK, this socket will get another chance to move
to the accept queue.</p>
</div>
<div class="section" id="tcp-fast-open">
<h2>TCP Fast Open<a class="headerlink" href="#tcp-fast-open" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>TcpEstabResets</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-48">RFC1213 tcpEstabResets</a>.</p>
<ul class="simple">
<li>TcpAttemptFails</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-48">RFC1213 tcpAttemptFails</a>.</p>
<ul class="simple">
<li>TcpOutRsts</li>
</ul>
<p>Defined in <a class="reference external" href="https://tools.ietf.org/html/rfc1213#page-52">RFC1213 tcpOutRsts</a>. The RFC says this counter indicates
the ‘segments sent containing the RST flag’, but in linux kernel, this
couner indicates the segments kerenl tried to send. The sending
process might be failed due to some errors (e.g. memory alloc failed).</p>
<ul class="simple">
<li>TcpExtTCPSpuriousRtxHostQueues</li>
</ul>
<p>When the TCP stack wants to retransmit a packet, and finds that packet
is not lost in the network, but the packet is not sent yet, the TCP
stack would give up the retransmission and update this counter. It
might happen if a packet stays too long time in a qdisc or driver
queue.</p>
<ul class="simple">
<li>TcpEstabResets</li>
</ul>
<p>The socket receives a RST packet in Establish or CloseWait state.</p>
<ul class="simple">
<li>TcpExtTCPKeepAlive</li>
</ul>
<p>This counter indicates many keepalive packets were sent. The keepalive
won’t be enabled by default. A userspace program could enable it by
setting the SO_KEEPALIVE socket option.</p>
<ul class="simple">
<li>TcpExtTCPSpuriousRTOs</li>
</ul>
<p>The spurious retransmission timeout detected by the <a class="reference external" href="https://tools.ietf.org/html/rfc5682">F-RTO</a>
algorithm.</p>
</div>
<div class="section" id="tcp-fast-path">
<h2>TCP Fast Path<a class="headerlink" href="#tcp-fast-path" title="Permalink to this headline">¶</a></h2>
<p>When kernel receives a TCP packet, it has two paths to handler the
packet, one is fast path, another is slow path. The comment in kernel
code provides a good explanation of them, I pasted them below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>It is split into a fast path and a slow path. The fast path is
disabled when:

- A zero window was announced from us
- zero window probing
  is only handled properly on the slow path.
- Out of order segments arrived.
- Urgent data is expected.
- There is no buffer space left
- Unexpected TCP flags/window values/header lengths are received
  (detected by checking the TCP header against pred_flags)
- Data is sent in both directions. The fast path only supports pure senders
  or pure receivers (this means either the sequence number or the ack
  value must stay constant)
- Unexpected TCP option.
</pre></div>
</div>
<p>Kernel will try to use fast path unless any of the above conditions
are satisfied. If the packets are out of order, kernel will handle
them in slow path, which means the performance might be not very
good. Kernel would also come into slow path if the “Delayed ack” is
used, because when using “Delayed ack”, the data is sent in both
directions. When the TCP window scale option is not used, kernel will
try to enable fast path immediately when the connection comes into the
established state, but if the TCP window scale option is used, kernel
will disable the fast path at first, and try to enable it after kernel
receives packets.</p>
<ul class="simple">
<li>TcpExtTCPPureAcks and TcpExtTCPHPAcks</li>
</ul>
<p>If a packet set ACK flag and has no data, it is a pure ACK packet, if
kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1,
if kernel handles it in the slow path, TcpExtTCPPureAcks will
increase 1.</p>
<ul class="simple">
<li>TcpExtTCPHPHits</li>
</ul>
<p>If a TCP packet has data (which means it is not a pure ACK packet),
and this packet is handled in the fast path, TcpExtTCPHPHits will
increase 1.</p>
</div>
<div class="section" id="tcp-abort">
<h2>TCP abort<a class="headerlink" href="#tcp-abort" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>TcpExtTCPAbortOnData</li>
</ul>
<p>It means TCP layer has data in flight, but need to close the
connection. So TCP layer sends a RST to the other side, indicate the
connection is not closed very graceful. An easy way to increase this
counter is using the SO_LINGER option. Please refer to the SO_LINGER
section of the <a class="reference external" href="http://man7.org/linux/man-pages/man7/socket.7.html">socket man page</a>:</p>
<p>By default, when an application closes a connection, the close function
will return immediately and kernel will try to send the in-flight data
async. If you use the SO_LINGER option, set l_onoff to 1, and l_linger
to a positive number, the close function won’t return immediately, but
wait for the in-flight data are acked by the other side, the max wait
time is l_linger seconds. If set l_onoff to 1 and set l_linger to 0,
when the application closes a connection, kernel will send a RST
immediately and increase the TcpExtTCPAbortOnData counter.</p>
<ul class="simple">
<li>TcpExtTCPAbortOnClose</li>
</ul>
<p>This counter means the application has unread data in the TCP layer when
the application wants to close the TCP connection. In such a situation,
kernel will send a RST to the other side of the TCP connection.</p>
<ul class="simple">
<li>TcpExtTCPAbortOnMemory</li>
</ul>
<p>When an application closes a TCP connection, kernel still need to track
the connection, let it complete the TCP disconnect process. E.g. an
app calls the close method of a socket, kernel sends fin to the other
side of the connection, then the app has no relationship with the
socket any more, but kernel need to keep the socket, this socket
becomes an orphan socket, kernel waits for the reply of the other side,
and would come to the TIME_WAIT state finally. When kernel has no
enough memory to keep the orphan socket, kernel would send an RST to
the other side, and delete the socket, in such situation, kernel will
increase 1 to the TcpExtTCPAbortOnMemory. Two conditions would trigger
TcpExtTCPAbortOnMemory:</p>
<p>1. the memory used by the TCP protocol is higher than the third value of
the tcp_mem. Please refer the tcp_mem section in the <a class="reference external" href="http://man7.org/linux/man-pages/man7/tcp.7.html">TCP man page</a>:</p>
<ol class="arabic simple" start="2">
<li>the orphan socket count is higher than net.ipv4.tcp_max_orphans</li>
</ol>
<ul class="simple">
<li>TcpExtTCPAbortOnTimeout</li>
</ul>
<p>This counter will increase when any of the TCP timers expire. In such
situation, kernel won’t send RST, just give up the connection.</p>
<ul class="simple">
<li>TcpExtTCPAbortOnLinger</li>
</ul>
<p>When a TCP connection comes into FIN_WAIT_2 state, instead of waiting
for the fin packet from the other side, kernel could send a RST and
delete the socket immediately. This is not the default behavior of
Linux kernel TCP stack. By configuring the TCP_LINGER2 socket option,
you could let kernel follow this behavior.</p>
<ul class="simple">
<li>TcpExtTCPAbortFailed</li>
</ul>
<p>The kernel TCP layer will send RST if the <a class="reference external" href="https://tools.ietf.org/html/rfc2525#page-50">RFC2525 2.17 section</a> is
satisfied. If an internal error occurs during this process,
TcpExtTCPAbortFailed will be increased.</p>
</div>
<div class="section" id="tcp-hybrid-slow-start">
<h2>TCP Hybrid Slow Start<a class="headerlink" href="#tcp-hybrid-slow-start" title="Permalink to this headline">¶</a></h2>
<p>The Hybrid Slow Start algorithm is an enhancement of the traditional
TCP congestion window Slow Start algorithm. It uses two pieces of
information to detect whether the max bandwidth of the TCP path is
approached. The two pieces of information are ACK train length and
increase in packet delay. For detail information, please refer the
<a class="reference external" href="https://pdfs.semanticscholar.org/25e9/ef3f03315782c7f1cbcd31b587857adae7d1.pdf">Hybrid Slow Start paper</a>. Either ACK train length or packet delay
hits a specific threshold, the congestion control algorithm will come
into the Congestion Avoidance state. Until v4.20, two congestion
control algorithms are using Hybrid Slow Start, they are cubic (the
default congestion control algorithm) and cdg. Four snmp counters
relate with the Hybrid Slow Start algorithm.</p>
<ul class="simple">
<li>TcpExtTCPHystartTrainDetect</li>
</ul>
<p>How many times the ACK train length threshold is detected</p>
<ul class="simple">
<li>TcpExtTCPHystartTrainCwnd</li>
</ul>
<p>The sum of CWND detected by ACK train length. Dividing this value by
TcpExtTCPHystartTrainDetect is the average CWND which detected by the
ACK train length.</p>
<ul class="simple">
<li>TcpExtTCPHystartDelayDetect</li>
</ul>
<p>How many times the packet delay threshold is detected.</p>
<ul class="simple">
<li>TcpExtTCPHystartDelayCwnd</li>
</ul>
<p>The sum of CWND detected by packet delay. Dividing this value by
TcpExtTCPHystartDelayDetect is the average CWND which detected by the
packet delay.</p>
</div>
<div class="section" id="tcp-retransmission-and-congestion-control">
<h2>TCP retransmission and congestion control<a class="headerlink" href="#tcp-retransmission-and-congestion-control" title="Permalink to this headline">¶</a></h2>
<p>The TCP protocol has two retransmission mechanisms: SACK and fast
recovery. They are exclusive with each other. When SACK is enabled,
the kernel TCP stack would use SACK, or kernel would use fast
recovery. The SACK is a TCP option, which is defined in <a class="reference external" href="https://tools.ietf.org/html/rfc2018">RFC2018</a>,
the fast recovery is defined in <a class="reference external" href="https://tools.ietf.org/html/rfc6582">RFC6582</a>, which is also called
‘Reno’.</p>
<p>The TCP congestion control is a big and complex topic. To understand
the related snmp counter, we need to know the states of the congestion
control state machine. There are 5 states: Open, Disorder, CWR,
Recovery and Loss. For details about these states, please refer page 5
and page 6 of this document:
<a class="reference external" href="https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf">https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf</a></p>
<ul class="simple">
<li>TcpExtTCPRenoRecovery and TcpExtTCPSackRecovery</li>
</ul>
<p>When the congestion control comes into Recovery state, if sack is
used, TcpExtTCPSackRecovery increases 1, if sack is not used,
TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP
stack begins to retransmit the lost packets.</p>
<ul class="simple">
<li>TcpExtTCPSACKReneging</li>
</ul>
<p>A packet was acknowledged by SACK, but the receiver has dropped this
packet, so the sender needs to retransmit this packet. In this
situation, the sender adds 1 to TcpExtTCPSACKReneging. A receiver
could drop a packet which has been acknowledged by SACK, although it is
unusual, it is allowed by the TCP protocol. The sender doesn’t really
know what happened on the receiver side. The sender just waits until
the RTO expires for this packet, then the sender assumes this packet
has been dropped by the receiver.</p>
<ul class="simple">
<li>TcpExtTCPRenoReorder</li>
</ul>
<p>The reorder packet is detected by fast recovery. It would only be used
if SACK is disabled. The fast recovery algorithm detects recorder by
the duplicate ACK number. E.g., if retransmission is triggered, and
the original retransmitted packet is not lost, it is just out of
order, the receiver would acknowledge multiple times, one for the
retransmitted packet, another for the arriving of the original out of
order packet. Thus the sender would find more ACks than its
expectation, and the sender knows out of order occurs.</p>
<ul class="simple">
<li>TcpExtTCPTSReorder</li>
</ul>
<p>The reorder packet is detected when a hole is filled. E.g., assume the
sender sends packet 1,2,3,4,5, and the receiving order is
1,2,4,5,3. When the sender receives the ACK of packet 3 (which will
fill the hole), two conditions will let TcpExtTCPTSReorder increase
1: (1) if the packet 3 is not re-retransmitted yet. (2) if the packet
3 is retransmitted but the timestamp of the packet 3’s ACK is earlier
than the retransmission timestamp.</p>
<ul class="simple">
<li>TcpExtTCPSACKReorder</li>
</ul>
<p>The reorder packet detected by SACK. The SACK has two methods to
detect reorder: (1) DSACK is received by the sender. It means the
sender sends the same packet more than one times. And the only reason
is the sender believes an out of order packet is lost so it sends the
packet again. (2) Assume packet 1,2,3,4,5 are sent by the sender, and
the sender has received SACKs for packet 2 and 5, now the sender
receives SACK for packet 4 and the sender doesn’t retransmit the
packet yet, the sender would know packet 4 is out of order. The TCP
stack of kernel will increase TcpExtTCPSACKReorder for both of the
above scenarios.</p>
<ul class="simple">
<li>TcpExtTCPSlowStartRetrans</li>
</ul>
<p>The TCP stack wants to retransmit a packet and the congestion control
state is ‘Loss’.</p>
<ul class="simple">
<li>TcpExtTCPFastRetrans</li>
</ul>
<p>The TCP stack wants to retransmit a packet and the congestion control
state is not ‘Loss’.</p>
<ul class="simple">
<li>TcpExtTCPLostRetransmit</li>
</ul>
<p>A SACK points out that a retransmission packet is lost again.</p>
<ul class="simple">
<li>TcpExtTCPRetransFail</li>
</ul>
<p>The TCP stack tries to deliver a retransmission packet to lower layers
but the lower layers return an error.</p>
<ul class="simple">
<li>TcpExtTCPSynRetrans</li>
</ul>
<p>The TCP stack retransmits a SYN packet.</p>
</div>
<div class="section" id="dsack">
<h2>DSACK<a class="headerlink" href="#dsack" title="Permalink to this headline">¶</a></h2>
<p>The DSACK is defined in <a class="reference external" href="https://tools.ietf.org/html/rfc2883">RFC2883</a>. The receiver uses DSACK to report
duplicate packets to the sender. There are two kinds of
duplications: (1) a packet which has been acknowledged is
duplicate. (2) an out of order packet is duplicate. The TCP stack
counts these two kinds of duplications on both receiver side and
sender side.</p>
<ul class="simple">
<li>TcpExtTCPDSACKOldSent</li>
</ul>
<p>The TCP stack receives a duplicate packet which has been acked, so it
sends a DSACK to the sender.</p>
<ul class="simple">
<li>TcpExtTCPDSACKOfoSent</li>
</ul>
<p>The TCP stack receives an out of order duplicate packet, so it sends a
DSACK to the sender.</p>
<ul class="simple">
<li>TcpExtTCPDSACKRecv</li>
</ul>
<p>The TCP stack receives a DSACK, which indicates an acknowledged
duplicate packet is received.</p>
<ul class="simple">
<li>TcpExtTCPDSACKOfoRecv</li>
</ul>
<p>The TCP stack receives a DSACK, which indicate an out of order
duplicate packet is received.</p>
</div>
<div class="section" id="invalid-sack-and-dsack">
<h2>invalid SACK and DSACK<a class="headerlink" href="#invalid-sack-and-dsack" title="Permalink to this headline">¶</a></h2>
<p>When a SACK (or DSACK) block is invalid, a corresponding counter would
be updated. The validation method is base on the start/end sequence
number of the SACK block. For more details, please refer the comment
of the function tcp_is_sackblock_valid in the kernel source code. A
SACK option could have up to 4 blocks, they are checked
individually. E.g., if 3 blocks of a SACk is invalid, the
corresponding counter would be updated 3 times. The comment of the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=18f02545a9a16c9a89778b91a162ad16d510bb32">Add counters for discarded SACK blocks</a> patch has additional
explaination:</p>
<ul class="simple">
<li>TcpExtTCPSACKDiscard</li>
</ul>
<p>This counter indicates how many SACK blocks are invalid. If the invalid
SACK block is caused by ACK recording, the TCP stack will only ignore
it and won’t update this counter.</p>
<ul class="simple">
<li>TcpExtTCPDSACKIgnoredOld and TcpExtTCPDSACKIgnoredNoUndo</li>
</ul>
<p>When a DSACK block is invalid, one of these two counters would be
updated. Which counter will be updated depends on the undo_marker flag
of the TCP socket. If the undo_marker is not set, the TCP stack isn’t
likely to re-transmit any packets, and we still receive an invalid
DSACK block, the reason might be that the packet is duplicated in the
middle of the network. In such scenario, TcpExtTCPDSACKIgnoredNoUndo
will be updated. If the undo_marker is set, TcpExtTCPDSACKIgnoredOld
will be updated. As implied in its name, it might be an old packet.</p>
</div>
<div class="section" id="sack-shift">
<h2>SACK shift<a class="headerlink" href="#sack-shift" title="Permalink to this headline">¶</a></h2>
<p>The linux networking stack stores data in sk_buff struct (skb for
short). If a SACK block acrosses multiple skb, the TCP stack will try
to re-arrange data in these skb. E.g. if a SACK block acknowledges seq
10 to 15, skb1 has seq 10 to 13, skb2 has seq 14 to 20. The seq 14 and
15 in skb2 would be moved to skb1. This operation is ‘shift’. If a
SACK block acknowledges seq 10 to 20, skb1 has seq 10 to 13, skb2 has
seq 14 to 20. All data in skb2 will be moved to skb1, and skb2 will be
discard, this operation is ‘merge’.</p>
<ul class="simple">
<li>TcpExtTCPSackShifted</li>
</ul>
<p>A skb is shifted</p>
<ul class="simple">
<li>TcpExtTCPSackMerged</li>
</ul>
<p>A skb is merged</p>
<ul class="simple">
<li>TcpExtTCPSackShiftFallback</li>
</ul>
<p>A skb should be shifted or merged, but the TCP stack doesn’t do it for
some reasons.</p>
</div>
<div class="section" id="tcp-out-of-order">
<h2>TCP out of order<a class="headerlink" href="#tcp-out-of-order" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>TcpExtTCPOFOQueue</li>
</ul>
<p>The TCP layer receives an out of order packet and has enough memory
to queue it.</p>
<ul class="simple">
<li>TcpExtTCPOFODrop</li>
</ul>
<p>The TCP layer receives an out of order packet but doesn’t have enough
memory, so drops it. Such packets won’t be counted into
TcpExtTCPOFOQueue.</p>
<ul class="simple">
<li>TcpExtTCPOFOMerge</li>
</ul>
<p>The received out of order packet has an overlay with the previous
packet. the overlay part will be dropped. All of TcpExtTCPOFOMerge
packets will also be counted into TcpExtTCPOFOQueue.</p>
</div>
<div class="section" id="tcp-paws">
<h2>TCP PAWS<a class="headerlink" href="#tcp-paws" title="Permalink to this headline">¶</a></h2>
<p>PAWS (Protection Against Wrapped Sequence numbers) is an algorithm
which is used to drop old packets. It depends on the TCP
timestamps. For detail information, please refer the <a class="reference external" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_timestamps">timestamp wiki</a>
and the <a class="reference external" href="https://tools.ietf.org/html/rfc1323#page-17">RFC of PAWS</a>.</p>
<ul class="simple">
<li>TcpExtPAWSActive</li>
</ul>
<p>Packets are dropped by PAWS in Syn-Sent status.</p>
<ul class="simple">
<li>TcpExtPAWSEstab</li>
</ul>
<p>Packets are dropped by PAWS in any status other than Syn-Sent.</p>
</div>
<div class="section" id="tcp-ack-skip">
<h2>TCP ACK skip<a class="headerlink" href="#tcp-ack-skip" title="Permalink to this headline">¶</a></h2>
<p>In some scenarios, kernel would avoid sending duplicate ACKs too
frequently. Please find more details in the tcp_invalid_ratelimit
section of the <a class="reference external" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">sysctl document</a>. When kernel decides to skip an ACK
due to tcp_invalid_ratelimit, kernel would update one of below
counters to indicate the ACK is skipped in which scenario. The ACK
would only be skipped if the received packet is either a SYN packet or
it has no data.</p>
<ul class="simple">
<li>TcpExtTCPACKSkippedSynRecv</li>
</ul>
<p>The ACK is skipped in Syn-Recv status. The Syn-Recv status means the
TCP stack receives a SYN and replies SYN+ACK. Now the TCP stack is
waiting for an ACK. Generally, the TCP stack doesn’t need to send ACK
in the Syn-Recv status. But in several scenarios, the TCP stack need
to send an ACK. E.g., the TCP stack receives the same SYN packet
repeately, the received packet does not pass the PAWS check, or the
received packet sequence number is out of window. In these scenarios,
the TCP stack needs to send ACK. If the ACk sending frequency is higher than
tcp_invalid_ratelimit allows, the TCP stack will skip sending ACK and
increase TcpExtTCPACKSkippedSynRecv.</p>
<ul class="simple">
<li>TcpExtTCPACKSkippedPAWS</li>
</ul>
<p>The ACK is skipped due to PAWS (Protect Against Wrapped Sequence
numbers) check fails. If the PAWS check fails in Syn-Recv, Fin-Wait-2
or Time-Wait statuses, the skipped ACK would be counted to
TcpExtTCPACKSkippedSynRecv, TcpExtTCPACKSkippedFinWait2 or
TcpExtTCPACKSkippedTimeWait. In all other statuses, the skipped ACK
would be counted to TcpExtTCPACKSkippedPAWS.</p>
<ul class="simple">
<li>TcpExtTCPACKSkippedSeq</li>
</ul>
<p>The sequence number is out of window and the timestamp passes the PAWS
check and the TCP status is not Syn-Recv, Fin-Wait-2, and Time-Wait.</p>
<ul class="simple">
<li>TcpExtTCPACKSkippedFinWait2</li>
</ul>
<p>The ACK is skipped in Fin-Wait-2 status, the reason would be either
PAWS check fails or the received sequence number is out of window.</p>
<ul class="simple">
<li>TcpExtTCPACKSkippedTimeWait</li>
</ul>
<p>Tha ACK is skipped in Time-Wait status, the reason would be either
PAWS check failed or the received sequence number is out of window.</p>
<ul class="simple">
<li>TcpExtTCPACKSkippedChallenge</li>
</ul>
<p>The ACK is skipped if the ACK is a challenge ACK. The RFC 5961 defines
3 kind of challenge ACK, please refer <a class="reference external" href="https://tools.ietf.org/html/rfc5961#page-7">RFC 5961 section 3.2</a>,
<a class="reference external" href="https://tools.ietf.org/html/rfc5961#page-9">RFC 5961 section 4.2</a> and <a class="reference external" href="https://tools.ietf.org/html/rfc5961#page-11">RFC 5961 section 5.2</a>. Besides these
three scenarios, In some TCP status, the linux TCP stack would also
send challenge ACKs if the ACK number is before the first
unacknowledged number (more strict than <a class="reference external" href="https://tools.ietf.org/html/rfc5961#page-11">RFC 5961 section 5.2</a>).</p>
</div>
<div class="section" id="tcp-receive-window">
<h2>TCP receive window<a class="headerlink" href="#tcp-receive-window" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>TcpExtTCPWantZeroWindowAdv</li>
</ul>
<p>Depending on current memory usage, the TCP stack tries to set receive
window to zero. But the receive window might still be a no-zero
value. For example, if the previous window size is 10, and the TCP
stack receives 3 bytes, the current window size would be 7 even if the
window size calculated by the memory usage is zero.</p>
<ul class="simple">
<li>TcpExtTCPToZeroWindowAdv</li>
</ul>
<p>The TCP receive window is set to zero from a no-zero value.</p>
<ul class="simple">
<li>TcpExtTCPFromZeroWindowAdv</li>
</ul>
<p>The TCP receive window is set to no-zero value from zero.</p>
</div>
<div class="section" id="delayed-ack">
<h2>Delayed ACK<a class="headerlink" href="#delayed-ack" title="Permalink to this headline">¶</a></h2>
<p>The TCP Delayed ACK is a technique which is used for reducing the
packet count in the network. For more details, please refer the
<a class="reference external" href="https://en.wikipedia.org/wiki/TCP_delayed_acknowledgment">Delayed ACK wiki</a></p>
<ul class="simple">
<li>TcpExtDelayedACKs</li>
</ul>
<p>A delayed ACK timer expires. The TCP stack will send a pure ACK packet
and exit the delayed ACK mode.</p>
<ul class="simple">
<li>TcpExtDelayedACKLocked</li>
</ul>
<p>A delayed ACK timer expires, but the TCP stack can’t send an ACK
immediately due to the socket is locked by a userspace program. The
TCP stack will send a pure ACK later (after the userspace program
unlock the socket). When the TCP stack sends the pure ACK later, the
TCP stack will also update TcpExtDelayedACKs and exit the delayed ACK
mode.</p>
<ul class="simple">
<li>TcpExtDelayedACKLost</li>
</ul>
<p>It will be updated when the TCP stack receives a packet which has been
ACKed. A Delayed ACK loss might cause this issue, but it would also be
triggered by other reasons, such as a packet is duplicated in the
network.</p>
</div>
<div class="section" id="tail-loss-probe-tlp">
<h2>Tail Loss Probe (TLP)<a class="headerlink" href="#tail-loss-probe-tlp" title="Permalink to this headline">¶</a></h2>
<p>TLP is an algorithm which is used to detect TCP packet loss. For more
details, please refer the <a class="reference external" href="https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01">TLP paper</a>.</p>
<ul class="simple">
<li>TcpExtTCPLossProbes</li>
</ul>
<p>A TLP probe packet is sent.</p>
<ul class="simple">
<li>TcpExtTCPLossProbeRecovery</li>
</ul>
<p>A packet loss is detected and recovered by TLP.</p>
</div>
<div class="section" id="id1">
<h2>TCP Fast Open<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>TCP Fast Open is a technology which allows data transfer before the
3-way handshake complete. Please refer the <a class="reference external" href="https://en.wikipedia.org/wiki/TCP_Fast_Open">TCP Fast Open wiki</a> for a
general description.</p>
<ul class="simple">
<li>TcpExtTCPFastOpenActive</li>
</ul>
<p>When the TCP stack receives an ACK packet in the SYN-SENT status, and
the ACK packet acknowledges the data in the SYN packet, the TCP stack
understand the TFO cookie is accepted by the other side, then it
updates this counter.</p>
<ul class="simple">
<li>TcpExtTCPFastOpenActiveFail</li>
</ul>
<p>This counter indicates that the TCP stack initiated a TCP Fast Open,
but it failed. This counter would be updated in three scenarios: (1)
the other side doesn’t acknowledge the data in the SYN packet. (2) The
SYN packet which has the TFO cookie is timeout at least once. (3)
after the 3-way handshake, the retransmission timeout happens
net.ipv4.tcp_retries1 times, because some middle-boxes may black-hole
fast open after the handshake.</p>
<ul class="simple">
<li>TcpExtTCPFastOpenPassive</li>
</ul>
<p>This counter indicates how many times the TCP stack accepts the fast
open request.</p>
<ul class="simple">
<li>TcpExtTCPFastOpenPassiveFail</li>
</ul>
<p>This counter indicates how many times the TCP stack rejects the fast
open request. It is caused by either the TFO cookie is invalid or the
TCP stack finds an error during the socket creating process.</p>
<ul class="simple">
<li>TcpExtTCPFastOpenListenOverflow</li>
</ul>
<p>When the pending fast open request number is larger than
fastopenq-&gt;max_qlen, the TCP stack will reject the fast open request
and update this counter. When this counter is updated, the TCP stack
won’t update TcpExtTCPFastOpenPassive or
TcpExtTCPFastOpenPassiveFail. The fastopenq-&gt;max_qlen is set by the
TCP_FASTOPEN socket operation and it could not be larger than
net.core.somaxconn. For example:</p>
<p>setsockopt(sfd, SOL_TCP, TCP_FASTOPEN, &amp;qlen, sizeof(qlen));</p>
<ul class="simple">
<li>TcpExtTCPFastOpenCookieReqd</li>
</ul>
<p>This counter indicates how many times a client wants to request a TFO
cookie.</p>
</div>
<div class="section" id="syn-cookies">
<h2>SYN cookies<a class="headerlink" href="#syn-cookies" title="Permalink to this headline">¶</a></h2>
<p>SYN cookies are used to mitigate SYN flood, for details, please refer
the <a class="reference external" href="https://en.wikipedia.org/wiki/SYN_cookies">SYN cookies wiki</a>.</p>
<ul class="simple">
<li>TcpExtSyncookiesSent</li>
</ul>
<p>It indicates how many SYN cookies are sent.</p>
<ul class="simple">
<li>TcpExtSyncookiesRecv</li>
</ul>
<p>How many reply packets of the SYN cookies the TCP stack receives.</p>
<ul class="simple">
<li>TcpExtSyncookiesFailed</li>
</ul>
<p>The MSS decoded from the SYN cookie is invalid. When this counter is
updated, the received packet won’t be treated as a SYN cookie and the
TcpExtSyncookiesRecv counter wont be updated.</p>
</div>
<div class="section" id="challenge-ack">
<h2>Challenge ACK<a class="headerlink" href="#challenge-ack" title="Permalink to this headline">¶</a></h2>
<p>For details of challenge ACK, please refer the explaination of
TcpExtTCPACKSkippedChallenge.</p>
<ul class="simple">
<li>TcpExtTCPChallengeACK</li>
</ul>
<p>The number of challenge acks sent.</p>
<ul class="simple">
<li>TcpExtTCPSYNChallenge</li>
</ul>
<p>The number of challenge acks sent in response to SYN packets. After
updates this counter, the TCP stack might send a challenge ACK and
update the TcpExtTCPChallengeACK counter, or it might also skip to
send the challenge and update the TcpExtTCPACKSkippedChallenge.</p>
</div>
<div class="section" id="prune">
<h2>prune<a class="headerlink" href="#prune" title="Permalink to this headline">¶</a></h2>
<p>When a socket is under memory pressure, the TCP stack will try to
reclaim memory from the receiving queue and out of order queue. One of
the reclaiming method is ‘collapse’, which means allocate a big sbk,
copy the contiguous skbs to the single big skb, and free these
contiguous skbs.</p>
<ul class="simple">
<li>TcpExtPruneCalled</li>
</ul>
<p>The TCP stack tries to reclaim memory for a socket. After updates this
counter, the TCP stack will try to collapse the out of order queue and
the receiving queue. If the memory is still not enough, the TCP stack
will try to discard packets from the out of order queue (and update the
TcpExtOfoPruned counter)</p>
<ul class="simple">
<li>TcpExtOfoPruned</li>
</ul>
<p>The TCP stack tries to discard packet on the out of order queue.</p>
<ul class="simple">
<li>TcpExtRcvPruned</li>
</ul>
<p>After ‘collapse’ and discard packets from the out of order queue, if
the actually used memory is still larger than the max allowed memory,
this counter will be updated. It means the ‘prune’ fails.</p>
<ul class="simple">
<li>TcpExtTCPRcvCollapsed</li>
</ul>
<p>This counter indicates how many skbs are freed during ‘collapse’.</p>
</div>
<div class="section" id="examples">
<h2>examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ping-test">
<h3>ping test<a class="headerlink" href="#ping-test" title="Permalink to this headline">¶</a></h3>
<p>Run the ping command against the public dns server 8.8.8.8:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ ping 8.8.8.8 -c 1
PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=119 time=17.8 ms

--- 8.8.8.8 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 17.875/17.875/17.875/0.000 ms
</pre></div>
</div>
<p>The nstayt result:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nstat
#kernel
IpInReceives                    1                  0.0
IpInDelivers                    1                  0.0
IpOutRequests                   1                  0.0
IcmpInMsgs                      1                  0.0
IcmpInEchoReps                  1                  0.0
IcmpOutMsgs                     1                  0.0
IcmpOutEchos                    1                  0.0
IcmpMsgInType0                  1                  0.0
IcmpMsgOutType8                 1                  0.0
IpExtInOctets                   84                 0.0
IpExtOutOctets                  84                 0.0
IpExtInNoECTPkts                1                  0.0
</pre></div>
</div>
<p>The Linux server sent an ICMP Echo packet, so IpOutRequests,
IcmpOutMsgs, IcmpOutEchos and IcmpMsgOutType8 were increased 1. The
server got ICMP Echo Reply from 8.8.8.8, so IpInReceives, IcmpInMsgs,
IcmpInEchoReps and IcmpMsgInType0 were increased 1. The ICMP Echo Reply
was passed to the ICMP layer via IP layer, so IpInDelivers was
increased 1. The default ping data size is 48, so an ICMP Echo packet
and its corresponding Echo Reply packet are constructed by:</p>
<ul class="simple">
<li>14 bytes MAC header</li>
<li>20 bytes IP header</li>
<li>16 bytes ICMP header</li>
<li>48 bytes data (default value of the ping command)</li>
</ul>
<p>So the IpExtInOctets and IpExtOutOctets are 20+16+48=84.</p>
</div>
<div class="section" id="tcp-3-way-handshake">
<h3>tcp 3-way handshake<a class="headerlink" href="#tcp-3-way-handshake" title="Permalink to this headline">¶</a></h3>
<p>On server side, we run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nc -lknv 0.0.0.0 9000
Listening on [0.0.0.0] (family 0, port 9000)
</pre></div>
</div>
<p>On client side, we run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nc -nv 192.168.122.251 9000
Connection to 192.168.122.251 9000 port [tcp/*] succeeded!
</pre></div>
</div>
<p>The server listened on tcp 9000 port, the client connected to it, they
completed the 3-way handshake.</p>
<p>On server side, we can find below nstat output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nstat | grep -i tcp
TcpPassiveOpens                 1                  0.0
TcpInSegs                       2                  0.0
TcpOutSegs                      1                  0.0
TcpExtTCPPureAcks               1                  0.0
</pre></div>
</div>
<p>On client side, we can find below nstat output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nstat | grep -i tcp
TcpActiveOpens                  1                  0.0
TcpInSegs                       1                  0.0
TcpOutSegs                      2                  0.0
</pre></div>
</div>
<p>When the server received the first SYN, it replied a SYN+ACK, and came into
SYN-RCVD state, so TcpPassiveOpens increased 1. The server received
SYN, sent SYN+ACK, received ACK, so server sent 1 packet, received 2
packets, TcpInSegs increased 2, TcpOutSegs increased 1. The last ACK
of the 3-way handshake is a pure ACK without data, so
TcpExtTCPPureAcks increased 1.</p>
<p>When the client sent SYN, the client came into the SYN-SENT state, so
TcpActiveOpens increased 1, the client sent SYN, received SYN+ACK, sent
ACK, so client sent 2 packets, received 1 packet, TcpInSegs increased
1, TcpOutSegs increased 2.</p>
</div>
<div class="section" id="tcp-normal-traffic">
<h3>TCP normal traffic<a class="headerlink" href="#tcp-normal-traffic" title="Permalink to this headline">¶</a></h3>
<p>Run nc on server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nc -lkv 0.0.0.0 9000
Listening on [0.0.0.0] (family 0, port 9000)
</pre></div>
</div>
<p>Run nc on client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nc -v nstat-b 9000
Connection to nstat-b 9000 port [tcp/*] succeeded!
</pre></div>
</div>
<p>Input a string in the nc client (‘hello’ in our example):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nc -v nstat-b 9000
Connection to nstat-b 9000 port [tcp/*] succeeded!
hello
</pre></div>
</div>
<p>The client side nstat output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nstat
#kernel
IpInReceives                    1                  0.0
IpInDelivers                    1                  0.0
IpOutRequests                   1                  0.0
TcpInSegs                       1                  0.0
TcpOutSegs                      1                  0.0
TcpExtTCPPureAcks               1                  0.0
TcpExtTCPOrigDataSent           1                  0.0
IpExtInOctets                   52                 0.0
IpExtOutOctets                  58                 0.0
IpExtInNoECTPkts                1                  0.0
</pre></div>
</div>
<p>The server side nstat output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nstat
#kernel
IpInReceives                    1                  0.0
IpInDelivers                    1                  0.0
IpOutRequests                   1                  0.0
TcpInSegs                       1                  0.0
TcpOutSegs                      1                  0.0
IpExtInOctets                   58                 0.0
IpExtOutOctets                  52                 0.0
IpExtInNoECTPkts                1                  0.0
</pre></div>
</div>
<p>Input a string in nc client side again (‘world’ in our exmaple):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nc -v nstat-b 9000
Connection to nstat-b 9000 port [tcp/*] succeeded!
hello
world
</pre></div>
</div>
<p>Client side nstat output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nstat
#kernel
IpInReceives                    1                  0.0
IpInDelivers                    1                  0.0
IpOutRequests                   1                  0.0
TcpInSegs                       1                  0.0
TcpOutSegs                      1                  0.0
TcpExtTCPHPAcks                 1                  0.0
TcpExtTCPOrigDataSent           1                  0.0
IpExtInOctets                   52                 0.0
IpExtOutOctets                  58                 0.0
IpExtInNoECTPkts                1                  0.0
</pre></div>
</div>
<p>Server side nstat output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nstat
#kernel
IpInReceives                    1                  0.0
IpInDelivers                    1                  0.0
IpOutRequests                   1                  0.0
TcpInSegs                       1                  0.0
TcpOutSegs                      1                  0.0
TcpExtTCPHPHits                 1                  0.0
IpExtInOctets                   58                 0.0
IpExtOutOctets                  52                 0.0
IpExtInNoECTPkts                1                  0.0
</pre></div>
</div>
<p>Compare the first client-side nstat and the second client-side nstat,
we could find one difference: the first one had a ‘TcpExtTCPPureAcks’,
but the second one had a ‘TcpExtTCPHPAcks’. The first server-side
nstat and the second server-side nstat had a difference too: the
second server-side nstat had a TcpExtTCPHPHits, but the first
server-side nstat didn’t have it. The network traffic patterns were
exactly the same: the client sent a packet to the server, the server
replied an ACK. But kernel handled them in different ways. When the
TCP window scale option is not used, kernel will try to enable fast
path immediately when the connection comes into the established state,
but if the TCP window scale option is used, kernel will disable the
fast path at first, and try to enable it after kerenl receives
packets. We could use the ‘ss’ command to verify whether the window
scale option is used. e.g. run below command on either server or
client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ ss -o state established -i &#39;( dport = :9000 or sport = :9000 )
Netid    Recv-Q     Send-Q            Local Address:Port             Peer Address:Port
tcp      0          0               192.168.122.250:40654         192.168.122.251:9000
           ts sack cubic wscale:7,7 rto:204 rtt:0.98/0.49 mss:1448 pmtu:1500 rcvmss:536 advmss:1448 cwnd:10 bytes_acked:1 segs_out:2 segs_in:1 send 118.2Mbps lastsnd:46572 lastrcv:46572 lastack:46572 pacing_rate 236.4Mbps rcv_space:29200 rcv_ssthresh:29200 minrtt:0.98
</pre></div>
</div>
<p>The ‘wscale:7,7’ means both server and client set the window scale
option to 7. Now we could explain the nstat output in our test:</p>
<p>In the first nstat output of client side, the client sent a packet, server
reply an ACK, when kernel handled this ACK, the fast path was not
enabled, so the ACK was counted into ‘TcpExtTCPPureAcks’.</p>
<p>In the second nstat output of client side, the client sent a packet again,
and received another ACK from the server, in this time, the fast path is
enabled, and the ACK was qualified for fast path, so it was handled by
the fast path, so this ACK was counted into TcpExtTCPHPAcks.</p>
<p>In the first nstat output of server side, fast path was not enabled,
so there was no ‘TcpExtTCPHPHits’.</p>
<p>In the second nstat output of server side, the fast path was enabled,
and the packet received from client qualified for fast path, so it
was counted into ‘TcpExtTCPHPHits’.</p>
</div>
<div class="section" id="tcpexttcpabortonclose">
<h3>TcpExtTCPAbortOnClose<a class="headerlink" href="#tcpexttcpabortonclose" title="Permalink to this headline">¶</a></h3>
<p>On the server side, we run below python script:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import socket
import time

port = 9000

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((&#39;0.0.0.0&#39;, port))
s.listen(1)
sock, addr = s.accept()
while True:
    time.sleep(9999999)
</pre></div>
</div>
<p>This python script listen on 9000 port, but doesn’t read anything from
the connection.</p>
<p>On the client side, we send the string “hello” by nc:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ echo &quot;hello&quot; | nc nstat-b 9000
</pre></div>
</div>
<p>Then, we come back to the server side, the server has received the “hello”
packet, and the TCP layer has acked this packet, but the application didn’t
read it yet. We type Ctrl-C to terminate the server script. Then we
could find TcpExtTCPAbortOnClose increased 1 on the server side:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nstat | grep -i abort
TcpExtTCPAbortOnClose           1                  0.0
</pre></div>
</div>
<p>If we run tcpdump on the server side, we could find the server sent a
RST after we type Ctrl-C.</p>
</div>
<div class="section" id="tcpexttcpabortonmemory-and-tcpexttcpabortontimeout">
<h3>TcpExtTCPAbortOnMemory and TcpExtTCPAbortOnTimeout<a class="headerlink" href="#tcpexttcpabortonmemory-and-tcpexttcpabortontimeout" title="Permalink to this headline">¶</a></h3>
<p>Below is an example which let the orphan socket count be higher than
net.ipv4.tcp_max_orphans.
Change tcp_max_orphans to a smaller value on client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sudo bash -c &quot;echo 10 &gt; /proc/sys/net/ipv4/tcp_max_orphans&quot;
</pre></div>
</div>
<p>Client code (create 64 connection to server):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ cat client_orphan.py
import socket
import time

server = &#39;nstat-b&#39; # server address
port = 9000

count = 64

connection_list = []

for i in range(64):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, port))
    connection_list.append(s)
    print(&quot;connection_count: %d&quot; % len(connection_list))

while True:
    time.sleep(99999)
</pre></div>
</div>
<p>Server code (accept 64 connection from client):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ cat server_orphan.py
import socket
import time

port = 9000
count = 64

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((&#39;0.0.0.0&#39;, port))
s.listen(count)
connection_list = []
while True:
    sock, addr = s.accept()
    connection_list.append((sock, addr))
    print(&quot;connection_count: %d&quot; % len(connection_list))
</pre></div>
</div>
<p>Run the python scripts on server and client.</p>
<p>On server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python3 server_orphan.py
</pre></div>
</div>
<p>On client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python3 client_orphan.py
</pre></div>
</div>
<p>Run iptables on server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sudo iptables -A INPUT -i ens3 -p tcp --destination-port 9000 -j DROP
</pre></div>
</div>
<p>Type Ctrl-C on client, stop client_orphan.py.</p>
<p>Check TcpExtTCPAbortOnMemory on client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nstat | grep -i abort
TcpExtTCPAbortOnMemory          54                 0.0
</pre></div>
</div>
<p>Check orphane socket count on client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ ss -s
Total: 131 (kernel 0)
TCP:   14 (estab 1, closed 0, orphaned 10, synrecv 0, timewait 0/0), ports 0

Transport Total     IP        IPv6
*         0         -         -
RAW       1         0         1
UDP       1         1         0
TCP       14        13        1
INET      16        14        2
FRAG      0         0         0
</pre></div>
</div>
<p>The explanation of the test: after run server_orphan.py and
client_orphan.py, we set up 64 connections between server and
client. Run the iptables command, the server will drop all packets from
the client, type Ctrl-C on client_orphan.py, the system of the client
would try to close these connections, and before they are closed
gracefully, these connections became orphan sockets. As the iptables
of the server blocked packets from the client, the server won’t receive fin
from the client, so all connection on clients would be stuck on FIN_WAIT_1
stage, so they will keep as orphan sockets until timeout. We have echo
10 to /proc/sys/net/ipv4/tcp_max_orphans, so the client system would
only keep 10 orphan sockets, for all other orphan sockets, the client
system sent RST for them and delete them. We have 64 connections, so
the ‘ss -s’ command shows the system has 10 orphan sockets, and the
value of TcpExtTCPAbortOnMemory was 54.</p>
<p>An additional explanation about orphan socket count: You could find the
exactly orphan socket count by the ‘ss -s’ command, but when kernel
decide whither increases TcpExtTCPAbortOnMemory and sends RST, kernel
doesn’t always check the exactly orphan socket count. For increasing
performance, kernel checks an approximate count firstly, if the
approximate count is more than tcp_max_orphans, kernel checks the
exact count again. So if the approximate count is less than
tcp_max_orphans, but exactly count is more than tcp_max_orphans, you
would find TcpExtTCPAbortOnMemory is not increased at all. If
tcp_max_orphans is large enough, it won’t occur, but if you decrease
tcp_max_orphans to a small value like our test, you might find this
issue. So in our test, the client set up 64 connections although the
tcp_max_orphans is 10. If the client only set up 11 connections, we
can’t find the change of TcpExtTCPAbortOnMemory.</p>
<p>Continue the previous test, we wait for several minutes. Because of the
iptables on the server blocked the traffic, the server wouldn’t receive
fin, and all the client’s orphan sockets would timeout on the
FIN_WAIT_1 state finally. So we wait for a few minutes, we could find
10 timeout on the client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nstat | grep -i abort
TcpExtTCPAbortOnTimeout         10                 0.0
</pre></div>
</div>
</div>
<div class="section" id="tcpexttcpabortonlinger">
<h3>TcpExtTCPAbortOnLinger<a class="headerlink" href="#tcpexttcpabortonlinger" title="Permalink to this headline">¶</a></h3>
<p>The server side code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ cat server_linger.py
import socket
import time

port = 9000

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((&#39;0.0.0.0&#39;, port))
s.listen(1)
sock, addr = s.accept()
while True:
    time.sleep(9999999)
</pre></div>
</div>
<p>The client side code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ cat client_linger.py
import socket
import struct

server = &#39;nstat-b&#39; # server address
port = 9000

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack(&#39;ii&#39;, 1, 10))
s.setsockopt(socket.SOL_TCP, socket.TCP_LINGER2, struct.pack(&#39;i&#39;, -1))
s.connect((server, port))
s.close()
</pre></div>
</div>
<p>Run server_linger.py on server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ python3 server_linger.py
</pre></div>
</div>
<p>Run client_linger.py on client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ python3 client_linger.py
</pre></div>
</div>
<p>After run client_linger.py, check the output of nstat:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nstat | grep -i abort
TcpExtTCPAbortOnLinger          1                  0.0
</pre></div>
</div>
</div>
<div class="section" id="tcpexttcprcvcoalesce">
<h3>TcpExtTCPRcvCoalesce<a class="headerlink" href="#tcpexttcprcvcoalesce" title="Permalink to this headline">¶</a></h3>
<p>On the server, we run a program which listen on TCP port 9000, but
doesn’t read any data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import socket
import time
port = 9000
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((&#39;0.0.0.0&#39;, port))
s.listen(1)
sock, addr = s.accept()
while True:
    time.sleep(9999999)
</pre></div>
</div>
<p>Save the above code as server_coalesce.py, and run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python3 server_coalesce.py
</pre></div>
</div>
<p>On the client, save below code as client_coalesce.py:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import socket
server = &#39;nstat-b&#39;
port = 9000
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((server, port))
</pre></div>
</div>
<p>Run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ python3 -i client_coalesce.py
</pre></div>
</div>
<p>We use ‘-i’ to come into the interactive mode, then a packet:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; s.send(b&#39;foo&#39;)
3
</pre></div>
</div>
<p>Send a packet again:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; s.send(b&#39;bar&#39;)
3
</pre></div>
</div>
<p>On the server, run nstat:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ubuntu@nstat-b:~$ nstat
#kernel
IpInReceives                    2                  0.0
IpInDelivers                    2                  0.0
IpOutRequests                   2                  0.0
TcpInSegs                       2                  0.0
TcpOutSegs                      2                  0.0
TcpExtTCPRcvCoalesce            1                  0.0
IpExtInOctets                   110                0.0
IpExtOutOctets                  104                0.0
IpExtInNoECTPkts                2                  0.0
</pre></div>
</div>
<p>The client sent two packets, server didn’t read any data. When
the second packet arrived at server, the first packet was still in
the receiving queue. So the TCP layer merged the two packets, and we
could find the TcpExtTCPRcvCoalesce increased 1.</p>
</div>
<div class="section" id="tcpextlistenoverflows-and-tcpextlistendrops">
<h3>TcpExtListenOverflows and TcpExtListenDrops<a class="headerlink" href="#tcpextlistenoverflows-and-tcpextlistendrops" title="Permalink to this headline">¶</a></h3>
<p>On server, run the nc command, listen on port 9000:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nc -lkv 0.0.0.0 9000
Listening on [0.0.0.0] (family 0, port 9000)
</pre></div>
</div>
<p>On client, run 3 nc commands in different terminals:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nc -v nstat-b 9000
Connection to nstat-b 9000 port [tcp/*] succeeded!
</pre></div>
</div>
<p>The nc command only accepts 1 connection, and the accept queue length
is 1. On current linux implementation, set queue length to n means the
actual queue length is n+1. Now we create 3 connections, 1 is accepted
by nc, 2 in accepted queue, so the accept queue is full.</p>
<p>Before running the 4th nc, we clean the nstat history on the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nstat -n
</pre></div>
</div>
<p>Run the 4th nc on the client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nc -v nstat-b 9000
</pre></div>
</div>
<p>If the nc server is running on kernel 4.10 or higher version, you
won’t see the “Connection to … succeeded!” string, because kernel
will drop the SYN if the accept queue is full. If the nc client is running
on an old kernel, you would see that the connection is succeeded,
because kernel would complete the 3 way handshake and keep the socket
on half open queue. I did the test on kernel 4.15. Below is the nstat
on the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nstat
#kernel
IpInReceives                    4                  0.0
IpInDelivers                    4                  0.0
TcpInSegs                       4                  0.0
TcpExtListenOverflows           4                  0.0
TcpExtListenDrops               4                  0.0
IpExtInOctets                   240                0.0
IpExtInNoECTPkts                4                  0.0
</pre></div>
</div>
<p>Both TcpExtListenOverflows and TcpExtListenDrops were 4. If the time
between the 4th nc and the nstat was longer, the value of
TcpExtListenOverflows and TcpExtListenDrops would be larger, because
the SYN of the 4th nc was dropped, the client was retrying.</p>
</div>
<div class="section" id="ipinaddrerrors-ipextinnoroutes-and-ipoutnoroutes">
<h3>IpInAddrErrors, IpExtInNoRoutes and IpOutNoRoutes<a class="headerlink" href="#ipinaddrerrors-ipextinnoroutes-and-ipoutnoroutes" title="Permalink to this headline">¶</a></h3>
<p>server A IP address: 192.168.122.250
server B IP address: 192.168.122.251
Prepare on server A, add a route to server B:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo ip route add 8.8.8.8/32 via 192.168.122.251
</pre></div>
</div>
<p>Prepare on server B, disable send_redirects for all interfaces:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo sysctl -w net.ipv4.conf.all.send_redirects=0
$ sudo sysctl -w net.ipv4.conf.ens3.send_redirects=0
$ sudo sysctl -w net.ipv4.conf.lo.send_redirects=0
$ sudo sysctl -w net.ipv4.conf.default.send_redirects=0
</pre></div>
</div>
<p>We want to let sever A send a packet to 8.8.8.8, and route the packet
to server B. When server B receives such packet, it might send a ICMP
Redirect message to server A, set send_redirects to 0 will disable
this behavior.</p>
<p>First, generate InAddrErrors. On server B, we disable IP forwarding:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo sysctl -w net.ipv4.conf.all.forwarding=0
</pre></div>
</div>
<p>On server A, we send packets to 8.8.8.8:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ nc -v 8.8.8.8 53
</pre></div>
</div>
<p>On server B, we check the output of nstat:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ nstat
#kernel
IpInReceives                    3                  0.0
IpInAddrErrors                  3                  0.0
IpExtInOctets                   180                0.0
IpExtInNoECTPkts                3                  0.0
</pre></div>
</div>
<p>As we have let server A route 8.8.8.8 to server B, and we disabled IP
forwarding on server B, Server A sent packets to server B, then server B
dropped packets and increased IpInAddrErrors. As the nc command would
re-send the SYN packet if it didn’t receive a SYN+ACK, we could find
multiple IpInAddrErrors.</p>
<p>Second, generate IpExtInNoRoutes. On server B, we enable IP
forwarding:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo sysctl -w net.ipv4.conf.all.forwarding=1
</pre></div>
</div>
<p>Check the route table of server B and remove the default route:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ip route show
default via 192.168.122.1 dev ens3 proto static
192.168.122.0/24 dev ens3 proto kernel scope link src 192.168.122.251
$ sudo ip route delete default via 192.168.122.1 dev ens3 proto static
</pre></div>
</div>
<p>On server A, we contact 8.8.8.8 again:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ nc -v 8.8.8.8 53
nc: connect to 8.8.8.8 port 53 (tcp) failed: Network is unreachable
</pre></div>
</div>
<p>On server B, run nstat:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ nstat
#kernel
IpInReceives                    1                  0.0
IpOutRequests                   1                  0.0
IcmpOutMsgs                     1                  0.0
IcmpOutDestUnreachs             1                  0.0
IcmpMsgOutType3                 1                  0.0
IpExtInNoRoutes                 1                  0.0
IpExtInOctets                   60                 0.0
IpExtOutOctets                  88                 0.0
IpExtInNoECTPkts                1                  0.0
</pre></div>
</div>
<p>We enabled IP forwarding on server B, when server B received a packet
which destination IP address is 8.8.8.8, server B will try to forward
this packet. We have deleted the default route, there was no route for
8.8.8.8, so server B increase IpExtInNoRoutes and sent the “ICMP
Destination Unreachable” message to server A.</p>
<p>Third, generate IpOutNoRoutes. Run ping command on server B:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ping -c 1 8.8.8.8
connect: Network is unreachable
</pre></div>
</div>
<p>Run nstat on server B:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ nstat
#kernel
IpOutNoRoutes                   1                  0.0
</pre></div>
</div>
<p>We have deleted the default route on server B. Server B couldn’t find
a route for the 8.8.8.8 IP address, so server B increased
IpOutNoRoutes.</p>
</div>
<div class="section" id="tcpexttcpackskippedsynrecv">
<h3>TcpExtTCPACKSkippedSynRecv<a class="headerlink" href="#tcpexttcpackskippedsynrecv" title="Permalink to this headline">¶</a></h3>
<p>In this test, we send 3 same SYN packets from client to server. The
first SYN will let server create a socket, set it to Syn-Recv status,
and reply a SYN/ACK. The second SYN will let server reply the SYN/ACK
again, and record the reply time (the duplicate ACK reply time). The
third SYN will let server check the previous duplicate ACK reply time,
and decide to skip the duplicate ACK, then increase the
TcpExtTCPACKSkippedSynRecv counter.</p>
<p>Run tcpdump to capture a SYN packet:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ sudo tcpdump -c 1 -w /tmp/syn.pcap port 9000
tcpdump: listening on ens3, link-type EN10MB (Ethernet), capture size 262144 bytes
</pre></div>
</div>
<p>Open another terminal, run nc command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nc nstat-b 9000
</pre></div>
</div>
<p>As the nstat-b didn’t listen on port 9000, it should reply a RST, and
the nc command exited immediately. It was enough for the tcpdump
command to capture a SYN packet. A linux server might use hardware
offload for the TCP checksum, so the checksum in the /tmp/syn.pcap
might be not correct. We call tcprewrite to fix it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ tcprewrite --infile=/tmp/syn.pcap --outfile=/tmp/syn_fixcsum.pcap --fixcsum
</pre></div>
</div>
<p>On nstat-b, we run nc to listen on port 9000:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nc -lkv 9000
Listening on [0.0.0.0] (family 0, port 9000)
</pre></div>
</div>
<p>On nstat-a, we blocked the packet from port 9000, or nstat-a would send
RST to nstat-b:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ sudo iptables -A INPUT -p tcp --sport 9000 -j DROP
</pre></div>
</div>
<p>Send 3 SYN repeatly to nstat-b:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ for i in {1..3}; do sudo tcpreplay -i ens3 /tmp/syn_fixcsum.pcap; done
</pre></div>
</div>
<p>Check snmp cunter on nstat-b:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nstat | grep -i skip
TcpExtTCPACKSkippedSynRecv      1                  0.0
</pre></div>
</div>
<p>As we expected, TcpExtTCPACKSkippedSynRecv is 1.</p>
</div>
<div class="section" id="tcpexttcpackskippedpaws">
<h3>TcpExtTCPACKSkippedPAWS<a class="headerlink" href="#tcpexttcpackskippedpaws" title="Permalink to this headline">¶</a></h3>
<p>To trigger PAWS, we could send an old SYN.</p>
<p>On nstat-b, let nc listen on port 9000:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nc -lkv 9000
Listening on [0.0.0.0] (family 0, port 9000)
</pre></div>
</div>
<p>On nstat-a, run tcpdump to capture a SYN:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ sudo tcpdump -w /tmp/paws_pre.pcap -c 1 port 9000
tcpdump: listening on ens3, link-type EN10MB (Ethernet), capture size 262144 bytes
</pre></div>
</div>
<p>On nstat-a, run nc as a client to connect nstat-b:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nc -v nstat-b 9000
Connection to nstat-b 9000 port [tcp/*] succeeded!
</pre></div>
</div>
<p>Now the tcpdump has captured the SYN and exit. We should fix the
checksum:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ tcprewrite --infile /tmp/paws_pre.pcap --outfile /tmp/paws.pcap --fixcsum
</pre></div>
</div>
<p>Send the SYN packet twice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ for i in {1..2}; do sudo tcpreplay -i ens3 /tmp/paws.pcap; done
</pre></div>
</div>
<p>On nstat-b, check the snmp counter:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nstat | grep -i skip
TcpExtTCPACKSkippedPAWS         1                  0.0
</pre></div>
</div>
<p>We sent two SYN via tcpreplay, both of them would let PAWS check
failed, the nstat-b replied an ACK for the first SYN, skipped the ACK
for the second SYN, and updated TcpExtTCPACKSkippedPAWS.</p>
</div>
<div class="section" id="tcpexttcpackskippedseq">
<h3>TcpExtTCPACKSkippedSeq<a class="headerlink" href="#tcpexttcpackskippedseq" title="Permalink to this headline">¶</a></h3>
<p>To trigger TcpExtTCPACKSkippedSeq, we send packets which have valid
timestamp (to pass PAWS check) but the sequence number is out of
window. The linux TCP stack would avoid to skip if the packet has
data, so we need a pure ACK packet. To generate such a packet, we
could create two sockets: one on port 9000, another on port 9001. Then
we capture an ACK on port 9001, change the source/destination port
numbers to match the port 9000 socket. Then we could trigger
TcpExtTCPACKSkippedSeq via this packet.</p>
<p>On nstat-b, open two terminals, run two nc commands to listen on both
port 9000 and port 9001:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nc -lkv 9000
Listening on [0.0.0.0] (family 0, port 9000)

nstatuser@nstat-b:~$ nc -lkv 9001
Listening on [0.0.0.0] (family 0, port 9001)
</pre></div>
</div>
<p>On nstat-a, run two nc clients:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ nc -v nstat-b 9000
Connection to nstat-b 9000 port [tcp/*] succeeded!

nstatuser@nstat-a:~$ nc -v nstat-b 9001
Connection to nstat-b 9001 port [tcp/*] succeeded!
</pre></div>
</div>
<p>On nstat-a, run tcpdump to capture an ACK:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ sudo tcpdump -w /tmp/seq_pre.pcap -c 1 dst port 9001
tcpdump: listening on ens3, link-type EN10MB (Ethernet), capture size 262144 bytes
</pre></div>
</div>
<p>On nstat-b, send a packet via the port 9001 socket. E.g. we sent a
string ‘foo’ in our example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nc -lkv 9001
Listening on [0.0.0.0] (family 0, port 9001)
Connection from nstat-a 42132 received!
foo
</pre></div>
</div>
<p>On nstat-a, the tcpdump should have caputred the ACK. We should check
the source port numbers of the two nc clients:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ ss -ta &#39;( dport = :9000 || dport = :9001 )&#39; | tee
State  Recv-Q   Send-Q         Local Address:Port           Peer Address:Port
ESTAB  0        0            192.168.122.250:50208       192.168.122.251:9000
ESTAB  0        0            192.168.122.250:42132       192.168.122.251:9001
</pre></div>
</div>
<p>Run tcprewrite, change port 9001 to port 9000, chagne port 42132 to
port 50208:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ tcprewrite --infile /tmp/seq_pre.pcap --outfile /tmp/seq.pcap -r 9001:9000 -r 42132:50208 --fixcsum
</pre></div>
</div>
<p>Now the /tmp/seq.pcap is the packet we need. Send it to nstat-b:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-a:~$ for i in {1..2}; do sudo tcpreplay -i ens3 /tmp/seq.pcap; done
</pre></div>
</div>
<p>Check TcpExtTCPACKSkippedSeq on nstat-b:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nstatuser@nstat-b:~$ nstat | grep -i skip
TcpExtTCPACKSkippedSeq          1                  0.0
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="checksum-offloads.html" class="btn btn-neutral float-right" title="Checksum Offloads" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="bridge.html" class="btn btn-neutral float-left" title="Ethernet Bridging" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>