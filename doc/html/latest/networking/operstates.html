

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Operational States &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Operational States</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/operstates.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="operational-states">
<h1>Operational States<a class="headerlink" href="#operational-states" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Linux distinguishes between administrative and operational state of an
interface. Administrative state is the result of “ip link set dev
&lt;dev&gt; up or down” and reflects whether the administrator wants to use
the device for traffic.</p>
<p>However, an interface is not usable just because the admin enabled it
- ethernet requires to be plugged into the switch and, depending on
a site’s networking policy and configuration, an 802.1X authentication
to be performed before user data can be transferred. Operational state
shows the ability of an interface to transmit this user data.</p>
<p>Thanks to 802.1X, userspace must be granted the possibility to
influence operational state. To accommodate this, operational state is
split into two parts: Two flags that can be set by the driver only, and
a RFC2863 compatible state that is derived from these flags, a policy,
and changeable from userspace under certain rules.</p>
</div>
<div class="section" id="querying-from-userspace">
<h2>2. Querying from userspace<a class="headerlink" href="#querying-from-userspace" title="Permalink to this headline">¶</a></h2>
<p>Both admin and operational state can be queried via the netlink
operation RTM_GETLINK. It is also possible to subscribe to RTNLGRP_LINK
to be notified of updates while the interface is admin up. This is
important for setting from userspace.</p>
<p>These values contain interface state:</p>
<dl class="docutils">
<dt>ifinfomsg::if_flags &amp; IFF_UP:</dt>
<dd>Interface is admin up</dd>
<dt>ifinfomsg::if_flags &amp; IFF_RUNNING:</dt>
<dd>Interface is in RFC2863 operational state UP or UNKNOWN. This is for
backward compatibility, routing daemons, dhcp clients can use this
flag to determine whether they should use the interface.</dd>
<dt>ifinfomsg::if_flags &amp; IFF_LOWER_UP:</dt>
<dd>Driver has signaled <a class="reference internal" href="kapi.html#c.netif_carrier_on" title="netif_carrier_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_carrier_on()</span></code></a></dd>
<dt>ifinfomsg::if_flags &amp; IFF_DORMANT:</dt>
<dd>Driver has signaled <a class="reference internal" href="kapi.html#c.netif_dormant_on" title="netif_dormant_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_dormant_on()</span></code></a></dd>
</dl>
<div class="section" id="tlv-ifla-operstate">
<h3>TLV IFLA_OPERSTATE<a class="headerlink" href="#tlv-ifla-operstate" title="Permalink to this headline">¶</a></h3>
<p>contains RFC2863 state of the interface in numeric representation:</p>
<dl class="docutils">
<dt>IF_OPER_UNKNOWN (0):</dt>
<dd>Interface is in unknown state, neither driver nor userspace has set
operational state. Interface must be considered for user data as
setting operational state has not been implemented in every driver.</dd>
<dt>IF_OPER_NOTPRESENT (1):</dt>
<dd>Unused in current kernel (notpresent interfaces normally disappear),
just a numerical placeholder.</dd>
<dt>IF_OPER_DOWN (2):</dt>
<dd>Interface is unable to transfer data on L1, f.e. ethernet is not
plugged or interface is ADMIN down.</dd>
<dt>IF_OPER_LOWERLAYERDOWN (3):</dt>
<dd>Interfaces stacked on an interface that is IF_OPER_DOWN show this
state (f.e. VLAN).</dd>
<dt>IF_OPER_TESTING (4):</dt>
<dd>Unused in current kernel.</dd>
<dt>IF_OPER_DORMANT (5):</dt>
<dd>Interface is L1 up, but waiting for an external event, f.e. for a
protocol to establish. (802.1X)</dd>
<dt>IF_OPER_UP (6):</dt>
<dd>Interface is operational up and can be used.</dd>
</dl>
<p>This TLV can also be queried via sysfs.</p>
</div>
<div class="section" id="tlv-ifla-linkmode">
<h3>TLV IFLA_LINKMODE<a class="headerlink" href="#tlv-ifla-linkmode" title="Permalink to this headline">¶</a></h3>
<p>contains link policy. This is needed for userspace interaction
described below.</p>
<p>This TLV can also be queried via sysfs.</p>
</div>
</div>
<div class="section" id="kernel-driver-api">
<h2>3. Kernel driver API<a class="headerlink" href="#kernel-driver-api" title="Permalink to this headline">¶</a></h2>
<p>Kernel drivers have access to two flags that map to IFF_LOWER_UP and
IFF_DORMANT. These flags can be set from everywhere, even from
interrupts. It is guaranteed that only the driver has write access,
however, if different layers of the driver manipulate the same flag,
the driver has to provide the synchronisation needed.</p>
<p>__LINK_STATE_NOCARRIER, maps to !IFF_LOWER_UP:</p>
<p>The driver uses <a class="reference internal" href="kapi.html#c.netif_carrier_on" title="netif_carrier_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_carrier_on()</span></code></a> to clear and <a class="reference internal" href="kapi.html#c.netif_carrier_off" title="netif_carrier_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_carrier_off()</span></code></a> to
set this flag. On <a class="reference internal" href="kapi.html#c.netif_carrier_off" title="netif_carrier_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_carrier_off()</span></code></a>, the scheduler stops sending
packets. The name ‘carrier’ and the inversion are historical, think of
it as lower layer.</p>
<p>Note that for certain kind of soft-devices, which are not managing any
real hardware, it is possible to set this bit from userspace.  One
should use TVL IFLA_CARRIER to do so.</p>
<p><a class="reference internal" href="kapi.html#c.netif_carrier_ok" title="netif_carrier_ok"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_carrier_ok()</span></code></a> can be used to query that bit.</p>
<p>__LINK_STATE_DORMANT, maps to IFF_DORMANT:</p>
<p>Set by the driver to express that the device cannot yet be used
because some driver controlled protocol establishment has to
complete. Corresponding functions are <a class="reference internal" href="kapi.html#c.netif_dormant_on" title="netif_dormant_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_dormant_on()</span></code></a> to set the
flag, <a class="reference internal" href="kapi.html#c.netif_dormant_off" title="netif_dormant_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_dormant_off()</span></code></a> to clear it and <a class="reference internal" href="kapi.html#c.netif_dormant" title="netif_dormant"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_dormant()</span></code></a> to query.</p>
<p>On device allocation, both flags __LINK_STATE_NOCARRIER and
__LINK_STATE_DORMANT are cleared, so the effective state is equivalent
to <a class="reference internal" href="kapi.html#c.netif_carrier_ok" title="netif_carrier_ok"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_carrier_ok()</span></code></a> and !<a class="reference internal" href="kapi.html#c.netif_dormant" title="netif_dormant"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_dormant()</span></code></a>.</p>
<p>Whenever the driver CHANGES one of these flags, a workqueue event is
scheduled to translate the flag combination to IFLA_OPERSTATE as
follows:</p>
<dl class="docutils">
<dt>!netif_carrier_ok():</dt>
<dd>IF_OPER_LOWERLAYERDOWN if the interface is stacked, IF_OPER_DOWN
otherwise. Kernel can recognise stacked interfaces because their
ifindex != iflink.</dd>
<dt>netif_carrier_ok() &amp;&amp; netif_dormant():</dt>
<dd>IF_OPER_DORMANT</dd>
<dt>netif_carrier_ok() &amp;&amp; !netif_dormant():</dt>
<dd>IF_OPER_UP if userspace interaction is disabled. Otherwise
IF_OPER_DORMANT with the possibility for userspace to initiate the
IF_OPER_UP transition afterwards.</dd>
</dl>
</div>
<div class="section" id="setting-from-userspace">
<h2>4. Setting from userspace<a class="headerlink" href="#setting-from-userspace" title="Permalink to this headline">¶</a></h2>
<p>Applications have to use the netlink interface to influence the
RFC2863 operational state of an interface. Setting IFLA_LINKMODE to 1
via RTM_SETLINK instructs the kernel that an interface should go to
IF_OPER_DORMANT instead of IF_OPER_UP when the combination
<a class="reference internal" href="kapi.html#c.netif_carrier_ok" title="netif_carrier_ok"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_carrier_ok()</span></code></a> &amp;&amp; !<a class="reference internal" href="kapi.html#c.netif_dormant" title="netif_dormant"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_dormant()</span></code></a> is set by the
driver. Afterwards, the userspace application can set IFLA_OPERSTATE
to IF_OPER_DORMANT or IF_OPER_UP as long as the driver does not set
<a class="reference internal" href="kapi.html#c.netif_carrier_off" title="netif_carrier_off"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_carrier_off()</span></code></a> or <a class="reference internal" href="kapi.html#c.netif_dormant_on" title="netif_dormant_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_dormant_on()</span></code></a>. Changes made by userspace
are multicasted on the netlink group RTNLGRP_LINK.</p>
<p>So basically a 802.1X supplicant interacts with the kernel like this:</p>
<ul class="simple">
<li>subscribe to RTNLGRP_LINK</li>
<li>set IFLA_LINKMODE to 1 via RTM_SETLINK</li>
<li>query RTM_GETLINK once to get initial state</li>
<li>if initial flags are not (IFF_LOWER_UP &amp;&amp; !IFF_DORMANT), wait until
netlink multicast signals this state</li>
<li>do 802.1X, eventually abort if flags go down again</li>
<li>send RTM_SETLINK to set operstate to IF_OPER_UP if authentication
succeeds, IF_OPER_DORMANT otherwise</li>
<li>see how operstate and IFF_RUNNING is echoed via netlink multicast</li>
<li>set interface back to IF_OPER_DORMANT if 802.1X reauthentication
fails</li>
<li>restart if kernel changes IFF_LOWER_UP or IFF_DORMANT flag</li>
</ul>
<p>if supplicant goes down, bring back IFLA_LINKMODE to 0 and
IFLA_OPERSTATE to a sane value.</p>
<p>A routing daemon or dhcp client just needs to care for IFF_RUNNING or
waiting for operstate to go IF_OPER_UP/IF_OPER_UNKNOWN before
considering the interface / querying a DHCP address.</p>
<p>For technical questions and/or comments please e-mail to Stefan Rompf
(stefan at loplof.de).</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>