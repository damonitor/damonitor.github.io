

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Light-weight System Calls for IA-64 &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Light-weight System Calls for IA-64</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/ia64/fsys.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="light-weight-system-calls-for-ia-64">
<h1>Light-weight System Calls for IA-64<a class="headerlink" href="#light-weight-system-calls-for-ia-64" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><blockquote>
<div>Started: 13-Jan-2003</div></blockquote>
<p>Last update: 27-Sep-2003</p>
<blockquote>
<div>David Mosberger-Tang
&lt;<a class="reference external" href="mailto:davidm&#37;&#52;&#48;hpl&#46;hp&#46;com">davidm<span>&#64;</span>hpl<span>&#46;</span>hp<span>&#46;</span>com</a>&gt;</div></blockquote>
</div></blockquote>
<p>Using the “epc” instruction effectively introduces a new mode of
execution to the ia64 linux kernel.  We call this mode the
“fsys-mode”.  To recap, the normal states of execution are:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>kernel mode:</dt>
<dd>Both the register stack and the memory stack have been
switched over to kernel memory.  The user-level state is saved
in a pt-regs structure at the top of the kernel memory stack.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>user mode:</dt>
<dd>Both the register stack and the kernel stack are in
user memory.  The user-level state is contained in the
CPU registers.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bank 0 interruption-handling mode:</dt>
<dd>This is the non-interruptible state which all
interruption-handlers start execution in.  The user-level
state remains in the CPU registers and some kernel state may
be stored in bank 0 of registers r16-r31.</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>In contrast, fsys-mode has the following special properties:</p>
<blockquote>
<div><ul class="simple">
<li>execution is at privilege level 0 (most-privileged)</li>
<li>CPU registers may contain a mixture of user-level and kernel-level
state (it is the responsibility of the kernel to ensure that no
security-sensitive kernel-level state is leaked back to
user-level)</li>
<li>execution is interruptible and preemptible (an fsys-mode handler
can disable interrupts and avoid all other interruption-sources
to avoid preemption)</li>
<li>neither the memory-stack nor the register-stack can be trusted while
in fsys-mode (they point to the user-level stacks, which may
be invalid, or completely bogus addresses)</li>
</ul>
</div></blockquote>
<p>In summary, fsys-mode is much more similar to running in user-mode
than it is to running in kernel-mode.  Of course, given that the
privilege level is at level 0, this means that fsys-mode requires some
care (see below).</p>
<div class="section" id="how-to-tell-fsys-mode">
<h2>How to tell fsys-mode<a class="headerlink" href="#how-to-tell-fsys-mode" title="Permalink to this headline">¶</a></h2>
<p>Linux operates in fsys-mode when (a) the privilege level is 0 (most
privileged) and (b) the stacks have NOT been switched to kernel memory
yet.  For convenience, the header file &lt;asm-ia64/ptrace.h&gt; provides
three macros:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>user_mode(regs)
user_stack(task,regs)
fsys_mode(task,regs)
</pre></div>
</div>
<p>The “regs” argument is a pointer to a pt_regs structure.  The “task”
argument is a pointer to the task structure to which the “regs”
pointer belongs to.  user_mode() returns TRUE if the CPU state pointed
to by “regs” was executing in user mode (privilege level 3).
user_stack() returns TRUE if the state pointed to by “regs” was
executing on the user-level stack(s).  Finally, fsys_mode() returns
TRUE if the CPU state pointed to by “regs” was executing in fsys-mode.
The fsys_mode() macro is equivalent to the expression:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!user_mode(regs) &amp;&amp; user_stack(task,regs)
</pre></div>
</div>
</div>
<div class="section" id="how-to-write-an-fsyscall-handler">
<h2>How to write an fsyscall handler<a class="headerlink" href="#how-to-write-an-fsyscall-handler" title="Permalink to this headline">¶</a></h2>
<p>The file arch/ia64/kernel/fsys.S contains a table of fsyscall-handlers
(fsyscall_table).  This table contains one entry for each system call.
By default, a system call is handled by fsys_fallback_syscall().  This
routine takes care of entering (full) kernel mode and calling the
normal Linux system call handler.  For performance-critical system
calls, it is possible to write a hand-tuned fsyscall_handler.  For
example, fsys.S contains fsys_getpid(), which is a hand-tuned version
of the getpid() system call.</p>
<p>The entry and exit-state of an fsyscall handler is as follows:</p>
<div class="section" id="machine-state-on-entry-to-fsyscall-handler">
<h3>Machine state on entry to fsyscall handler<a class="headerlink" href="#machine-state-on-entry-to-fsyscall-handler" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>r10</td>
<td>0</td>
</tr>
<tr class="row-even"><td>r11</td>
<td>saved ar.pfs (a user-level value)</td>
</tr>
<tr class="row-odd"><td>r15</td>
<td>system call number</td>
</tr>
<tr class="row-even"><td>r16</td>
<td>“current” task pointer (in normal kernel-mode, this is in r13)</td>
</tr>
<tr class="row-odd"><td>r32-r39</td>
<td>system call arguments</td>
</tr>
<tr class="row-even"><td>b6</td>
<td>return address (a user-level value)</td>
</tr>
<tr class="row-odd"><td>ar.pfs</td>
<td>previous frame-state (a user-level value)</td>
</tr>
<tr class="row-even"><td>PSR.be</td>
<td>cleared to zero (i.e., little-endian byte order is in effect)</td>
</tr>
<tr class="row-odd"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>all other registers may contain values passed in from user-mode</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="required-machine-state-on-exit-to-fsyscall-handler">
<h3>Required machine state on exit to fsyscall handler<a class="headerlink" href="#required-machine-state-on-exit-to-fsyscall-handler" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>r11</td>
<td>saved ar.pfs (as passed into the fsyscall handler)</td>
</tr>
<tr class="row-even"><td>r15</td>
<td>system call number (as passed into the fsyscall handler)</td>
</tr>
<tr class="row-odd"><td>r32-r39</td>
<td>system call arguments (as passed into the fsyscall handler)</td>
</tr>
<tr class="row-even"><td>b6</td>
<td>return address (as passed into the fsyscall handler)</td>
</tr>
<tr class="row-odd"><td>ar.pfs</td>
<td>previous frame-state (as passed into the fsyscall handler)</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Fsyscall handlers can execute with very little overhead, but with that
speed comes a set of restrictions:</p>
<blockquote>
<div><ul class="simple">
<li>Fsyscall-handlers MUST check for any pending work in the flags
member of the thread-info structure and if any of the
TIF_ALLWORK_MASK flags are set, the handler needs to fall back on
doing a full system call (by calling fsys_fallback_syscall).</li>
<li>Fsyscall-handlers MUST preserve incoming arguments (r32-r39, r11,
r15, b6, and ar.pfs) because they will be needed in case of a
system call restart.  Of course, all “preserved” registers also
must be preserved, in accordance to the normal calling conventions.</li>
<li>Fsyscall-handlers MUST check argument registers for containing a
NaT value before using them in any way that could trigger a
NaT-consumption fault.  If a system call argument is found to
contain a NaT value, an fsyscall-handler may return immediately
with r8=EINVAL, r10=-1.</li>
<li>Fsyscall-handlers MUST NOT use the “alloc” instruction or perform
any other operation that would trigger mandatory RSE
(register-stack engine) traffic.</li>
<li>Fsyscall-handlers MUST NOT write to any stacked registers because
it is not safe to assume that user-level called a handler with the
proper number of arguments.</li>
<li>Fsyscall-handlers need to be careful when accessing per-CPU variables:
unless proper safe-guards are taken (e.g., interruptions are avoided),
execution may be pre-empted and resumed on another CPU at any given
time.</li>
<li>Fsyscall-handlers must be careful not to leak sensitive kernel’
information back to user-level.  In particular, before returning to
user-level, care needs to be taken to clear any scratch registers
that could contain sensitive information (note that the current
task pointer is not considered sensitive: it’s already exposed
through ar.k6).</li>
<li>Fsyscall-handlers MUST NOT access user-memory without first
validating access-permission (this can be done typically via
probe.r.fault and/or probe.w.fault) and without guarding against
memory access exceptions (this can be done with the EX() macros
defined by asmmacro.h).</li>
</ul>
</div></blockquote>
<p>The above restrictions may seem draconian, but remember that it’s
possible to trade off some of the restrictions by paying a slightly
higher overhead.  For example, if an fsyscall-handler could benefit
from the shadow register bank, it could temporarily disable PSR.i and
PSR.ic, switch to bank 0 (bsw.0) and then use the shadow registers as
needed.  In other words, following the above rules yields extremely
fast system call execution (while fully preserving system call
semantics), but there is also a lot of flexibility in handling more
complicated cases.</p>
</div>
</div>
<div class="section" id="signal-handling">
<h2>Signal handling<a class="headerlink" href="#signal-handling" title="Permalink to this headline">¶</a></h2>
<p>The delivery of (asynchronous) signals must be delayed until fsys-mode
is exited.  This is accomplished with the help of the lower-privilege
transfer trap: arch/ia64/kernel/process.c:do_notify_resume_user()
checks whether the interrupted task was in fsys-mode and, if so, sets
PSR.lp and returns immediately.  When fsys-mode is exited via the
“br.ret” instruction that lowers the privilege level, a trap will
occur.  The trap handler clears PSR.lp again and returns immediately.
The kernel exit path then checks for and delivers any pending signals.</p>
</div>
<div class="section" id="psr-handling">
<h2>PSR Handling<a class="headerlink" href="#psr-handling" title="Permalink to this headline">¶</a></h2>
<p>The “epc” instruction doesn’t change the contents of PSR at all.  This
is in contrast to a regular interruption, which clears almost all
bits.  Because of that, some care needs to be taken to ensure things
work as expected.  The following discussion describes how each PSR bit
is handled.</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>PSR.be</td>
<td>Cleared when entering fsys-mode.  A srlz.d instruction is used
to ensure the CPU is in little-endian mode before the first
load/store instruction is executed.  PSR.be is normally NOT
restored upon return from an fsys-mode handler.  In other
words, user-level code must not rely on PSR.be being preserved
across a system call.</td>
</tr>
<tr class="row-even"><td>PSR.up</td>
<td>Unchanged.</td>
</tr>
<tr class="row-odd"><td>PSR.ac</td>
<td>Unchanged.</td>
</tr>
<tr class="row-even"><td>PSR.mfl</td>
<td>Unchanged.  Note: fsys-mode handlers must not write-registers!</td>
</tr>
<tr class="row-odd"><td>PSR.mfh</td>
<td>Unchanged.  Note: fsys-mode handlers must not write-registers!</td>
</tr>
<tr class="row-even"><td>PSR.ic</td>
<td>Unchanged.  Note: fsys-mode handlers can clear the bit, if needed.</td>
</tr>
<tr class="row-odd"><td>PSR.i</td>
<td>Unchanged.  Note: fsys-mode handlers can clear the bit, if needed.</td>
</tr>
<tr class="row-even"><td>PSR.pk</td>
<td>Unchanged.</td>
</tr>
<tr class="row-odd"><td>PSR.dt</td>
<td>Unchanged.</td>
</tr>
<tr class="row-even"><td>PSR.dfl</td>
<td>Unchanged.  Note: fsys-mode handlers must not write-registers!</td>
</tr>
<tr class="row-odd"><td>PSR.dfh</td>
<td>Unchanged.  Note: fsys-mode handlers must not write-registers!</td>
</tr>
<tr class="row-even"><td>PSR.sp</td>
<td>Unchanged.</td>
</tr>
<tr class="row-odd"><td>PSR.pp</td>
<td>Unchanged.</td>
</tr>
<tr class="row-even"><td>PSR.di</td>
<td>Unchanged.</td>
</tr>
<tr class="row-odd"><td>PSR.si</td>
<td>Unchanged.</td>
</tr>
<tr class="row-even"><td>PSR.db</td>
<td>Unchanged.  The kernel prevents user-level from setting a hardware
breakpoint that triggers at any privilege level other than
3 (user-mode).</td>
</tr>
<tr class="row-odd"><td>PSR.lp</td>
<td>Unchanged.</td>
</tr>
<tr class="row-even"><td>PSR.tb</td>
<td>Lazy redirect.  If a taken-branch trap occurs while in
fsys-mode, the trap-handler modifies the saved machine state
such that execution resumes in the gate page at
syscall_via_break(), with privilege level 3.  Note: the
taken branch would occur on the branch invoking the
fsyscall-handler, at which point, by definition, a syscall
restart is still safe.  If the system call number is invalid,
the fsys-mode handler will return directly to user-level.  This
return will trigger a taken-branch trap, but since the trap is
taken _after_ restoring the privilege level, the CPU has already
left fsys-mode, so no special treatment is needed.</td>
</tr>
<tr class="row-odd"><td>PSR.rt</td>
<td>Unchanged.</td>
</tr>
<tr class="row-even"><td>PSR.cpl</td>
<td>Cleared to 0.</td>
</tr>
<tr class="row-odd"><td>PSR.is</td>
<td>Unchanged (guaranteed to be 0 on entry to the gate page).</td>
</tr>
<tr class="row-even"><td>PSR.mc</td>
<td>Unchanged.</td>
</tr>
<tr class="row-odd"><td>PSR.it</td>
<td>Unchanged (guaranteed to be 1).</td>
</tr>
<tr class="row-even"><td>PSR.id</td>
<td>Unchanged.  Note: the ia64 linux kernel never sets this bit.</td>
</tr>
<tr class="row-odd"><td>PSR.da</td>
<td>Unchanged.  Note: the ia64 linux kernel never sets this bit.</td>
</tr>
<tr class="row-even"><td>PSR.dd</td>
<td>Unchanged.  Note: the ia64 linux kernel never sets this bit.</td>
</tr>
<tr class="row-odd"><td>PSR.ss</td>
<td>Lazy redirect.  If set, “epc” will cause a Single Step Trap to
be taken.  The trap handler then modifies the saved machine
state such that execution resumes in the gate page at
syscall_via_break(), with privilege level 3.</td>
</tr>
<tr class="row-even"><td>PSR.ri</td>
<td>Unchanged.</td>
</tr>
<tr class="row-odd"><td>PSR.ed</td>
<td>Unchanged.  Note: This bit could only have an effect if an fsys-mode
handler performed a speculative load that gets NaTted.  If so, this
would be the normal &amp; expected behavior, so no special treatment is
needed.</td>
</tr>
<tr class="row-even"><td>PSR.bn</td>
<td>Unchanged.  Note: fsys-mode handlers may clear the bit, if needed.
Doing so requires clearing PSR.i and PSR.ic as well.</td>
</tr>
<tr class="row-odd"><td>PSR.ia</td>
<td>Unchanged.  Note: the ia64 linux kernel never sets this bit.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="using-fast-system-calls">
<h2>Using fast system calls<a class="headerlink" href="#using-fast-system-calls" title="Permalink to this headline">¶</a></h2>
<p>To use fast system calls, userspace applications need simply call
__kernel_syscall_via_epc().  For example</p>
<p>– example fgettimeofday() call –</p>
<p>– fgettimeofday.S –</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;asm/asmmacro.h&gt;

GLOBAL_ENTRY(fgettimeofday)
.prologue
.save ar.pfs, r11
mov r11 = ar.pfs
.body

mov r2 = 0xa000000000020660;;  // gate address
                             // found by inspection of System.map for the
                             // __kernel_syscall_via_epc() function.  See
                             // below for how to do this for real.

mov b7 = r2
mov r15 = 1087                       // gettimeofday syscall
;;
br.call.sptk.many b6 = b7
;;

.restore sp

mov ar.pfs = r11
br.ret.sptk.many rp;;       // return to caller
END(fgettimeofday)
</pre></div>
</div>
<p>– end fgettimeofday.S –</p>
<p>In reality, getting the gate address is accomplished by two extra
values passed via the ELF auxiliary vector (include/asm-ia64/elf.h)</p>
<blockquote>
<div><ul class="simple">
<li>AT_SYSINFO : is the address of __kernel_syscall_via_epc()</li>
<li>AT_SYSINFO_EHDR : is the address of the kernel gate ELF DSO</li>
</ul>
</div></blockquote>
<p>The ELF DSO is a pre-linked library that is mapped in by the kernel at
the gate page.  It is a proper ELF shared object so, with a dynamic
loader that recognises the library, you should be able to make calls to
the exported functions within it as with any other shared library.
AT_SYSINFO points into the kernel DSO at the
__kernel_syscall_via_epc() function for historical reasons (it was
used before the kernel DSO) and as a convenience.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>