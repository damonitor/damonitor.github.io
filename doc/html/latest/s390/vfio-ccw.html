

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>vfio-ccw: the basic infrastructure &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The s390 SCSI dump tool (zfcpdump)" href="zfcpdump.html" />
    <link rel="prev" title="Adjunct Processor (AP) facility" href="vfio-ap.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mic/index.html">Intel Many Integrated Core (MIC) architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">s390 Architecture</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="cds.html">Linux for S/390 and zSeries</a></li>
<li class="toctree-l2"><a class="reference internal" href="3270.html">IBM 3270 Display System support</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver-model.html">S/390 driver model interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="monreader.html">Linux API for read access to z/VM Monitor Records</a></li>
<li class="toctree-l2"><a class="reference internal" href="qeth.html">IBM s390 QDIO Ethernet Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390dbf.html">S390 Debug Feature</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-ap.html">Adjunct Processor (AP) facility</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">vfio-ccw: the basic infrastructure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#motivation-of-vfio-ccw">Motivation of vfio-ccw</a></li>
<li class="toctree-l3"><a class="reference internal" href="#access-patterns-of-ccw-devices">Access patterns of CCW devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#physical-vfio-ccw-device-and-its-child-mdev">Physical vfio ccw device and its child mdev</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vfio-ccw-regions">VFIO-CCW Regions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vfio-ccw-i-o-region">vfio-ccw I/O region</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vfio-ccw-cmd-region">vfio-ccw cmd region</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vfio-ccw-operation-details">vfio-ccw operation details</a></li>
<li class="toctree-l3"><a class="reference internal" href="#limitations">Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="zfcpdump.html">The s390 SCSI dump tool (zfcpdump)</a></li>
<li class="toctree-l2"><a class="reference internal" href="common_io.html">S/390 common I/O-Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="text_files.html">ibm 3270 changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="text_files.html#ibm-3270-config3270-sh">ibm 3270 config3270.sh</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">s390 Architecture</a> &raquo;</li>
        
      <li>vfio-ccw: the basic infrastructure</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/s390/vfio-ccw.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vfio-ccw-the-basic-infrastructure">
<h1>vfio-ccw: the basic infrastructure<a class="headerlink" href="#vfio-ccw-the-basic-infrastructure" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Here we describe the vfio support for I/O subchannel devices for
Linux/s390. Motivation for vfio-ccw is to passthrough subchannels to a
virtual machine, while vfio is the means.</p>
<p>Different than other hardware architectures, s390 has defined a unified
I/O access method, which is so called Channel I/O. It has its own access
patterns:</p>
<ul class="simple">
<li>Channel programs run asynchronously on a separate (co)processor.</li>
<li>The channel subsystem will access any memory designated by the caller
in the channel program directly, i.e. there is no iommu involved.</li>
</ul>
<p>Thus when we introduce vfio support for these devices, we realize it
with a mediated device (mdev) implementation. The vfio mdev will be
added to an iommu group, so as to make itself able to be managed by the
vfio framework. And we add read/write callbacks for special vfio I/O
regions to pass the channel programs from the mdev to its parent device
(the real I/O subchannel device) to do further address translation and
to perform I/O instructions.</p>
<p>This document does not intend to explain the s390 I/O architecture in
every detail. More information/reference could be found here:</p>
<ul class="simple">
<li>A good start to know Channel I/O in general:
<a class="reference external" href="https://en.wikipedia.org/wiki/Channel_I/O">https://en.wikipedia.org/wiki/Channel_I/O</a></li>
<li>s390 architecture:
s390 Principles of Operation manual (IBM Form. No. SA22-7832)</li>
<li>The existing QEMU code which implements a simple emulated channel
subsystem could also be a good reference. It makes it easier to follow
the flow.
qemu/hw/s390x/css.c</li>
</ul>
<p>For vfio mediated device framework:
- Documentation/driver-api/vfio-mediated-device.rst</p>
</div>
<div class="section" id="motivation-of-vfio-ccw">
<h2>Motivation of vfio-ccw<a class="headerlink" href="#motivation-of-vfio-ccw" title="Permalink to this headline">¶</a></h2>
<p>Typically, a guest virtualized via QEMU/KVM on s390 only sees
paravirtualized virtio devices via the “Virtio Over Channel I/O
(virtio-ccw)” transport. This makes virtio devices discoverable via
standard operating system algorithms for handling channel devices.</p>
<p>However this is not enough. On s390 for the majority of devices, which
use the standard Channel I/O based mechanism, we also need to provide
the functionality of passing through them to a QEMU virtual machine.
This includes devices that don’t have a virtio counterpart (e.g. tape
drives) or that have specific characteristics which guests want to
exploit.</p>
<p>For passing a device to a guest, we want to use the same interface as
everybody else, namely vfio. We implement this vfio support for channel
devices via the vfio mediated device framework and the subchannel device
driver “vfio_ccw”.</p>
</div>
<div class="section" id="access-patterns-of-ccw-devices">
<h2>Access patterns of CCW devices<a class="headerlink" href="#access-patterns-of-ccw-devices" title="Permalink to this headline">¶</a></h2>
<p>s390 architecture has implemented a so called channel subsystem, that
provides a unified view of the devices physically attached to the
systems. Though the s390 hardware platform knows about a huge variety of
different peripheral attachments like disk devices (aka. DASDs), tapes,
communication controllers, etc. They can all be accessed by a well
defined access method and they are presenting I/O completion a unified
way: I/O interruptions.</p>
<p>All I/O requires the use of channel command words (CCWs). A CCW is an
instruction to a specialized I/O channel processor. A channel program is
a sequence of CCWs which are executed by the I/O channel subsystem.  To
issue a channel program to the channel subsystem, it is required to
build an operation request block (ORB), which can be used to point out
the format of the CCW and other control information to the system. The
operating system signals the I/O channel subsystem to begin executing
the channel program with a SSCH (start sub-channel) instruction. The
central processor is then free to proceed with non-I/O instructions
until interrupted. The I/O completion result is received by the
interrupt handler in the form of interrupt response block (IRB).</p>
<p>Back to vfio-ccw, in short:</p>
<ul class="simple">
<li>ORBs and channel programs are built in guest kernel (with guest
physical addresses).</li>
<li>ORBs and channel programs are passed to the host kernel.</li>
<li>Host kernel translates the guest physical addresses to real addresses
and starts the I/O with issuing a privileged Channel I/O instruction
(e.g SSCH).</li>
<li>channel programs run asynchronously on a separate processor.</li>
<li>I/O completion will be signaled to the host with I/O interruptions.
And it will be copied as IRB to user space to pass it back to the
guest.</li>
</ul>
</div>
<div class="section" id="physical-vfio-ccw-device-and-its-child-mdev">
<h2>Physical vfio ccw device and its child mdev<a class="headerlink" href="#physical-vfio-ccw-device-and-its-child-mdev" title="Permalink to this headline">¶</a></h2>
<p>As mentioned above, we realize vfio-ccw with a mdev implementation.</p>
<p>Channel I/O does not have IOMMU hardware support, so the physical
vfio-ccw device does not have an IOMMU level translation or isolation.</p>
<p>Subchannel I/O instructions are all privileged instructions. When
handling the I/O instruction interception, vfio-ccw has the software
policing and translation how the channel program is programmed before
it gets sent to hardware.</p>
<p>Within this implementation, we have two drivers for two types of
devices:</p>
<ul class="simple">
<li>The vfio_ccw driver for the physical subchannel device.
This is an I/O subchannel driver for the real subchannel device.  It
realizes a group of callbacks and registers to the mdev framework as a
parent (physical) device. As a consequence, mdev provides vfio_ccw a
generic interface (sysfs) to create mdev devices. A vfio mdev could be
created by vfio_ccw then and added to the mediated bus. It is the vfio
device that added to an IOMMU group and a vfio group.
vfio_ccw also provides an I/O region to accept channel program
request from user space and store I/O interrupt result for user
space to retrieve. To notify user space an I/O completion, it offers
an interface to setup an eventfd fd for asynchronous signaling.</li>
<li>The vfio_mdev driver for the mediated vfio ccw device.
This is provided by the mdev framework. It is a vfio device driver for
the mdev that created by vfio_ccw.
It realizes a group of vfio device driver callbacks, adds itself to a
vfio group, and registers itself to the mdev framework as a mdev
driver.
It uses a vfio iommu backend that uses the existing map and unmap
ioctls, but rather than programming them into an IOMMU for a device,
it simply stores the translations for use by later requests. This
means that a device programmed in a VM with guest physical addresses
can have the vfio kernel convert that address to process virtual
address, pin the page and program the hardware with the host physical
address in one step.
For a mdev, the vfio iommu backend will not pin the pages during the
VFIO_IOMMU_MAP_DMA ioctl. Mdev framework will only maintain a database
of the iova&lt;-&gt;vaddr mappings in this operation. And they export a
vfio_pin_pages and a vfio_unpin_pages interfaces from the vfio iommu
backend for the physical devices to pin and unpin pages by demand.</li>
</ul>
<p>Below is a high Level block diagram:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-------------+
|             |
| +---------+ | mdev_register_driver() +--------------+
| |  Mdev   | +&lt;-----------------------+              |
| |  bus    | |                        | vfio_mdev.ko |
| | driver  | +-----------------------&gt;+              |&lt;-&gt; VFIO user
| +---------+ |    probe()/remove()    +--------------+    APIs
|             |
|  MDEV CORE  |
|   MODULE    |
|   mdev.ko   |
| +---------+ | mdev_register_device() +--------------+
| |Physical | +&lt;-----------------------+              |
| | device  | |                        |  vfio_ccw.ko |&lt;-&gt; subchannel
| |interface| +-----------------------&gt;+              |     device
| +---------+ |       callback         +--------------+
+-------------+
</pre></div>
</div>
<p>The process of how these work together.</p>
<ol class="arabic simple">
<li>vfio_ccw.ko drives the physical I/O subchannel, and registers the
physical device (with callbacks) to mdev framework.
When vfio_ccw probing the subchannel device, it registers device
pointer and callbacks to the mdev framework. Mdev related file nodes
under the device node in sysfs would be created for the subchannel
device, namely ‘mdev_create’, ‘mdev_destroy’ and
‘mdev_supported_types’.</li>
<li>Create a mediated vfio ccw device.
Use the ‘mdev_create’ sysfs file, we need to manually create one (and
only one for our case) mediated device.</li>
<li>vfio_mdev.ko drives the mediated ccw device.
vfio_mdev is also the vfio device drvier. It will probe the mdev and
add it to an iommu_group and a vfio_group. Then we could pass through
the mdev to a guest.</li>
</ol>
</div>
<div class="section" id="vfio-ccw-regions">
<h2>VFIO-CCW Regions<a class="headerlink" href="#vfio-ccw-regions" title="Permalink to this headline">¶</a></h2>
<p>The vfio-ccw driver exposes MMIO regions to accept requests from and return
results to userspace.</p>
</div>
<div class="section" id="vfio-ccw-i-o-region">
<h2>vfio-ccw I/O region<a class="headerlink" href="#vfio-ccw-i-o-region" title="Permalink to this headline">¶</a></h2>
<p>An I/O region is used to accept channel program request from user
space and store I/O interrupt result for user space to retrieve. The
definition of the region is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ccw_io_region {
#define ORB_AREA_SIZE 12
        __u8    orb_area[ORB_AREA_SIZE];
#define SCSW_AREA_SIZE 12
        __u8    scsw_area[SCSW_AREA_SIZE];
#define IRB_AREA_SIZE 96
        __u8    irb_area[IRB_AREA_SIZE];
        __u32   ret_code;
} __packed;
</pre></div>
</div>
<p>While starting an I/O request, orb_area should be filled with the
guest ORB, and scsw_area should be filled with the SCSW of the Virtual
Subchannel.</p>
<p>irb_area stores the I/O result.</p>
<p>ret_code stores a return code for each access of the region.</p>
<p>This region is always available.</p>
</div>
<div class="section" id="vfio-ccw-cmd-region">
<h2>vfio-ccw cmd region<a class="headerlink" href="#vfio-ccw-cmd-region" title="Permalink to this headline">¶</a></h2>
<p>The vfio-ccw cmd region is used to accept asynchronous instructions
from userspace:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define VFIO_CCW_ASYNC_CMD_HSCH (1 &lt;&lt; 0)
#define VFIO_CCW_ASYNC_CMD_CSCH (1 &lt;&lt; 1)
struct ccw_cmd_region {
       __u32 command;
       __u32 ret_code;
} __packed;
</pre></div>
</div>
<p>This region is exposed via region type VFIO_REGION_SUBTYPE_CCW_ASYNC_CMD.</p>
<p>Currently, CLEAR SUBCHANNEL and HALT SUBCHANNEL use this region.</p>
</div>
<div class="section" id="vfio-ccw-operation-details">
<h2>vfio-ccw operation details<a class="headerlink" href="#vfio-ccw-operation-details" title="Permalink to this headline">¶</a></h2>
<p>vfio-ccw follows what vfio-pci did on the s390 platform and uses
vfio-iommu-type1 as the vfio iommu backend.</p>
<ul>
<li><p class="first">CCW translation APIs
A group of APIs (start with <cite>cp_</cite>) to do CCW translation. The CCWs
passed in by a user space program are organized with their guest
physical memory addresses. These APIs will copy the CCWs into kernel
space, and assemble a runnable kernel channel program by updating the
guest physical addresses with their corresponding host physical addresses.
Note that we have to use IDALs even for direct-access CCWs, as the
referenced memory can be located anywhere, including above 2G.</p>
</li>
<li><p class="first">vfio_ccw device driver
This driver utilizes the CCW translation APIs and introduces
vfio_ccw, which is the driver for the I/O subchannel devices you want
to pass through.
vfio_ccw implements the following vfio ioctls:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VFIO_DEVICE_GET_INFO
VFIO_DEVICE_GET_IRQ_INFO
VFIO_DEVICE_GET_REGION_INFO
VFIO_DEVICE_RESET
VFIO_DEVICE_SET_IRQS
</pre></div>
</div>
<p>This provides an I/O region, so that the user space program can pass a
channel program to the kernel, to do further CCW translation before
issuing them to a real device.
This also provides the SET_IRQ ioctl to setup an event notifier to
notify the user space program the I/O completion in an asynchronous
way.</p>
</li>
</ul>
<p>The use of vfio-ccw is not limited to QEMU, while QEMU is definitely a
good example to get understand how these patches work. Here is a little
bit more detail how an I/O request triggered by the QEMU guest will be
handled (without error handling).</p>
<p>Explanation:</p>
<ul class="simple">
<li>Q1-Q7: QEMU side process.</li>
<li>K1-K5: Kernel side process.</li>
</ul>
<dl class="docutils">
<dt>Q1.</dt>
<dd>Get I/O region info during initialization.</dd>
<dt>Q2.</dt>
<dd>Setup event notifier and handler to handle I/O completion.</dd>
</dl>
<p>… …</p>
<dl class="docutils">
<dt>Q3.</dt>
<dd>Intercept a ssch instruction.</dd>
<dt>Q4.</dt>
<dd><p class="first">Write the guest channel program and ORB to the I/O region.</p>
<dl class="last docutils">
<dt>K1.</dt>
<dd>Copy from guest to kernel.</dd>
<dt>K2.</dt>
<dd>Translate the guest channel program to a host kernel space
channel program, which becomes runnable for a real device.</dd>
<dt>K3.</dt>
<dd>With the necessary information contained in the orb passed in
by QEMU, issue the ccwchain to the device.</dd>
<dt>K4.</dt>
<dd>Return the ssch CC code.</dd>
</dl>
</dd>
<dt>Q5.</dt>
<dd>Return the CC code to the guest.</dd>
</dl>
<p>… …</p>
<blockquote>
<div><dl class="docutils">
<dt>K5.</dt>
<dd>Interrupt handler gets the I/O result and write the result to
the I/O region.</dd>
<dt>K6.</dt>
<dd>Signal QEMU to retrieve the result.</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Q6.</dt>
<dd>Get the signal and event handler reads out the result from the I/O
region.</dd>
<dt>Q7.</dt>
<dd>Update the irb for the guest.</dd>
</dl>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>The current vfio-ccw implementation focuses on supporting basic commands
needed to implement block device functionality (read/write) of DASD/ECKD
device only. Some commands may need special handling in the future, for
example, anything related to path grouping.</p>
<p>DASD is a kind of storage device. While ECKD is a data recording format.
More information for DASD and ECKD could be found here:
<a class="reference external" href="https://en.wikipedia.org/wiki/Direct-access_storage_device">https://en.wikipedia.org/wiki/Direct-access_storage_device</a>
<a class="reference external" href="https://en.wikipedia.org/wiki/Count_key_data">https://en.wikipedia.org/wiki/Count_key_data</a></p>
<p>Together with the corresponding work in QEMU, we can bring the passed
through DASD/ECKD device online in a guest now and use it as a block
device.</p>
<p>The current code allows the guest to start channel programs via
START SUBCHANNEL, and to issue HALT SUBCHANNEL and CLEAR SUBCHANNEL.</p>
<p>vfio-ccw supports classic (command mode) channel I/O only. Transport
mode (HPF) is not supported.</p>
<p>QDIO subchannels are currently not supported. Classic devices other than
DASD/ECKD might work, but have not been tested.</p>
</div>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>ESA/s390 Principles of Operation manual (IBM Form. No. SA22-7832)</li>
<li>ESA/390 Common I/O Device Commands manual (IBM Form. No. SA22-7204)</li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Channel_I/O">https://en.wikipedia.org/wiki/Channel_I/O</a></li>
<li>Documentation/s390/cds.rst</li>
<li>Documentation/driver-api/vfio.rst</li>
<li>Documentation/driver-api/vfio-mediated-device.rst</li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="zfcpdump.html" class="btn btn-neutral float-right" title="The s390 SCSI dump tool (zfcpdump)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="vfio-ap.html" class="btn btn-neutral float-left" title="Adjunct Processor (AP) facility" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>