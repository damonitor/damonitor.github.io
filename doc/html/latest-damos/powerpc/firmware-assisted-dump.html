

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Firmware-Assisted Dump &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Firmware-Assisted Dump</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/powerpc/firmware-assisted-dump.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="firmware-assisted-dump">
<h1>Firmware-Assisted Dump<a class="headerlink" href="#firmware-assisted-dump" title="Permalink to this headline">¶</a></h1>
<p>July 2011</p>
<p>The goal of firmware-assisted dump is to enable the dump of
a crashed system, and to do so from a fully-reset system, and
to minimize the total elapsed time until the system is back
in production use.</p>
<ul class="simple">
<li>Firmware-Assisted Dump (FADump) infrastructure is intended to replace
the existing phyp assisted dump.</li>
<li>Fadump uses the same firmware interfaces and memory reservation model
as phyp assisted dump.</li>
<li>Unlike phyp dump, FADump exports the memory dump through /proc/vmcore
in the ELF format in the same way as kdump. This helps us reuse the
kdump infrastructure for dump capture and filtering.</li>
<li>Unlike phyp dump, userspace tool does not need to refer any sysfs
interface while reading /proc/vmcore.</li>
<li>Unlike phyp dump, FADump allows user to release all the memory reserved
for dump, with a single operation of echo 1 &gt; /sys/kernel/fadump_release_mem.</li>
<li>Once enabled through kernel boot parameter, FADump can be
started/stopped through /sys/kernel/fadump_registered interface (see
sysfs files section below) and can be easily integrated with kdump
service start/stop init scripts.</li>
</ul>
<p>Comparing with kdump or other strategies, firmware-assisted
dump offers several strong, practical advantages:</p>
<ul class="simple">
<li>Unlike kdump, the system has been reset, and loaded
with a fresh copy of the kernel.  In particular,
PCI and I/O devices have been reinitialized and are
in a clean, consistent state.</li>
<li>Once the dump is copied out, the memory that held the dump
is immediately available to the running kernel. And therefore,
unlike kdump, FADump doesn’t need a 2nd reboot to get back
the system to the production configuration.</li>
</ul>
<p>The above can only be accomplished by coordination with,
and assistance from the Power firmware. The procedure is
as follows:</p>
<ul>
<li><p class="first">The first kernel registers the sections of memory with the
Power firmware for dump preservation during OS initialization.
These registered sections of memory are reserved by the first
kernel during early boot.</p>
</li>
<li><p class="first">When system crashes, the Power firmware will copy the registered
low memory regions (boot memory) from source to destination area.
It will also save hardware PTE’s.</p>
<dl class="docutils">
<dt>NOTE:</dt>
<dd><p class="first last">The term ‘boot memory’ means size of the low memory chunk
that is required for a kernel to boot successfully when
booted with restricted memory. By default, the boot memory
size will be the larger of 5% of system RAM or 256MB.
Alternatively, user can also specify boot memory size
through boot parameter ‘crashkernel=’ which will override
the default calculated size. Use this option if default
boot memory size is not sufficient for second kernel to
boot successfully. For syntax of crashkernel= parameter,
refer to Documentation/admin-guide/kdump/kdump.rst. If any
offset is provided in crashkernel= parameter, it will be
ignored as FADump uses a predefined offset to reserve memory
for boot memory dump preservation in case of a crash.</p>
</dd>
</dl>
</li>
<li><p class="first">After the low memory (boot memory) area has been saved, the
firmware will reset PCI and other hardware state.  It will
<em>not</em> clear the RAM. It will then launch the bootloader, as
normal.</p>
</li>
<li><p class="first">The freshly booted kernel will notice that there is a new node
(rtas/ibm,kernel-dump on pSeries or ibm,opal/dump/mpipl-boot
on OPAL platform) in the device tree, indicating that
there is crash data available from a previous boot. During
the early boot OS will reserve rest of the memory above
boot memory size effectively booting with restricted memory
size. This will make sure that this kernel (also, referred
to as second kernel or capture kernel) will not touch any
of the dump memory area.</p>
</li>
<li><p class="first">User-space tools will read /proc/vmcore to obtain the contents
of memory, which holds the previous crashed kernel dump in ELF
format. The userspace tools may copy this info to disk, or
network, nas, san, iscsi, etc. as desired.</p>
</li>
<li><p class="first">Once the userspace tool is done saving dump, it will echo
‘1’ to /sys/kernel/fadump_release_mem to release the reserved
memory back to general use, except the memory required for
next firmware-assisted dump registration.</p>
<p>e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo 1 &gt; /sys/kernel/fadump_release_mem
</pre></div>
</div>
</li>
</ul>
<p>Please note that the firmware-assisted dump feature
is only available on POWER6 and above systems on pSeries
(PowerVM) platform and POWER9 and above systems with OP940
or later firmware versions on PowerNV (OPAL) platform.
Note that, OPAL firmware exports ibm,opal/dump node when
FADump is supported on PowerNV platform.</p>
<p>On OPAL based machines, system first boots into an intermittent
kernel (referred to as petitboot kernel) before booting into the
capture kernel. This kernel would have minimal kernel and/or
userspace support to process crash data. Such kernel needs to
preserve previously crash’ed kernel’s memory for the subsequent
capture kernel boot to process this crash data. Kernel config
option CONFIG_PRESERVE_FA_DUMP has to be enabled on such kernel
to ensure that crash data is preserved to process later.</p>
<dl class="docutils">
<dt>– On OPAL based machines (PowerNV), if the kernel is build with</dt>
<dd><p class="first">CONFIG_OPAL_CORE=y, OPAL memory at the time of crash is also
exported as /sys/firmware/opal/mpipl/core file. This procfs file is
helpful in debugging OPAL crashes with GDB. The kernel memory
used for exporting this procfs file can be released by echo’ing
‘1’ to /sys/firmware/opal/mpipl/release_core node.</p>
<dl class="last docutils">
<dt>e.g.</dt>
<dd># echo 1 &gt; /sys/firmware/opal/mpipl/release_core</dd>
</dl>
</dd>
</dl>
<div class="section" id="implementation-details">
<h2>Implementation details:<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>During boot, a check is made to see if firmware supports
this feature on that particular machine. If it does, then
we check to see if an active dump is waiting for us. If yes
then everything but boot memory size of RAM is reserved during
early boot (See Fig. 2). This area is released once we finish
collecting the dump from user land scripts (e.g. kdump scripts)
that are run. If there is dump data, then the
/sys/kernel/fadump_release_mem file is created, and the reserved
memory is held.</p>
<p>If there is no waiting dump data, then only the memory required to
hold CPU state, HPTE region, boot memory dump, FADump header and
elfcore header, is usually reserved at an offset greater than boot
memory size (see Fig. 1). This area is <em>not</em> released: this region
will be kept permanently reserved, so that it can act as a receptacle
for a copy of the boot memory content in addition to CPU state and
HPTE region, in the case a crash does occur.</p>
<p>Since this reserved memory area is used only after the system crash,
there is no point in blocking this significant chunk of memory from
production kernel. Hence, the implementation uses the Linux kernel’s
Contiguous Memory Allocator (CMA) for memory reservation if CMA is
configured for kernel. With CMA reservation this memory will be
available for applications to use it, while kernel is prevented from
using it. With this FADump will still be able to capture all of the
kernel memory and most of the user space memory except the user pages
that were present in CMA region:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>o Memory Reservation during first kernel

Low memory                                                 Top of memory
0    boot memory size   |&lt;--- Reserved dump area ---&gt;|       |
|           |           |    Permanent Reservation   |       |
V           V           |                            |       V
+-----------+-----/ /---+---+----+-------+-----+-----+----+--+
|           |           |///|////|  DUMP | HDR | ELF |////|  |
+-----------+-----/ /---+---+----+-------+-----+-----+----+--+
      |                   ^    ^     ^      ^           ^
      |                   |    |     |      |           |
      \                  CPU  HPTE   /      |           |
       ------------------------------       |           |
    Boot memory content gets transferred    |           |
    to reserved area by firmware at the     |           |
    time of crash.                          |           |
                                        FADump Header   |
                                         (meta area)    |
                                                        |
                                                        |
                    Metadata: This area holds a metadata struture whose
                    address is registered with f/w and retrieved in the
                    second kernel after crash, on platforms that support
                    tags (OPAL). Having such structure with info needed
                    to process the crashdump eases dump capture process.

                 Fig. 1


o Memory Reservation during second kernel after crash

Low memory                                              Top of memory
0      boot memory size                                      |
|           |&lt;------------ Crash preserved area ------------&gt;|
V           V           |&lt;--- Reserved dump area ---&gt;|       |
+-----------+-----/ /---+---+----+-------+-----+-----+----+--+
|           |           |///|////|  DUMP | HDR | ELF |////|  |
+-----------+-----/ /---+---+----+-------+-----+-----+----+--+
      |                                           |
      V                                           V
 Used by second                             /proc/vmcore
 kernel to boot

      +---+
      |///| -&gt; Regions (CPU, HPTE &amp; Metadata) marked like this in the above
      +---+    figures are not always present. For example, OPAL platform
               does not have CPU &amp; HPTE regions while Metadata region is
               not supported on pSeries currently.

                 Fig. 2
</pre></div>
</div>
<p>Currently the dump will be copied from /proc/vmcore to a new file upon
user intervention. The dump data available through /proc/vmcore will be
in ELF format. Hence the existing kdump infrastructure (kdump scripts)
to save the dump works fine with minor modifications. KDump scripts on
major Distro releases have already been modified to work seemlessly (no
user intervention in saving the dump) when FADump is used, instead of
KDump, as dump mechanism.</p>
<p>The tools to examine the dump will be same as the ones
used for kdump.</p>
</div>
<div class="section" id="how-to-enable-firmware-assisted-dump-fadump">
<h2>How to enable firmware-assisted dump (FADump):<a class="headerlink" href="#how-to-enable-firmware-assisted-dump-fadump" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Set config option CONFIG_FA_DUMP=y and build kernel.</li>
<li>Boot into linux kernel with ‘fadump=on’ kernel cmdline option.
By default, FADump reserved memory will be initialized as CMA area.
Alternatively, user can boot linux kernel with ‘fadump=nocma’ to
prevent FADump to use CMA.</li>
<li>Optionally, user can also set ‘crashkernel=’ kernel cmdline
to specify size of the memory to reserve for boot memory dump
preservation.</li>
</ol>
<dl class="docutils">
<dt>NOTE:</dt>
<dd><ol class="first last arabic simple">
<li>‘fadump_reserve_mem=’ parameter has been deprecated. Instead
use ‘crashkernel=’ to specify size of the memory to reserve
for boot memory dump preservation.</li>
<li>If firmware-assisted dump fails to reserve memory then it
will fallback to existing kdump mechanism if ‘crashkernel=’
option is set at kernel cmdline.</li>
<li>if user wants to capture all of user space memory and ok with
reserved memory not available to production system, then
‘fadump=nocma’ kernel parameter can be used to fallback to
old behaviour.</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="sysfs-debugfs-files">
<h2>Sysfs/debugfs files:<a class="headerlink" href="#sysfs-debugfs-files" title="Permalink to this headline">¶</a></h2>
<p>Firmware-assisted dump feature uses sysfs file system to hold
the control files and debugfs file to display memory reserved region.</p>
<p>Here is the list of files under kernel sysfs:</p>
<blockquote>
<div><dl class="docutils">
<dt>/sys/kernel/fadump_enabled</dt>
<dd><p class="first">This is used to display the FADump status.</p>
<ul class="simple">
<li>0 = FADump is disabled</li>
<li>1 = FADump is enabled</li>
</ul>
<p class="last">This interface can be used by kdump init scripts to identify if
FADump is enabled in the kernel and act accordingly.</p>
</dd>
<dt>/sys/kernel/fadump_registered</dt>
<dd><p class="first">This is used to display the FADump registration status as well
as to control (start/stop) the FADump registration.</p>
<ul class="simple">
<li>0 = FADump is not registered.</li>
<li>1 = FADump is registered and ready to handle system crash.</li>
</ul>
<p class="last">To register FADump echo 1 &gt; /sys/kernel/fadump_registered and
echo 0 &gt; /sys/kernel/fadump_registered for un-register and stop the
FADump. Once the FADump is un-registered, the system crash will not
be handled and vmcore will not be captured. This interface can be
easily integrated with kdump service start/stop.</p>
</dd>
</dl>
<p>/sys/kernel/fadump/mem_reserved</p>
<blockquote>
<div>This is used to display the memory reserved by FADump for saving the
crash dump.</div></blockquote>
<dl class="docutils">
<dt>/sys/kernel/fadump_release_mem</dt>
<dd><p class="first">This file is available only when FADump is active during
second kernel. This is used to release the reserved memory
region that are held for saving crash dump. To release the
reserved memory echo 1 to it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 1  &gt; /sys/kernel/fadump_release_mem
</pre></div>
</div>
<p>After echo 1, the content of the /sys/kernel/debug/powerpc/fadump_region
file will change to reflect the new memory reservations.</p>
<p class="last">The existing userspace tools (kdump infrastructure) can be easily
enhanced to use this interface to release the memory reserved for
dump and continue without 2nd reboot.</p>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Note: /sys/kernel/fadump_release_opalcore sysfs has moved to</dt>
<dd><blockquote class="first">
<div>/sys/firmware/opal/mpipl/release_core</div></blockquote>
<p>/sys/firmware/opal/mpipl/release_core</p>
<blockquote class="last">
<div><p>This file is available only on OPAL based machines when FADump is
active during capture kernel. This is used to release the memory
used by the kernel to export /sys/firmware/opal/mpipl/core file. To
release this memory, echo ‘1’ to it:</p>
<p>echo 1  &gt; /sys/firmware/opal/mpipl/release_core</p>
</div></blockquote>
</dd>
</dl>
<p>Note: The following FADump sysfs files are deprecated.</p>
<table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="48%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Deprecated</td>
<td>Alternative</td>
</tr>
<tr class="row-even"><td>/sys/kernel/fadump_enabled</td>
<td>/sys/kernel/fadump/enabled</td>
</tr>
<tr class="row-odd"><td>/sys/kernel/fadump_registered</td>
<td>/sys/kernel/fadump/registered</td>
</tr>
<tr class="row-even"><td>/sys/kernel/fadump_release_mem</td>
<td>/sys/kernel/fadump/release_mem</td>
</tr>
</tbody>
</table>
<p>Here is the list of files under powerpc debugfs:
(Assuming debugfs is mounted on /sys/kernel/debug directory.)</p>
<blockquote>
<div><dl class="docutils">
<dt>/sys/kernel/debug/powerpc/fadump_region</dt>
<dd><p class="first">This file shows the reserved memory regions if FADump is
enabled otherwise this file is empty. The output format
is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;region&gt;: [&lt;start&gt;-&lt;end&gt;] &lt;reserved-size&gt; bytes, Dumped: &lt;dump-size&gt;
</pre></div>
</div>
<p>and for kernel DUMP region is:</p>
<p>DUMP: Src: &lt;src-addr&gt;, Dest: &lt;dest-addr&gt;, Size: &lt;size&gt;, Dumped: # bytes</p>
<p>e.g.
Contents when FADump is registered during first kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /sys/kernel/debug/powerpc/fadump_region
CPU : [0x0000006ffb0000-0x0000006fff001f] 0x40020 bytes, Dumped: 0x0
HPTE: [0x0000006fff0020-0x0000006fff101f] 0x1000 bytes, Dumped: 0x0
DUMP: [0x0000006fff1020-0x0000007fff101f] 0x10000000 bytes, Dumped: 0x0
</pre></div>
</div>
<p>Contents when FADump is active during second kernel:</p>
<div class="last highlight-none notranslate"><div class="highlight"><pre><span></span># cat /sys/kernel/debug/powerpc/fadump_region
CPU : [0x0000006ffb0000-0x0000006fff001f] 0x40020 bytes, Dumped: 0x40020
HPTE: [0x0000006fff0020-0x0000006fff101f] 0x1000 bytes, Dumped: 0x1000
DUMP: [0x0000006fff1020-0x0000007fff101f] 0x10000000 bytes, Dumped: 0x10000000
    : [0x00000010000000-0x0000006ffaffff] 0x5ffb0000 bytes, Dumped: 0x5ffb0000
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>NOTE:</dt>
<dd>Please refer to Documentation/filesystems/debugfs.txt on
how to mount the debugfs filesystem.</dd>
</dl>
</div>
<div class="section" id="todo">
<h2>TODO:<a class="headerlink" href="#todo" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul>
<li><p class="first">Need to come up with the better approach to find out more
accurate boot memory size that is required for a kernel to
boot successfully when booted with restricted memory.</p>
</li>
<li><p class="first">The FADump implementation introduces a FADump crash info structure
in the scratch area before the ELF core header. The idea of introducing
this structure is to pass some important crash info data to the second
kernel which will help second kernel to populate ELF core header with
correct data before it gets exported through /proc/vmcore. The current
design implementation does not address a possibility of introducing
additional fields (in future) to this structure without affecting
compatibility. Need to come up with the better approach to address this.</p>
<p>The possible approaches are:</p>
<blockquote>
<div><p>1. Introduce version field for version tracking, bump up the version
whenever a new field is added to the structure in future. The version
field can be used to find out what fields are valid for the current
version of the structure.
2. Reserve the area of predefined size (say PAGE_SIZE) for this
structure and have unused area as reserved (initialized to zero)
for future field additions.</p>
</div></blockquote>
<p>The advantage of approach 1 over 2 is we don’t need to reserve extra space.</p>
</li>
</ul>
</div></blockquote>
<p>Author: Mahesh Salgaonkar &lt;<a class="reference external" href="mailto:mahesh&#37;&#52;&#48;linux&#46;vnet&#46;ibm&#46;com">mahesh<span>&#64;</span>linux<span>&#46;</span>vnet<span>&#46;</span>ibm<span>&#46;</span>com</a>&gt;</p>
<p>This document is based on the original documentation written for phyp</p>
<p>assisted dump by Linas Vepstas and Manish Ahuja.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>