

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Shadow Variables &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Shadow Variables</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/livepatch/shadow-vars.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="shadow-variables">
<h1>Shadow Variables<a class="headerlink" href="#shadow-variables" title="Permalink to this headline">¶</a></h1>
<p>Shadow variables are a simple way for livepatch modules to associate
additional “shadow” data with existing data structures.  Shadow data is
allocated separately from parent data structures, which are left
unmodified.  The shadow variable API described in this document is used
to allocate/add and remove/free shadow variables to/from their parents.</p>
<p>The implementation introduces a global, in-kernel hashtable that
associates pointers to parent objects and a numeric identifier of the
shadow data.  The numeric identifier is a simple enumeration that may be
used to describe shadow variable version, class or type, etc.  More
specifically, the parent pointer serves as the hashtable key while the
numeric id subsequently filters hashtable queries.  Multiple shadow
variables may attach to the same parent object, but their numeric
identifier distinguishes between them.</p>
<div class="section" id="brief-api-summary">
<h2>1. Brief API summary<a class="headerlink" href="#brief-api-summary" title="Permalink to this headline">¶</a></h2>
<p>(See the full API usage docbook notes in livepatch/shadow.c.)</p>
<p>A hashtable references all shadow variables.  These references are
stored and retrieved through a &lt;obj, id&gt; pair.</p>
<ul class="simple">
<li>The klp_shadow variable data structure encapsulates both tracking
meta-data and shadow-data:<ul>
<li>meta-data<ul>
<li>obj - pointer to parent object</li>
<li>id - data identifier</li>
</ul>
</li>
<li>data[] - storage for shadow data</li>
</ul>
</li>
</ul>
<p>It is important to note that the klp_shadow_alloc() and
klp_shadow_get_or_alloc() are zeroing the variable by default.
They also allow to call a custom constructor function when a non-zero
value is needed. Callers should provide whatever mutual exclusion
is required.</p>
<p>Note that the constructor is called under klp_shadow_lock spinlock. It allows
to do actions that can be done only once when a new variable is allocated.</p>
<ul>
<li><p class="first">klp_shadow_get() - retrieve a shadow variable data pointer
- search hashtable for &lt;obj, id&gt; pair</p>
</li>
<li><p class="first">klp_shadow_alloc() - allocate and add a new shadow variable
- search hashtable for &lt;obj, id&gt; pair</p>
<ul class="simple">
<li>if exists<ul>
<li>WARN and return NULL</li>
</ul>
</li>
<li>if &lt;obj, id&gt; doesn’t already exist<ul>
<li>allocate a new shadow variable</li>
<li>initialize the variable using a custom constructor and data when provided</li>
<li>add &lt;obj, id&gt; to the global hashtable</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">klp_shadow_get_or_alloc() - get existing or alloc a new shadow variable
- search hashtable for &lt;obj, id&gt; pair</p>
<ul class="simple">
<li>if exists<ul>
<li>return existing shadow variable</li>
</ul>
</li>
<li>if &lt;obj, id&gt; doesn’t already exist<ul>
<li>allocate a new shadow variable</li>
<li>initialize the variable using a custom constructor and data when provided</li>
<li>add &lt;obj, id&gt; pair to the global hashtable</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">klp_shadow_free() - detach and free a &lt;obj, id&gt; shadow variable
- find and remove a &lt;obj, id&gt; reference from global hashtable</p>
<blockquote>
<div><ul class="simple">
<li>if found<ul>
<li>call destructor function if defined</li>
<li>free shadow variable</li>
</ul>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">klp_shadow_free_all() - detach and free all &lt;<em>, id&gt; shadow variables
- find and remove any &lt;</em>, id&gt; references from global hashtable</p>
<blockquote>
<div><ul class="simple">
<li>if found<ul>
<li>call destructor function if defined</li>
<li>free shadow variable</li>
</ul>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="use-cases">
<h2>2. Use cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h2>
<p>(See the example shadow variable livepatch modules in samples/livepatch/
for full working demonstrations.)</p>
<p>For the following use-case examples, consider commit 1d147bfa6429
(“mac80211: fix AP powersave TX vs.  wakeup race”), which added a
spinlock to net/mac80211/sta_info.h :: struct sta_info.  Each use-case
example can be considered a stand-alone livepatch implementation of this
fix.</p>
<div class="section" id="matching-parent-s-lifecycle">
<h3>Matching parent’s lifecycle<a class="headerlink" href="#matching-parent-s-lifecycle" title="Permalink to this headline">¶</a></h3>
<p>If parent data structures are frequently created and destroyed, it may
be easiest to align their shadow variables lifetimes to the same
allocation and release functions.  In this case, the parent data
structure is typically allocated, initialized, then registered in some
manner.  Shadow variable allocation and setup can then be considered
part of the parent’s initialization and should be completed before the
parent “goes live” (ie, any shadow variable get-API requests are made
for this &lt;obj, id&gt; pair.)</p>
<p>For commit 1d147bfa6429, when a parent sta_info structure is allocated,
allocate a shadow copy of the ps_lock pointer, then initialize it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define PS_LOCK 1
struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,
                                const u8 *addr, gfp_t gfp)
{
      struct sta_info *sta;
      spinlock_t *ps_lock;

      /* Parent structure is created */
      sta = kzalloc(sizeof(*sta) + hw-&gt;sta_data_size, gfp);

      /* Attach a corresponding shadow variable, then initialize it */
      ps_lock = klp_shadow_alloc(sta, PS_LOCK, sizeof(*ps_lock), gfp,
                                 NULL, NULL);
      if (!ps_lock)
              goto shadow_fail;
      spin_lock_init(ps_lock);
      ...
</pre></div>
</div>
<p>When requiring a ps_lock, query the shadow variable API to retrieve one
for a specific struct sta_info::</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)
{
      spinlock_t *ps_lock;

      /* sync with ieee80211_tx_h_unicast_ps_buf */
      ps_lock = klp_shadow_get(sta, PS_LOCK);
      if (ps_lock)
              spin_lock(ps_lock);
      ...
</pre></div>
</div>
<p>When the parent sta_info structure is freed, first free the shadow
variable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void sta_info_free(struct ieee80211_local *local, struct sta_info *sta)
{
      klp_shadow_free(sta, PS_LOCK, NULL);
      kfree(sta);
      ...
</pre></div>
</div>
</div>
<div class="section" id="in-flight-parent-objects">
<h3>In-flight parent objects<a class="headerlink" href="#in-flight-parent-objects" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it may not be convenient or possible to allocate shadow
variables alongside their parent objects.  Or a livepatch fix may
require shadow varibles to only a subset of parent object instances.  In
these cases, the klp_shadow_get_or_alloc() call can be used to attach
shadow variables to parents already in-flight.</p>
<p>For commit 1d147bfa6429, a good spot to allocate a shadow spinlock is
inside ieee80211_sta_ps_deliver_wakeup():</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int ps_lock_shadow_ctor(void *obj, void *shadow_data, void *ctor_data)
{
      spinlock_t *lock = shadow_data;

      spin_lock_init(lock);
      return 0;
}

#define PS_LOCK 1
void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)
{
      spinlock_t *ps_lock;

      /* sync with ieee80211_tx_h_unicast_ps_buf */
      ps_lock = klp_shadow_get_or_alloc(sta, PS_LOCK,
                      sizeof(*ps_lock), GFP_ATOMIC,
                      ps_lock_shadow_ctor, NULL);

      if (ps_lock)
              spin_lock(ps_lock);
      ...
</pre></div>
</div>
<p>This usage will create a shadow variable, only if needed, otherwise it
will use one that was already created for this &lt;obj, id&gt; pair.</p>
<p>Like the previous use-case, the shadow spinlock needs to be cleaned up.
A shadow variable can be freed just before its parent object is freed,
or even when the shadow variable itself is no longer required.</p>
</div>
<div class="section" id="other-use-cases">
<h3>Other use-cases<a class="headerlink" href="#other-use-cases" title="Permalink to this headline">¶</a></h3>
<p>Shadow variables can also be used as a flag indicating that a data
structure was allocated by new, livepatched code.  In this case, it
doesn’t matter what data value the shadow variable holds, its existence
suggests how to handle the parent object.</p>
</div>
</div>
<div class="section" id="references">
<h2>3. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first"><a class="reference external" href="https://github.com/dynup/kpatch">https://github.com/dynup/kpatch</a></p>
<p>The livepatch implementation is based on the kpatch version of shadow
variables.</p>
</li>
<li><p class="first"><a class="reference external" href="http://files.mkgnu.net/files/dynamos/doc/papers/dynamos_eurosys_07.pdf">http://files.mkgnu.net/files/dynamos/doc/papers/dynamos_eurosys_07.pdf</a></p>
<p>Dynamic and Adaptive Updates of Non-Quiescent Subsystems in Commodity
Operating System Kernels (Kritis Makris, Kyung Dong Ryu 2007) presented
a datatype update technique called “shadow data structures”.</p>
</li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>