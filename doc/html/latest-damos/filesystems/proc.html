

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The /proc Filesystem &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The /proc Filesystem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/proc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-proc-filesystem">
<h1>The /proc Filesystem<a class="headerlink" href="#the-proc-filesystem" title="Permalink to this headline">¶</a></h1>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="51%" />
<col width="21%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>/proc/sys</td>
<td>Terrehon Bowden &lt;<a class="reference external" href="mailto:terrehon&#37;&#52;&#48;pacbell&#46;net">terrehon<span>&#64;</span>pacbell<span>&#46;</span>net</a>&gt;,
Bodo Bauer &lt;<a class="reference external" href="mailto:bb&#37;&#52;&#48;ricochet&#46;net">bb<span>&#64;</span>ricochet<span>&#46;</span>net</a>&gt;</td>
<td>October 7 1999</td>
</tr>
<tr class="row-even"><td>2.4.x update</td>
<td>Jorge Nerin &lt;<a class="reference external" href="mailto:comandante&#37;&#52;&#48;zaralinux&#46;com">comandante<span>&#64;</span>zaralinux<span>&#46;</span>com</a>&gt;</td>
<td>November 14 2000</td>
</tr>
<tr class="row-odd"><td>move /proc/sys</td>
<td>Shen Feng &lt;<a class="reference external" href="mailto:shen&#37;&#52;&#48;cn&#46;fujitsu&#46;com">shen<span>&#64;</span>cn<span>&#46;</span>fujitsu<span>&#46;</span>com</a>&gt;</td>
<td>April 1 2009</td>
</tr>
<tr class="row-even"><td>fixes/update part 1.1</td>
<td>Stefani Seibold &lt;<a class="reference external" href="mailto:stefani&#37;&#52;&#48;seibold&#46;net">stefani<span>&#64;</span>seibold<span>&#46;</span>net</a>&gt;</td>
<td>June 9 2009</td>
</tr>
</tbody>
</table>
<div class="section" id="preface">
<h2>Preface<a class="headerlink" href="#preface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction-credits">
<h3>0.1 Introduction/Credits<a class="headerlink" href="#introduction-credits" title="Permalink to this headline">¶</a></h3>
<p>This documentation is  part of a soon (or  so we hope) to be  released book on
the SuSE  Linux distribution. As  there is  no complete documentation  for the
/proc file system and we’ve used  many freely available sources to write these
chapters, it  seems only fair  to give the work  back to the  Linux community.
This work is  based on the 2.2.*  kernel version and the  upcoming 2.4.*. I’m
afraid it’s still far from complete, but we  hope it will be useful. As far as
we know, it is the first ‘all-in-one’ document about the /proc file system. It
is focused  on the Intel  x86 hardware,  so if you  are looking for  PPC, ARM,
SPARC, AXP, etc., features, you probably  won’t find what you are looking for.
It also only covers IPv4 networking, not IPv6 nor other protocols - sorry. But
additions and patches  are welcome and will  be added to this  document if you
mail them to Bodo.</p>
<p>We’d like  to  thank Alan Cox, Rik van Riel, and Alexey Kuznetsov and a lot of
other people for help compiling this documentation. We’d also like to extend a
special thank  you to Andi Kleen for documentation, which we relied on heavily
to create  this  document,  as well as the additional information he provided.
Thanks to  everybody  else  who contributed source or docs to the Linux kernel
and helped create a great piece of software… :)</p>
<p>If you  have  any comments, corrections or additions, please don’t hesitate to
contact Bodo  Bauer  at  <a class="reference external" href="mailto:bb&#37;&#52;&#48;ricochet&#46;net">bb<span>&#64;</span>ricochet<span>&#46;</span>net</a>.  We’ll  be happy to add them to this
document.</p>
<p>The   latest   version    of   this   document   is    available   online   at
<a class="reference external" href="http://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html">http://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html</a></p>
<p>If  the above  direction does  not works  for you,  you could  try the  kernel
mailing  list  at  <a class="reference external" href="mailto:linux-kernel&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-kernel<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>  and/or try  to  reach  me  at
<a class="reference external" href="mailto:comandante&#37;&#52;&#48;zaralinux&#46;com">comandante<span>&#64;</span>zaralinux<span>&#46;</span>com</a>.</p>
</div>
<div class="section" id="legal-stuff">
<h3>0.2 Legal Stuff<a class="headerlink" href="#legal-stuff" title="Permalink to this headline">¶</a></h3>
<p>We don’t  guarantee  the  correctness  of this document, and if you come to us
complaining about  how  you  screwed  up  your  system  because  of  incorrect
documentation, we won’t feel responsible…</p>
</div>
</div>
<div class="section" id="chapter-1-collecting-system-information">
<h2>Chapter 1: Collecting System Information<a class="headerlink" href="#chapter-1-collecting-system-information" title="Permalink to this headline">¶</a></h2>
<div class="section" id="in-this-chapter">
<h3>In This Chapter<a class="headerlink" href="#in-this-chapter" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Investigating  the  properties  of  the  pseudo  file  system  /proc and its
ability to provide information on the running Linux system</li>
<li>Examining /proc’s structure</li>
<li>Uncovering  various  information  about the kernel and the processes running
on the system</li>
</ul>
<hr class="docutils" />
<p>The proc  file  system acts as an interface to internal data structures in the
kernel. It  can  be  used to obtain information about the system and to change
certain kernel parameters at runtime (sysctl).</p>
<p>First, we’ll  take  a  look  at the read-only parts of /proc. In Chapter 2, we
show you how you can use /proc/sys to change settings.</p>
</div>
<div class="section" id="process-specific-subdirectories">
<h3>1.1 Process-Specific Subdirectories<a class="headerlink" href="#process-specific-subdirectories" title="Permalink to this headline">¶</a></h3>
<p>The directory  /proc  contains  (among other things) one subdirectory for each
process running on the system, which is named after the process ID (PID).</p>
<p>The link  self  points  to  the  process reading the file system. Each process
subdirectory has the entries listed in Table 1-1.</p>
<p>Note that an open a file descriptor to /proc/&lt;pid&gt; or to any of its
contained files or subdirectories does not prevent &lt;pid&gt; being reused
for some other process in the event that &lt;pid&gt; exits. Operations on
open /proc/&lt;pid&gt; file descriptors corresponding to dead processes
never act on any new process that the kernel may, through chance, have
also assigned the process ID &lt;pid&gt;. Instead, operations on these FDs
usually fail with ESRCH.</p>
<table border="1" class="docutils" id="id7">
<caption><span class="caption-text">Table 1-1: Process specific entries in /proc</span><a class="headerlink" href="#id7" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>clear_refs</td>
<td>Clears page referenced bits shown in smaps output</td>
</tr>
<tr class="row-odd"><td>cmdline</td>
<td>Command line arguments</td>
</tr>
<tr class="row-even"><td>cpu</td>
<td>Current and last cpu in which it was executed   (2.4)(smp)</td>
</tr>
<tr class="row-odd"><td>cwd</td>
<td>Link to the current working directory</td>
</tr>
<tr class="row-even"><td>environ</td>
<td>Values of environment variables</td>
</tr>
<tr class="row-odd"><td>exe</td>
<td>Link to the executable of this process</td>
</tr>
<tr class="row-even"><td>fd</td>
<td>Directory, which contains all file descriptors</td>
</tr>
<tr class="row-odd"><td>maps</td>
<td>Memory maps to executables and library files    (2.4)</td>
</tr>
<tr class="row-even"><td>mem</td>
<td>Memory held by this process</td>
</tr>
<tr class="row-odd"><td>root</td>
<td>Link to the root directory of this process</td>
</tr>
<tr class="row-even"><td>stat</td>
<td>Process status</td>
</tr>
<tr class="row-odd"><td>statm</td>
<td>Process memory status information</td>
</tr>
<tr class="row-even"><td>status</td>
<td>Process status in human readable form</td>
</tr>
<tr class="row-odd"><td>wchan</td>
<td>Present with CONFIG_KALLSYMS=y: it shows the kernel function
symbol the task is blocked in - or “0” if not blocked.</td>
</tr>
<tr class="row-even"><td>pagemap</td>
<td>Page table</td>
</tr>
<tr class="row-odd"><td>stack</td>
<td>Report full stack trace, enable via CONFIG_STACKTRACE</td>
</tr>
<tr class="row-even"><td>smaps</td>
<td>An extension based on maps, showing the memory consumption of
each mapping and flags associated with it</td>
</tr>
<tr class="row-odd"><td>smaps_rollup</td>
<td>Accumulated smaps stats for all mappings of the process.  This
can be derived from smaps, but is faster and more convenient</td>
</tr>
<tr class="row-even"><td>numa_maps</td>
<td>An extension based on maps, showing the memory locality and
binding policy as well as mem usage (in pages) of each mapping.</td>
</tr>
</tbody>
</table>
<p>For example, to get the status information of a process, all you have to do is
read the file /proc/PID/status:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;cat /proc/self/status
Name:   cat
State:  R (running)
Tgid:   5452
Pid:    5452
PPid:   743
TracerPid:      0                                             (2.4)
Uid:    501     501     501     501
Gid:    100     100     100     100
FDSize: 256
Groups: 100 14 16
VmPeak:     5004 kB
VmSize:     5004 kB
VmLck:         0 kB
VmHWM:       476 kB
VmRSS:       476 kB
RssAnon:             352 kB
RssFile:             120 kB
RssShmem:              4 kB
VmData:      156 kB
VmStk:        88 kB
VmExe:        68 kB
VmLib:      1412 kB
VmPTE:        20 kb
VmSwap:        0 kB
HugetlbPages:          0 kB
CoreDumping:    0
THP_enabled:    1
Threads:        1
SigQ:   0/28578
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000000000
SigCgt: 0000000000000000
CapInh: 00000000fffffeff
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: ffffffffffffffff
CapAmb: 0000000000000000
NoNewPrivs:     0
Seccomp:        0
Speculation_Store_Bypass:       thread vulnerable
voluntary_ctxt_switches:        0
nonvoluntary_ctxt_switches:     1
</pre></div>
</div>
<p>This shows you nearly the same information you would get if you viewed it with
the ps  command.  In  fact,  ps  uses  the  proc  file  system  to  obtain its
information.  But you get a more detailed  view of the  process by reading the
file /proc/PID/status. It fields are described in table 1-2.</p>
<p>The  statm  file  contains  more  detailed  information about the process
memory usage. Its seven fields are explained in Table 1-3.  The stat file
contains details information about the process itself.  Its fields are
explained in Table 1-4.</p>
<p>(for SMP CONFIG users)</p>
<p>For making accounting scalable, RSS related information are handled in an
asynchronous manner and the value may not be very precise. To see a precise
snapshot of a moment, you can see /proc/&lt;pid&gt;/smaps file and scan page table.
It’s slow but very precise.</p>
<table border="1" class="docutils" id="id8">
<caption><span class="caption-text">Table 1-2: Contents of the status files (as of 4.19)</span><a class="headerlink" href="#id8" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Name</td>
<td>filename of the executable</td>
</tr>
<tr class="row-odd"><td>Umask</td>
<td>file mode creation mask</td>
</tr>
<tr class="row-even"><td>State</td>
<td>state (R is running, S is sleeping, D is sleeping
in an uninterruptible wait, Z is zombie,
T is traced or stopped)</td>
</tr>
<tr class="row-odd"><td>Tgid</td>
<td>thread group ID</td>
</tr>
<tr class="row-even"><td>Ngid</td>
<td>NUMA group ID (0 if none)</td>
</tr>
<tr class="row-odd"><td>Pid</td>
<td>process id</td>
</tr>
<tr class="row-even"><td>PPid</td>
<td>process id of the parent process</td>
</tr>
<tr class="row-odd"><td>TracerPid</td>
<td>PID of process tracing this process (0 if not)</td>
</tr>
<tr class="row-even"><td>Uid</td>
<td>Real, effective, saved set, and  file system UIDs</td>
</tr>
<tr class="row-odd"><td>Gid</td>
<td>Real, effective, saved set, and  file system GIDs</td>
</tr>
<tr class="row-even"><td>FDSize</td>
<td>number of file descriptor slots currently allocated</td>
</tr>
<tr class="row-odd"><td>Groups</td>
<td>supplementary group list</td>
</tr>
<tr class="row-even"><td>NStgid</td>
<td>descendant namespace thread group ID hierarchy</td>
</tr>
<tr class="row-odd"><td>NSpid</td>
<td>descendant namespace process ID hierarchy</td>
</tr>
<tr class="row-even"><td>NSpgid</td>
<td>descendant namespace process group ID hierarchy</td>
</tr>
<tr class="row-odd"><td>NSsid</td>
<td>descendant namespace session ID hierarchy</td>
</tr>
<tr class="row-even"><td>VmPeak</td>
<td>peak virtual memory size</td>
</tr>
<tr class="row-odd"><td>VmSize</td>
<td>total program size</td>
</tr>
<tr class="row-even"><td>VmLck</td>
<td>locked memory size</td>
</tr>
<tr class="row-odd"><td>VmPin</td>
<td>pinned memory size</td>
</tr>
<tr class="row-even"><td>VmHWM</td>
<td>peak resident set size (“high water mark”)</td>
</tr>
<tr class="row-odd"><td>VmRSS</td>
<td>size of memory portions. It contains the three
following parts
(VmRSS = RssAnon + RssFile + RssShmem)</td>
</tr>
<tr class="row-even"><td>RssAnon</td>
<td>size of resident anonymous memory</td>
</tr>
<tr class="row-odd"><td>RssFile</td>
<td>size of resident file mappings</td>
</tr>
<tr class="row-even"><td>RssShmem</td>
<td>size of resident shmem memory (includes SysV shm,
mapping of tmpfs and shared anonymous mappings)</td>
</tr>
<tr class="row-odd"><td>VmData</td>
<td>size of private data segments</td>
</tr>
<tr class="row-even"><td>VmStk</td>
<td>size of stack segments</td>
</tr>
<tr class="row-odd"><td>VmExe</td>
<td>size of text segment</td>
</tr>
<tr class="row-even"><td>VmLib</td>
<td>size of shared library code</td>
</tr>
<tr class="row-odd"><td>VmPTE</td>
<td>size of page table entries</td>
</tr>
<tr class="row-even"><td>VmSwap</td>
<td>amount of swap used by anonymous private data
(shmem swap usage is not included)</td>
</tr>
<tr class="row-odd"><td>HugetlbPages</td>
<td>size of hugetlb memory portions</td>
</tr>
<tr class="row-even"><td>CoreDumping</td>
<td>process’s memory is currently being dumped
(killing the process may lead to a corrupted core)</td>
</tr>
<tr class="row-odd"><td>THP_enabled</td>
<td>process is allowed to use THP (returns 0 when
PR_SET_THP_DISABLE is set on the process</td>
</tr>
<tr class="row-even"><td>Threads</td>
<td>number of threads</td>
</tr>
<tr class="row-odd"><td>SigQ</td>
<td>number of signals queued/max. number for queue</td>
</tr>
<tr class="row-even"><td>SigPnd</td>
<td>bitmap of pending signals for the thread</td>
</tr>
<tr class="row-odd"><td>ShdPnd</td>
<td>bitmap of shared pending signals for the process</td>
</tr>
<tr class="row-even"><td>SigBlk</td>
<td>bitmap of blocked signals</td>
</tr>
<tr class="row-odd"><td>SigIgn</td>
<td>bitmap of ignored signals</td>
</tr>
<tr class="row-even"><td>SigCgt</td>
<td>bitmap of caught signals</td>
</tr>
<tr class="row-odd"><td>CapInh</td>
<td>bitmap of inheritable capabilities</td>
</tr>
<tr class="row-even"><td>CapPrm</td>
<td>bitmap of permitted capabilities</td>
</tr>
<tr class="row-odd"><td>CapEff</td>
<td>bitmap of effective capabilities</td>
</tr>
<tr class="row-even"><td>CapBnd</td>
<td>bitmap of capabilities bounding set</td>
</tr>
<tr class="row-odd"><td>CapAmb</td>
<td>bitmap of ambient capabilities</td>
</tr>
<tr class="row-even"><td>NoNewPrivs</td>
<td>no_new_privs, like prctl(PR_GET_NO_NEW_PRIV, …)</td>
</tr>
<tr class="row-odd"><td>Seccomp</td>
<td>seccomp mode, like prctl(PR_GET_SECCOMP, …)</td>
</tr>
<tr class="row-even"><td>Speculation_Store_Bypass</td>
<td>speculative store bypass mitigation status</td>
</tr>
<tr class="row-odd"><td>Cpus_allowed</td>
<td>mask of CPUs on which this process may run</td>
</tr>
<tr class="row-even"><td>Cpus_allowed_list</td>
<td>Same as previous, but in “list format”</td>
</tr>
<tr class="row-odd"><td>Mems_allowed</td>
<td>mask of memory nodes allowed to this process</td>
</tr>
<tr class="row-even"><td>Mems_allowed_list</td>
<td>Same as previous, but in “list format”</td>
</tr>
<tr class="row-odd"><td>voluntary_ctxt_switches</td>
<td>number of voluntary context switches</td>
</tr>
<tr class="row-even"><td>nonvoluntary_ctxt_switches</td>
<td>number of non voluntary context switches</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id9">
<caption><span class="caption-text">Table 1-3: Contents of the statm files (as of 2.6.8-rc3)</span><a class="headerlink" href="#id9" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="12%" />
<col width="45%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Content</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>size</td>
<td>total program size (pages)</td>
<td>(same as VmSize in status)</td>
</tr>
<tr class="row-odd"><td>resident</td>
<td>size of memory portions (pages)</td>
<td>(same as VmRSS in status)</td>
</tr>
<tr class="row-even"><td>shared</td>
<td>number of pages that are shared</td>
<td>(i.e. backed by a file, same
as RssFile+RssShmem in status)</td>
</tr>
<tr class="row-odd"><td>trs</td>
<td>number of pages that are ‘code’</td>
<td>(not including libs; broken,
includes data segment)</td>
</tr>
<tr class="row-even"><td>lrs</td>
<td>number of pages of library</td>
<td>(always 0 on 2.6)</td>
</tr>
<tr class="row-odd"><td>drs</td>
<td>number of pages of data/stack</td>
<td>(including libs; broken,
includes library text)</td>
</tr>
<tr class="row-even"><td>dt</td>
<td>number of dirty pages</td>
<td>(always 0 on 2.6)</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id10">
<caption><span class="caption-text">Table 1-4: Contents of the stat files (as of 2.6.30-rc7)</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>pid</td>
<td>process id</td>
</tr>
<tr class="row-odd"><td>tcomm</td>
<td>filename of the executable</td>
</tr>
<tr class="row-even"><td>state</td>
<td>state (R is running, S is sleeping, D is sleeping in an
uninterruptible wait, Z is zombie, T is traced or stopped)</td>
</tr>
<tr class="row-odd"><td>ppid</td>
<td>process id of the parent process</td>
</tr>
<tr class="row-even"><td>pgrp</td>
<td>pgrp of the process</td>
</tr>
<tr class="row-odd"><td>sid</td>
<td>session id</td>
</tr>
<tr class="row-even"><td>tty_nr</td>
<td>tty the process uses</td>
</tr>
<tr class="row-odd"><td>tty_pgrp</td>
<td>pgrp of the tty</td>
</tr>
<tr class="row-even"><td>flags</td>
<td>task flags</td>
</tr>
<tr class="row-odd"><td>min_flt</td>
<td>number of minor faults</td>
</tr>
<tr class="row-even"><td>cmin_flt</td>
<td>number of minor faults with child’s</td>
</tr>
<tr class="row-odd"><td>maj_flt</td>
<td>number of major faults</td>
</tr>
<tr class="row-even"><td>cmaj_flt</td>
<td>number of major faults with child’s</td>
</tr>
<tr class="row-odd"><td>utime</td>
<td>user mode jiffies</td>
</tr>
<tr class="row-even"><td>stime</td>
<td>kernel mode jiffies</td>
</tr>
<tr class="row-odd"><td>cutime</td>
<td>user mode jiffies with child’s</td>
</tr>
<tr class="row-even"><td>cstime</td>
<td>kernel mode jiffies with child’s</td>
</tr>
<tr class="row-odd"><td>priority</td>
<td>priority level</td>
</tr>
<tr class="row-even"><td>nice</td>
<td>nice level</td>
</tr>
<tr class="row-odd"><td>num_threads</td>
<td>number of threads</td>
</tr>
<tr class="row-even"><td>it_real_value</td>
<td>(obsolete, always 0)</td>
</tr>
<tr class="row-odd"><td>start_time</td>
<td>time the process started after system boot</td>
</tr>
<tr class="row-even"><td>vsize</td>
<td>virtual memory size</td>
</tr>
<tr class="row-odd"><td>rss</td>
<td>resident set memory size</td>
</tr>
<tr class="row-even"><td>rsslim</td>
<td>current limit in bytes on the rss</td>
</tr>
<tr class="row-odd"><td>start_code</td>
<td>address above which program text can run</td>
</tr>
<tr class="row-even"><td>end_code</td>
<td>address below which program text can run</td>
</tr>
<tr class="row-odd"><td>start_stack</td>
<td>address of the start of the main process stack</td>
</tr>
<tr class="row-even"><td>esp</td>
<td>current value of ESP</td>
</tr>
<tr class="row-odd"><td>eip</td>
<td>current value of EIP</td>
</tr>
<tr class="row-even"><td>pending</td>
<td>bitmap of pending signals</td>
</tr>
<tr class="row-odd"><td>blocked</td>
<td>bitmap of blocked signals</td>
</tr>
<tr class="row-even"><td>sigign</td>
<td>bitmap of ignored signals</td>
</tr>
<tr class="row-odd"><td>sigcatch</td>
<td>bitmap of caught signals</td>
</tr>
<tr class="row-even"><td>0</td>
<td>(place holder, used to be the wchan address,
use /proc/PID/wchan instead)</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>(place holder)</td>
</tr>
<tr class="row-even"><td>0</td>
<td>(place holder)</td>
</tr>
<tr class="row-odd"><td>exit_signal</td>
<td>signal to send to parent thread on exit</td>
</tr>
<tr class="row-even"><td>task_cpu</td>
<td>which CPU the task is scheduled on</td>
</tr>
<tr class="row-odd"><td>rt_priority</td>
<td>realtime priority</td>
</tr>
<tr class="row-even"><td>policy</td>
<td>scheduling policy (man sched_setscheduler)</td>
</tr>
<tr class="row-odd"><td>blkio_ticks</td>
<td>time spent waiting for block IO</td>
</tr>
<tr class="row-even"><td>gtime</td>
<td>guest time of the task in jiffies</td>
</tr>
<tr class="row-odd"><td>cgtime</td>
<td>guest time of the task children in jiffies</td>
</tr>
<tr class="row-even"><td>start_data</td>
<td>address above which program data+bss is placed</td>
</tr>
<tr class="row-odd"><td>end_data</td>
<td>address below which program data+bss is placed</td>
</tr>
<tr class="row-even"><td>start_brk</td>
<td>address above which program heap can be expanded with brk()</td>
</tr>
<tr class="row-odd"><td>arg_start</td>
<td>address above which program command line is placed</td>
</tr>
<tr class="row-even"><td>arg_end</td>
<td>address below which program command line is placed</td>
</tr>
<tr class="row-odd"><td>env_start</td>
<td>address above which program environment is placed</td>
</tr>
<tr class="row-even"><td>env_end</td>
<td>address below which program environment is placed</td>
</tr>
<tr class="row-odd"><td>exit_code</td>
<td>the thread’s exit_code in the form reported by the waitpid
system call</td>
</tr>
</tbody>
</table>
<p>The /proc/PID/maps file contains the currently mapped memory regions and
their access permissions.</p>
<p>The format is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>address           perms offset  dev   inode      pathname

08048000-08049000 r-xp 00000000 03:00 8312       /opt/test
08049000-0804a000 rw-p 00001000 03:00 8312       /opt/test
0804a000-0806b000 rw-p 00000000 00:00 0          [heap]
a7cb1000-a7cb2000 ---p 00000000 00:00 0
a7cb2000-a7eb2000 rw-p 00000000 00:00 0
a7eb2000-a7eb3000 ---p 00000000 00:00 0
a7eb3000-a7ed5000 rw-p 00000000 00:00 0
a7ed5000-a8008000 r-xp 00000000 03:00 4222       /lib/libc.so.6
a8008000-a800a000 r--p 00133000 03:00 4222       /lib/libc.so.6
a800a000-a800b000 rw-p 00135000 03:00 4222       /lib/libc.so.6
a800b000-a800e000 rw-p 00000000 00:00 0
a800e000-a8022000 r-xp 00000000 03:00 14462      /lib/libpthread.so.0
a8022000-a8023000 r--p 00013000 03:00 14462      /lib/libpthread.so.0
a8023000-a8024000 rw-p 00014000 03:00 14462      /lib/libpthread.so.0
a8024000-a8027000 rw-p 00000000 00:00 0
a8027000-a8043000 r-xp 00000000 03:00 8317       /lib/ld-linux.so.2
a8043000-a8044000 r--p 0001b000 03:00 8317       /lib/ld-linux.so.2
a8044000-a8045000 rw-p 0001c000 03:00 8317       /lib/ld-linux.so.2
aff35000-aff4a000 rw-p 00000000 00:00 0          [stack]
ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]
</pre></div>
</div>
<p>where “address” is the address space in the process that it occupies, “perms”
is a set of permissions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>r = read
w = write
x = execute
s = shared
p = private (copy on write)
</pre></div>
</div>
<p>“offset” is the offset into the mapping, “dev” is the device (major:minor), and
“inode” is the inode  on that device.  0 indicates that  no inode is associated
with the memory region, as the case would be with BSS (uninitialized data).
The “pathname” shows the name associated file for this mapping.  If the mapping
is not associated with a file:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>[heap]</td>
<td>the heap of the program</td>
</tr>
<tr class="row-even"><td>[stack]</td>
<td>the stack of the main process</td>
</tr>
<tr class="row-odd"><td>[vdso]</td>
<td>the “virtual dynamic shared object”,
the kernel system call handler</td>
</tr>
</tbody>
</table>
<p>or if empty, the mapping is anonymous.</p>
</div></blockquote>
<p>The /proc/PID/smaps is an extension based on maps, showing the memory
consumption for each of the process’s mappings. For each mapping (aka Virtual
Memory Area, or VMA) there is a series of lines such as the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>08048000-080bc000 r-xp 00000000 03:02 13130      /bin/bash

Size:               1084 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Rss:                 892 kB
Pss:                 374 kB
Shared_Clean:        892 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:          892 kB
Anonymous:             0 kB
LazyFree:              0 kB
AnonHugePages:         0 kB
ShmemPmdMapped:        0 kB
Shared_Hugetlb:        0 kB
Private_Hugetlb:       0 kB
Swap:                  0 kB
SwapPss:               0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
THPeligible:           0
VmFlags: rd ex mr mw me dw
</pre></div>
</div>
<p>The first of these lines shows the same information as is displayed for the
mapping in /proc/PID/maps.  Following lines show the size of the mapping
(size); the size of each page allocated when backing a VMA (KernelPageSize),
which is usually the same as the size in the page table entries; the page size
used by the MMU when backing a VMA (in most cases, the same as KernelPageSize);
the amount of the mapping that is currently resident in RAM (RSS); the
process’ proportional share of this mapping (PSS); and the number of clean and
dirty shared and private pages in the mapping.</p>
<p>The “proportional set size” (PSS) of a process is the count of pages it has
in memory, where each page is divided by the number of processes sharing it.
So if a process has 1000 pages all to itself, and 1000 shared with one other
process, its PSS will be 1500.</p>
<p>Note that even a page which is part of a MAP_SHARED mapping, but has only
a single pte mapped, i.e.  is currently used by only one process, is accounted
as private and not as shared.</p>
<p>“Referenced” indicates the amount of memory currently marked as referenced or
accessed.</p>
<p>“Anonymous” shows the amount of memory that does not belong to any file.  Even
a mapping associated with a file may contain anonymous pages: when MAP_PRIVATE
and a page is modified, the file page is replaced by a private anonymous copy.</p>
<p>“LazyFree” shows the amount of memory which is marked by madvise(MADV_FREE).
The memory isn’t freed immediately with madvise(). It’s freed in memory
pressure if the memory is clean. Please note that the printed value might
be lower than the real value due to optimizations used in the current
implementation. If this is not desirable please file a bug report.</p>
<p>“AnonHugePages” shows the ammount of memory backed by transparent hugepage.</p>
<p>“ShmemPmdMapped” shows the ammount of shared (shmem/tmpfs) memory backed by
huge pages.</p>
<p>“Shared_Hugetlb” and “Private_Hugetlb” show the ammounts of memory backed by
hugetlbfs page which is <em>not</em> counted in “RSS” or “PSS” field for historical
reasons. And these are not included in {Shared,Private}_{Clean,Dirty} field.</p>
<p>“Swap” shows how much would-be-anonymous memory is also used, but out on swap.</p>
<p>For shmem mappings, “Swap” includes also the size of the mapped (and not
replaced by copy-on-write) part of the underlying shmem object out on swap.
“SwapPss” shows proportional swap share of this mapping. Unlike “Swap”, this
does not take into account swapped out page of underlying shmem objects.
“Locked” indicates whether the mapping is locked in memory or not.
“THPeligible” indicates whether the mapping is eligible for allocating THP
pages - 1 if true, 0 otherwise. It just shows the current status.</p>
<p>“VmFlags” field deserves a separate description. This member represents the
kernel flags associated with the particular virtual memory area in two letter
encoded manner. The codes are the following:</p>
<blockquote>
<div></div></blockquote>
<p>Note that there is no guarantee that every flag and associated mnemonic will
be present in all further kernel releases. Things get changed, the flags may
be vanished or the reverse – new added. Interpretation of their meaning
might change in future as well. So each consumer of these flags has to
follow each specific kernel version for the exact semantic.</p>
<p>This file is only present if the CONFIG_MMU kernel configuration option is
enabled.</p>
<p>Note: reading /proc/PID/maps or /proc/PID/smaps is inherently racy (consistent
output can be achieved only in the single read call).</p>
<p>This typically manifests when doing partial reads of these files while the
memory map is being modified.  Despite the races, we do provide the following
guarantees:</p>
<ol class="arabic simple">
<li>The mapped addresses never go backwards, which implies no two
regions will ever overlap.</li>
<li>If there is something at a given vaddr during the entirety of the
life of the smaps/maps walk, there will be some output for it.</li>
</ol>
<p>The /proc/PID/smaps_rollup file includes the same fields as /proc/PID/smaps,
but their values are the sums of the corresponding values for all mappings of
the process.  Additionally, it contains these fields:</p>
<ul class="simple">
<li>Pss_Anon</li>
<li>Pss_File</li>
<li>Pss_Shmem</li>
</ul>
<p>They represent the proportional shares of anonymous, file, and shmem pages, as
described for smaps above.  These fields are omitted in smaps since each
mapping identifies the type (anon, file, or shmem) of all pages it contains.
Thus all information in smaps_rollup can be derived from smaps, but at a
significantly higher cost.</p>
<p>The /proc/PID/clear_refs is used to reset the PG_Referenced and ACCESSED/YOUNG
bits on both physical and virtual pages associated with a process, and the
soft-dirty bit on pte (see Documentation/admin-guide/mm/soft-dirty.rst
for details).
To clear the bits for all the pages associated with the process:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; echo 1 &gt; /proc/PID/clear_refs
</pre></div>
</div>
<p>To clear the bits for the anonymous pages associated with the process:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; echo 2 &gt; /proc/PID/clear_refs
</pre></div>
</div>
<p>To clear the bits for the file mapped pages associated with the process:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; echo 3 &gt; /proc/PID/clear_refs
</pre></div>
</div>
<p>To clear the soft-dirty bit:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; echo 4 &gt; /proc/PID/clear_refs
</pre></div>
</div>
<p>To reset the peak resident set size (“high water mark”) to the process’s
current value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; echo 5 &gt; /proc/PID/clear_refs
</pre></div>
</div>
<p>Any other value written to /proc/PID/clear_refs will have no effect.</p>
<p>The /proc/pid/pagemap gives the PFN, which can be used to find the pageflags
using /proc/kpageflags and number of times a page is mapped using
/proc/kpagecount. For detailed explanation, see
Documentation/admin-guide/mm/pagemap.rst.</p>
<p>The /proc/pid/numa_maps is an extension based on maps, showing the memory
locality and binding policy, as well as the memory usage (in pages) of
each mapping. The output follows a general format where mapping details get
summarized separated by blank spaces, one mapping per each file line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>address   policy    mapping details

00400000 default file=/usr/local/bin/app mapped=1 active=0 N3=1 kernelpagesize_kB=4
00600000 default file=/usr/local/bin/app anon=1 dirty=1 N3=1 kernelpagesize_kB=4
3206000000 default file=/lib64/ld-2.12.so mapped=26 mapmax=6 N0=24 N3=2 kernelpagesize_kB=4
320621f000 default file=/lib64/ld-2.12.so anon=1 dirty=1 N3=1 kernelpagesize_kB=4
3206220000 default file=/lib64/ld-2.12.so anon=1 dirty=1 N3=1 kernelpagesize_kB=4
3206221000 default anon=1 dirty=1 N3=1 kernelpagesize_kB=4
3206800000 default file=/lib64/libc-2.12.so mapped=59 mapmax=21 active=55 N0=41 N3=18 kernelpagesize_kB=4
320698b000 default file=/lib64/libc-2.12.so
3206b8a000 default file=/lib64/libc-2.12.so anon=2 dirty=2 N3=2 kernelpagesize_kB=4
3206b8e000 default file=/lib64/libc-2.12.so anon=1 dirty=1 N3=1 kernelpagesize_kB=4
3206b8f000 default anon=3 dirty=3 active=1 N3=3 kernelpagesize_kB=4
7f4dc10a2000 default anon=3 dirty=3 N3=3 kernelpagesize_kB=4
7f4dc10b4000 default anon=2 dirty=2 active=1 N3=2 kernelpagesize_kB=4
7f4dc1200000 default file=/anon_hugepage\040(deleted) huge anon=1 dirty=1 N3=1 kernelpagesize_kB=2048
7fff335f0000 default stack anon=3 dirty=3 N3=3 kernelpagesize_kB=4
7fff3369d000 default mapped=1 mapmax=35 active=0 N3=1 kernelpagesize_kB=4
</pre></div>
</div>
<p>Where:</p>
<p>“address” is the starting address for the mapping;</p>
<p>“policy” reports the NUMA memory policy set for the mapping (see Documentation/admin-guide/mm/numa_memory_policy.rst);</p>
<p>“mapping details” summarizes mapping data such as mapping type, page usage counters,
node locality page counters (N0 == node0, N1 == node1, …) and the kernel page
size, in KB, that is backing the mapping up.</p>
</div>
<div class="section" id="kernel-data">
<h3>1.2 Kernel data<a class="headerlink" href="#kernel-data" title="Permalink to this headline">¶</a></h3>
<p>Similar to  the  process entries, the kernel data files give information about
the running kernel. The files used to obtain this information are contained in
/proc and  are  listed  in Table 1-5. Not all of these will be present in your
system. It  depends  on the kernel configuration and the loaded modules, which
files are there, and which are missing.</p>
<table border="1" class="docutils" id="id11">
<caption><span class="caption-text">Table 1-5: Kernel info in /proc</span><a class="headerlink" href="#id11" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>apm</td>
<td>Advanced power management info</td>
</tr>
<tr class="row-odd"><td>buddyinfo</td>
<td>Kernel memory allocator information (see text)    (2.5)</td>
</tr>
<tr class="row-even"><td>bus</td>
<td>Directory containing bus specific information</td>
</tr>
<tr class="row-odd"><td>cmdline</td>
<td>Kernel command line</td>
</tr>
<tr class="row-even"><td>cpuinfo</td>
<td>Info about the CPU</td>
</tr>
<tr class="row-odd"><td>devices</td>
<td>Available devices (block and character)</td>
</tr>
<tr class="row-even"><td>dma</td>
<td>Used DMS channels</td>
</tr>
<tr class="row-odd"><td>filesystems</td>
<td>Supported filesystems</td>
</tr>
<tr class="row-even"><td>driver</td>
<td>Various drivers grouped here, currently rtc       (2.4)</td>
</tr>
<tr class="row-odd"><td>execdomains</td>
<td>Execdomains, related to security                  (2.4)</td>
</tr>
<tr class="row-even"><td>fb</td>
<td>Frame Buffer devices                              (2.4)</td>
</tr>
<tr class="row-odd"><td>fs</td>
<td>File system parameters, currently nfs/exports     (2.4)</td>
</tr>
<tr class="row-even"><td>ide</td>
<td>Directory containing info about the IDE subsystem</td>
</tr>
<tr class="row-odd"><td>interrupts</td>
<td>Interrupt usage</td>
</tr>
<tr class="row-even"><td>iomem</td>
<td>Memory map                                        (2.4)</td>
</tr>
<tr class="row-odd"><td>ioports</td>
<td>I/O port usage</td>
</tr>
<tr class="row-even"><td>irq</td>
<td>Masks for irq to cpu affinity                     (2.4)(smp?)</td>
</tr>
<tr class="row-odd"><td>isapnp</td>
<td>ISA PnP (Plug&amp;Play) Info                          (2.4)</td>
</tr>
<tr class="row-even"><td>kcore</td>
<td>Kernel core image (can be ELF or A.OUT(deprecated in 2.4))</td>
</tr>
<tr class="row-odd"><td>kmsg</td>
<td>Kernel messages</td>
</tr>
<tr class="row-even"><td>ksyms</td>
<td>Kernel symbol table</td>
</tr>
<tr class="row-odd"><td>loadavg</td>
<td>Load average of last 1, 5 &amp; 15 minutes</td>
</tr>
<tr class="row-even"><td>locks</td>
<td>Kernel locks</td>
</tr>
<tr class="row-odd"><td>meminfo</td>
<td>Memory info</td>
</tr>
<tr class="row-even"><td>misc</td>
<td>Miscellaneous</td>
</tr>
<tr class="row-odd"><td>modules</td>
<td>List of loaded modules</td>
</tr>
<tr class="row-even"><td>mounts</td>
<td>Mounted filesystems</td>
</tr>
<tr class="row-odd"><td>net</td>
<td>Networking info (see text)</td>
</tr>
<tr class="row-even"><td>pagetypeinfo</td>
<td>Additional page allocator information (see text)  (2.5)</td>
</tr>
<tr class="row-odd"><td>partitions</td>
<td>Table of partitions known to the system</td>
</tr>
<tr class="row-even"><td>pci</td>
<td>Deprecated info of PCI bus (new way -&gt; /proc/bus/pci/,
decoupled by lspci                                (2.4)</td>
</tr>
<tr class="row-odd"><td>rtc</td>
<td>Real time clock</td>
</tr>
<tr class="row-even"><td>scsi</td>
<td>SCSI info (see text)</td>
</tr>
<tr class="row-odd"><td>slabinfo</td>
<td>Slab pool info</td>
</tr>
<tr class="row-even"><td>softirqs</td>
<td>softirq usage</td>
</tr>
<tr class="row-odd"><td>stat</td>
<td>Overall statistics</td>
</tr>
<tr class="row-even"><td>swaps</td>
<td>Swap space utilization</td>
</tr>
<tr class="row-odd"><td>sys</td>
<td>See chapter 2</td>
</tr>
<tr class="row-even"><td>sysvipc</td>
<td>Info of SysVIPC Resources (msg, sem, shm)         (2.4)</td>
</tr>
<tr class="row-odd"><td>tty</td>
<td>Info of tty drivers</td>
</tr>
<tr class="row-even"><td>uptime</td>
<td>Wall clock since boot, combined idle time of all cpus</td>
</tr>
<tr class="row-odd"><td>version</td>
<td>Kernel version</td>
</tr>
<tr class="row-even"><td>video</td>
<td>bttv info of video resources                      (2.4)</td>
</tr>
<tr class="row-odd"><td>vmallocinfo</td>
<td>Show vmalloced areas</td>
</tr>
</tbody>
</table>
<p>You can,  for  example,  check  which interrupts are currently in use and what
they are used for by looking in the file /proc/interrupts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/interrupts
           CPU0
  0:    8728810          XT-PIC  timer
  1:        895          XT-PIC  keyboard
  2:          0          XT-PIC  cascade
  3:     531695          XT-PIC  aha152x
  4:    2014133          XT-PIC  serial
  5:      44401          XT-PIC  pcnet_cs
  8:          2          XT-PIC  rtc
 11:          8          XT-PIC  i82365
 12:     182918          XT-PIC  PS/2 Mouse
 13:          1          XT-PIC  fpu
 14:    1232265          XT-PIC  ide0
 15:          7          XT-PIC  ide1
NMI:          0
</pre></div>
</div>
<p>In 2.4.* a couple of lines where added to this file LOC &amp; ERR (this time is the
output of a SMP machine):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/interrupts

           CPU0       CPU1
  0:    1243498    1214548    IO-APIC-edge  timer
  1:       8949       8958    IO-APIC-edge  keyboard
  2:          0          0          XT-PIC  cascade
  5:      11286      10161    IO-APIC-edge  soundblaster
  8:          1          0    IO-APIC-edge  rtc
  9:      27422      27407    IO-APIC-edge  3c503
 12:     113645     113873    IO-APIC-edge  PS/2 Mouse
 13:          0          0          XT-PIC  fpu
 14:      22491      24012    IO-APIC-edge  ide0
 15:       2183       2415    IO-APIC-edge  ide1
 17:      30564      30414   IO-APIC-level  eth0
 18:        177        164   IO-APIC-level  bttv
NMI:    2457961    2457959
LOC:    2457882    2457881
ERR:       2155
</pre></div>
</div>
<p>NMI is incremented in this case because every timer interrupt generates a NMI
(Non Maskable Interrupt) which is used by the NMI Watchdog to detect lockups.</p>
<p>LOC is the local interrupt counter of the internal APIC of every CPU.</p>
<p>ERR is incremented in the case of errors in the IO-APIC bus (the bus that
connects the CPUs in a SMP system. This means that an error has been detected,
the IO-APIC automatically retry the transmission, so it should not be a big
problem, but you should read the SMP-FAQ.</p>
<p>In 2.6.2* /proc/interrupts was expanded again.  This time the goal was for
/proc/interrupts to display every IRQ vector in use by the system, not
just those considered ‘most important’.  The new vectors are:</p>
<dl class="docutils">
<dt>THR</dt>
<dd>interrupt raised when a machine check threshold counter
(typically counting ECC corrected errors of memory or cache) exceeds
a configurable threshold.  Only available on some systems.</dd>
<dt>TRM</dt>
<dd>a thermal event interrupt occurs when a temperature threshold
has been exceeded for the CPU.  This interrupt may also be generated
when the temperature drops back to normal.</dd>
<dt>SPU</dt>
<dd>a spurious interrupt is some interrupt that was raised then lowered
by some IO device before it could be fully processed by the APIC.  Hence
the APIC sees the interrupt but does not know what device it came from.
For this case the APIC will generate the interrupt with a IRQ vector
of 0xff. This might also be generated by chipset bugs.</dd>
<dt>RES, CAL, TLB]</dt>
<dd>rescheduling, call and TLB flush interrupts are
sent from one CPU to another per the needs of the OS.  Typically,
their statistics are used by kernel developers and interested users to
determine the occurrence of interrupts of the given type.</dd>
</dl>
<p>The above IRQ vectors are displayed only when relevant.  For example,
the threshold vector does not exist on x86_64 platforms.  Others are
suppressed when the system is a uniprocessor.  As of this writing, only
i386 and x86_64 platforms support the new IRQ vector displays.</p>
<p>Of some interest is the introduction of the /proc/irq directory to 2.4.
It could be used to set IRQ to CPU affinity, this means that you can “hook” an
IRQ to only one CPU, or to exclude a CPU of handling IRQs. The contents of the
irq subdir is one subdir for each IRQ, and two files; default_smp_affinity and
prof_cpu_mask.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; ls /proc/irq/
0  10  12  14  16  18  2  4  6  8  prof_cpu_mask
1  11  13  15  17  19  3  5  7  9  default_smp_affinity
&gt; ls /proc/irq/0/
smp_affinity
</pre></div>
</div>
<p>smp_affinity is a bitmask, in which you can specify which CPUs can handle the
IRQ, you can set it by doing:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; echo 1 &gt; /proc/irq/10/smp_affinity
</pre></div>
</div>
<p>This means that only the first CPU will handle the IRQ, but you can also echo
5 which means that only the first and third CPU can handle the IRQ.</p>
<p>The contents of each smp_affinity file is the same by default:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/irq/0/smp_affinity
ffffffff
</pre></div>
</div>
<p>There is an alternate interface, smp_affinity_list which allows specifying
a cpu range instead of a bitmask:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/irq/0/smp_affinity_list
1024-1031
</pre></div>
</div>
<p>The default_smp_affinity mask applies to all non-active IRQs, which are the
IRQs which have not yet been allocated/activated, and hence which lack a
/proc/irq/[0-9]* directory.</p>
<p>The node file on an SMP system shows the node to which the device using the IRQ
reports itself as being attached. This hardware locality information does not
include information about any possible driver locality preference.</p>
<p>prof_cpu_mask specifies which CPUs are to be profiled by the system wide
profiler. Default value is ffffffff (all cpus if there are only 32 of them).</p>
<p>The way IRQs are routed is handled by the IO-APIC, and it’s Round Robin
between all the CPUs which are allowed to handle it. As usual the kernel has
more info than you and does a better job than you, so the defaults are the
best choice for almost everyone.  [Note this applies only to those IO-APIC’s
that support “Round Robin” interrupt distribution.]</p>
<p>There are  three  more  important subdirectories in /proc: net, scsi, and sys.
The general  rule  is  that  the  contents,  or  even  the  existence of these
directories, depend  on your kernel configuration. If SCSI is not enabled, the
directory scsi  may  not  exist. The same is true with the net, which is there
only when networking support is present in the running kernel.</p>
<p>The slabinfo  file  gives  information  about  memory usage at the slab level.
Linux uses  slab  pools for memory management above page level in version 2.2.
Commonly used  objects  have  their  own  slab  pool (such as network buffers,
directory cache, and so on).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/buddyinfo

Node 0, zone      DMA      0      4      5      4      4      3 ...
Node 0, zone   Normal      1      0      0      1    101      8 ...
Node 0, zone  HighMem      2      0      0      1      1      0 ...
</pre></div>
</div>
<p>External fragmentation is a problem under some workloads, and buddyinfo is a
useful tool for helping diagnose these problems.  Buddyinfo will give you a
clue as to how big an area you can safely allocate, or why a previous
allocation failed.</p>
<p>Each column represents the number of pages of a certain order which are
available.  In this case, there are 0 chunks of 2^0*PAGE_SIZE available in
ZONE_DMA, 4 chunks of 2^1*PAGE_SIZE in ZONE_DMA, 101 chunks of 2^4*PAGE_SIZE
available in ZONE_NORMAL, etc…</p>
<p>More information relevant to external fragmentation can be found in
pagetypeinfo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/pagetypeinfo
Page block order: 9
Pages per block:  512

Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, zone      DMA, type    Unmovable      0      0      0      1      1      1      1      1      1      1      0
Node    0, zone      DMA, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone      DMA, type      Movable      1      1      2      1      2      1      1      0      1      0      2
Node    0, zone      DMA, type      Reserve      0      0      0      0      0      0      0      0      0      1      0
Node    0, zone      DMA, type      Isolate      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone    DMA32, type    Unmovable    103     54     77      1      1      1     11      8      7      1      9
Node    0, zone    DMA32, type  Reclaimable      0      0      2      1      0      0      0      0      1      0      0
Node    0, zone    DMA32, type      Movable    169    152    113     91     77     54     39     13      6      1    452
Node    0, zone    DMA32, type      Reserve      1      2      2      2      2      0      1      1      1      1      0
Node    0, zone    DMA32, type      Isolate      0      0      0      0      0      0      0      0      0      0      0

Number of blocks type     Unmovable  Reclaimable      Movable      Reserve      Isolate
Node 0, zone      DMA            2            0            5            1            0
Node 0, zone    DMA32           41            6          967            2            0
</pre></div>
</div>
<p>Fragmentation avoidance in the kernel works by grouping pages of different
migrate types into the same contiguous regions of memory called page blocks.
A page block is typically the size of the default hugepage size e.g. 2MB on
X86-64. By keeping pages grouped based on their ability to move, the kernel
can reclaim pages within a page block to satisfy a high-order allocation.</p>
<p>The pagetypinfo begins with information on the size of a page block. It
then gives the same type of information as buddyinfo except broken down
by migrate-type and finishes with details on how many page blocks of each
type exist.</p>
<p>If min_free_kbytes has been tuned correctly (recommendations made by hugeadm
from libhugetlbfs <a class="reference external" href="https://github.com/libhugetlbfs/libhugetlbfs/">https://github.com/libhugetlbfs/libhugetlbfs/</a>), one can
make an estimate of the likely number of huge pages that can be allocated
at a given point in time. All the “Movable” blocks should be allocatable
unless memory has been mlock()’d. Some of the Reclaimable blocks should
also be allocatable although a lot of filesystem metadata may have to be
reclaimed to achieve this.</p>
<div class="section" id="meminfo">
<h4>meminfo<a class="headerlink" href="#meminfo" title="Permalink to this headline">¶</a></h4>
<p>Provides information about distribution and utilization of memory.  This
varies by architecture and compile options.  The following is from a
16GB PIII, which has highmem enabled.  You may not have all of these fields.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/meminfo

MemTotal:     16344972 kB
MemFree:      13634064 kB
MemAvailable: 14836172 kB
Buffers:          3656 kB
Cached:        1195708 kB
SwapCached:          0 kB
Active:         891636 kB
Inactive:      1077224 kB
HighTotal:    15597528 kB
HighFree:     13629632 kB
LowTotal:       747444 kB
LowFree:          4432 kB
SwapTotal:           0 kB
SwapFree:            0 kB
Dirty:             968 kB
Writeback:           0 kB
AnonPages:      861800 kB
Mapped:         280372 kB
Shmem:             644 kB
KReclaimable:   168048 kB
Slab:           284364 kB
SReclaimable:   159856 kB
SUnreclaim:     124508 kB
PageTables:      24448 kB
NFS_Unstable:        0 kB
Bounce:              0 kB
WritebackTmp:        0 kB
CommitLimit:   7669796 kB
Committed_AS:   100056 kB
VmallocTotal:   112216 kB
VmallocUsed:       428 kB
VmallocChunk:   111088 kB
Percpu:          62080 kB
HardwareCorrupted:   0 kB
AnonHugePages:   49152 kB
ShmemHugePages:      0 kB
ShmemPmdMapped:      0 kB
</pre></div>
</div>
<dl class="docutils">
<dt>MemTotal</dt>
<dd>Total usable ram (i.e. physical ram minus a few reserved
bits and the kernel binary code)</dd>
<dt>MemFree</dt>
<dd>The sum of LowFree+HighFree</dd>
<dt>MemAvailable</dt>
<dd>An estimate of how much memory is available for starting new
applications, without swapping. Calculated from MemFree,
SReclaimable, the size of the file LRU lists, and the low
watermarks in each zone.
The estimate takes into account that the system needs some
page cache to function well, and that not all reclaimable
slab will be reclaimable, due to items being in use. The
impact of those factors will vary from system to system.</dd>
<dt>Buffers</dt>
<dd>Relatively temporary storage for raw disk blocks
shouldn’t get tremendously large (20MB or so)</dd>
<dt>Cached</dt>
<dd>in-memory cache for files read from the disk (the
pagecache).  Doesn’t include SwapCached</dd>
<dt>SwapCached</dt>
<dd>Memory that once was swapped out, is swapped back in but
still also is in the swapfile (if memory is needed it
doesn’t need to be swapped out AGAIN because it is already
in the swapfile. This saves I/O)</dd>
<dt>Active</dt>
<dd>Memory that has been used more recently and usually not
reclaimed unless absolutely necessary.</dd>
<dt>Inactive</dt>
<dd>Memory which has been less recently used.  It is more
eligible to be reclaimed for other purposes</dd>
<dt>HighTotal, HighFree</dt>
<dd>Highmem is all memory above ~860MB of physical memory
Highmem areas are for use by userspace programs, or
for the pagecache.  The kernel must use tricks to access
this memory, making it slower to access than lowmem.</dd>
<dt>LowTotal, LowFree</dt>
<dd>Lowmem is memory which can be used for everything that
highmem can be used for, but it is also available for the
kernel’s use for its own data structures.  Among many
other things, it is where everything from the Slab is
allocated.  Bad things happen when you’re out of lowmem.</dd>
<dt>SwapTotal</dt>
<dd>total amount of swap space available</dd>
<dt>SwapFree</dt>
<dd>Memory which has been evicted from RAM, and is temporarily
on the disk</dd>
<dt>Dirty</dt>
<dd>Memory which is waiting to get written back to the disk</dd>
<dt>Writeback</dt>
<dd>Memory which is actively being written back to the disk</dd>
<dt>AnonPages</dt>
<dd>Non-file backed pages mapped into userspace page tables</dd>
<dt>HardwareCorrupted</dt>
<dd>The amount of RAM/memory in KB, the kernel identifies as
corrupted.</dd>
<dt>AnonHugePages</dt>
<dd>Non-file backed huge pages mapped into userspace page tables</dd>
<dt>Mapped</dt>
<dd>files which have been mmaped, such as libraries</dd>
<dt>Shmem</dt>
<dd>Total memory used by shared memory (shmem) and tmpfs</dd>
<dt>ShmemHugePages</dt>
<dd>Memory used by shared memory (shmem) and tmpfs allocated
with huge pages</dd>
<dt>ShmemPmdMapped</dt>
<dd>Shared memory mapped into userspace with huge pages</dd>
<dt>KReclaimable</dt>
<dd>Kernel allocations that the kernel will attempt to reclaim
under memory pressure. Includes SReclaimable (below), and other
direct allocations with a shrinker.</dd>
<dt>Slab</dt>
<dd>in-kernel data structures cache</dd>
<dt>SReclaimable</dt>
<dd>Part of Slab, that might be reclaimed, such as caches</dd>
<dt>SUnreclaim</dt>
<dd>Part of Slab, that cannot be reclaimed on memory pressure</dd>
<dt>PageTables</dt>
<dd>amount of memory dedicated to the lowest level of page
tables.</dd>
<dt>NFS_Unstable</dt>
<dd>Always zero. Previous counted pages which had been written to
the server, but has not been committed to stable storage.</dd>
<dt>Bounce</dt>
<dd>Memory used for block device “bounce buffers”</dd>
<dt>WritebackTmp</dt>
<dd>Memory used by FUSE for temporary writeback buffers</dd>
<dt>CommitLimit</dt>
<dd><p class="first">Based on the overcommit ratio (‘vm.overcommit_ratio’),
this is the total amount of  memory currently available to
be allocated on the system. This limit is only adhered to
if strict overcommit accounting is enabled (mode 2 in
‘vm.overcommit_memory’).</p>
<p>The CommitLimit is calculated with the following formula:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CommitLimit = ([total RAM pages] - [total huge TLB pages]) *
               overcommit_ratio / 100 + [total swap pages]
</pre></div>
</div>
<p>For example, on a system with 1G of physical RAM and 7G
of swap with a <cite>vm.overcommit_ratio</cite> of 30 it would
yield a CommitLimit of 7.3G.</p>
<p class="last">For more details, see the memory overcommit documentation
in vm/overcommit-accounting.</p>
</dd>
<dt>Committed_AS</dt>
<dd>The amount of memory presently allocated on the system.
The committed memory is a sum of all of the memory which
has been allocated by processes, even if it has not been
“used” by them as of yet. A process which malloc()’s 1G
of memory, but only touches 300M of it will show up as
using 1G. This 1G is memory which has been “committed” to
by the VM and can be used at any time by the allocating
application. With strict overcommit enabled on the system
(mode 2 in ‘vm.overcommit_memory’),allocations which would
exceed the CommitLimit (detailed above) will not be permitted.
This is useful if one needs to guarantee that processes will
not fail due to lack of memory once that memory has been
successfully allocated.</dd>
<dt>VmallocTotal</dt>
<dd>total size of vmalloc memory area</dd>
<dt>VmallocUsed</dt>
<dd>amount of vmalloc area which is used</dd>
<dt>VmallocChunk</dt>
<dd>largest contiguous block of vmalloc area which is free</dd>
<dt>Percpu</dt>
<dd>Memory allocated to the percpu allocator used to back percpu
allocations. This stat excludes the cost of metadata.</dd>
</dl>
</div>
<div class="section" id="vmallocinfo">
<h4>vmallocinfo<a class="headerlink" href="#vmallocinfo" title="Permalink to this headline">¶</a></h4>
<p>Provides information about vmalloced/vmaped areas. One line per area,
containing the virtual address range of the area, size in bytes,
caller information of the creator, and optional information depending
on the kind of area :</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>pages=nr</td>
<td>number of pages</td>
</tr>
<tr class="row-even"><td>phys=addr</td>
<td>if a physical address was specified</td>
</tr>
<tr class="row-odd"><td>ioremap</td>
<td>I/O mapping (<a class="reference internal" href="../driver-api/device-io.html#c.ioremap" title="ioremap"><code class="xref c c-func docutils literal notranslate"><span class="pre">ioremap()</span></code></a> and friends)</td>
</tr>
<tr class="row-even"><td>vmalloc</td>
<td><a class="reference internal" href="../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a> area</td>
</tr>
<tr class="row-odd"><td>vmap</td>
<td><a class="reference internal" href="../core-api/mm-api.html#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a>ed pages</td>
</tr>
<tr class="row-even"><td>user</td>
<td>VM_USERMAP area</td>
</tr>
<tr class="row-odd"><td>vpages</td>
<td>buffer for pages pointers was vmalloced (huge area)</td>
</tr>
<tr class="row-even"><td>N&lt;node&gt;=nr</td>
<td>(Only on NUMA kernels)
Number of pages allocated on memory node &lt;node&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/vmallocinfo
0xffffc20000000000-0xffffc20000201000 2101248 alloc_large_system_hash+0x204 ...
/0x2c0 pages=512 vmalloc N0=128 N1=128 N2=128 N3=128
0xffffc20000201000-0xffffc20000302000 1052672 alloc_large_system_hash+0x204 ...
/0x2c0 pages=256 vmalloc N0=64 N1=64 N2=64 N3=64
0xffffc20000302000-0xffffc20000304000    8192 acpi_tb_verify_table+0x21/0x4f...
phys=7fee8000 ioremap
0xffffc20000304000-0xffffc20000307000   12288 acpi_tb_verify_table+0x21/0x4f...
phys=7fee7000 ioremap
0xffffc2000031d000-0xffffc2000031f000    8192 init_vdso_vars+0x112/0x210
0xffffc2000031f000-0xffffc2000032b000   49152 cramfs_uncompress_init+0x2e ...
/0x80 pages=11 vmalloc N0=3 N1=3 N2=2 N3=3
0xffffc2000033a000-0xffffc2000033d000   12288 sys_swapon+0x640/0xac0      ...
pages=2 vmalloc N1=2
0xffffc20000347000-0xffffc2000034c000   20480 xt_alloc_table_info+0xfe ...
/0x130 [x_tables] pages=4 vmalloc N0=4
0xffffffffa0000000-0xffffffffa000f000   61440 sys_init_module+0xc27/0x1d00 ...
pages=14 vmalloc N2=14
0xffffffffa000f000-0xffffffffa0014000   20480 sys_init_module+0xc27/0x1d00 ...
pages=4 vmalloc N1=4
0xffffffffa0014000-0xffffffffa0017000   12288 sys_init_module+0xc27/0x1d00 ...
pages=2 vmalloc N1=2
0xffffffffa0017000-0xffffffffa0022000   45056 sys_init_module+0xc27/0x1d00 ...
pages=10 vmalloc N0=10
</pre></div>
</div>
</div>
<div class="section" id="softirqs">
<h4>softirqs<a class="headerlink" href="#softirqs" title="Permalink to this headline">¶</a></h4>
<p>Provides counts of softirq handlers serviced since boot time, for each cpu.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/softirqs
                CPU0       CPU1       CPU2       CPU3
    HI:          0          0          0          0
TIMER:      27166      27120      27097      27034
NET_TX:          0          0          0         17
NET_RX:         42          0          0         39
BLOCK:          0          0        107       1121
TASKLET:          0          0          0        290
SCHED:      27035      26983      26971      26746
HRTIMER:          0          0          0          0
    RCU:       1678       1769       2178       2250
</pre></div>
</div>
</div>
</div>
<div class="section" id="ide-devices-in-proc-ide">
<h3>1.3 IDE devices in /proc/ide<a class="headerlink" href="#ide-devices-in-proc-ide" title="Permalink to this headline">¶</a></h3>
<p>The subdirectory /proc/ide contains information about all IDE devices of which
the kernel  is  aware.  There is one subdirectory for each IDE controller, the
file drivers  and a link for each IDE device, pointing to the device directory
in the controller specific subtree.</p>
<p>The file  drivers  contains general information about the drivers used for the
IDE devices:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/ide/drivers
ide-cdrom version 4.53
ide-disk version 1.08
</pre></div>
</div>
<p>More detailed  information  can  be  found  in  the  controller  specific
subdirectories. These  are  named  ide0,  ide1  and  so  on.  Each  of  these
directories contains the files shown in table 1-6.</p>
<table border="1" class="docutils" id="id12">
<caption><span class="caption-text">Table 1-6: IDE controller info in  /proc/ide/ide?</span><a class="headerlink" href="#id12" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>channel</td>
<td>IDE channel (0 or 1)</td>
</tr>
<tr class="row-odd"><td>config</td>
<td>Configuration (only for PCI/IDE bridge)</td>
</tr>
<tr class="row-even"><td>mate</td>
<td>Mate name</td>
</tr>
<tr class="row-odd"><td>model</td>
<td>Type/Chipset of IDE controller</td>
</tr>
</tbody>
</table>
<p>Each device  connected  to  a  controller  has  a separate subdirectory in the
controllers directory.  The  files  listed in table 1-7 are contained in these
directories.</p>
<table border="1" class="docutils" id="id13">
<caption><span class="caption-text">Table 1-7: IDE device information</span><a class="headerlink" href="#id13" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>cache</td>
<td>The cache</td>
</tr>
<tr class="row-odd"><td>capacity</td>
<td>Capacity of the medium (in 512Byte blocks)</td>
</tr>
<tr class="row-even"><td>driver</td>
<td>driver and version</td>
</tr>
<tr class="row-odd"><td>geometry</td>
<td>physical and logical geometry</td>
</tr>
<tr class="row-even"><td>identify</td>
<td>device identify block</td>
</tr>
<tr class="row-odd"><td>media</td>
<td>media type</td>
</tr>
<tr class="row-even"><td>model</td>
<td>device identifier</td>
</tr>
<tr class="row-odd"><td>settings</td>
<td>device setup</td>
</tr>
<tr class="row-even"><td>smart_thresholds</td>
<td>IDE disk management thresholds</td>
</tr>
<tr class="row-odd"><td>smart_values</td>
<td>IDE disk management values</td>
</tr>
</tbody>
</table>
<p>The most  interesting  file is <code class="docutils literal notranslate"><span class="pre">settings</span></code>. This file contains a nice
overview of the drive parameters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /proc/ide/ide0/hda/settings
name                    value           min             max             mode
----                    -----           ---             ---             ----
bios_cyl                526             0               65535           rw
bios_head               255             0               255             rw
bios_sect               63              0               63              rw
breada_readahead        4               0               127             rw
bswap                   0               0               1               r
file_readahead          72              0               2097151         rw
io_32bit                0               0               3               rw
keepsettings            0               0               1               rw
max_kb_per_request      122             1               127             rw
multcount               0               0               8               rw
nice1                   1               0               1               rw
nowerr                  0               0               1               rw
pio_mode                write-only      0               255             w
slow                    0               0               1               rw
unmaskirq               0               0               1               rw
using_dma               0               0               1               rw
</pre></div>
</div>
</div>
<div class="section" id="networking-info-in-proc-net">
<h3>1.4 Networking info in /proc/net<a class="headerlink" href="#networking-info-in-proc-net" title="Permalink to this headline">¶</a></h3>
<p>The subdirectory  /proc/net  follows  the  usual  pattern. Table 1-8 shows the
additional values  you  get  for  IP  version 6 if you configure the kernel to
support this. Table 1-9 lists the files and their meaning.</p>
<table border="1" class="docutils" id="id14">
<caption><span class="caption-text">Table 1-8: IPv6 info in /proc/net</span><a class="headerlink" href="#id14" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>udp6</td>
<td>UDP sockets (IPv6)</td>
</tr>
<tr class="row-odd"><td>tcp6</td>
<td>TCP sockets (IPv6)</td>
</tr>
<tr class="row-even"><td>raw6</td>
<td>Raw device statistics (IPv6)</td>
</tr>
<tr class="row-odd"><td>igmp6</td>
<td>IP multicast addresses, which this host joined (IPv6)</td>
</tr>
<tr class="row-even"><td>if_inet6</td>
<td>List of IPv6 interface addresses</td>
</tr>
<tr class="row-odd"><td>ipv6_route</td>
<td>Kernel routing table for IPv6</td>
</tr>
<tr class="row-even"><td>rt6_stats</td>
<td>Global IPv6 routing tables statistics</td>
</tr>
<tr class="row-odd"><td>sockstat6</td>
<td>Socket statistics (IPv6)</td>
</tr>
<tr class="row-even"><td>snmp6</td>
<td>Snmp data (IPv6)</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id15">
<caption><span class="caption-text">Table 1-9: Network info in /proc/net</span><a class="headerlink" href="#id15" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>arp</td>
<td>Kernel  ARP table</td>
</tr>
<tr class="row-odd"><td>dev</td>
<td>network devices with statistics</td>
</tr>
<tr class="row-even"><td>dev_mcast</td>
<td>the Layer2 multicast groups a device is listening too
(interface index, label, number of references, number of bound
addresses).</td>
</tr>
<tr class="row-odd"><td>dev_stat</td>
<td>network device status</td>
</tr>
<tr class="row-even"><td>ip_fwchains</td>
<td>Firewall chain linkage</td>
</tr>
<tr class="row-odd"><td>ip_fwnames</td>
<td>Firewall chain names</td>
</tr>
<tr class="row-even"><td>ip_masq</td>
<td>Directory containing the masquerading tables</td>
</tr>
<tr class="row-odd"><td>ip_masquerade</td>
<td>Major masquerading table</td>
</tr>
<tr class="row-even"><td>netstat</td>
<td>Network statistics</td>
</tr>
<tr class="row-odd"><td>raw</td>
<td>raw device statistics</td>
</tr>
<tr class="row-even"><td>route</td>
<td>Kernel routing table</td>
</tr>
<tr class="row-odd"><td>rpc</td>
<td>Directory containing rpc info</td>
</tr>
<tr class="row-even"><td>rt_cache</td>
<td>Routing cache</td>
</tr>
<tr class="row-odd"><td>snmp</td>
<td>SNMP data</td>
</tr>
<tr class="row-even"><td>sockstat</td>
<td>Socket statistics</td>
</tr>
<tr class="row-odd"><td>tcp</td>
<td>TCP  sockets</td>
</tr>
<tr class="row-even"><td>udp</td>
<td>UDP sockets</td>
</tr>
<tr class="row-odd"><td>unix</td>
<td>UNIX domain sockets</td>
</tr>
<tr class="row-even"><td>wireless</td>
<td>Wireless interface data (Wavelan etc)</td>
</tr>
<tr class="row-odd"><td>igmp</td>
<td>IP multicast addresses, which this host joined</td>
</tr>
<tr class="row-even"><td>psched</td>
<td>Global packet scheduler parameters.</td>
</tr>
<tr class="row-odd"><td>netlink</td>
<td>List of PF_NETLINK sockets</td>
</tr>
<tr class="row-even"><td>ip_mr_vifs</td>
<td>List of multicast virtual interfaces</td>
</tr>
<tr class="row-odd"><td>ip_mr_cache</td>
<td>List of multicast routing cache</td>
</tr>
</tbody>
</table>
<p>You can  use  this  information  to see which network devices are available in
your system and how much traffic was routed over those devices:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/net/dev
Inter-|Receive                                                   |[...
 face |bytes    packets errs drop fifo frame compressed multicast|[...
    lo:  908188   5596     0    0    0     0          0         0 [...
  ppp0:15475140  20721   410    0    0   410          0         0 [...
  eth0:  614530   7085     0    0    0     0          0         1 [...

...] Transmit
...] bytes    packets errs drop fifo colls carrier compressed
...]  908188     5596    0    0    0     0       0          0
...] 1375103    17405    0    0    0     0       0          0
...] 1703981     5535    0    0    0     3       0          0
</pre></div>
</div>
<p>In addition, each Channel Bond interface has its own directory.  For
example, the bond0 device will have a directory called /proc/net/bond0/.
It will contain information that is specific to that bond, such as the
current slaves of the bond, the link status of the slaves, and how
many times the slaves link has failed.</p>
</div>
<div class="section" id="scsi-info">
<h3>1.5 SCSI info<a class="headerlink" href="#scsi-info" title="Permalink to this headline">¶</a></h3>
<p>If you  have  a  SCSI  host adapter in your system, you’ll find a subdirectory
named after  the driver for this adapter in /proc/scsi. You’ll also see a list
of all recognized SCSI devices in /proc/scsi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;cat /proc/scsi/scsi
Attached devices:
Host: scsi0 Channel: 00 Id: 00 Lun: 00
  Vendor: IBM      Model: DGHS09U          Rev: 03E0
  Type:   Direct-Access                    ANSI SCSI revision: 03
Host: scsi0 Channel: 00 Id: 06 Lun: 00
  Vendor: PIONEER  Model: CD-ROM DR-U06S   Rev: 1.04
  Type:   CD-ROM                           ANSI SCSI revision: 02
</pre></div>
</div>
<p>The directory  named  after  the driver has one file for each adapter found in
the system.  These  files  contain information about the controller, including
the used  IRQ  and  the  IO  address range. The amount of information shown is
dependent on  the adapter you use. The example shows the output for an Adaptec
AHA-2940 SCSI adapter:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/scsi/aic7xxx/0

Adaptec AIC7xxx driver version: 5.1.19/3.2.4
Compile Options:
  TCQ Enabled By Default : Disabled
  AIC7XXX_PROC_STATS     : Disabled
  AIC7XXX_RESET_DELAY    : 5
Adapter Configuration:
           SCSI Adapter: Adaptec AHA-294X Ultra SCSI host adapter
                           Ultra Wide Controller
    PCI MMAPed I/O Base: 0xeb001000
 Adapter SEEPROM Config: SEEPROM found and used.
      Adaptec SCSI BIOS: Enabled
                    IRQ: 10
                   SCBs: Active 0, Max Active 2,
                         Allocated 15, HW 16, Page 255
             Interrupts: 160328
      BIOS Control Word: 0x18b6
   Adapter Control Word: 0x005b
   Extended Translation: Enabled
Disconnect Enable Flags: 0xffff
     Ultra Enable Flags: 0x0001
 Tag Queue Enable Flags: 0x0000
Ordered Queue Tag Flags: 0x0000
Default Tag Queue Depth: 8
    Tagged Queue By Device array for aic7xxx host instance 0:
      {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255}
    Actual queue depth per device for aic7xxx host instance 0:
      {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
Statistics:
(scsi0:0:0:0)
  Device using Wide/Sync transfers at 40.0 MByte/sec, offset 8
  Transinfo settings: current(12/8/1/0), goal(12/8/1/0), user(12/15/1/0)
  Total transfers 160151 (74577 reads and 85574 writes)
(scsi0:0:6:0)
  Device using Narrow/Sync transfers at 5.0 MByte/sec, offset 15
  Transinfo settings: current(50/15/0/0), goal(50/15/0/0), user(50/15/0/0)
  Total transfers 0 (0 reads and 0 writes)
</pre></div>
</div>
</div>
<div class="section" id="parallel-port-info-in-proc-parport">
<h3>1.6 Parallel port info in /proc/parport<a class="headerlink" href="#parallel-port-info-in-proc-parport" title="Permalink to this headline">¶</a></h3>
<p>The directory  /proc/parport  contains information about the parallel ports of
your system.  It  has  one  subdirectory  for  each port, named after the port
number (0,1,2,…).</p>
<p>These directories contain the four files shown in Table 1-10.</p>
<table border="1" class="docutils" id="id16">
<caption><span class="caption-text">Table 1-10: Files in /proc/parport</span><a class="headerlink" href="#id16" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>autoprobe</td>
<td>Any IEEE-1284 device ID information that has been acquired.</td>
</tr>
<tr class="row-odd"><td>devices</td>
<td>list of the device drivers using that port. A + will appear by the
name of the device currently using the port (it might not appear
against any).</td>
</tr>
<tr class="row-even"><td>hardware</td>
<td>Parallel port’s base address, IRQ line and DMA channel.</td>
</tr>
<tr class="row-odd"><td>irq</td>
<td>IRQ that parport is using for that port. This is in a separate
file to allow you to alter it by writing a new value in (IRQ
number or none).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="tty-info-in-proc-tty">
<h3>1.7 TTY info in /proc/tty<a class="headerlink" href="#tty-info-in-proc-tty" title="Permalink to this headline">¶</a></h3>
<p>Information about  the  available  and actually used tty’s can be found in the
directory /proc/tty.You’ll  find  entries  for drivers and line disciplines in
this directory, as shown in Table 1-11.</p>
<table border="1" class="docutils" id="id17">
<caption><span class="caption-text">Table 1-11: Files in /proc/tty</span><a class="headerlink" href="#id17" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File</th>
<th class="head">Content</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>drivers</td>
<td>list of drivers and their usage</td>
</tr>
<tr class="row-odd"><td>ldiscs</td>
<td>registered line disciplines</td>
</tr>
<tr class="row-even"><td>driver/serial</td>
<td>usage statistic and status of single tty lines</td>
</tr>
</tbody>
</table>
<p>To see  which  tty’s  are  currently in use, you can simply look into the file
/proc/tty/drivers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/tty/drivers
pty_slave            /dev/pts      136   0-255 pty:slave
pty_master           /dev/ptm      128   0-255 pty:master
pty_slave            /dev/ttyp       3   0-255 pty:slave
pty_master           /dev/pty        2   0-255 pty:master
serial               /dev/cua        5   64-67 serial:callout
serial               /dev/ttyS       4   64-67 serial
/dev/tty0            /dev/tty0       4       0 system:vtmaster
/dev/ptmx            /dev/ptmx       5       2 system
/dev/console         /dev/console    5       1 system:console
/dev/tty             /dev/tty        5       0 system:/dev/tty
unknown              /dev/tty        4    1-63 console
</pre></div>
</div>
</div>
<div class="section" id="miscellaneous-kernel-statistics-in-proc-stat">
<h3>1.8 Miscellaneous kernel statistics in /proc/stat<a class="headerlink" href="#miscellaneous-kernel-statistics-in-proc-stat" title="Permalink to this headline">¶</a></h3>
<p>Various pieces   of  information about  kernel activity  are  available in the
/proc/stat file.  All  of  the numbers reported  in  this file are  aggregates
since the system first booted.  For a quick look, simply cat the file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/stat
cpu  2255 34 2290 22625563 6290 127 456 0 0 0
cpu0 1132 34 1441 11311718 3675 127 438 0 0 0
cpu1 1123 0 849 11313845 2614 0 18 0 0 0
intr 114930548 113199788 3 0 5 263 0 4 [... lots more numbers ...]
ctxt 1990473
btime 1062191376
processes 2915
procs_running 1
procs_blocked 0
softirq 183433 0 21755 12 39 1137 231 21459 2263
</pre></div>
</div>
<p>The very first  “cpu” line aggregates the  numbers in all  of the other “cpuN”
lines.  These numbers identify the amount of time the CPU has spent performing
different kinds of work.  Time units are in USER_HZ (typically hundredths of a
second).  The meanings of the columns are as follows, from left to right:</p>
<ul>
<li><p class="first">user: normal processes executing in user mode</p>
</li>
<li><p class="first">nice: niced processes executing in user mode</p>
</li>
<li><p class="first">system: processes executing in kernel mode</p>
</li>
<li><p class="first">idle: twiddling thumbs</p>
</li>
<li><p class="first">iowait: In a word, iowait stands for waiting for I/O to complete. But there
are several problems:</p>
<ol class="arabic simple">
<li>Cpu will not wait for I/O to complete, iowait is the time that a task is
waiting for I/O to complete. When cpu goes into idle state for
outstanding task io, another task will be scheduled on this CPU.</li>
<li>In a multi-core CPU, the task waiting for I/O to complete is not running
on any CPU, so the iowait of each CPU is difficult to calculate.</li>
<li>The value of iowait field in /proc/stat will decrease in certain
conditions.</li>
</ol>
<p>So, the iowait is not reliable by reading from /proc/stat.</p>
</li>
<li><p class="first">irq: servicing interrupts</p>
</li>
<li><p class="first">softirq: servicing softirqs</p>
</li>
<li><p class="first">steal: involuntary wait</p>
</li>
<li><p class="first">guest: running a normal guest</p>
</li>
<li><p class="first">guest_nice: running a niced guest</p>
</li>
</ul>
<p>The “intr” line gives counts of interrupts  serviced since boot time, for each
of the  possible system interrupts.   The first  column  is the  total of  all
interrupts serviced  including  unnumbered  architecture specific  interrupts;
each  subsequent column is the  total for that particular numbered interrupt.
Unnumbered interrupts are not shown, only summed into the total.</p>
<p>The “ctxt” line gives the total number of context switches across all CPUs.</p>
<p>The “btime” line gives  the time at which the  system booted, in seconds since
the Unix epoch.</p>
<p>The “processes” line gives the number  of processes and threads created, which
includes (but  is not limited  to) those  created by  calls to the  fork() and
clone() system calls.</p>
<p>The “procs_running” line gives the total number of threads that are
running or ready to run (i.e., the total number of runnable threads).</p>
<p>The   “procs_blocked” line gives  the  number of  processes currently blocked,
waiting for I/O to complete.</p>
<p>The “softirq” line gives counts of softirqs serviced since boot time, for each
of the possible system softirqs. The first column is the total of all
softirqs serviced; each subsequent column is the total for that particular
softirq.</p>
</div>
<div class="section" id="ext4-file-system-parameters">
<h3>1.9 Ext4 file system parameters<a class="headerlink" href="#ext4-file-system-parameters" title="Permalink to this headline">¶</a></h3>
<p>Information about mounted ext4 file systems can be found in
/proc/fs/ext4.  Each mounted filesystem will have a directory in
/proc/fs/ext4 based on its device name (i.e., /proc/fs/ext4/hdc or
/proc/fs/ext4/dm-0).   The files in each per-device directory are shown
in Table 1-12, below.</p>
<table border="1" class="docutils" id="id18">
<caption><span class="caption-text">Table 1-12: Files in /proc/fs/ext4/&lt;devname&gt;</span><a class="headerlink" href="#id18" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>File</td>
<td>Content</td>
</tr>
<tr class="row-even"><td>mb_groups</td>
<td>details of multiblock allocator buddy cache of free blocks</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="proc-consoles">
<h3>2.0 /proc/consoles<a class="headerlink" href="#proc-consoles" title="Permalink to this headline">¶</a></h3>
<p>Shows registered system console lines.</p>
<p>To see which character device lines are currently used for the system console
/dev/console, you may simply look into the file /proc/consoles:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; cat /proc/consoles
tty0                 -WU (ECp)       4:7
ttyS0                -W- (Ep)        4:64
</pre></div>
</div>
<p>The columns are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">device</th>
<th class="head">name of the device</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>operations</td>
<td><ul class="first last simple">
<li>R = can do read operations</li>
<li>W = can do write operations</li>
<li>U = can do unblank</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>flags</td>
<td><ul class="first last simple">
<li>E = it is enabled</li>
<li>C = it is preferred console</li>
<li>B = it is primary boot console</li>
<li>p = it is used for printk buffer</li>
<li>b = it is not a TTY but a Braille device</li>
<li>a = it is safe to use when cpu is offline</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>major:minor</td>
<td>major and minor number of the device separated by a
colon</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>The /proc file system serves information about the running system. It not only
allows access to process data but also allows you to request the kernel status
by reading files in the hierarchy.</p>
<p>The directory  structure  of /proc reflects the types of information and makes
it easy, if not obvious, where to look for specific data.</p>
</div>
</div>
<div class="section" id="chapter-2-modifying-system-parameters">
<h2>Chapter 2: Modifying System Parameters<a class="headerlink" href="#chapter-2-modifying-system-parameters" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>In This Chapter<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Modifying kernel parameters by writing into files found in /proc/sys</li>
<li>Exploring the files which modify certain parameters</li>
<li>Review of the /proc/sys file tree</li>
</ul>
<hr class="docutils" />
<p>A very  interesting part of /proc is the directory /proc/sys. This is not only
a source  of  information,  it also allows you to change parameters within the
kernel. Be  very  careful  when attempting this. You can optimize your system,
but you  can  also  cause  it  to  crash.  Never  alter kernel parameters on a
production system.  Set  up  a  development machine and test to make sure that
everything works  the  way  you want it to. You may have no alternative but to
reboot the machine once an error has been made.</p>
<p>To change  a  value,  simply  echo  the new value into the file. An example is
given below  in the section on the file system data. You need to be root to do
this. You  can  create  your  own  boot script to perform this every time your
system boots.</p>
<p>The files  in /proc/sys can be used to fine tune and monitor miscellaneous and
general things  in  the operation of the Linux kernel. Since some of the files
can inadvertently  disrupt  your  system,  it  is  advisable  to  read  both
documentation and  source  before actually making adjustments. In any case, be
very careful  when  writing  to  any  of these files. The entries in /proc may
change slightly between the 2.1.* and the 2.2 kernel, so if there is any doubt
review the kernel documentation in the directory /usr/src/linux/Documentation.
This chapter  is  heavily  based  on the documentation included in the pre 2.2
kernels, and became part of it in version 2.2.1 of the Linux kernel.</p>
<p>Please see: Documentation/admin-guide/sysctl/ directory for descriptions of these
entries.</p>
</div>
<div class="section" id="id2">
<h3>Summary<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Certain aspects  of  kernel  behavior  can be modified at runtime, without the
need to  recompile  the kernel, or even to reboot the system. The files in the
/proc/sys tree  can  not only be read, but also modified. You can use the echo
command to write value into these files, thereby changing the default settings
of the kernel.</p>
</div>
</div>
<div class="section" id="chapter-3-per-process-parameters">
<h2>Chapter 3: Per-process Parameters<a class="headerlink" href="#chapter-3-per-process-parameters" title="Permalink to this headline">¶</a></h2>
<div class="section" id="proc-pid-oom-adj-proc-pid-oom-score-adj-adjust-the-oom-killer-score">
<h3>3.1 /proc/&lt;pid&gt;/oom_adj &amp; /proc/&lt;pid&gt;/oom_score_adj- Adjust the oom-killer score<a class="headerlink" href="#proc-pid-oom-adj-proc-pid-oom-score-adj-adjust-the-oom-killer-score" title="Permalink to this headline">¶</a></h3>
<p>These file can be used to adjust the badness heuristic used to select which
process gets killed in out of memory conditions.</p>
<p>The badness heuristic assigns a value to each candidate task ranging from 0
(never kill) to 1000 (always kill) to determine which process is targeted.  The
units are roughly a proportion along that range of allowed memory the process
may allocate from based on an estimation of its current memory and swap use.
For example, if a task is using all allowed memory, its badness score will be
1000.  If it is using half of its allowed memory, its score will be 500.</p>
<p>There is an additional factor included in the badness score: the current memory
and swap usage is discounted by 3% for root processes.</p>
<p>The amount of “allowed” memory depends on the context in which the oom killer
was called.  If it is due to the memory assigned to the allocating task’s cpuset
being exhausted, the allowed memory represents the set of mems assigned to that
cpuset.  If it is due to a mempolicy’s node(s) being exhausted, the allowed
memory represents the set of mempolicy nodes.  If it is due to a memory
limit (or swap limit) being reached, the allowed memory is that configured
limit.  Finally, if it is due to the entire system being out of memory, the
allowed memory represents all allocatable resources.</p>
<p>The value of /proc/&lt;pid&gt;/oom_score_adj is added to the badness score before it
is used to determine which task to kill.  Acceptable values range from -1000
(OOM_SCORE_ADJ_MIN) to +1000 (OOM_SCORE_ADJ_MAX).  This allows userspace to
polarize the preference for oom killing either by always preferring a certain
task or completely disabling it.  The lowest possible value, -1000, is
equivalent to disabling oom killing entirely for that task since it will always
report a badness score of 0.</p>
<p>Consequently, it is very simple for userspace to define the amount of memory to
consider for each task.  Setting a /proc/&lt;pid&gt;/oom_score_adj value of +500, for
example, is roughly equivalent to allowing the remainder of tasks sharing the
same system, cpuset, mempolicy, or memory controller resources to use at least
50% more memory.  A value of -500, on the other hand, would be roughly
equivalent to discounting 50% of the task’s allowed memory from being considered
as scoring against the task.</p>
<p>For backwards compatibility with previous kernels, /proc/&lt;pid&gt;/oom_adj may also
be used to tune the badness score.  Its acceptable values range from -16
(OOM_ADJUST_MIN) to +15 (OOM_ADJUST_MAX) and a special value of -17
(OOM_DISABLE) to disable oom killing entirely for that task.  Its value is
scaled linearly with /proc/&lt;pid&gt;/oom_score_adj.</p>
<p>The value of /proc/&lt;pid&gt;/oom_score_adj may be reduced no lower than the last
value set by a CAP_SYS_RESOURCE process. To reduce the value any lower
requires CAP_SYS_RESOURCE.</p>
<p>Caveat: when a parent task is selected, the oom killer will sacrifice any first
generation children with separate address spaces instead, if possible.  This
avoids servers and important system daemons from being killed and loses the
minimal amount of work.</p>
</div>
<div class="section" id="proc-pid-oom-score-display-current-oom-killer-score">
<h3>3.2 /proc/&lt;pid&gt;/oom_score - Display current oom-killer score<a class="headerlink" href="#proc-pid-oom-score-display-current-oom-killer-score" title="Permalink to this headline">¶</a></h3>
<p>This file can be used to check the current score used by the oom-killer is for
any given &lt;pid&gt;. Use it together with /proc/&lt;pid&gt;/oom_score_adj to tune which
process should be killed in an out-of-memory situation.</p>
</div>
<div class="section" id="proc-pid-io-display-the-io-accounting-fields">
<h3>3.3  /proc/&lt;pid&gt;/io - Display the IO accounting fields<a class="headerlink" href="#proc-pid-io-display-the-io-accounting-fields" title="Permalink to this headline">¶</a></h3>
<p>This file contains IO statistics for each running process</p>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>test:/tmp # dd if=/dev/zero of=/tmp/test.dat &amp;
[1] 3828

test:/tmp # cat /proc/3828/io
rchar: 323934931
wchar: 323929600
syscr: 632687
syscw: 632675
read_bytes: 0
write_bytes: 323932160
cancelled_write_bytes: 0
</pre></div>
</div>
</div>
<div class="section" id="description">
<h4>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h4>
<div class="section" id="rchar">
<h5>rchar<a class="headerlink" href="#rchar" title="Permalink to this headline">¶</a></h5>
<p>I/O counter: chars read
The number of bytes which this task has caused to be read from storage. This
is simply the sum of bytes which this process passed to read() and pread().
It includes things like tty IO and it is unaffected by whether or not actual
physical disk IO was required (the read might have been satisfied from
pagecache)</p>
</div>
<div class="section" id="wchar">
<h5>wchar<a class="headerlink" href="#wchar" title="Permalink to this headline">¶</a></h5>
<p>I/O counter: chars written
The number of bytes which this task has caused, or shall cause to be written
to disk. Similar caveats apply here as with rchar.</p>
</div>
<div class="section" id="syscr">
<h5>syscr<a class="headerlink" href="#syscr" title="Permalink to this headline">¶</a></h5>
<p>I/O counter: read syscalls
Attempt to count the number of read I/O operations, i.e. syscalls like read()
and pread().</p>
</div>
<div class="section" id="syscw">
<h5>syscw<a class="headerlink" href="#syscw" title="Permalink to this headline">¶</a></h5>
<p>I/O counter: write syscalls
Attempt to count the number of write I/O operations, i.e. syscalls like
write() and pwrite().</p>
</div>
<div class="section" id="read-bytes">
<h5>read_bytes<a class="headerlink" href="#read-bytes" title="Permalink to this headline">¶</a></h5>
<p>I/O counter: bytes read
Attempt to count the number of bytes which this process really did cause to
be fetched from the storage layer. Done at the <a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio()</span></code></a> level, so it is
accurate for block-backed filesystems. &lt;please add status regarding NFS and
CIFS at a later time&gt;</p>
</div>
<div class="section" id="write-bytes">
<h5>write_bytes<a class="headerlink" href="#write-bytes" title="Permalink to this headline">¶</a></h5>
<p>I/O counter: bytes written
Attempt to count the number of bytes which this process caused to be sent to
the storage layer. This is done at page-dirtying time.</p>
</div>
<div class="section" id="cancelled-write-bytes">
<h5>cancelled_write_bytes<a class="headerlink" href="#cancelled-write-bytes" title="Permalink to this headline">¶</a></h5>
<p>The big inaccuracy here is truncate. If a process writes 1MB to a file and
then deletes the file, it will in fact perform no writeout. But it will have
been accounted as having caused 1MB of write.
In other words: The number of bytes which this process caused to not happen,
by truncating pagecache. A task can cause “negative” IO too. If this task
truncates some dirty pagecache, some IO which another task has been accounted
for (in its write_bytes) will not be happening. We _could_ just subtract that
from the truncating task’s write_bytes, but there is information loss in doing
that.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">At its current implementation state, this is a bit racy on 32-bit machines:
if process A reads process B’s /proc/pid/io while process B is updating one
of those 64-bit counters, process A could see an intermediate result.</p>
</div>
<p>More information about this can be found within the taskstats documentation in
Documentation/accounting.</p>
</div>
</div>
</div>
<div class="section" id="proc-pid-coredump-filter-core-dump-filtering-settings">
<h3>3.4 /proc/&lt;pid&gt;/coredump_filter - Core dump filtering settings<a class="headerlink" href="#proc-pid-coredump-filter-core-dump-filtering-settings" title="Permalink to this headline">¶</a></h3>
<p>When a process is dumped, all anonymous memory is written to a core file as
long as the size of the core file isn’t limited. But sometimes we don’t want
to dump some memory segments, for example, huge shared memory or DAX.
Conversely, sometimes we want to save file-backed memory segments into a core
file, not only the individual files.</p>
<p>/proc/&lt;pid&gt;/coredump_filter allows you to customize which memory segments
will be dumped when the &lt;pid&gt; process is dumped. coredump_filter is a bitmask
of memory types. If a bit of the bitmask is set, memory segments of the
corresponding memory type are dumped, otherwise they are not dumped.</p>
<p>The following 9 memory types are supported:</p>
<blockquote>
<div><ul class="simple">
<li>(bit 0) anonymous private memory</li>
<li>(bit 1) anonymous shared memory</li>
<li>(bit 2) file-backed private memory</li>
<li>(bit 3) file-backed shared memory</li>
<li>(bit 4) ELF header pages in file-backed private memory areas (it is
effective only if the bit 2 is cleared)</li>
<li>(bit 5) hugetlb private memory</li>
<li>(bit 6) hugetlb shared memory</li>
<li>(bit 7) DAX private memory</li>
<li>(bit 8) DAX shared memory</li>
</ul>
<p>Note that MMIO pages such as frame buffer are never dumped and vDSO pages
are always dumped regardless of the bitmask status.</p>
<p>Note that bits 0-4 don’t affect hugetlb or DAX memory. hugetlb memory is
only affected by bit 5-6, and DAX is only affected by bits 7-8.</p>
</div></blockquote>
<p>The default value of coredump_filter is 0x33; this means all anonymous memory
segments, ELF header pages and hugetlb private memory are dumped.</p>
<p>If you don’t want to dump all shared memory segments attached to pid 1234,
write 0x31 to the process’s proc file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo 0x31 &gt; /proc/1234/coredump_filter
</pre></div>
</div>
<p>When a new process is created, the process inherits the bitmask status from its
parent. It is useful to set up coredump_filter before the program runs.
For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo 0x7 &gt; /proc/self/coredump_filter
$ ./some_program
</pre></div>
</div>
</div>
<div class="section" id="proc-pid-mountinfo-information-about-mounts">
<h3>3.5     /proc/&lt;pid&gt;/mountinfo - Information about mounts<a class="headerlink" href="#proc-pid-mountinfo-information-about-mounts" title="Permalink to this headline">¶</a></h3>
<p>This file contains lines of the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>36 35 98:0 /mnt1 /mnt2 rw,noatime master:1 - ext3 /dev/root rw,errors=continue
(1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)

(1) mount ID:  unique identifier of the mount (may be reused after umount)
(2) parent ID:  ID of parent (or of self for the top of the mount tree)
(3) major:minor:  value of st_dev for files on filesystem
(4) root:  root of the mount within the filesystem
(5) mount point:  mount point relative to the process&#39;s root
(6) mount options:  per mount options
(7) optional fields:  zero or more fields of the form &quot;tag[:value]&quot;
(8) separator:  marks the end of the optional fields
(9) filesystem type:  name of filesystem of the form &quot;type[.subtype]&quot;
(10) mount source:  filesystem specific information or &quot;none&quot;
(11) super options:  per super block options
</pre></div>
</div>
<p>Parsers should ignore all unrecognised optional fields.  Currently the
possible optional fields are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>shared:X</td>
<td>mount is shared in peer group X</td>
</tr>
<tr class="row-even"><td>master:X</td>
<td>mount is slave to peer group X</td>
</tr>
<tr class="row-odd"><td>propagate_from:X</td>
<td>mount is slave and receives propagation from peer group X <a class="footnote-reference" href="#id4" id="id3">[1]</a></td>
</tr>
<tr class="row-even"><td>unbindable</td>
<td>mount is unbindable</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>X is the closest dominant peer group under the process’s root.  If
X is the immediate master of the mount, or if there’s no dominant peer
group under the same root, then only the “master:X” field is present
and not the “propagate_from:X” field.</td></tr>
</tbody>
</table>
<p>For more information on mount propagation see:</p>
<blockquote>
<div>Documentation/filesystems/sharedsubtree.rst</div></blockquote>
</div>
<div class="section" id="proc-pid-comm-proc-pid-task-tid-comm">
<h3>3.6     /proc/&lt;pid&gt;/comm  &amp; /proc/&lt;pid&gt;/task/&lt;tid&gt;/comm<a class="headerlink" href="#proc-pid-comm-proc-pid-task-tid-comm" title="Permalink to this headline">¶</a></h3>
<p>These files provide a method to access a tasks comm value. It also allows for
a task to set its own or one of its thread siblings comm value. The comm value
is limited in size compared to the cmdline value, so writing anything longer
then the kernel’s TASK_COMM_LEN (currently 16 chars) will result in a truncated
comm value.</p>
</div>
<div class="section" id="proc-pid-task-tid-children-information-about-task-children">
<h3>3.7     /proc/&lt;pid&gt;/task/&lt;tid&gt;/children - Information about task children<a class="headerlink" href="#proc-pid-task-tid-children-information-about-task-children" title="Permalink to this headline">¶</a></h3>
<p>This file provides a fast way to retrieve first level children pids
of a task pointed by &lt;pid&gt;/&lt;tid&gt; pair. The format is a space separated
stream of pids.</p>
<p>Note the “first level” here – if a child has own children they will
not be listed here, one needs to read /proc/&lt;children-pid&gt;/task/&lt;tid&gt;/children
to obtain the descendants.</p>
<p>Since this interface is intended to be fast and cheap it doesn’t
guarantee to provide precise results and some children might be
skipped, especially if they’ve exited right after we printed their
pids, so one need to either stop or freeze processes being inspected
if precise results are needed.</p>
</div>
<div class="section" id="proc-pid-fdinfo-fd-information-about-opened-file">
<h3>3.8     /proc/&lt;pid&gt;/fdinfo/&lt;fd&gt; - Information about opened file<a class="headerlink" href="#proc-pid-fdinfo-fd-information-about-opened-file" title="Permalink to this headline">¶</a></h3>
<p>This file provides information associated with an opened file. The regular
files have at least three fields – ‘pos’, ‘flags’ and mnt_id. The ‘pos’
represents the current offset of the opened file in decimal form [see lseek(2)
for details], ‘flags’ denotes the octal O_xxx mask the file has been
created with [see open(2) for details] and ‘mnt_id’ represents mount ID of
the file system containing the opened file [see 3.5 /proc/&lt;pid&gt;/mountinfo
for details].</p>
<p>A typical output is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pos:    0
flags:  0100002
mnt_id: 19
</pre></div>
</div>
<p>All locks associated with a file descriptor are shown in its fdinfo too:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lock:       1: FLOCK  ADVISORY  WRITE 359 00:13:11691 0 EOF
</pre></div>
</div>
<p>The files such as eventfd, fsnotify, signalfd, epoll among the regular pos/flags
pair provide additional information particular to the objects they represent.</p>
<div class="section" id="eventfd-files">
<h4>Eventfd files<a class="headerlink" href="#eventfd-files" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pos:    0
flags:  04002
mnt_id: 9
eventfd-count:  5a
</pre></div>
</div>
<p>where ‘eventfd-count’ is hex value of a counter.</p>
</div>
<div class="section" id="signalfd-files">
<h4>Signalfd files<a class="headerlink" href="#signalfd-files" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pos:    0
flags:  04002
mnt_id: 9
sigmask:        0000000000000200
</pre></div>
</div>
<p>where ‘sigmask’ is hex value of the signal mask associated
with a file.</p>
</div>
<div class="section" id="epoll-files">
<h4>Epoll files<a class="headerlink" href="#epoll-files" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pos:    0
flags:  02
mnt_id: 9
tfd:        5 events:       1d data: ffffffffffffffff pos:0 ino:61af sdev:7
</pre></div>
</div>
<p>where ‘tfd’ is a target file descriptor number in decimal form,
‘events’ is events mask being watched and the ‘data’ is data
associated with a target [see epoll(7) for more details].</p>
<p>The ‘pos’ is current offset of the target file in decimal form
[see lseek(2)], ‘ino’ and ‘sdev’ are inode and device numbers
where target file resides, all in hex format.</p>
</div>
<div class="section" id="fsnotify-files">
<h4>Fsnotify files<a class="headerlink" href="#fsnotify-files" title="Permalink to this headline">¶</a></h4>
<p>For inotify files the format is the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pos:    0
flags:  02000000
inotify wd:3 ino:9e7e sdev:800013 mask:800afce ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:7e9e0000640d1b6d
</pre></div>
</div>
<p>where ‘wd’ is a watch descriptor in decimal form, ie a target file
descriptor number, ‘ino’ and ‘sdev’ are inode and device where the
target file resides and the ‘mask’ is the mask of events, all in hex
form [see inotify(7) for more details].</p>
<p>If the kernel was built with exportfs support, the path to the target
file is encoded as a file handle.  The file handle is provided by three
fields ‘fhandle-bytes’, ‘fhandle-type’ and ‘f_handle’, all in hex
format.</p>
<p>If the kernel is built without exportfs support the file handle won’t be
printed out.</p>
<p>If there is no inotify mark attached yet the ‘inotify’ line will be omitted.</p>
<p>For fanotify files the format is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pos:    0
flags:  02
mnt_id: 9
fanotify flags:10 event-flags:0
fanotify mnt_id:12 mflags:40 mask:38 ignored_mask:40000003
fanotify ino:4f969 sdev:800013 mflags:0 mask:3b ignored_mask:40000000 fhandle-bytes:8 fhandle-type:1 f_handle:69f90400c275b5b4
</pre></div>
</div>
<p>where fanotify ‘flags’ and ‘event-flags’ are values used in fanotify_init
call, ‘mnt_id’ is the mount point identifier, ‘mflags’ is the value of
flags associated with mark which are tracked separately from events
mask. ‘ino’, ‘sdev’ are target inode and device, ‘mask’ is the events
mask and ‘ignored_mask’ is the mask of events which are to be ignored.
All in hex format. Incorporation of ‘mflags’, ‘mask’ and ‘ignored_mask’
does provide information about flags and mask used in fanotify_mark
call [see fsnotify manpage for details].</p>
<p>While the first three lines are mandatory and always printed, the rest is
optional and may be omitted if no marks created yet.</p>
</div>
<div class="section" id="timerfd-files">
<h4>Timerfd files<a class="headerlink" href="#timerfd-files" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pos:    0
flags:  02
mnt_id: 9
clockid: 0
ticks: 0
settime flags: 01
it_value: (0, 49406829)
it_interval: (1, 0)
</pre></div>
</div>
<p>where ‘clockid’ is the clock type and ‘ticks’ is the number of the timer expirations
that have occurred [see timerfd_create(2) for details]. ‘settime flags’ are
flags in octal form been used to setup the timer [see timerfd_settime(2) for
details]. ‘it_value’ is remaining time until the timer exiration.
‘it_interval’ is the interval for the timer. Note the timer might be set up
with TIMER_ABSTIME option which will be shown in ‘settime flags’, but ‘it_value’
still exhibits timer’s remaining time.</p>
</div>
</div>
<div class="section" id="proc-pid-map-files-information-about-memory-mapped-files">
<h3>3.9     /proc/&lt;pid&gt;/map_files - Information about memory mapped files<a class="headerlink" href="#proc-pid-map-files-information-about-memory-mapped-files" title="Permalink to this headline">¶</a></h3>
<p>This directory contains symbolic links which represent memory mapped files
the process is maintaining.  Example output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>| lr-------- 1 root root 64 Jan 27 11:24 333c600000-333c620000 -&gt; /usr/lib64/ld-2.18.so
| lr-------- 1 root root 64 Jan 27 11:24 333c81f000-333c820000 -&gt; /usr/lib64/ld-2.18.so
| lr-------- 1 root root 64 Jan 27 11:24 333c820000-333c821000 -&gt; /usr/lib64/ld-2.18.so
| ...
| lr-------- 1 root root 64 Jan 27 11:24 35d0421000-35d0422000 -&gt; /usr/lib64/libselinux.so.1
| lr-------- 1 root root 64 Jan 27 11:24 400000-41a000 -&gt; /usr/bin/ls
</pre></div>
</div>
<p>The name of a link represents the virtual memory bounds of a mapping, i.e.
vm_area_struct::vm_start-vm_area_struct::vm_end.</p>
<p>The main purpose of the map_files is to retrieve a set of memory mapped
files in a fast way instead of parsing /proc/&lt;pid&gt;/maps or
/proc/&lt;pid&gt;/smaps, both of which contain many more records.  At the same
time one can open(2) mappings from the listings of two processes and
comparing their inode numbers to figure out which anonymous memory areas
are actually shared.</p>
</div>
<div class="section" id="proc-pid-timerslack-ns-task-timerslack-value">
<h3>3.10    /proc/&lt;pid&gt;/timerslack_ns - Task timerslack value<a class="headerlink" href="#proc-pid-timerslack-ns-task-timerslack-value" title="Permalink to this headline">¶</a></h3>
<p>This file provides the value of the task’s timerslack value in nanoseconds.
This value specifies a amount of time that normal timers may be deferred
in order to coalesce timers and avoid unnecessary wakeups.</p>
<p>This allows a task’s interactivity vs power consumption trade off to be
adjusted.</p>
<p>Writing 0 to the file will set the tasks timerslack to the default value.</p>
<p>Valid values are from 0 - ULLONG_MAX</p>
<p>An application setting the value must have PTRACE_MODE_ATTACH_FSCREDS level
permissions on the task specified to change its timerslack_ns value.</p>
</div>
<div class="section" id="proc-pid-patch-state-livepatch-patch-operation-state">
<h3>3.11    /proc/&lt;pid&gt;/patch_state - Livepatch patch operation state<a class="headerlink" href="#proc-pid-patch-state-livepatch-patch-operation-state" title="Permalink to this headline">¶</a></h3>
<p>When CONFIG_LIVEPATCH is enabled, this file displays the value of the
patch state for the task.</p>
<p>A value of ‘-1’ indicates that no patch is in transition.</p>
<p>A value of ‘0’ indicates that a patch is in transition and the task is
unpatched.  If the patch is being enabled, then the task hasn’t been
patched yet.  If the patch is being disabled, then the task has already
been unpatched.</p>
<p>A value of ‘1’ indicates that a patch is in transition and the task is
patched.  If the patch is being enabled, then the task has already been
patched.  If the patch is being disabled, then the task hasn’t been
unpatched yet.</p>
</div>
<div class="section" id="proc-pid-arch-status-task-architecture-specific-status">
<h3>3.12 /proc/&lt;pid&gt;/arch_status - task architecture specific status<a class="headerlink" href="#proc-pid-arch-status-task-architecture-specific-status" title="Permalink to this headline">¶</a></h3>
<p>When CONFIG_PROC_PID_ARCH_STATUS is enabled, this file displays the
architecture specific status of the task.</p>
<div class="section" id="id5">
<h4>Example<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /proc/6753/arch_status
AVX512_elapsed_ms:      8
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>Description<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="x86-specific-entries">
<h4>x86 specific entries:<a class="headerlink" href="#x86-specific-entries" title="Permalink to this headline">¶</a></h4>
<div class="section" id="avx512-elapsed-ms">
<h5>AVX512_elapsed_ms:<a class="headerlink" href="#avx512-elapsed-ms" title="Permalink to this headline">¶</a></h5>
<blockquote>
<div><p>If AVX512 is supported on the machine, this entry shows the milliseconds
elapsed since the last time AVX512 usage was recorded. The recording
happens on a best effort basis when a task is scheduled out. This means
that the value depends on two factors:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The time which the task spent on the CPU without being scheduled
out. With CPU isolation and a single runnable task this can take
several seconds.</li>
<li>The time since the task was scheduled out last. Depending on the
reason for being scheduled out (time slice exhausted, syscall …)
this can be arbitrary long time.</li>
</ol>
</div></blockquote>
<p>As a consequence the value cannot be considered precise and authoritative
information. The application which uses this information has to be aware
of the overall scenario on the system in order to determine whether a
task is a real AVX512 user or not. Precise information can be obtained
with performance counters.</p>
<p>A special value of ‘-1’ indicates that no AVX512 usage was recorded, thus
the task is unlikely an AVX512 user, but depends on the workload and the
scheduling scenario, it also could be a false negative mentioned above.</p>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="configuring-procfs">
<h3>Configuring procfs<a class="headerlink" href="#configuring-procfs" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="mount-options">
<h3>4.1     Mount options<a class="headerlink" href="#mount-options" title="Permalink to this headline">¶</a></h3>
<p>The following mount options are supported:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>hidepid=</td>
<td>Set /proc/&lt;pid&gt;/ access mode.</td>
</tr>
<tr class="row-even"><td>gid=</td>
<td>Set the group authorized to learn processes information.</td>
</tr>
<tr class="row-odd"><td>subset=</td>
<td>Show only the specified subset of procfs.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>hidepid=off or hidepid=0 means classic mode - everybody may access all
/proc/&lt;pid&gt;/ directories (default).</p>
<p>hidepid=noaccess or hidepid=1 means users may not access any /proc/&lt;pid&gt;/
directories but their own.  Sensitive files like cmdline, sched*, status are now
protected against other users.  This makes it impossible to learn whether any
user runs specific program (given the program doesn’t reveal itself by its
behaviour).  As an additional bonus, as /proc/&lt;pid&gt;/cmdline is unaccessible for
other users, poorly written programs passing sensitive information via program
arguments are now protected against local eavesdroppers.</p>
<p>hidepid=invisible or hidepid=2 means hidepid=1 plus all /proc/&lt;pid&gt;/ will be
fully invisible to other users.  It doesn’t mean that it hides a fact whether a
process with a specific pid value exists (it can be learned by other means, e.g.
by “kill -0 $PID”), but it hides process’ uid and gid, which may be learned by
stat()’ing /proc/&lt;pid&gt;/ otherwise.  It greatly complicates an intruder’s task of
gathering information about running processes, whether some daemon runs with
elevated privileges, whether other user runs some sensitive program, whether
other users run any program at all, etc.</p>
<p>hidepid=ptraceable or hidepid=4 means that procfs should only contain
/proc/&lt;pid&gt;/ directories that the caller can ptrace.</p>
<p>gid= defines a group authorized to learn processes information otherwise
prohibited by hidepid=.  If you use some daemon like identd which needs to learn
information about processes information, just add identd to this group.</p>
<p>subset=pid hides all top level files and directories in the procfs that
are not related to tasks.</p>
</div>
<div class="section" id="filesystem-behavior">
<h3>5       Filesystem behavior<a class="headerlink" href="#filesystem-behavior" title="Permalink to this headline">¶</a></h3>
<p>Originally, before the advent of pid namepsace, procfs was a global file
system. It means that there was only one procfs instance in the system.</p>
<p>When pid namespace was added, a separate procfs instance was mounted in
each pid namespace. So, procfs mount options are global among all
mountpoints within the same namespace.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># grep ^proc /proc/mounts
</pre></div>
</div>
<p>proc /proc proc rw,relatime,hidepid=2 0 0</p>
<p># strace -e mount mount -o hidepid=1 -t proc proc /tmp/proc
mount(“proc”, “/tmp/proc”, “proc”, 0, “hidepid=1”) = 0
+++ exited with 0 +++</p>
<p># grep ^proc /proc/mounts
proc /proc proc rw,relatime,hidepid=2 0 0
proc /tmp/proc proc rw,relatime,hidepid=2 0 0</p>
<p>and only after remounting procfs mount options will change at all
mountpoints.</p>
<p># mount -o remount,hidepid=1 -t proc proc /tmp/proc</p>
<p># grep ^proc /proc/mounts
proc /proc proc rw,relatime,hidepid=1 0 0
proc /tmp/proc proc rw,relatime,hidepid=1 0 0</p>
<p>This behavior is different from the behavior of other filesystems.</p>
<p>The new procfs behavior is more like other filesystems. Each procfs mount
creates a new procfs instance. Mount options affect own procfs instance.
It means that it became possible to have several procfs instances
displaying tasks with different filtering options in one pid namespace.</p>
<p># mount -o hidepid=invisible -t proc proc /proc
# mount -o hidepid=noaccess -t proc proc /tmp/proc
# grep ^proc /proc/mounts
proc /proc proc rw,relatime,hidepid=invisible 0 0
proc /tmp/proc proc rw,relatime,hidepid=noaccess 0 0</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>