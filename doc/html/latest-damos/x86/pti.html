

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>15. Page Table Isolation (PTI) &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>15. Page Table Isolation (PTI)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/x86/pti.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="page-table-isolation-pti">
<h1>15. Page Table Isolation (PTI)<a class="headerlink" href="#page-table-isolation-pti" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>15.1. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Page Table Isolation (pti, previously known as KAISER <a class="footnote-reference" href="#id3" id="id1">[1]</a>) is a
countermeasure against attacks on the shared user/kernel address
space such as the “Meltdown” approach <a class="footnote-reference" href="#id4" id="id2">[2]</a>.</p>
<p>To mitigate this class of attacks, we create an independent set of
page tables for use only when running userspace applications.  When
the kernel is entered via syscalls, interrupts or exceptions, the
page tables are switched to the full “kernel” copy.  When the system
switches back to user mode, the user copy is used again.</p>
<p>The userspace page tables contain only a minimal amount of kernel
data: only what is needed to enter/exit the kernel such as the
entry/exit functions themselves and the interrupt descriptor table
(IDT).  There are a few strictly unnecessary things that get mapped
such as the first C function when entering an interrupt (see
comments in pti.c).</p>
<p>This approach helps to ensure that side-channel attacks leveraging
the paging structures do not function when PTI is enabled.  It can be
enabled by setting CONFIG_PAGE_TABLE_ISOLATION=y at compile time.
Once enabled at compile-time, it can be disabled at boot with the
‘nopti’ or ‘pti=’ kernel parameters (see kernel-parameters.txt).</p>
</div>
<div class="section" id="page-table-management">
<h2>15.2. Page Table Management<a class="headerlink" href="#page-table-management" title="Permalink to this headline">¶</a></h2>
<p>When PTI is enabled, the kernel manages two sets of page tables.
The first set is very similar to the single set which is present in
kernels without PTI.  This includes a complete mapping of userspace
that the kernel can use for things like copy_to_user().</p>
<p>Although _complete_, the user portion of the kernel page tables is
crippled by setting the NX bit in the top level.  This ensures
that any missed kernel-&gt;user CR3 switch will immediately crash
userspace upon executing its first instruction.</p>
<p>The userspace page tables map only the kernel data needed to enter
and exit the kernel.  This data is entirely contained in the ‘struct
cpu_entry_area’ structure which is placed in the fixmap which gives
each CPU’s copy of the area a compile-time-fixed virtual address.</p>
<p>For new userspace mappings, the kernel makes the entries in its
page tables like normal.  The only difference is when the kernel
makes entries in the top (PGD) level.  In addition to setting the
entry in the main kernel PGD, a copy of the entry is made in the
userspace page tables’ PGD.</p>
<p>This sharing at the PGD level also inherently shares all the lower
layers of the page tables.  This leaves a single, shared set of
userspace page tables to manage.  One PTE to lock, one set of
accessed bits, dirty bits, etc…</p>
</div>
<div class="section" id="overhead">
<h2>15.3. Overhead<a class="headerlink" href="#overhead" title="Permalink to this headline">¶</a></h2>
<p>Protection against side-channel attacks is important.  But,
this protection comes at a cost:</p>
<ol class="arabic simple">
<li>Increased Memory Use</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>Each process now needs an order-1 PGD instead of order-0.
(Consumes an additional 4k per process).</li>
<li>The ‘cpu_entry_area’ structure must be 2MB in size and 2MB
aligned so that it can be mapped by setting a single PMD
entry.  This consumes nearly 2MB of RAM once the kernel
is decompressed, but no space in the kernel image itself.</li>
</ol>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>Runtime Cost</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>CR3 manipulation to switch between the page table copies
must be done at interrupt, syscall, and exception entry
and exit (it can be skipped when the kernel is interrupted,
though.)  Moves to CR3 are on the order of a hundred
cycles, and are required at every entry and exit.</li>
<li>A “trampoline” must be used for SYSCALL entry.  This
trampoline depends on a smaller set of resources than the
non-PTI SYSCALL entry code, so requires mapping fewer
things into the userspace page tables.  The downside is
that stacks must be switched at entry time.</li>
<li>Global pages are disabled for all kernel structures not
mapped into both kernel and userspace page tables.  This
feature of the MMU allows different processes to share TLB
entries mapping the kernel.  Losing the feature means more
TLB misses after a context switch.  The actual loss of
performance is very small, however, never exceeding 1%.</li>
<li>Process Context IDentifiers (PCID) is a CPU feature that
allows us to skip flushing the entire TLB when switching page
tables by setting a special bit in CR3 when the page tables
are changed.  This makes switching the page tables (at context
switch, or kernel entry/exit) cheaper.  But, on systems with
PCID support, the context switch code must flush both the user
and kernel entries out of the TLB.  The user PCID TLB flush is
deferred until the exit to userspace, minimizing the cost.
See intel.com/sdm for the gory PCID/INVPCID details.</li>
<li>The userspace page tables must be populated for each new
process.  Even without PTI, the shared kernel mappings
are created by copying top-level (PGD) entries into each
new process.  But, with PTI, there are now <em>two</em> kernel
mappings: one in the kernel page tables that maps everything
and one for the entry/exit structures.  At fork(), we need to
copy both.</li>
<li>In addition to the fork()-time copying, there must also
be an update to the userspace PGD any time a set_pgd() is done
on a PGD used to map userspace.  This ensures that the kernel
and userspace copies always map the same userspace
memory.</li>
<li>On systems without PCID support, each CR3 write flushes
the entire TLB.  That means that each syscall, interrupt
or exception flushes the TLB.</li>
<li>INVPCID is a TLB-flushing instruction which allows flushing
of TLB entries for non-current PCIDs.  Some systems support
PCIDs, but do not support INVPCID.  On these systems, addresses
can only be flushed from the TLB for the current PCID.  When
flushing a kernel address, we need to flush all PCIDs, so a
single kernel address flush will require a TLB-flushing CR3
write upon the next use of every PCID.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="possible-future-work">
<h2>15.4. Possible Future Work<a class="headerlink" href="#possible-future-work" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>We can be more careful about not actually writing to CR3
unless its value is actually changed.</li>
<li>Allow PTI to be enabled/disabled at runtime in addition to the
boot-time switching.</li>
</ol>
</div>
<div class="section" id="testing">
<h2>15.5. Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>To test stability of PTI, the following test procedure is recommended,
ideally doing all of these in parallel:</p>
<ol class="arabic">
<li><p class="first">Set CONFIG_DEBUG_ENTRY=y</p>
</li>
<li><p class="first">Run several copies of all of the tools/testing/selftests/x86/ tests
(excluding MPX and protection_keys) in a loop on multiple CPUs for
several minutes.  These tests frequently uncover corner cases in the
kernel entry code.  In general, old kernels might cause these tests
themselves to crash, but they should never crash the kernel.</p>
</li>
<li><p class="first">Run the ‘perf’ tool in a mode (top or record) that generates many
frequent performance monitoring non-maskable interrupts (see “NMI”
in /proc/interrupts).  This exercises the NMI entry/exit code which
is known to trigger bugs in code paths that did not expect to be
interrupted, including nested NMIs.  Using “-c” boosts the rate of
NMIs, and using two -c with separate counters encourages nested NMIs
and less deterministic behavior.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while true; do perf record -c 10000 -e instructions,cycles -a sleep 10; done
</pre></div>
</div>
</li>
<li><p class="first">Launch a KVM virtual machine.</p>
</li>
<li><p class="first">Run 32-bit binaries on systems supporting the SYSCALL instruction.
This has been a lightly-tested code path and needs extra scrutiny.</p>
</li>
</ol>
</div>
<div class="section" id="debugging">
<h2>15.6. Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h2>
<p>Bugs in PTI cause a few different signatures of crashes
that are worth noting here.</p>
<blockquote>
<div><ul class="simple">
<li>Failures of the selftests/x86 code.  Usually a bug in one of the
more obscure corners of entry_64.S</li>
<li>Crashes in early boot, especially around CPU bringup.  Bugs
in the trampoline code or mappings cause these.</li>
<li>Crashes at the first interrupt.  Caused by bugs in entry_64.S,
like screwing up a page table switch.  Also caused by
incorrectly mapping the IRQ handler entry code.</li>
<li>Crashes at the first NMI.  The NMI code is separate from main
interrupt handlers and can have bugs that do not affect
normal interrupts.  Also caused by incorrectly mapping NMI
code.  NMIs that interrupt the entry code must be very
careful and can be the cause of crashes that show up when
running perf.</li>
<li>Kernel crashes at the first exit to userspace.  entry_64.S
bugs, or failing to map some of the exit code.</li>
<li>Crashes at first interrupt that interrupts userspace. The paths
in entry_64.S that return to userspace are sometimes separate
from the ones that return to the kernel.</li>
<li>Double faults: overflowing the kernel stack because of page
faults upon page faults.  Caused by touching non-pti-mapped
data in the entry code, or forgetting to switch to kernel
CR3 before calling into C functions which are not pti-mapped.</li>
<li>Userspace segfaults early in boot, sometimes manifesting
as mount(8) failing to mount the rootfs.  These have
tended to be TLB invalidation issues.  Usually invalidating
the wrong PCID, or otherwise missing an invalidation.</li>
</ul>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://gruss.cc/files/kaiser.pdf">https://gruss.cc/files/kaiser.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="https://meltdownattack.com/meltdown.pdf">https://meltdownattack.com/meltdown.pdf</a></td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>