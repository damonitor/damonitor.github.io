

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PCI Peer-to-Peer DMA Support &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>PCI Peer-to-Peer DMA Support</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/pci/p2pdma.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pci-peer-to-peer-dma-support">
<h1>PCI Peer-to-Peer DMA Support<a class="headerlink" href="#pci-peer-to-peer-dma-support" title="Permalink to this headline">¶</a></h1>
<p>The PCI bus has pretty decent support for performing DMA transfers
between two devices on the bus. This type of transaction is henceforth
called Peer-to-Peer (or P2P). However, there are a number of issues that
make P2P transactions tricky to do in a perfectly safe way.</p>
<p>One of the biggest issues is that PCI doesn’t require forwarding
transactions between hierarchy domains, and in PCIe, each Root Port
defines a separate hierarchy domain. To make things worse, there is no
simple way to determine if a given Root Complex supports this or not.
(See PCIe r4.0, sec 1.3.1). Therefore, as of this writing, the kernel
only supports doing P2P when the endpoints involved are all behind the
same PCI bridge, as such devices are all in the same PCI hierarchy
domain, and the spec guarantees that all transactions within the
hierarchy will be routable, but it does not require routing
between hierarchies.</p>
<p>The second issue is that to make use of existing interfaces in Linux,
memory that is used for P2P transactions needs to be backed by struct
pages. However, PCI BARs are not typically cache coherent so there are
a few corner case gotchas with these pages so developers need to
be careful about what they do with them.</p>
<div class="section" id="driver-writer-s-guide">
<h2>Driver Writer’s Guide<a class="headerlink" href="#driver-writer-s-guide" title="Permalink to this headline">¶</a></h2>
<p>In a given P2P implementation there may be three or more different
types of kernel drivers in play:</p>
<ul class="simple">
<li>Provider - A driver which provides or publishes P2P resources like
memory or doorbell registers to other drivers.</li>
<li>Client - A driver which makes use of a resource by setting up a
DMA transaction to or from it.</li>
<li>Orchestrator - A driver which orchestrates the flow of data between
clients and providers.</li>
</ul>
<p>In many cases there could be overlap between these three types (i.e.,
it may be typical for a driver to be both a provider and a client).</p>
<p>For example, in the NVMe Target Copy Offload implementation:</p>
<ul class="simple">
<li>The NVMe PCI driver is both a client, provider and orchestrator
in that it exposes any CMB (Controller Memory Buffer) as a P2P memory
resource (provider), it accepts P2P memory pages as buffers in requests
to be used directly (client) and it can also make use of the CMB as
submission queue entries (orchestrator).</li>
<li>The RDMA driver is a client in this arrangement so that an RNIC
can DMA directly to the memory exposed by the NVMe device.</li>
<li>The NVMe Target driver (nvmet) can orchestrate the data from the RNIC
to the P2P memory (CMB) and then to the NVMe device (and vice versa).</li>
</ul>
<p>This is currently the only arrangement supported by the kernel but
one could imagine slight tweaks to this that would allow for the same
functionality. For example, if a specific RNIC added a BAR with some
memory behind it, its driver could add support as a P2P provider and
then the NVMe Target could use the RNIC’s memory instead of the CMB
in cases where the NVMe cards in use do not have CMB support.</p>
<div class="section" id="provider-drivers">
<h3>Provider Drivers<a class="headerlink" href="#provider-drivers" title="Permalink to this headline">¶</a></h3>
<p>A provider simply needs to register a BAR (or a portion of a BAR)
as a P2P DMA resource using <a class="reference internal" href="#c.pci_p2pdma_add_resource" title="pci_p2pdma_add_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_add_resource()</span></code></a>.
This will register struct pages for all the specified memory.</p>
<p>After that it may optionally publish all of its resources as
P2P memory using <a class="reference internal" href="#c.pci_p2pmem_publish" title="pci_p2pmem_publish"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_publish()</span></code></a>. This will allow
any orchestrator drivers to find and use the memory. When marked in
this way, the resource must be regular memory with no side effects.</p>
<p>For the time being this is fairly rudimentary in that all resources
are typically going to be P2P memory. Future work will likely expand
this to include other types of resources like doorbells.</p>
</div>
<div class="section" id="client-drivers">
<h3>Client Drivers<a class="headerlink" href="#client-drivers" title="Permalink to this headline">¶</a></h3>
<p>A client driver typically only has to conditionally change its DMA map
routine to use the mapping function <code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_map_sg()</span></code> instead
of the usual <code class="xref c c-func docutils literal notranslate"><span class="pre">dma_map_sg()</span></code> function. Memory mapped in this
way does not need to be unmapped.</p>
<p>The client may also, optionally, make use of
<code class="xref c c-func docutils literal notranslate"><span class="pre">is_pci_p2pdma_page()</span></code> to determine when to use the P2P mapping
functions and when to use the regular mapping functions. In some
situations, it may be more appropriate to use a flag to indicate a
given request is P2P memory and map appropriately. It is important to
ensure that struct pages that back P2P memory stay out of code that
does not have support for them as other code may treat the pages as
regular memory which may not be appropriate.</p>
</div>
<div class="section" id="orchestrator-drivers">
<h3>Orchestrator Drivers<a class="headerlink" href="#orchestrator-drivers" title="Permalink to this headline">¶</a></h3>
<p>The first task an orchestrator driver must do is compile a list of
all client devices that will be involved in a given transaction. For
example, the NVMe Target driver creates a list including the namespace
block device and the RNIC in use. If the orchestrator has access to
a specific P2P provider to use it may check compatibility using
<code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_distance()</span></code> otherwise it may find a memory provider
that’s compatible with all clients using  <code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_find()</span></code>.
If more than one provider is supported, the one nearest to all the clients will
be chosen first. If more than one provider is an equal distance away, the
one returned will be chosen at random (it is not an arbitrary but
truly random). This function returns the PCI device to use for the provider
with a reference taken and therefore when it’s no longer needed it should be
returned with <a class="reference internal" href="pci.html#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_dev_put()</span></code></a>.</p>
<p>Once a provider is selected, the orchestrator can then use
<a class="reference internal" href="#c.pci_alloc_p2pmem" title="pci_alloc_p2pmem"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_p2pmem()</span></code></a> and <a class="reference internal" href="#c.pci_free_p2pmem" title="pci_free_p2pmem"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_free_p2pmem()</span></code></a> to
allocate P2P memory from the provider. <a class="reference internal" href="#c.pci_p2pmem_alloc_sgl" title="pci_p2pmem_alloc_sgl"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_alloc_sgl()</span></code></a>
and <a class="reference internal" href="#c.pci_p2pmem_free_sgl" title="pci_p2pmem_free_sgl"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_free_sgl()</span></code></a> are convenience functions for
allocating scatter-gather lists with P2P memory.</p>
</div>
<div class="section" id="struct-page-caveats">
<h3>Struct Page Caveats<a class="headerlink" href="#struct-page-caveats" title="Permalink to this headline">¶</a></h3>
<p>Driver writers should be very careful about not passing these special
struct pages to code that isn’t prepared for it. At this time, the kernel
interfaces do not have any checks for ensuring this. This obviously
precludes passing these pages to userspace.</p>
<p>P2P memory is also technically IO memory but should never have any side
effects behind it. Thus, the order of loads and stores should not be important
and ioreadX(), iowriteX() and friends should not be necessary.</p>
</div>
</div>
<div class="section" id="p2p-dma-support-library">
<h2>P2P DMA Support Library<a class="headerlink" href="#p2p-dma-support-library" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.pci_p2pdma_add_resource">
int <code class="descname">pci_p2pdma_add_resource</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, int<em>&nbsp;bar</em>, size_t<em>&nbsp;size</em>, u64<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_add_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>add memory for use as p2p memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device to add the memory to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar</span></code></dt>
<dd>PCI BAR to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the memory to add, may be zero to use the whole BAR</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">offset</span></code></dt>
<dd>offset into the PCI BAR</dd>
</dl>
<p><strong>Description</strong></p>
<p>The memory will be given ZONE_DEVICE struct pages so that it may
be used with any DMA request.</p>
<dl class="function">
<dt id="c.pci_p2pdma_distance_many">
int <code class="descname">pci_p2pdma_distance_many</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;provider</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> **<em>&nbsp;clients</em>, int<em>&nbsp;num_clients</em>, bool<em>&nbsp;verbose</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_distance_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the cumulative distance between a p2pdma provider and the clients in use.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">provider</span></code></dt>
<dd>p2pdma provider to check against the client list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">**</span> <span class="pre">clients</span></code></dt>
<dd>array of devices to check (NULL-terminated)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clients</span></code></dt>
<dd>number of clients in the array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">verbose</span></code></dt>
<dd>if true, print warnings for devices when we return -1</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -1 if any of the clients are not compatible, otherwise returns a
positive number where a lower number is the preferable choice. (If there’s
one client that’s the same as the provider it will return 0, which is best
choice).</p>
<p>“compatible” means the provider and the clients are either all behind
the same PCI root port or the host bridges connected to each of the devices
are listed in the ‘pci_p2pdma_whitelist’.</p>
<dl class="function">
<dt id="c.pci_has_p2pmem">
bool <code class="descname">pci_has_p2pmem</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_has_p2pmem" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given PCI device has published any p2pmem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device to check</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pmem_find_many">
struct pci_dev * <code class="descname">pci_p2pmem_find_many</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> **<em>&nbsp;clients</em>, int<em>&nbsp;num_clients</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_find_many" title="Permalink to this definition">¶</a></dt>
<dd><p>find a peer-to-peer DMA memory device compatible with the specified list of clients and shortest distance (as determined by pci_p2pmem_dma())</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">**</span> <span class="pre">clients</span></code></dt>
<dd>array of devices to check (NULL-terminated)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clients</span></code></dt>
<dd>number of client devices in the list</dd>
</dl>
<p><strong>Description</strong></p>
<p>If multiple devices are behind the same switch, the one “closest” to the
client devices in use will be chosen first. (So if one of the providers is
the same as one of the clients, that provider will be used ahead of any
other providers that are unrelated). If multiple providers are an equal
distance away, one will be chosen at random.</p>
<p>Returns a pointer to the PCI device with a reference taken (use pci_dev_put
to return the reference) or NULL if no compatible device is found. The
found provider will also be assigned to the client list.</p>
<dl class="function">
<dt id="c.pci_alloc_p2pmem">
void * <code class="descname">pci_alloc_p2pmem</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_alloc_p2pmem" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate peer-to-peer DMA memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device to allocate memory from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>number of bytes to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the allocated memory or NULL on error.</p>
<dl class="function">
<dt id="c.pci_free_p2pmem">
void <code class="descname">pci_free_p2pmem</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, void *<em>&nbsp;addr</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_free_p2pmem" title="Permalink to this definition">¶</a></dt>
<dd><p>free peer-to-peer DMA memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device the memory was allocated from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>address of the memory that was allocated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>number of bytes that were allocated</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pmem_virt_to_bus">
pci_bus_addr_t <code class="descname">pci_p2pmem_virt_to_bus</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_virt_to_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>return the PCI bus address for a given virtual address obtained with <a class="reference internal" href="#c.pci_alloc_p2pmem" title="pci_alloc_p2pmem"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_p2pmem()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device the memory was allocated from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>address of the memory that was allocated</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pmem_alloc_sgl">
struct scatterlist * <code class="descname">pci_p2pmem_alloc_sgl</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, unsigned int *<em>&nbsp;nents</em>, u32<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_alloc_sgl" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate peer-to-peer DMA memory in a scatterlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device to allocate memory from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">nents</span></code></dt>
<dd>the number of SG entries in the list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">length</span></code></dt>
<dd>number of bytes to allocate</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error or <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span></code> pointer and <strong>nents</strong> on success</p>
<dl class="function">
<dt id="c.pci_p2pmem_free_sgl">
void <code class="descname">pci_p2pmem_free_sgl</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, struct scatterlist *<em>&nbsp;sgl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_free_sgl" title="Permalink to this definition">¶</a></dt>
<dd><p>free a scatterlist allocated by <a class="reference internal" href="#c.pci_p2pmem_alloc_sgl" title="pci_p2pmem_alloc_sgl"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pmem_alloc_sgl()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device to allocate memory from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sgl</span></code></dt>
<dd>the allocated scatterlist</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pmem_publish">
void <code class="descname">pci_p2pmem_publish</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, bool<em>&nbsp;publish</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pmem_publish" title="Permalink to this definition">¶</a></dt>
<dd><p>publish the peer-to-peer DMA memory for use by other devices with pci_p2pmem_find()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the device with peer-to-peer DMA memory to publish</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">publish</span></code></dt>
<dd>set to true to publish the memory, false to unpublish it</dd>
</dl>
<p><strong>Description</strong></p>
<p>Published memory can be used by other PCI device drivers for
peer-2-peer DMA operations. Non-published memory is reserved for
exclusive use of the device driver that registers the peer-to-peer
memory.</p>
<dl class="function">
<dt id="c.pci_p2pdma_map_sg_attrs">
int <code class="descname">pci_p2pdma_map_sg_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct scatterlist *<em>&nbsp;sg</em>, int<em>&nbsp;nents</em>, enum dma_data_direction<em>&nbsp;dir</em>, unsigned long<em>&nbsp;attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_map_sg_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>map a PCI peer-to-peer scatterlist for DMA</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device doing the DMA request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>scatter list to map</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nents</span></code></dt>
<dd>elements in the scatterlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA direction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt>
<dd>DMA attributes passed to dma_map_sg() (if called)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scatterlists mapped with this function should be unmapped using
<a class="reference internal" href="#c.pci_p2pdma_unmap_sg_attrs" title="pci_p2pdma_unmap_sg_attrs"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_unmap_sg_attrs()</span></code></a>.</p>
<p>Returns the number of SG entries mapped or 0 on error.</p>
<dl class="function">
<dt id="c.pci_p2pdma_unmap_sg_attrs">
void <code class="descname">pci_p2pdma_unmap_sg_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct scatterlist *<em>&nbsp;sg</em>, int<em>&nbsp;nents</em>, enum dma_data_direction<em>&nbsp;dir</em>, unsigned long<em>&nbsp;attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_unmap_sg_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap a PCI peer-to-peer scatterlist that was mapped with pci_p2pdma_map_sg()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device doing the DMA request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>scatter list to map</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nents</span></code></dt>
<dd>number of elements returned by pci_p2pdma_map_sg()</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA direction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt>
<dd>DMA attributes passed to dma_unmap_sg() (if called)</dd>
</dl>
<dl class="function">
<dt id="c.pci_p2pdma_enable_store">
int <code class="descname">pci_p2pdma_enable_store</code><span class="sig-paren">(</span>const char *<em>&nbsp;page</em>, struct pci_dev **<em>&nbsp;p2p_dev</em>, bool *<em>&nbsp;use_p2pdma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_enable_store" title="Permalink to this definition">¶</a></dt>
<dd><p>parse a configfs/sysfs attribute store to enable p2pdma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>contents of the value to be stored</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">**</span> <span class="pre">p2p_dev</span></code></dt>
<dd>returns the PCI device that was selected to be used
(if one was specified in the stored value)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">use_p2pdma</span></code></dt>
<dd>returns whether to enable p2pdma or not</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses an attribute value to decide whether to enable p2pdma.
The value can select a PCI device (using its full BDF device
name) or a boolean (in any format strtobool() accepts). A false
value disables p2pdma, a true value expects the caller
to automatically find a compatible device and specifying a PCI device
expects the caller to use the specific provider.</p>
<p><a class="reference internal" href="#c.pci_p2pdma_enable_show" title="pci_p2pdma_enable_show"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_enable_show()</span></code></a> should be used as the show operation for
the attribute.</p>
<p>Returns 0 on success</p>
<dl class="function">
<dt id="c.pci_p2pdma_enable_show">
ssize_t <code class="descname">pci_p2pdma_enable_show</code><span class="sig-paren">(</span>char *<em>&nbsp;page</em>, struct pci_dev *<em>&nbsp;p2p_dev</em>, bool<em>&nbsp;use_p2pdma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_p2pdma_enable_show" title="Permalink to this definition">¶</a></dt>
<dd><p>show a configfs/sysfs attribute indicating whether p2pdma is enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>contents of the stored value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">p2p_dev</span></code></dt>
<dd>the selected p2p device (NULL if no device is selected)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_p2pdma</span></code></dt>
<dd>whether p2pdma has been enabled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attributes that use <a class="reference internal" href="#c.pci_p2pdma_enable_store" title="pci_p2pdma_enable_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_p2pdma_enable_store()</span></code></a> should use this function
to show the value of the attribute.</p>
<p>Returns 0 on success</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>