

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>USB Type-C connector class &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>USB Type-C connector class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/usb/typec.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="usb-type-c-connector-class">
<span id="typec"></span><h1>USB Type-C connector class<a class="headerlink" href="#usb-type-c-connector-class" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The typec class is meant for describing the USB Type-C ports in a system to the
user space in unified fashion. The class is designed to provide nothing else
except the user space interface implementation in hope that it can be utilized
on as many platforms as possible.</p>
<p>The platforms are expected to register every USB Type-C port they have with the
class. In a normal case the registration will be done by a USB Type-C or PD PHY
driver, but it may be a driver for firmware interface such as UCSI, driver for
USB PD controller or even driver for Thunderbolt3 controller. This document
considers the component registering the USB Type-C ports with the class as “port
driver”.</p>
<p>On top of showing the capabilities, the class also offer user space control over
the roles and alternate modes of ports, partners and cable plugs when the port
driver is capable of supporting those features.</p>
<p>The class provides an API for the port drivers described in this document. The
attributes are described in Documentation/ABI/testing/sysfs-class-typec.</p>
</div>
<div class="section" id="user-space-interface">
<h2>User space interface<a class="headerlink" href="#user-space-interface" title="Permalink to this headline">¶</a></h2>
<p>Every port will be presented as its own device under /sys/class/typec/. The
first port will be named “port0”, the second “port1” and so on.</p>
<p>When connected, the partner will be presented also as its own device under
/sys/class/typec/. The parent of the partner device will always be the port it
is attached to. The partner attached to port “port0” will be named
“port0-partner”. Full path to the device would be
/sys/class/typec/port0/port0-partner/.</p>
<p>The cable and the two plugs on it may also be optionally presented as their own
devices under /sys/class/typec/. The cable attached to the port “port0” port
will be named port0-cable and the plug on the SOP Prime end (see USB Power
Delivery Specification ch. 2.4) will be named “port0-plug0” and on the SOP
Double Prime end “port0-plug1”. The parent of a cable will always be the port,
and the parent of the cable plugs will always be the cable.</p>
<p>If the port, partner or cable plug supports Alternate Modes, every supported
Alternate Mode SVID will have their own device describing them. Note that the
Alternate Mode devices will not be attached to the typec class. The parent of an
alternate mode will be the device that supports it, so for example an alternate
mode of port0-partner will be presented under /sys/class/typec/port0-partner/.
Every mode that is supported will have its own group under the Alternate Mode
device named “mode&lt;index&gt;”, for example /sys/class/typec/port0/&lt;alternate
mode&gt;/mode1/. The requests for entering/exiting a mode can be done with “active”
attribute file in that group.</p>
</div>
<div class="section" id="driver-api">
<h2>Driver API<a class="headerlink" href="#driver-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="registering-the-ports">
<h3>Registering the ports<a class="headerlink" href="#registering-the-ports" title="Permalink to this headline">¶</a></h3>
<p>The port drivers will describe every Type-C port they control with struct
typec_capability data structure, and register them with the following API:</p>
<dl class="function">
<dt id="c.typec_register_port">
struct typec_port * <code class="descname">typec_register_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;parent</em>, const struct typec_capability *<em>&nbsp;cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_register_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a USB Type-C Port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>Parent device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_capability</span> <span class="pre">*</span> <span class="pre">cap</span></code></dt>
<dd>Description of the port</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a device for USB Type-C Port described in <strong>cap</strong>.</p>
<p>Returns handle to the port on success or ERR_PTR on failure.</p>
<dl class="function">
<dt id="c.typec_unregister_port">
void <code class="descname">typec_unregister_port</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a USB Type-C Port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>The port to be unregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_register_port" title="typec_register_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_register_port()</span></code></a>.</p>
<p>When registering the ports, the prefer_role member in struct typec_capability
deserves special notice. If the port that is being registered does not have
initial role preference, which means the port does not execute Try.SNK or
Try.SRC by default, the member must have value TYPEC_NO_PREFERRED_ROLE.
Otherwise if the port executes Try.SNK by default, the member must have value
TYPEC_DEVICE, and with Try.SRC the value must be TYPEC_HOST.</p>
</div>
<div class="section" id="registering-partners">
<h3>Registering Partners<a class="headerlink" href="#registering-partners" title="Permalink to this headline">¶</a></h3>
<p>After successful connection of a partner, the port driver needs to register the
partner with the class. Details about the partner need to be described in struct
typec_partner_desc. The class copies the details of the partner during
registration. The class offers the following API for registering/unregistering
partners.</p>
<dl class="function">
<dt id="c.typec_register_partner">
struct typec_partner * <code class="descname">typec_register_partner</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em>, struct typec_partner_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_register_partner" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a USB Type-C Partner</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>The USB Type-C Port the partner is connected to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_partner_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Description of the partner</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a device for USB Type-C Partner described in <strong>desc</strong>.</p>
<p>Returns handle to the partner on success or ERR_PTR on failure.</p>
<dl class="function">
<dt id="c.typec_unregister_partner">
void <code class="descname">typec_unregister_partner</code><span class="sig-paren">(</span>struct typec_partner *<em>&nbsp;partner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_partner" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a USB Type-C Partner</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_partner</span> <span class="pre">*</span> <span class="pre">partner</span></code></dt>
<dd>The partner to be unregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_register_partner" title="typec_register_partner"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_register_partner()</span></code></a>.</p>
<p>The class will provide a handle to struct typec_partner if the registration was
successful, or NULL.</p>
<p>If the partner is USB Power Delivery capable, and the port driver is able to
show the result of Discover Identity command, the partner descriptor structure
should include handle to struct usb_pd_identity instance. The class will then
create a sysfs directory for the identity under the partner device. The result
of Discover Identity command can then be reported with the following API:</p>
<dl class="function">
<dt id="c.typec_partner_set_identity">
int <code class="descname">typec_partner_set_identity</code><span class="sig-paren">(</span>struct typec_partner *<em>&nbsp;partner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_partner_set_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Report result from Discover Identity command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_partner</span> <span class="pre">*</span> <span class="pre">partner</span></code></dt>
<dd>The partner updated identity values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to report that the result of Discover Identity USB power
delivery command has become available.</p>
</div>
<div class="section" id="registering-cables">
<h3>Registering Cables<a class="headerlink" href="#registering-cables" title="Permalink to this headline">¶</a></h3>
<p>After successful connection of a cable that supports USB Power Delivery
Structured VDM “Discover Identity”, the port driver needs to register the cable
and one or two plugs, depending if there is CC Double Prime controller present
in the cable or not. So a cable capable of SOP Prime communication, but not SOP
Double Prime communication, should only have one plug registered. For more
information about SOP communication, please read chapter about it from the
latest USB Power Delivery specification.</p>
<p>The plugs are represented as their own devices. The cable is registered first,
followed by registration of the cable plugs. The cable will be the parent device
for the plugs. Details about the cable need to be described in struct
typec_cable_desc and about a plug in struct typec_plug_desc. The class copies
the details during registration. The class offers the following API for
registering/unregistering cables and their plugs:</p>
<dl class="function">
<dt id="c.typec_register_plug">
struct typec_plug * <code class="descname">typec_register_plug</code><span class="sig-paren">(</span>struct typec_cable *<em>&nbsp;cable</em>, struct typec_plug_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_register_plug" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a USB Type-C Cable Plug</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_cable</span> <span class="pre">*</span> <span class="pre">cable</span></code></dt>
<dd>USB Type-C Cable with the plug</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_plug_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Description of the cable plug</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a device for USB Type-C Cable Plug described in <strong>desc</strong>. A USB Type-C
Cable Plug represents a plug with electronics in it that can response to USB
Power Delivery SOP Prime or SOP Double Prime packages.</p>
<p>Returns handle to the cable plug on success or ERR_PTR on failure.</p>
<dl class="function">
<dt id="c.typec_unregister_plug">
void <code class="descname">typec_unregister_plug</code><span class="sig-paren">(</span>struct typec_plug *<em>&nbsp;plug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_plug" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a USB Type-C Cable Plug</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_plug</span> <span class="pre">*</span> <span class="pre">plug</span></code></dt>
<dd>The cable plug to be unregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_register_plug" title="typec_register_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_register_plug()</span></code></a>.</p>
<dl class="function">
<dt id="c.typec_register_cable">
struct typec_cable * <code class="descname">typec_register_cable</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em>, struct typec_cable_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_register_cable" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a USB Type-C Cable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>The USB Type-C Port the cable is connected to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_cable_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Description of the cable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a device for USB Type-C Cable described in <strong>desc</strong>. The cable will be
parent for the optional cable plug devises.</p>
<p>Returns handle to the cable on success or ERR_PTR on failure.</p>
<dl class="function">
<dt id="c.typec_unregister_cable">
void <code class="descname">typec_unregister_cable</code><span class="sig-paren">(</span>struct typec_cable *<em>&nbsp;cable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_cable" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a USB Type-C Cable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_cable</span> <span class="pre">*</span> <span class="pre">cable</span></code></dt>
<dd>The cable to be unregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_register_cable" title="typec_register_cable"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_register_cable()</span></code></a>.</p>
<p>The class will provide a handle to struct typec_cable and struct typec_plug if
the registration is successful, or NULL if it isn’t.</p>
<p>If the cable is USB Power Delivery capable, and the port driver is able to show
the result of Discover Identity command, the cable descriptor structure should
include handle to struct usb_pd_identity instance. The class will then create a
sysfs directory for the identity under the cable device. The result of Discover
Identity command can then be reported with the following API:</p>
<dl class="function">
<dt id="c.typec_cable_set_identity">
int <code class="descname">typec_cable_set_identity</code><span class="sig-paren">(</span>struct typec_cable *<em>&nbsp;cable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_cable_set_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Report result from Discover Identity command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_cable</span> <span class="pre">*</span> <span class="pre">cable</span></code></dt>
<dd>The cable updated identity values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to report that the result of Discover Identity USB power
delivery command has become available.</p>
</div>
<div class="section" id="notifications">
<h3>Notifications<a class="headerlink" href="#notifications" title="Permalink to this headline">¶</a></h3>
<p>When the partner has executed a role change, or when the default roles change
during connection of a partner or cable, the port driver must use the following
APIs to report it to the class:</p>
<dl class="function">
<dt id="c.typec_set_data_role">
void <code class="descname">typec_set_data_role</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em>, enum typec_data_role<em>&nbsp;role</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_data_role" title="Permalink to this definition">¶</a></dt>
<dd><p>Report data role change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>The USB Type-C Port where the role was changed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_data_role</span> <span class="pre">role</span></code></dt>
<dd>The new data role</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used by the port drivers to report data role changes.</p>
<dl class="function">
<dt id="c.typec_set_pwr_role">
void <code class="descname">typec_set_pwr_role</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em>, enum typec_role<em>&nbsp;role</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_pwr_role" title="Permalink to this definition">¶</a></dt>
<dd><p>Report power role change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>The USB Type-C Port where the role was changed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_role</span> <span class="pre">role</span></code></dt>
<dd>The new data role</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used by the port drivers to report power role changes.</p>
<dl class="function">
<dt id="c.typec_set_vconn_role">
void <code class="descname">typec_set_vconn_role</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em>, enum typec_role<em>&nbsp;role</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_vconn_role" title="Permalink to this definition">¶</a></dt>
<dd><p>Report VCONN source change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>The USB Type-C Port which VCONN role changed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_role</span> <span class="pre">role</span></code></dt>
<dd>Source when <strong>port</strong> is sourcing VCONN, or Sink when it’s not</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used by the port drivers to report if the VCONN source is
changes.</p>
<dl class="function">
<dt id="c.typec_set_pwr_opmode">
void <code class="descname">typec_set_pwr_opmode</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em>, enum typec_pwr_opmode<em>&nbsp;opmode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_pwr_opmode" title="Permalink to this definition">¶</a></dt>
<dd><p>Report changed power operation mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>The USB Type-C Port where the mode was changed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_pwr_opmode</span> <span class="pre">opmode</span></code></dt>
<dd>New power operation mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used by the port drivers to report changed power operation
mode in <strong>port</strong>. The modes are USB (default), 1.5A, 3.0A as defined in USB
Type-C specification, and “USB Power Delivery” when the power levels are
negotiated with methods defined in USB Power Delivery specification.</p>
</div>
<div class="section" id="alternate-modes">
<h3>Alternate Modes<a class="headerlink" href="#alternate-modes" title="Permalink to this headline">¶</a></h3>
<p>USB Type-C ports, partners and cable plugs may support Alternate Modes. Each
Alternate Mode will have identifier called SVID, which is either a Standard ID
given by USB-IF or vendor ID, and each supported SVID can have 1 - 6 modes. The
class provides struct typec_mode_desc for describing individual mode of a SVID,
and struct typec_altmode_desc which is a container for all the supported modes.</p>
<p>Ports that support Alternate Modes need to register each SVID they support with
the following API:</p>
<dl class="function">
<dt id="c.typec_port_register_altmode">
struct typec_altmode * <code class="descname">typec_port_register_altmode</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em>, const struct typec_altmode_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_port_register_altmode" title="Permalink to this definition">¶</a></dt>
<dd><p>Register USB Type-C Port Alternate Mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>USB Type-C Port that supports the alternate mode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_altmode_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Description of the alternate mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to register an alternate mode that <strong>port</strong> is capable of
supporting.</p>
<p>Returns handle to the alternate mode on success or ERR_PTR on failure.</p>
<p>If a partner or cable plug provides a list of SVIDs as response to USB Power
Delivery Structured VDM Discover SVIDs message, each SVID needs to be
registered.</p>
<p>API for the partners:</p>
<dl class="function">
<dt id="c.typec_partner_register_altmode">
struct typec_altmode * <code class="descname">typec_partner_register_altmode</code><span class="sig-paren">(</span>struct typec_partner *<em>&nbsp;partner</em>, const struct typec_altmode_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_partner_register_altmode" title="Permalink to this definition">¶</a></dt>
<dd><p>Register USB Type-C Partner Alternate Mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_partner</span> <span class="pre">*</span> <span class="pre">partner</span></code></dt>
<dd>USB Type-C Partner that supports the alternate mode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_altmode_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Description of the alternate mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to register each alternate mode individually that
<strong>partner</strong> has listed in response to Discover SVIDs command. The modes for a
SVID listed in response to Discover Modes command need to be listed in an
array in <strong>desc</strong>.</p>
<p>Returns handle to the alternate mode on success or NULL on failure.</p>
<p>API for the Cable Plugs:</p>
<dl class="function">
<dt id="c.typec_plug_register_altmode">
struct typec_altmode * <code class="descname">typec_plug_register_altmode</code><span class="sig-paren">(</span>struct typec_plug *<em>&nbsp;plug</em>, const struct typec_altmode_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_plug_register_altmode" title="Permalink to this definition">¶</a></dt>
<dd><p>Register USB Type-C Cable Plug Alternate Mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_plug</span> <span class="pre">*</span> <span class="pre">plug</span></code></dt>
<dd>USB Type-C Cable Plug that supports the alternate mode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_altmode_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Description of the alternate mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to register each alternate mode individually that <strong>plug</strong>
has listed in response to Discover SVIDs command. The modes for a SVID that
the plug lists in response to Discover Modes command need to be listed in an
array in <strong>desc</strong>.</p>
<p>Returns handle to the alternate mode on success or ERR_PTR on failure.</p>
<p>So ports, partners and cable plugs will register the alternate modes with their
own functions, but the registration will always return a handle to struct
typec_altmode on success, or NULL. The unregistration will happen with the same
function:</p>
<dl class="function">
<dt id="c.typec_unregister_altmode">
void <code class="descname">typec_unregister_altmode</code><span class="sig-paren">(</span>struct typec_altmode *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_unregister_altmode" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister Alternate Mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_altmode</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>The alternate mode to be unregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister device created with <a class="reference internal" href="#c.typec_partner_register_altmode" title="typec_partner_register_altmode"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_partner_register_altmode()</span></code></a>,
<a class="reference internal" href="#c.typec_plug_register_altmode" title="typec_plug_register_altmode"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_plug_register_altmode()</span></code></a> or <a class="reference internal" href="#c.typec_port_register_altmode" title="typec_port_register_altmode"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_port_register_altmode()</span></code></a>.</p>
<p>If a partner or cable plug enters or exits a mode, the port driver needs to
notify the class with the following API:</p>
<dl class="function">
<dt id="c.typec_altmode_update_active">
void <code class="descname">typec_altmode_update_active</code><span class="sig-paren">(</span>struct typec_altmode *<em>&nbsp;adev</em>, bool<em>&nbsp;active</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_altmode_update_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Report Enter/Exit mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_altmode</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>Handle to the alternate mode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">active</span></code></dt>
<dd>True when the mode has been entered</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a partner or cable plug executes Enter/Exit Mode command successfully, the
drivers use this routine to report the updated state of the mode.</p>
</div>
<div class="section" id="multiplexer-demultiplexer-switches">
<h3>Multiplexer/DeMultiplexer Switches<a class="headerlink" href="#multiplexer-demultiplexer-switches" title="Permalink to this headline">¶</a></h3>
<p>USB Type-C connectors may have one or more mux/demux switches behind them. Since
the plugs can be inserted right-side-up or upside-down, a switch is needed to
route the correct data pairs from the connector to the USB controllers. If
Alternate or Accessory Modes are supported, another switch is needed that can
route the pins on the connector to some other component besides USB. USB Type-C
Connector Class supplies an API for registering those switches.</p>
<dl class="function">
<dt id="c.typec_switch_register">
struct typec_switch * <code class="descname">typec_switch_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;parent</em>, const struct typec_switch_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_switch_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register USB Type-C orientation switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>Parent device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_switch_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Orientation switch description</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers a switch that can be used for routing the correct
data pairs depending on the cable plug orientation from the USB Type-C
connector to the USB controllers. USB Type-C plugs can be inserted
right-side-up or upside-down.</p>
<dl class="function">
<dt id="c.typec_switch_unregister">
void <code class="descname">typec_switch_unregister</code><span class="sig-paren">(</span>struct typec_switch *<em>&nbsp;sw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_switch_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister USB Type-C orientation switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_switch</span> <span class="pre">*</span> <span class="pre">sw</span></code></dt>
<dd>USB Type-C orientation switch</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister switch that was registered with <a class="reference internal" href="#c.typec_switch_register" title="typec_switch_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_switch_register()</span></code></a>.</p>
<dl class="function">
<dt id="c.typec_mux_register">
struct typec_mux * <code class="descname">typec_mux_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;parent</em>, const struct typec_mux_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_mux_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register Multiplexer routing USB Type-C pins</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>Parent device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">typec_mux_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Multiplexer description</dd>
</dl>
<p><strong>Description</strong></p>
<p>USB Type-C connectors can be used for alternate modes of operation besides
USB when Accessory/Alternate Modes are supported. With some of those modes,
the pins on the connector need to be reconfigured. This function registers
multiplexer switches routing the pins on the connector.</p>
<dl class="function">
<dt id="c.typec_mux_unregister">
void <code class="descname">typec_mux_unregister</code><span class="sig-paren">(</span>struct typec_mux *<em>&nbsp;mux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_mux_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister Multiplexer Switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_mux</span> <span class="pre">*</span> <span class="pre">mux</span></code></dt>
<dd>USB Type-C Connector Multiplexer/DeMultiplexer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister mux that was registered with <a class="reference internal" href="#c.typec_mux_register" title="typec_mux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">typec_mux_register()</span></code></a>.</p>
<p>In most cases the same physical mux will handle both the orientation and mode.
However, as the port drivers will be responsible for the orientation, and the
alternate mode drivers for the mode, the two are always separated into their
own logical components: “mux” for the mode and “switch” for the orientation.</p>
<p>When a port is registered, USB Type-C Connector Class requests both the mux and
the switch for the port. The drivers can then use the following API for
controlling them:</p>
<dl class="function">
<dt id="c.typec_set_orientation">
int <code class="descname">typec_set_orientation</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em>, enum typec_orientation<em>&nbsp;orientation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Set USB Type-C cable plug orientation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>USB Type-C Port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">typec_orientation</span> <span class="pre">orientation</span></code></dt>
<dd>USB Type-C cable plug orientation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set cable plug orientation for <strong>port</strong>.</p>
<dl class="function">
<dt id="c.typec_set_mode">
int <code class="descname">typec_set_mode</code><span class="sig-paren">(</span>struct typec_port *<em>&nbsp;port</em>, int<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.typec_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set mode of operation for USB Type-C connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">typec_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>USB Type-C connector</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mode</span></code></dt>
<dd>Accessory Mode, USB Operation or Safe State</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure <strong>port</strong> for Accessory Mode <strong>mode</strong>. This function will configure the
muxes needed for <strong>mode</strong>.</p>
<p>If the connector is dual-role capable, there may also be a switch for the data
role. USB Type-C Connector Class does not supply separate API for them. The
port drivers can use USB Role Class API with those.</p>
<p>Illustration of the muxes behind a connector that supports an alternate mode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>               ------------------------
               |       Connector      |
               ------------------------
                      |         |
               ------------------------
                \     Orientation    /
                 --------------------
                          |
                 --------------------
                /        Mode        \
               ------------------------
                   /              \
------------------------        --------------------
|       Alt Mode       |       /      USB Role      \
------------------------      ------------------------
                                   /            \
               ------------------------      ------------------------
               |       USB Host       |      |       USB Device     |
               ------------------------      ------------------------
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>