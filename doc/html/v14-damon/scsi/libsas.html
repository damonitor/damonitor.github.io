

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SAS Layer &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>SAS Layer</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/scsi/libsas.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sas-layer">
<h1>SAS Layer<a class="headerlink" href="#sas-layer" title="Permalink to this headline">¶</a></h1>
<p>The SAS Layer is a management infrastructure which manages
SAS LLDDs.  It sits between SCSI Core and SAS LLDDs.  The
layout is as follows: while SCSI Core is concerned with
SAM/SPC issues, and a SAS LLDD+sequencer is concerned with
phy/OOB/link management, the SAS layer is concerned with:</p>
<blockquote>
<div><ul class="simple">
<li>SAS Phy/Port/HA event management (LLDD generates,
SAS Layer processes),</li>
<li>SAS Port management (creation/destruction),</li>
<li>SAS Domain discovery and revalidation,</li>
<li>SAS Domain device management,</li>
<li>SCSI Host registration/unregistration,</li>
<li>Device registration with SCSI Core (SAS) or libata
(SATA), and</li>
<li>Expander management and exporting expander control
to user space.</li>
</ul>
</div></blockquote>
<p>A SAS LLDD is a PCI device driver.  It is concerned with
phy/OOB management, and vendor specific tasks and generates
events to the SAS layer.</p>
<p>The SAS Layer does most SAS tasks as outlined in the SAS 1.1
spec.</p>
<p>The sas_ha_struct describes the SAS LLDD to the SAS layer.
Most of it is used by the SAS Layer but a few fields need to
be initialized by the LLDDs.</p>
<p>After initializing your hardware, from the probe() function
you call sas_register_ha(). It will register your LLDD with
the SCSI subsystem, creating a SCSI host and it will
register your SAS driver with the sysfs SAS tree it creates.
It will then return.  Then you enable your phys to actually
start OOB (at which point your driver will start calling the
notify_* event callbacks).</p>
<div class="section" id="structure-descriptions">
<h2>Structure descriptions<a class="headerlink" href="#structure-descriptions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="struct-sas-phy">
<h3><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span></code><a class="headerlink" href="#struct-sas-phy" title="Permalink to this headline">¶</a></h3>
<p>Normally this is statically embedded to your driver’s
phy structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_phy {
        blah;
        struct sas_phy sas_phy;
        bleh;
};
</pre></div>
</div>
<p>And then all the phys are an array of my_phy in your HA
struct (shown below).</p>
<p>Then as you go along and initialize your phys you also
initialize the sas_phy struct, along with your own
phy structure.</p>
<p>In general, the phys are managed by the LLDD and the ports
are managed by the SAS layer.  So the phys are initialized
and updated by the LLDD and the ports are initialized and
updated by the SAS layer.</p>
<p>There is a scheme where the LLDD can RW certain fields,
and the SAS layer can only read such ones, and vice versa.
The idea is to avoid unnecessary locking.</p>
<dl class="docutils">
<dt>enabled</dt>
<dd><ul class="first last simple">
<li>must be set (0/1)</li>
</ul>
</dd>
<dt>id</dt>
<dd><ul class="first last simple">
<li>must be set [0,MAX_PHYS)]</li>
</ul>
</dd>
<dt>class, proto, type, role, oob_mode, linkrate</dt>
<dd><ul class="first last simple">
<li>must be set</li>
</ul>
</dd>
<dt>oob_mode</dt>
<dd><ul class="first last simple">
<li>you set this when OOB has finished and then notify
the SAS Layer.</li>
</ul>
</dd>
<dt>sas_addr</dt>
<dd><ul class="first last simple">
<li>this normally points to an array holding the sas
address of the phy, possibly somewhere in your my_phy
struct.</li>
</ul>
</dd>
<dt>attached_sas_addr</dt>
<dd><ul class="first last simple">
<li>set this when you (LLDD) receive an
IDENTIFY frame or a FIS frame, _before_ notifying the SAS
layer.  The idea is that sometimes the LLDD may want to fake
or provide a different SAS address on that phy/port and this
allows it to do this.  At best you should copy the sas
address from the IDENTIFY frame or maybe generate a SAS
address for SATA directly attached devices.  The Discover
process may later change this.</li>
</ul>
</dd>
<dt>frame_rcvd</dt>
<dd><ul class="first last simple">
<li>this is where you copy the IDENTIFY/FIS frame
when you get it; you lock, copy, set frame_rcvd_size and
unlock the lock, and then call the event.  It is a pointer
since there’s no way to know your hw frame size _exactly_,
so you define the actual array in your phy struct and let
this pointer point to it.  You copy the frame from your
DMAable memory to that area holding the lock.</li>
</ul>
</dd>
<dt>sas_prim</dt>
<dd><ul class="first last simple">
<li>this is where primitives go when they’re
received.  See sas.h. Grab the lock, set the primitive,
release the lock, notify.</li>
</ul>
</dd>
<dt>port</dt>
<dd><ul class="first last simple">
<li>this points to the sas_port if the phy belongs
to a port – the LLDD only reads this. It points to the
sas_port this phy is part of.  Set by the SAS Layer.</li>
</ul>
</dd>
<dt>ha</dt>
<dd><ul class="first last simple">
<li>may be set; the SAS layer sets it anyway.</li>
</ul>
</dd>
<dt>lldd_phy</dt>
<dd><ul class="first last simple">
<li>you should set this to point to your phy so you
can find your way around faster when the SAS layer calls one
of your callbacks and passes you a phy.  If the sas_phy is
embedded you can also use container_of – whatever you
prefer.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="struct-sas-port">
<h3><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span></code><a class="headerlink" href="#struct-sas-port" title="Permalink to this headline">¶</a></h3>
<p>The LLDD doesn’t set any fields of this struct – it only
reads them.  They should be self explanatory.</p>
<p>phy_mask is 32 bit, this should be enough for now, as I
haven’t heard of a HA having more than 8 phys.</p>
<dl class="docutils">
<dt>lldd_port</dt>
<dd><ul class="first last simple">
<li>I haven’t found use for that – maybe other
LLDD who wish to have internal port representation can make
use of this.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="struct-sas-ha-struct">
<h3><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_ha_struct</span></code><a class="headerlink" href="#struct-sas-ha-struct" title="Permalink to this headline">¶</a></h3>
<p>It normally is statically declared in your own LLDD
structure describing your adapter:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_sas_ha {
    blah;
    struct sas_ha_struct sas_ha;
    struct my_phy phys[MAX_PHYS];
    struct sas_port sas_ports[MAX_PHYS]; /* (1) */
    bleh;
};

(1) If your LLDD doesn&#39;t have its own port representation.
</pre></div>
</div>
<p>What needs to be initialized (sample function given below).</p>
<div class="section" id="pcidev">
<h4>pcidev<a class="headerlink" href="#pcidev" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>sas_addr</dt>
<dd><ul class="first last simple">
<li>since the SAS layer doesn’t want to mess with
memory allocation, etc, this points to statically
allocated array somewhere (say in your host adapter
structure) and holds the SAS address of the host
adapter as given by you or the manufacturer, etc.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="sas-port">
<h4>sas_port<a class="headerlink" href="#sas-port" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>sas_phy</dt>
<dd><ul class="first last simple">
<li>an array of pointers to structures. (see
note above on sas_addr).
These must be set.  See more notes below.</li>
</ul>
</dd>
<dt>num_phys</dt>
<dd><ul class="first last simple">
<li>the number of phys present in the sas_phy array,
and the number of ports present in the sas_port
array.  There can be a maximum num_phys ports (one per
port) so we drop the num_ports, and only use
num_phys.</li>
</ul>
</dd>
</dl>
<p>The event interface:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* LLDD calls these to notify the class of an event. */
void (*notify_ha_event)(struct sas_ha_struct *, enum ha_event);
void (*notify_port_event)(struct sas_phy *, enum port_event);
void (*notify_phy_event)(struct sas_phy *, enum phy_event);
</pre></div>
</div>
<p>When sas_register_ha() returns, those are set and can be
called by the LLDD to notify the SAS layer of such events
the SAS layer.</p>
<p>The port notification:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* The class calls these to notify the LLDD of an event. */
void (*lldd_port_formed)(struct sas_phy *);
void (*lldd_port_deformed)(struct sas_phy *);
</pre></div>
</div>
<p>If the LLDD wants notification when a port has been formed
or deformed it sets those to a function satisfying the type.</p>
<p>A SAS LLDD should also implement at least one of the Task
Management Functions (TMFs) described in SAM:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Task Management Functions. Must be called from process context. */
int (*lldd_abort_task)(struct sas_task *);
int (*lldd_abort_task_set)(struct domain_device *, u8 *lun);
int (*lldd_clear_aca)(struct domain_device *, u8 *lun);
int (*lldd_clear_task_set)(struct domain_device *, u8 *lun);
int (*lldd_I_T_nexus_reset)(struct domain_device *);
int (*lldd_lu_reset)(struct domain_device *, u8 *lun);
int (*lldd_query_task)(struct sas_task *);
</pre></div>
</div>
<p>For more information please read SAM from T10.org.</p>
<p>Port and Adapter management:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Port and Adapter management */
int (*lldd_clear_nexus_port)(struct sas_port *);
int (*lldd_clear_nexus_ha)(struct sas_ha_struct *);
</pre></div>
</div>
<p>A SAS LLDD should implement at least one of those.</p>
<p>Phy management:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Phy management */
int (*lldd_control_phy)(struct sas_phy *, enum phy_func);
</pre></div>
</div>
<dl class="docutils">
<dt>lldd_ha</dt>
<dd><ul class="first last simple">
<li>set this to point to your HA struct. You can also
use container_of if you embedded it as shown above.</li>
</ul>
</dd>
</dl>
<p>A sample initialization and registration function
can look like this (called last thing from probe())
<em>but</em> before you enable the phys to do OOB:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int register_sas_ha(struct my_sas_ha *my_ha)
{
        int i;
        static struct sas_phy   *sas_phys[MAX_PHYS];
        static struct sas_port  *sas_ports[MAX_PHYS];

        my_ha-&gt;sas_ha.sas_addr = &amp;my_ha-&gt;sas_addr[0];

        for (i = 0; i &lt; MAX_PHYS; i++) {
                sas_phys[i] = &amp;my_ha-&gt;phys[i].sas_phy;
                sas_ports[i] = &amp;my_ha-&gt;sas_ports[i];
        }

        my_ha-&gt;sas_ha.sas_phy  = sas_phys;
        my_ha-&gt;sas_ha.sas_port = sas_ports;
        my_ha-&gt;sas_ha.num_phys = MAX_PHYS;

        my_ha-&gt;sas_ha.lldd_port_formed = my_port_formed;

        my_ha-&gt;sas_ha.lldd_dev_found = my_dev_found;
        my_ha-&gt;sas_ha.lldd_dev_gone = my_dev_gone;

        my_ha-&gt;sas_ha.lldd_execute_task = my_execute_task;

        my_ha-&gt;sas_ha.lldd_abort_task     = my_abort_task;
        my_ha-&gt;sas_ha.lldd_abort_task_set = my_abort_task_set;
        my_ha-&gt;sas_ha.lldd_clear_aca      = my_clear_aca;
        my_ha-&gt;sas_ha.lldd_clear_task_set = my_clear_task_set;
        my_ha-&gt;sas_ha.lldd_I_T_nexus_reset= NULL; (2)
        my_ha-&gt;sas_ha.lldd_lu_reset       = my_lu_reset;
        my_ha-&gt;sas_ha.lldd_query_task     = my_query_task;

        my_ha-&gt;sas_ha.lldd_clear_nexus_port = my_clear_nexus_port;
        my_ha-&gt;sas_ha.lldd_clear_nexus_ha = my_clear_nexus_ha;

        my_ha-&gt;sas_ha.lldd_control_phy = my_control_phy;

        return sas_register_ha(&amp;my_ha-&gt;sas_ha);
}
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>SAS 1.1 does not define I_T Nexus Reset TMF.</li>
</ol>
</div>
</div>
</div>
<div class="section" id="events">
<h2>Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h2>
<p>Events are <strong>the only way</strong> a SAS LLDD notifies the SAS layer
of anything.  There is no other method or way a LLDD to tell
the SAS layer of anything happening internally or in the SAS
domain.</p>
<p>Phy events:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PHYE_LOSS_OF_SIGNAL, (C)
PHYE_OOB_DONE,
PHYE_OOB_ERROR,      (C)
PHYE_SPINUP_HOLD.
</pre></div>
</div>
<p>Port events, passed on a _phy_:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PORTE_BYTES_DMAED,      (M)
PORTE_BROADCAST_RCVD,   (E)
PORTE_LINK_RESET_ERR,   (C)
PORTE_TIMER_EVENT,      (C)
PORTE_HARD_RESET.
</pre></div>
</div>
<dl class="docutils">
<dt>Host Adapter event:</dt>
<dd>HAE_RESET</dd>
</dl>
<p>A SAS LLDD should be able to generate</p>
<blockquote>
<div><ul class="simple">
<li>at least one event from group C (choice),</li>
<li>events marked M (mandatory) are mandatory (only one),</li>
<li>events marked E (expander) if it wants the SAS layer
to handle domain revalidation (only one such).</li>
<li>Unmarked events are optional.</li>
</ul>
</div></blockquote>
<p>Meaning:</p>
<dl class="docutils">
<dt>HAE_RESET</dt>
<dd><ul class="first last simple">
<li>when your HA got internal error and was reset.</li>
</ul>
</dd>
<dt>PORTE_BYTES_DMAED</dt>
<dd><ul class="first last simple">
<li>on receiving an IDENTIFY/FIS frame</li>
</ul>
</dd>
<dt>PORTE_BROADCAST_RCVD</dt>
<dd><ul class="first last simple">
<li>on receiving a primitive</li>
</ul>
</dd>
<dt>PORTE_LINK_RESET_ERR</dt>
<dd><ul class="first last simple">
<li>timer expired, loss of signal, loss of DWS, etc. <a class="footnote-reference" href="#id5" id="id1">[1]</a></li>
</ul>
</dd>
<dt>PORTE_TIMER_EVENT</dt>
<dd><ul class="first last simple">
<li>DWS reset timeout timer expired <a class="footnote-reference" href="#id5" id="id2">[1]</a></li>
</ul>
</dd>
<dt>PORTE_HARD_RESET</dt>
<dd><ul class="first last simple">
<li>Hard Reset primitive received.</li>
</ul>
</dd>
<dt>PHYE_LOSS_OF_SIGNAL</dt>
<dd><ul class="first last simple">
<li>the device is gone <a class="footnote-reference" href="#id5" id="id3">[1]</a></li>
</ul>
</dd>
<dt>PHYE_OOB_DONE</dt>
<dd><ul class="first last simple">
<li>OOB went fine and oob_mode is valid</li>
</ul>
</dd>
<dt>PHYE_OOB_ERROR</dt>
<dd><ul class="first last simple">
<li>Error while doing OOB, the device probably
got disconnected. <a class="footnote-reference" href="#id5" id="id4">[1]</a></li>
</ul>
</dd>
<dt>PHYE_SPINUP_HOLD</dt>
<dd><ul class="first last simple">
<li>SATA is present, COMWAKE not sent.</li>
</ul>
</dd>
</dl>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id3">3</a>, <a class="fn-backref" href="#id4">4</a>)</em> should set/clear the appropriate fields in the phy,
or alternatively call the inlined sas_phy_disconnected()
which is just a helper, from their tasklet.</td></tr>
</tbody>
</table>
<p>The Execute Command SCSI RPC:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*lldd_execute_task)(struct sas_task *, gfp_t gfp_flags);
</pre></div>
</div>
<p>Used to queue a task to the SAS LLDD.  &#64;task is the task to be executed.
&#64;gfp_mask is the gfp_mask defining the context of the caller.</p>
<p>This function should implement the Execute Command SCSI RPC,</p>
<p>That is, when lldd_execute_task() is called, the command
go out on the transport <em>immediately</em>.  There is <em>no</em>
queuing of any sort and at any level in a SAS LLDD.</p>
<p>Returns:</p>
<blockquote>
<div><ul class="simple">
<li>-SAS_QUEUE_FULL, -ENOMEM, nothing was queued;</li>
<li>0, the task(s) were queued.</li>
</ul>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sas_task {
        dev -- the device this task is destined to
        task_proto -- _one_ of enum sas_proto
        scatter -- pointer to scatter gather list array
        num_scatter -- number of elements in scatter
        total_xfer_len -- total number of bytes expected to be transferred
        data_dir -- PCI_DMA_...
        task_done -- callback when the task has finished execution
};
</pre></div>
</div>
</div>
<div class="section" id="discovery">
<h2>Discovery<a class="headerlink" href="#discovery" title="Permalink to this headline">¶</a></h2>
<p>The sysfs tree has the following purposes:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>It shows you the physical layout of the SAS domain at
the current time, i.e. how the domain looks in the
physical world right now.</li>
<li>Shows some device parameters _at_discovery_time_.</li>
</ol>
</div></blockquote>
<p>This is a link to the tree(1) program, very useful in
viewing the SAS domain:
<a class="reference external" href="ftp://mama.indstate.edu/linux/tree/">ftp://mama.indstate.edu/linux/tree/</a></p>
<p>I expect user space applications to actually create a
graphical interface of this.</p>
<p>That is, the sysfs domain tree doesn’t show or keep state if
you e.g., change the meaning of the READY LED MEANING
setting, but it does show you the current connection status
of the domain device.</p>
<p>Keeping internal device state changes is responsibility of
upper layers (Command set drivers) and user space.</p>
<p>When a device or devices are unplugged from the domain, this
is reflected in the sysfs tree immediately, and the device(s)
removed from the system.</p>
<p>The structure domain_device describes any device in the SAS
domain.  It is completely managed by the SAS layer.  A task
points to a domain device, this is how the SAS LLDD knows
where to send the task(s) to.  A SAS LLDD only reads the
contents of the domain_device structure, but it never creates
or destroys one.</p>
</div>
<div class="section" id="expander-management-from-user-space">
<h2>Expander management from User Space<a class="headerlink" href="#expander-management-from-user-space" title="Permalink to this headline">¶</a></h2>
<p>In each expander directory in sysfs, there is a file called
“smp_portal”.  It is a binary sysfs attribute file, which
implements an SMP portal (Note: this is <em>NOT</em> an SMP port),
to which user space applications can send SMP requests and
receive SMP responses.</p>
<p>Functionality is deceptively simple:</p>
<ol class="arabic simple">
<li>Build the SMP frame you want to send. The format and layout
is described in the SAS spec.  Leave the CRC field equal 0.</li>
</ol>
<p>open(2)</p>
<ol class="arabic simple" start="2">
<li>Open the expander’s SMP portal sysfs file in RW mode.</li>
</ol>
<p>write(2)</p>
<ol class="arabic simple" start="3">
<li>Write the frame you built in 1.</li>
</ol>
<p>read(2)</p>
<ol class="arabic simple" start="4">
<li>Read the amount of data you expect to receive for the frame you built.
If you receive different amount of data you expected to receive,
then there was some kind of error.</li>
</ol>
<p>close(2)</p>
<p>All this process is shown in detail in the function do_smp_func()
and its callers, in the file “expander_conf.c”.</p>
<p>The kernel functionality is implemented in the file
“sas_expander.c”.</p>
<p>The program “expander_conf.c” implements this. It takes one
argument, the sysfs file name of the SMP portal to the
expander, and gives expander information, including routing
tables.</p>
<p>The SMP portal gives you complete control of the expander,
so please be careful.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>