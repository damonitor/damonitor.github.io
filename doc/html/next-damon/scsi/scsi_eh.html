

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SCSI EH &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>SCSI EH</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/scsi/scsi_eh.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="scsi-eh">
<h1>SCSI EH<a class="headerlink" href="#scsi-eh" title="Permalink to this headline">¶</a></h1>
<p>This document describes SCSI midlayer error handling infrastructure.
Please refer to Documentation/scsi/scsi_mid_low_api.rst for more
information regarding SCSI midlayer.</p>
<div class="section" id="how-scsi-commands-travel-through-the-midlayer-and-to-eh">
<h2>1. How SCSI commands travel through the midlayer and to EH<a class="headerlink" href="#how-scsi-commands-travel-through-the-midlayer-and-to-eh" title="Permalink to this headline">¶</a></h2>
<div class="section" id="struct-scsi-cmnd">
<h3>1.1 struct scsi_cmnd<a class="headerlink" href="#struct-scsi-cmnd" title="Permalink to this headline">¶</a></h3>
<p>Each SCSI command is represented with struct scsi_cmnd (== scmd).  A
scmd has two list_head’s to link itself into lists.  The two are
scmd-&gt;list and scmd-&gt;eh_entry.  The former is used for free list or
per-device allocated scmd list and not of much interest to this EH
discussion.  The latter is used for completion and EH lists and unless
otherwise stated scmds are always linked using scmd-&gt;eh_entry in this
discussion.</p>
</div>
<div class="section" id="how-do-scmd-s-get-completed">
<h3>1.2 How do scmd’s get completed?<a class="headerlink" href="#how-do-scmd-s-get-completed" title="Permalink to this headline">¶</a></h3>
<p>Once LLDD gets hold of a scmd, either the LLDD will complete the
command by calling scsi_done callback passed from midlayer when
invoking hostt-&gt;queuecommand() or the block layer will time it out.</p>
<div class="section" id="completing-a-scmd-w-scsi-done">
<h4>1.2.1 Completing a scmd w/ scsi_done<a class="headerlink" href="#completing-a-scmd-w-scsi-done" title="Permalink to this headline">¶</a></h4>
<p>For all non-EH commands, scsi_done() is the completion callback.  It
just calls blk_complete_request() to delete the block layer timer and
raise SCSI_SOFTIRQ</p>
<p>SCSI_SOFTIRQ handler scsi_softirq calls scsi_decide_disposition() to
determine what to do with the command.  scsi_decide_disposition()
looks at the scmd-&gt;result value and sense data to determine what to do
with the command.</p>
<blockquote>
<div><ul>
<li><p class="first">SUCCESS</p>
<blockquote>
<div><p>scsi_finish_command() is invoked for the command.  The
function does some maintenance chores and then calls
scsi_io_completion() to finish the I/O.
scsi_io_completion() then notifies the block layer on
the completed request by calling blk_end_request and
friends or figures out what to do with the remainder
of the data in case of an error.</p>
</div></blockquote>
</li>
<li><p class="first">NEEDS_RETRY</p>
</li>
<li><p class="first">ADD_TO_MLQUEUE</p>
<blockquote>
<div><p>scmd is requeued to blk queue.</p>
</div></blockquote>
</li>
<li><p class="first">otherwise</p>
<blockquote>
<div><p>scsi_eh_scmd_add(scmd) is invoked for the command.  See
[1-3] for details of this function.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="completing-a-scmd-w-timeout">
<h4>1.2.2 Completing a scmd w/ timeout<a class="headerlink" href="#completing-a-scmd-w-timeout" title="Permalink to this headline">¶</a></h4>
<p>The timeout handler is scsi_times_out().  When a timeout occurs, this
function</p>
<blockquote>
<div><ol class="arabic simple">
<li>invokes optional hostt-&gt;eh_timed_out() callback.  Return value can
be one of<ul>
<li><dl class="first docutils">
<dt>BLK_EH_RESET_TIMER</dt>
<dd>This indicates that more time is required to finish the
command.  Timer is restarted.  This action is counted as a
retry and only allowed scmd-&gt;allowed + 1(!) times.  Once the
limit is reached, action for BLK_EH_DONE is taken instead.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>BLK_EH_DONE</dt>
<dd>eh_timed_out() callback did not handle the command.
Step #2 is taken.</dd>
</dl>
</li>
</ul>
</li>
<li>scsi_abort_command() is invoked to schedule an asynchrous abort.
Asynchronous abort are not invoked for commands which the
SCSI_EH_ABORT_SCHEDULED flag is set (this indicates that the command
already had been aborted once, and this is a retry which failed),
or when the EH deadline is expired. In these case Step #3 is taken.</li>
<li>scsi_eh_scmd_add(scmd, SCSI_EH_CANCEL_CMD) is invoked for the
command.  See [1-4] for more information.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="asynchronous-command-aborts">
<h3>1.3 Asynchronous command aborts<a class="headerlink" href="#asynchronous-command-aborts" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>After a timeout occurs a command abort is scheduled from
scsi_abort_command(). If the abort is successful the command
will either be retried (if the number of retries is not exhausted)
or terminated with DID_TIME_OUT.</p>
<p>Otherwise scsi_eh_scmd_add() is invoked for the command.
See [1-4] for more information.</p>
</div></blockquote>
</div>
<div class="section" id="how-eh-takes-over">
<h3>1.4 How EH takes over<a class="headerlink" href="#how-eh-takes-over" title="Permalink to this headline">¶</a></h3>
<p>scmds enter EH via scsi_eh_scmd_add(), which does the following.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Links scmd-&gt;eh_entry to shost-&gt;eh_cmd_q</li>
<li>Sets SHOST_RECOVERY bit in shost-&gt;shost_state</li>
<li>Increments shost-&gt;host_failed</li>
<li>Wakes up SCSI EH thread if shost-&gt;host_busy == shost-&gt;host_failed</li>
</ol>
</div></blockquote>
<p>As can be seen above, once any scmd is added to shost-&gt;eh_cmd_q,
SHOST_RECOVERY shost_state bit is turned on.  This prevents any new
scmd to be issued from blk queue to the host; eventually, all scmds on
the host either complete normally, fail and get added to eh_cmd_q, or
time out and get added to shost-&gt;eh_cmd_q.</p>
<p>If all scmds either complete or fail, the number of in-flight scmds
becomes equal to the number of failed scmds - i.e. shost-&gt;host_busy ==
shost-&gt;host_failed.  This wakes up SCSI EH thread.  So, once woken up,
SCSI EH thread can expect that all in-flight commands have failed and
are linked on shost-&gt;eh_cmd_q.</p>
<p>Note that this does not mean lower layers are quiescent.  If a LLDD
completed a scmd with error status, the LLDD and lower layers are
assumed to forget about the scmd at that point.  However, if a scmd
has timed out, unless hostt-&gt;eh_timed_out() made lower layers forget
about the scmd, which currently no LLDD does, the command is still
active as long as lower layers are concerned and completion could
occur at any time.  Of course, all such completions are ignored as the
timer has already expired.</p>
<p>We’ll talk about how SCSI EH takes actions to abort - make LLDD
forget about - timed out scmds later.</p>
</div>
</div>
<div class="section" id="how-scsi-eh-works">
<h2>2. How SCSI EH works<a class="headerlink" href="#how-scsi-eh-works" title="Permalink to this headline">¶</a></h2>
<p>LLDD’s can implement SCSI EH actions in one of the following two
ways.</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>Fine-grained EH callbacks</dt>
<dd>LLDD can implement fine-grained EH callbacks and let SCSI
midlayer drive error handling and call appropriate callbacks.
This will be discussed further in [2-1].</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>eh_strategy_handler() callback</dt>
<dd>This is one big callback which should perform whole error
handling.  As such, it should do all chores the SCSI midlayer
performs during recovery.  This will be discussed in [2-2].</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Once recovery is complete, SCSI EH resumes normal operation by
calling scsi_restart_operations(), which</p>
<blockquote>
<div><ol class="arabic simple">
<li>Checks if door locking is needed and locks door.</li>
<li>Clears SHOST_RECOVERY shost_state bit</li>
<li>Wakes up waiters on shost-&gt;host_wait.  This occurs if someone
calls <a class="reference internal" href="../driver-api/scsi.html#c.scsi_block_when_processing_errors" title="scsi_block_when_processing_errors"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_block_when_processing_errors()</span></code></a> on the host.
(<em>QUESTION</em> why is it needed?  All operations will be blocked
anyway after it reaches blk queue.)</li>
<li>Kicks queues in all devices on the host in the asses</li>
</ol>
</div></blockquote>
<div class="section" id="eh-through-fine-grained-callbacks">
<h3>2.1 EH through fine-grained callbacks<a class="headerlink" href="#eh-through-fine-grained-callbacks" title="Permalink to this headline">¶</a></h3>
<div class="section" id="overview">
<h4>2.1.1 Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h4>
<p>If eh_strategy_handler() is not present, SCSI midlayer takes charge
of driving error handling.  EH’s goals are two - make LLDD, host and
device forget about timed out scmds and make them ready for new
commands.  A scmd is said to be recovered if the scmd is forgotten by
lower layers and lower layers are ready to process or fail the scmd
again.</p>
<p>To achieve these goals, EH performs recovery actions with increasing
severity.  Some actions are performed by issuing SCSI commands and
others are performed by invoking one of the following fine-grained
hostt EH callbacks.  Callbacks may be omitted and omitted ones are
considered to fail always.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (* eh_abort_handler)(struct scsi_cmnd *);
int (* eh_device_reset_handler)(struct scsi_cmnd *);
int (* eh_bus_reset_handler)(struct scsi_cmnd *);
int (* eh_host_reset_handler)(struct scsi_cmnd *);
</pre></div>
</div>
<p>Higher-severity actions are taken only when lower-severity actions
cannot recover some of failed scmds.  Also, note that failure of the
highest-severity action means EH failure and results in offlining of
all unrecovered devices.</p>
<p>During recovery, the following rules are followed</p>
<blockquote>
<div><ul>
<li><p class="first">Recovery actions are performed on failed scmds on the to do list,
eh_work_q.  If a recovery action succeeds for a scmd, recovered
scmds are removed from eh_work_q.</p>
<p>Note that single recovery action on a scmd can recover multiple
scmds.  e.g. resetting a device recovers all failed scmds on the
device.</p>
</li>
<li><p class="first">Higher severity actions are taken iff eh_work_q is not empty after
lower severity actions are complete.</p>
</li>
<li><p class="first">EH reuses failed scmds to issue commands for recovery.  For
timed-out scmds, SCSI EH ensures that LLDD forgets about a scmd
before reusing it for EH commands.</p>
</li>
</ul>
</div></blockquote>
<p>When a scmd is recovered, the scmd is moved from eh_work_q to EH
local eh_done_q using <a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_finish_cmd" title="scsi_eh_finish_cmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_finish_cmd()</span></code></a>.  After all scmds are
recovered (eh_work_q is empty), <a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_flush_done_q" title="scsi_eh_flush_done_q"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_flush_done_q()</span></code></a> is invoked to
either retry or error-finish (notify upper layer of failure) recovered
scmds.</p>
<p>scmds are retried iff its sdev is still online (not offlined during
EH), REQ_FAILFAST is not set and ++scmd-&gt;retries is less than
scmd-&gt;allowed.</p>
</div>
<div class="section" id="flow-of-scmds-through-eh">
<h4>2.1.2 Flow of scmds through EH<a class="headerlink" href="#flow-of-scmds-through-eh" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ol class="arabic simple">
<li>Error completion / time out<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ACTION:</th><td class="field-body">scsi_eh_scmd_add() is invoked for scmd<ul>
<li>add scmd to shost-&gt;eh_cmd_q</li>
<li>set SHOST_RECOVERY</li>
<li>shost-&gt;host_failed++</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">LOCKING:</th><td class="field-body">shost-&gt;host_lock</td>
</tr>
</tbody>
</table>
</li>
<li>EH starts<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ACTION:</th><td class="field-body">move all scmds to EH’s local eh_work_q.  shost-&gt;eh_cmd_q
is cleared.</td>
</tr>
<tr class="field-even field"><th class="field-name">LOCKING:</th><td class="field-body">shost-&gt;host_lock (not strictly necessary, just for
consistency)</td>
</tr>
</tbody>
</table>
</li>
<li>scmd recovered<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ACTION:</th><td class="field-body"><a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_finish_cmd" title="scsi_eh_finish_cmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_finish_cmd()</span></code></a> is invoked to EH-finish scmd<ul>
<li>scsi_setup_cmd_retry()</li>
<li>move from local eh_work_q to local eh_done_q</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">LOCKING:</th><td class="field-body">none</td>
</tr>
<tr class="field-odd field"><th class="field-name">CONCURRENCY:</th><td class="field-body">at most one thread per separate eh_work_q to
keep queue manipulation lockless</td>
</tr>
</tbody>
</table>
</li>
<li>EH completes<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">ACTION:</th><td class="field-body"><a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_flush_done_q" title="scsi_eh_flush_done_q"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_flush_done_q()</span></code></a> retries scmds or notifies upper
layer of failure. May be called concurrently but must have
a no more than one thread per separate eh_work_q to
manipulate the queue locklessly<ul>
<li>scmd is removed from eh_done_q and scmd-&gt;eh_entry is cleared</li>
<li>if retry is necessary, scmd is requeued using
scsi_queue_insert()</li>
<li>otherwise, scsi_finish_command() is invoked for scmd</li>
<li>zero shost-&gt;host_failed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">LOCKING:</th><td class="field-body">queue or finish function performs appropriate locking</td>
</tr>
</tbody>
</table>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="flow-of-control">
<h4>2.1.3 Flow of control<a class="headerlink" href="#flow-of-control" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>EH through fine-grained callbacks start from scsi_unjam_host().</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">scsi_unjam_host</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>Lock shost-&gt;host_lock, splice_init shost-&gt;eh_cmd_q into local
eh_work_q and unlock host_lock.  Note that shost-&gt;eh_cmd_q is
cleared by this action.</li>
<li>Invoke scsi_eh_get_sense.</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">scsi_eh_get_sense</span></code></p>
<blockquote>
<div><p>This action is taken for each error-completed
(!SCSI_EH_CANCEL_CMD) commands without valid sense data.  Most
SCSI transports/LLDDs automatically acquire sense data on
command failures (autosense).  Autosense is recommended for
performance reasons and as sense information could get out of
sync between occurrence of CHECK CONDITION and this action.</p>
<p>Note that if autosense is not supported, scmd-&gt;sense_buffer
contains invalid sense data when error-completing the scmd
with scsi_done().  scsi_decide_disposition() always returns
FAILED in such cases thus invoking SCSI EH.  When the scmd
reaches here, sense data is acquired and
scsi_decide_disposition() is called again.</p>
<ol class="arabic simple">
<li>Invoke scsi_request_sense() which issues REQUEST_SENSE
command.  If fails, no action.  Note that taking no action
causes higher-severity recovery to be taken for the scmd.</li>
<li>Invoke scsi_decide_disposition() on the scmd<ul>
<li><dl class="first docutils">
<dt>SUCCESS</dt>
<dd>scmd-&gt;retries is set to scmd-&gt;allowed preventing
<a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_flush_done_q" title="scsi_eh_flush_done_q"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_flush_done_q()</span></code></a> from retrying the scmd and
<a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_finish_cmd" title="scsi_eh_finish_cmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_finish_cmd()</span></code></a> is invoked.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NEEDS_RETRY</dt>
<dd><a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_finish_cmd" title="scsi_eh_finish_cmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_finish_cmd()</span></code></a> invoked</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>otherwise</dt>
<dd>No action.</dd>
</dl>
</li>
</ul>
</li>
</ol>
</div></blockquote>
<ol class="arabic simple" start="3">
<li>If !list_empty(&amp;eh_work_q), invoke scsi_eh_abort_cmds().</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">scsi_eh_abort_cmds</span></code></p>
<blockquote>
<div><p>This action is taken for each timed out command when
no_async_abort is enabled in the host template.
hostt-&gt;eh_abort_handler() is invoked for each scmd.  The
handler returns SUCCESS if it has succeeded to make LLDD and
all related hardware forget about the scmd.</p>
<p>If a timedout scmd is successfully aborted and the sdev is
either offline or ready, <a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_finish_cmd" title="scsi_eh_finish_cmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_finish_cmd()</span></code></a> is invoked for
the scmd.  Otherwise, the scmd is left in eh_work_q for
higher-severity actions.</p>
<p>Note that both offline and ready status mean that the sdev is
ready to process new scmds, where processing also implies
immediate failing; thus, if a sdev is in one of the two
states, no further recovery action is needed.</p>
<p>Device readiness is tested using scsi_eh_tur() which issues
TEST_UNIT_READY command.  Note that the scmd must have been
aborted successfully before reusing it for TEST_UNIT_READY.</p>
</div></blockquote>
<ol class="arabic simple" start="4">
<li>If !list_empty(&amp;eh_work_q), invoke <a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_ready_devs" title="scsi_eh_ready_devs"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_ready_devs()</span></code></a></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">scsi_eh_ready_devs</span></code></p>
<blockquote>
<div><p>This function takes four increasingly more severe measures to
make failed sdevs ready for new commands.</p>
<ol class="arabic simple">
<li>Invoke scsi_eh_stu()</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">scsi_eh_stu</span></code></p>
<blockquote>
<div><p>For each sdev which has failed scmds with valid sense data
of which <a class="reference internal" href="../driver-api/scsi.html#c.scsi_check_sense" title="scsi_check_sense"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_check_sense()</span></code></a>’s verdict is FAILED,
START_STOP_UNIT command is issued w/ start=1.  Note that
as we explicitly choose error-completed scmds, it is known
that lower layers have forgotten about the scmd and we can
reuse it for STU.</p>
<p>If STU succeeds and the sdev is either offline or ready,
all failed scmds on the sdev are EH-finished with
<a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_finish_cmd" title="scsi_eh_finish_cmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_finish_cmd()</span></code></a>.</p>
<p><em>NOTE</em> If hostt-&gt;eh_abort_handler() isn’t implemented or
failed, we may still have timed out scmds at this point
and STU doesn’t make lower layers forget about those
scmds.  Yet, this function EH-finish all scmds on the sdev
if STU succeeds leaving lower layers in an inconsistent
state.  It seems that STU action should be taken only when
a sdev has no timed out scmd.</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>If !list_empty(&amp;eh_work_q), invoke scsi_eh_bus_device_reset().</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">scsi_eh_bus_device_reset</span></code></p>
<blockquote>
<div>This action is very similar to scsi_eh_stu() except that,
instead of issuing STU, hostt-&gt;eh_device_reset_handler()
is used.  Also, as we’re not issuing SCSI commands and
resetting clears all scmds on the sdev, there is no need
to choose error-completed scmds.</div></blockquote>
<ol class="arabic simple" start="3">
<li>If !list_empty(&amp;eh_work_q), invoke scsi_eh_bus_reset()</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">scsi_eh_bus_reset</span></code></p>
<blockquote>
<div>hostt-&gt;eh_bus_reset_handler() is invoked for each channel
with failed scmds.  If bus reset succeeds, all failed
scmds on all ready or offline sdevs on the channel are
EH-finished.</div></blockquote>
<ol class="arabic simple" start="4">
<li>If !list_empty(&amp;eh_work_q), invoke scsi_eh_host_reset()</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">scsi_eh_host_reset</span></code></p>
<blockquote>
<div>This is the last resort.  hostt-&gt;eh_host_reset_handler()
is invoked.  If host reset succeeds, all failed scmds on
all ready or offline sdevs on the host are EH-finished.</div></blockquote>
<ol class="arabic simple" start="5">
<li>If !list_empty(&amp;eh_work_q), invoke scsi_eh_offline_sdevs()</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">scsi_eh_offline_sdevs</span></code></p>
<blockquote>
<div>Take all sdevs which still have unrecovered scmds offline
and EH-finish the scmds.</div></blockquote>
</div></blockquote>
<ol class="arabic" start="5">
<li><p class="first">Invoke <a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_flush_done_q" title="scsi_eh_flush_done_q"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_flush_done_q()</span></code></a>.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">scsi_eh_flush_done_q</span></code></p>
<blockquote>
<div><p>At this point all scmds are recovered (or given up) and
put on eh_done_q by <a class="reference internal" href="../driver-api/scsi.html#c.scsi_eh_finish_cmd" title="scsi_eh_finish_cmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_finish_cmd()</span></code></a>.  This function
flushes eh_done_q by either retrying or notifying upper
layer of failure of the scmds.</p>
</div></blockquote>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="eh-through-transportt-eh-strategy-handler">
<h3>2.2 EH through transportt-&gt;eh_strategy_handler()<a class="headerlink" href="#eh-through-transportt-eh-strategy-handler" title="Permalink to this headline">¶</a></h3>
<p>transportt-&gt;eh_strategy_handler() is invoked in the place of
scsi_unjam_host() and it is responsible for whole recovery process.
On completion, the handler should have made lower layers forget about
all failed scmds and either ready for new commands or offline.  Also,
it should perform SCSI EH maintenance chores to maintain integrity of
SCSI midlayer.  IOW, of the steps described in [2-1-2], all steps
except for #1 must be implemented by eh_strategy_handler().</p>
<div class="section" id="pre-transportt-eh-strategy-handler-scsi-midlayer-conditions">
<h4>2.2.1 Pre transportt-&gt;eh_strategy_handler() SCSI midlayer conditions<a class="headerlink" href="#pre-transportt-eh-strategy-handler-scsi-midlayer-conditions" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The following conditions are true on entry to the handler.</p>
<ul class="simple">
<li>Each failed scmd’s eh_flags field is set appropriately.</li>
<li>Each failed scmd is linked on scmd-&gt;eh_cmd_q by scmd-&gt;eh_entry.</li>
<li>SHOST_RECOVERY is set.</li>
<li>shost-&gt;host_failed == shost-&gt;host_busy</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="post-transportt-eh-strategy-handler-scsi-midlayer-conditions">
<h4>2.2.2 Post transportt-&gt;eh_strategy_handler() SCSI midlayer conditions<a class="headerlink" href="#post-transportt-eh-strategy-handler-scsi-midlayer-conditions" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The following conditions must be true on exit from the handler.</p>
<ul class="simple">
<li>shost-&gt;host_failed is zero.</li>
<li>Each scmd is in such a state that scsi_setup_cmd_retry() on the
scmd doesn’t make any difference.</li>
<li>shost-&gt;eh_cmd_q is cleared.</li>
<li>Each scmd-&gt;eh_entry is cleared.</li>
<li>Either scsi_queue_insert() or scsi_finish_command() is called on
each scmd.  Note that the handler is free to use scmd-&gt;retries and
-&gt;allowed to limit the number of retries.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="things-to-consider">
<h4>2.2.3 Things to consider<a class="headerlink" href="#things-to-consider" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>Know that timed out scmds are still active on lower layers.  Make
lower layers forget about them before doing anything else with
those scmds.</li>
<li>For consistency, when accessing/modifying shost data structure,
grab shost-&gt;host_lock.</li>
<li>On completion, each failed sdev must have forgotten about all
active scmds.</li>
<li>On completion, each failed sdev must be ready for new commands or
offline.</li>
</ul>
</div></blockquote>
<p>Tejun Heo
<a class="reference external" href="mailto:htejun&#37;&#52;&#48;gmail&#46;com">htejun<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
<p>11th September 2005</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>