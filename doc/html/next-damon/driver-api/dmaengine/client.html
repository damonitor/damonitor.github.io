

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DMA Engine API Guide &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>DMA Engine API Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/dmaengine/client.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dma-engine-api-guide">
<h1>DMA Engine API Guide<a class="headerlink" href="#dma-engine-api-guide" title="Permalink to this headline">¶</a></h1>
<p>Vinod Koul &lt;vinod dot koul at intel.com&gt;</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For DMA Engine usage in async_tx please see:
<code class="docutils literal notranslate"><span class="pre">Documentation/crypto/async-tx-api.txt</span></code></p>
</div>
<p>Below is a guide to device driver writers on how to use the Slave-DMA API of the
DMA Engine. This is applicable only for slave DMA usage only.</p>
<div class="section" id="dma-usage">
<h2>DMA usage<a class="headerlink" href="#dma-usage" title="Permalink to this headline">¶</a></h2>
<p>The slave DMA usage consists of following steps:</p>
<ul class="simple">
<li>Allocate a DMA slave channel</li>
<li>Set slave and controller specific parameters</li>
<li>Get a descriptor for transaction</li>
<li>Submit the transaction</li>
<li>Issue pending requests and wait for callback notification</li>
</ul>
<p>The details of these operations are:</p>
<ol class="arabic">
<li><p class="first">Allocate a DMA slave channel</p>
<p>Channel allocation is slightly different in the slave DMA context,
client drivers typically need a channel from a particular DMA
controller only and even in some cases a specific channel is desired.
To request a channel dma_request_chan() API is used.</p>
<p>Interface:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="nf">dma_request_chan</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>Which will find and return the <code class="docutils literal notranslate"><span class="pre">name</span></code> DMA channel associated with the ‘dev’
device. The association is done via DT, ACPI or board file based
dma_slave_map matching table.</p>
<p>A channel allocated via this interface is exclusive to the caller,
until dma_release_channel() is called.</p>
</li>
<li><p class="first">Set slave and controller specific parameters</p>
<p>Next step is always to pass some specific information to the DMA
driver. Most of the generic information which a slave DMA can use
is in struct dma_slave_config. This allows the clients to specify
DMA direction, DMA addresses, bus widths, DMA burst lengths etc
for the peripheral.</p>
<p>If some DMA controllers have more parameters to be sent then they
should try to embed struct dma_slave_config in their controller
specific structure. That gives flexibility to client to pass more
parameters, if required.</p>
<p>Interface:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">dmaengine_slave_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
                  <span class="k">struct</span> <span class="n">dma_slave_config</span> <span class="o">*</span><span class="n">config</span><span class="p">)</span>
</pre></div>
</div>
<p>Please see the dma_slave_config structure definition in dmaengine.h
for a detailed explanation of the struct members. Please note
that the ‘direction’ member will be going away as it duplicates the
direction given in the prepare call.</p>
</li>
<li><p class="first">Get a descriptor for transaction</p>
</li>
</ol>
<blockquote>
<div><p>For slave usage the various modes of slave transfers supported by the
DMA-engine are:</p>
<ul class="simple">
<li>slave_sg: DMA a list of scatter gather buffers from/to a peripheral</li>
<li>dma_cyclic: Perform a cyclic DMA operation from/to a peripheral till the
operation is explicitly stopped.</li>
<li>interleaved_dma: This is common to Slave as well as M2M clients. For slave
address of devices’ fifo could be already known to the driver.
Various types of operations could be expressed by setting
appropriate values to the ‘dma_interleaved_template’ members.</li>
</ul>
<p>A non-NULL return of this transfer API represents a “descriptor” for
the given transaction.</p>
<p>Interface:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">dmaengine_prep_slave_sg</span><span class="p">(</span>
           <span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
           <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_len</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">,</span>
           <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">dmaengine_prep_dma_cyclic</span><span class="p">(</span>
           <span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">buf_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">,</span>
           <span class="kt">size_t</span> <span class="n">period_len</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">dmaengine_prep_interleaved_dma</span><span class="p">(</span>
           <span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_interleaved_template</span> <span class="o">*</span><span class="n">xt</span><span class="p">,</span>
           <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
</pre></div>
</div>
<p>The peripheral driver is expected to have mapped the scatterlist for
the DMA operation prior to calling dmaengine_prep_slave_sg(), and must
keep the scatterlist mapped until the DMA operation has completed.
The scatterlist must be mapped using the DMA struct device.
If a mapping needs to be synchronized later, dma_sync_*_for_*() must be
called using the DMA struct device, too.
So, normal setup should look like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">nr_sg</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">sg_len</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">nr_sg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
           <span class="cm">/* error */</span>

   <span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">nr_sg</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</pre></div>
</div>
<p>Once a descriptor has been obtained, the callback information can be
added and the descriptor must then be submitted. Some DMA engine
drivers may hold a spinlock between a successful preparation and
submission so it is important that these two operations are closely
paired.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Although the async_tx API specifies that completion callback
routines cannot submit any new operations, this is not the
case for slave/cyclic DMA.</p>
<p>For slave DMA, the subsequent transaction may not be available
for submission prior to callback function being invoked, so
slave DMA callbacks are permitted to prepare and submit a new
transaction.</p>
<p>For cyclic DMA, a callback function may wish to terminate the
DMA via dmaengine_terminate_async().</p>
<p>Therefore, it is important that DMA engine drivers drop any
locks before calling the callback function which may cause a
deadlock.</p>
<p class="last">Note that callbacks will always be invoked from the DMA
engines tasklet, never from interrupt context.</p>
</div>
<p><strong>Optional: per descriptor metadata</strong></p>
<p>DMAengine provides two ways for metadata support.</p>
<p>DESC_METADATA_CLIENT</p>
<blockquote>
<div>The metadata buffer is allocated/provided by the client driver and it is
attached to the descriptor.</div></blockquote>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">dmaengine_desc_attach_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
                              <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>DESC_METADATA_ENGINE</p>
<blockquote>
<div><p>The metadata buffer is allocated/managed by the DMA driver. The client
driver can ask for the pointer, maximum size and the currently used size of
the metadata and can directly update or read it.</p>
<p>Becasue the DMA driver manages the memory area containing the metadata,
clients must make sure that they do not try to access or get the pointer
after their transfer completion callback has run for the descriptor.
If no completion callback has been defined for the transfer, then the
metadata must not be accessed after issue_pending.
In other words: if the aim is to read back metadata after the transfer is
completed, then the client must use completion callback.</p>
</div></blockquote>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">dmaengine_desc_get_metadata_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
           <span class="kt">size_t</span> <span class="o">*</span><span class="n">payload_len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">max_len</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">dmaengine_desc_set_metadata_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
           <span class="kt">size_t</span> <span class="n">payload_len</span><span class="p">);</span>
</pre></div>
</div>
<p>Client drivers can query if a given mode is supported with:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">dmaengine_is_metadata_mode_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
           <span class="k">enum</span> <span class="n">dma_desc_metadata_mode</span> <span class="n">mode</span><span class="p">);</span>
</pre></div>
</div>
<p>Depending on the used mode client drivers must follow different flow.</p>
<p>DESC_METADATA_CLIENT</p>
<blockquote>
<div><ul class="simple">
<li>DMA_MEM_TO_DEV / DEV_MEM_TO_MEM:<ol class="arabic">
<li>prepare the descriptor (dmaengine_prep_*)
construct the metadata in the client’s buffer</li>
<li>use dmaengine_desc_attach_metadata() to attach the buffer to the
descriptor</li>
<li>submit the transfer</li>
</ol>
</li>
<li>DMA_DEV_TO_MEM:<ol class="arabic">
<li>prepare the descriptor (dmaengine_prep_*)</li>
<li>use dmaengine_desc_attach_metadata() to attach the buffer to the
descriptor</li>
<li>submit the transfer</li>
<li>when the transfer is completed, the metadata should be available in the
attached buffer</li>
</ol>
</li>
</ul>
</div></blockquote>
<p>DESC_METADATA_ENGINE</p>
<blockquote>
<div><ul class="simple">
<li>DMA_MEM_TO_DEV / DEV_MEM_TO_MEM:<ol class="arabic">
<li>prepare the descriptor (dmaengine_prep_*)</li>
<li>use dmaengine_desc_get_metadata_ptr() to get the pointer to the
engine’s metadata area</li>
<li>update the metadata at the pointer</li>
<li>use dmaengine_desc_set_metadata_len()  to tell the DMA engine the
amount of data the client has placed into the metadata buffer</li>
<li>submit the transfer</li>
</ol>
</li>
<li>DMA_DEV_TO_MEM:<ol class="arabic">
<li>prepare the descriptor (dmaengine_prep_*)</li>
<li>submit the transfer</li>
<li>on transfer completion, use dmaengine_desc_get_metadata_ptr() to get
the pointer to the engine’s metadata area</li>
<li>read out the metadata from the pointer</li>
</ol>
</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>When DESC_METADATA_ENGINE mode is used the metadata area for the descriptor
is no longer valid after the transfer has been completed (valid up to the
point when the completion callback returns if used).</p>
<p class="last">Mixed use of DESC_METADATA_CLIENT / DESC_METADATA_ENGINE is not allowed,
client drivers must use either of the modes per descriptor.</p>
</div>
</div></blockquote>
<ol class="arabic" start="4">
<li><p class="first">Submit the transaction</p>
<p>Once the descriptor has been prepared and the callback information
added, it must be placed on the DMA engine drivers pending queue.</p>
<p>Interface:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dma_cookie_t</span> <span class="n">dmaengine_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
</pre></div>
</div>
<p>This returns a cookie can be used to check the progress of DMA engine
activity via other DMA engine calls not covered in this document.</p>
<p>dmaengine_submit() will not start the DMA operation, it merely adds
it to the pending queue. For this, see step 5, dma_async_issue_pending.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">After calling <code class="docutils literal notranslate"><span class="pre">dmaengine_submit()</span></code> the submitted transfer descriptor
(<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_async_tx_descriptor</span></code>) belongs to the DMA engine.
Consequently, the client must consider invalid the pointer to that
descriptor.</p>
</div>
</li>
<li><p class="first">Issue pending DMA requests and wait for callback notification</p>
<p>The transactions in the pending queue can be activated by calling the
issue_pending API. If channel is idle then the first transaction in
queue is started and subsequent ones queued up.</p>
<p>On completion of each DMA operation, the next in queue is started and
a tasklet triggered. The tasklet will then call the client driver
completion callback routine for notification, if set.</p>
<p>Interface:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">dma_async_issue_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ol>
<div class="section" id="further-apis">
<h3>Further APIs<a class="headerlink" href="#further-apis" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">Terminate APIs</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">dmaengine_terminate_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dmaengine_terminate_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">dmaengine_terminate_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span> <span class="cm">/* DEPRECATED */</span>
</pre></div>
</div>
<p>This causes all activity for the DMA channel to be stopped, and may
discard data in the DMA FIFO which hasn’t been fully transferred.
No callback functions will be called for any incomplete transfers.</p>
<p>Two variants of this function are available.</p>
<p>dmaengine_terminate_async() might not wait until the DMA has been fully
stopped or until any running complete callbacks have finished. But it is
possible to call dmaengine_terminate_async() from atomic context or from
within a complete callback. dmaengine_synchronize() must be called before it
is safe to free the memory accessed by the DMA transfer or free resources
accessed from within the complete callback.</p>
<p>dmaengine_terminate_sync() will wait for the transfer and any running
complete callbacks to finish before it returns. But the function must not be
called from atomic context or from within a complete callback.</p>
<p>dmaengine_terminate_all() is deprecated and should not be used in new code.</p>
</li>
<li><p class="first">Pause API</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">dmaengine_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
</pre></div>
</div>
<p>This pauses activity on the DMA channel without data loss.</p>
</li>
<li><p class="first">Resume API</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">dmaengine_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
</pre></div>
</div>
<p>Resume a previously paused DMA channel. It is invalid to resume a
channel which is not currently paused.</p>
</li>
<li><p class="first">Check Txn complete</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">dma_status</span> <span class="n">dma_async_is_tx_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
          <span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">dma_cookie_t</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="n">dma_cookie_t</span> <span class="o">*</span><span class="n">used</span><span class="p">)</span>
</pre></div>
</div>
<p>This can be used to check the status of the channel. Please see
the documentation in include/linux/dmaengine.h for a more complete
description of this API.</p>
<p>This can be used in conjunction with dma_async_is_complete() and
the cookie returned from dmaengine_submit() to check for
completion of a specific DMA transaction.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Not all DMA engine drivers can return reliable information for
a running DMA channel. It is recommended that DMA engine users
pause or stop (via dmaengine_terminate_all()) the channel before
using this API.</p>
</div>
</li>
<li><p class="first">Synchronize termination API</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">dmaengine_synchronize</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
</pre></div>
</div>
<p>Synchronize the termination of the DMA channel to the current context.</p>
<p>This function should be used after dmaengine_terminate_async() to synchronize
the termination of the DMA channel to the current context. The function will
wait for the transfer and any running complete callbacks to finish before it
returns.</p>
<p>If dmaengine_terminate_async() is used to stop the DMA channel this function
must be called before it is safe to free memory accessed by previously
submitted descriptors or to free any resources accessed within the complete
callback of previously submitted descriptors.</p>
<p>The behavior of this function is undefined if dma_async_issue_pending() has
been called between dmaengine_terminate_async() and this function.</p>
</li>
</ol>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>