

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="Evaluation" href="eval.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.10.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">DAMON: Data Access MONitor</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="design.html">Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="eval.html">Evaluation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#structures">Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">DAMON: Data Access MONitor</a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/vm/damon/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<p>Kernel space programs can use every feature of DAMON using below APIs.  All you
need to do is including <code class="docutils literal notranslate"><span class="pre">damon.h</span></code>, which is located in <code class="docutils literal notranslate"><span class="pre">include/linux/</span></code> of
the source tree.</p>
<div class="section" id="structures">
<h2>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.V4L.damon_addr_range">
struct <code class="sig-name descname">damon_addr_range</code><a class="headerlink" href="#c.V4L.damon_addr_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents an address region of [<strong>start</strong>, <strong>end</strong>).</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct damon_addr_range {
  unsigned long start;
  unsigned long end;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>Start address of the region (inclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end</span></code></dt><dd><p>End address of the region (exclusive).</p>
</dd>
</dl>
<dl class="type">
<dt id="c.V4L.damon_region">
struct <code class="sig-name descname">damon_region</code><a class="headerlink" href="#c.V4L.damon_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a monitoring target region.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct damon_region {
  struct damon_addr_range ar;
  unsigned long sampling_addr;
  unsigned int nr_accesses;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ar</span></code></dt><dd><p>The address range of the region.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sampling_addr</span></code></dt><dd><p>Address of the sample for the next access check.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_accesses</span></code></dt><dd><p>Access frequency of this region.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>List head for siblings.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.V4L.damon_target">
struct <code class="sig-name descname">damon_target</code><a class="headerlink" href="#c.V4L.damon_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a monitoring target.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct damon_target {
  unsigned long id;
  struct list_head regions_list;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Unique identifier for this target.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regions_list</span></code></dt><dd><p>Head of the monitoring target regions of this target.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>List head for siblings.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each monitoring context could have multiple targets.  For example, a context
for virtual memory address spaces could have multiple target processes.  The
<strong>id</strong> of each target should be unique among the targets of the context.  For
example, in the virtual address monitoring context, it could be a pidfd or
an address of an mm_struct.</p>
<dl class="type">
<dt id="c.V4L.damon_primitive">
struct <code class="sig-name descname">damon_primitive</code><a class="headerlink" href="#c.V4L.damon_primitive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct damon_primitive {
  void (*init_target_regions)(struct damon_ctx *context);
  void (*update_target_regions)(struct damon_ctx *context);
  void (*prepare_access_checks)(struct damon_ctx *context);
  unsigned int (*check_accesses)(struct damon_ctx *context);
  void (*reset_aggregated)(struct damon_ctx *context);
  bool (*target_valid)(void *target);
  void (*cleanup)(struct damon_ctx *context);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">init_target_regions</span></code></dt><dd><p>Constructs initial monitoring target regions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update_target_regions</span></code></dt><dd><p>Updates monitoring target regions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_access_checks</span></code></dt><dd><p>Prepares next access check of target regions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">check_accesses</span></code></dt><dd><p>Checks the access of target regions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_aggregated</span></code></dt><dd><p>Resets aggregated accesses monitoring results.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">target_valid</span></code></dt><dd><p>Determine if the target is valid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup</span></code></dt><dd><p>Cleans up the context.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>DAMON can be extended for various address spaces and usages.  For this,
users should register the low level primitives for their target address
space and usecase via the <code class="xref c c-type docutils literal notranslate"><span class="pre">damon_ctx.primitive</span></code>.  Then, the monitoring thread
calls <strong>init_target_regions</strong> and <strong>prepare_access_checks</strong> before starting the
monitoring, <strong>update_target_regions</strong> after each
<code class="xref c c-type docutils literal notranslate"><span class="pre">damon_ctx.regions_update_interval</span></code>, and <strong>check_accesses</strong>, <strong>target_valid</strong> and
<strong>prepare_access_checks</strong> after each <code class="xref c c-type docutils literal notranslate"><span class="pre">damon_ctx.sample_interval</span></code>.  Finally,
<strong>reset_aggregated</strong> is called after each <code class="xref c c-type docutils literal notranslate"><span class="pre">damon_ctx.aggr_interval</span></code>.</p>
<p><strong>init_target_regions</strong> should construct proper monitoring target regions and
link those to the DAMON context struct.  The regions should be defined by
user and saved in <strong>damon_ctx.arbitrary_target</strong> if <strong>damon_ctx.target_type</strong> is
<code class="xref c c-type docutils literal notranslate"><span class="pre">DAMON_ARBITRARY_TARGET</span></code>.  Otherwise, <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">damon_region</span></code> should be used.
<strong>update_target_regions</strong> should update the monitoring target regions for
current status.
<strong>prepare_access_checks</strong> should manipulate the monitoring regions to be
prepared for the next access check.
<strong>check_accesses</strong> should check the accesses to each region that made after the
last preparation and update the number of observed accesses of each region.
It should also return max number of observed accesses that made as a result
of its update.
<strong>reset_aggregated</strong> should reset the access monitoring results that aggregated
by <strong>check_accesses</strong>.
<strong>target_valid</strong> should check whether the target is still valid for the
monitoring.  It receives <code class="xref c c-type docutils literal notranslate"><span class="pre">damon_ctx.arbitrary_target</span></code> or <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">damon_target</span></code>
pointer depends on <code class="xref c c-type docutils literal notranslate"><span class="pre">damon_ctx.target_type</span></code>.
<strong>cleanup</strong> is called from <strong>kdamond</strong> just before its termination.  After this
call, only <strong>kdamond_lock</strong> and <strong>kdamond</strong> will be touched.</p>
<dl class="type">
<dt id="c.V4L.damon_target_type">
enum <code class="sig-name descname">damon_target_type</code><a class="headerlink" href="#c.V4L.damon_target_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the type of the monitoring target.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DAMON_ADAPTIVE_TARGET</span></code></dt><dd><p>Adaptive regions adjustment applied target.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DAMON_ARBITRARY_TARGET</span></code></dt><dd><p>User-defined arbitrary type target.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.V4L.damon_ctx">
struct <code class="sig-name descname">damon_ctx</code><a class="headerlink" href="#c.V4L.damon_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a context for each monitoring. This is the main interface that allows users to set the attributes and get the results of the monitoring.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct damon_ctx {
  unsigned long sample_interval;
  unsigned long aggr_interval;
  unsigned long regions_update_interval;
  struct timespec64 last_aggregation;
  struct timespec64 last_regions_update;
  struct task_struct *kdamond;
  bool kdamond_stop;
  struct mutex kdamond_lock;
  struct damon_primitive primitive;
  struct damon_callback callback;
  enum damon_target_type target_type;
  union {
    struct {
      unsigned long min_nr_regions;
      unsigned long max_nr_regions;
      struct list_head adaptive_targets;
    };
    void *arbitrary_target;
  };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sample_interval</span></code></dt><dd><p>The time between access samplings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aggr_interval</span></code></dt><dd><p>The time between monitor results aggregations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regions_update_interval</span></code></dt><dd><p>The time between monitor regions updates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kdamond</span></code></dt><dd><p>Kernel thread who does the monitoring.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kdamond_stop</span></code></dt><dd><p>Notifies whether kdamond should stop.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kdamond_lock</span></code></dt><dd><p>Mutex for the synchronizations with <strong>kdamond</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">primitive</span></code></dt><dd><p>Set of monitoring primitives for given use cases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">callback</span></code></dt><dd><p>Set of callbacks for monitoring events notifications.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">target_type</span></code></dt><dd><p>Type of the monitoring target.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_nr_regions</span></code></dt><dd><p>The minimum number of adaptive monitoring regions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_nr_regions</span></code></dt><dd><p>The maximum number of adaptive monitoring regions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adaptive_targets</span></code></dt><dd><p>Head of monitoring targets (<code class="xref c c-type docutils literal notranslate"><span class="pre">damon_target</span></code>) list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">arbitrary_target</span></code></dt><dd><p>Pointer to arbitrary type target.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each <strong>sample_interval</strong>, DAMON checks whether each region is accessed or
not.  It aggregates and keeps the access information (number of accesses to
each region) for <strong>aggr_interval</strong> time.  DAMON also checks whether the target
memory regions need update (e.g., by <code class="docutils literal notranslate"><span class="pre">mmap()</span></code> calls from the application,
in case of virtual memory monitoring) and applies the changes for each
<strong>regions_update_interval</strong>.  All time intervals are in micro-seconds.  Please
refer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">damon_primitive</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">damon_callback</span></code> for more detail.</p>
<p>For each monitoring context, one kernel thread for the monitoring is
created.  The pointer to the thread is stored in <strong>kdamond</strong>.</p>
<p>Once started, the monitoring thread runs until explicitly required to be
terminated or every monitoring target is invalid.  The validity of the
targets is checked via the <code class="xref c c-type docutils literal notranslate"><span class="pre">damon_primitive.target_valid</span></code> of <strong>primitive</strong>.  The
termination can also be explicitly requested by writing non-zero to
<strong>kdamond_stop</strong>.  The thread sets <strong>kdamond</strong> to NULL when it terminates.
Therefore, users can know whether the monitoring is ongoing or terminated by
reading <strong>kdamond</strong>.  Reads and writes to <strong>kdamond</strong> and <strong>kdamond_stop</strong> from
outside of the monitoring thread must be protected by <strong>kdamond_lock</strong>.</p>
<p>Note that the monitoring thread protects only <strong>kdamond</strong> and <strong>kdamond_stop</strong> via
<strong>kdamond_lock</strong>.  Accesses to other fields must be protected by themselves.</p>
<p><strong>min_nr_regions</strong>, <strong>max_nr_regions</strong> and <strong>adaptive_targets</strong> are valid only if
<strong>target_type</strong> is <code class="xref c c-type docutils literal notranslate"><span class="pre">DAMON_ADAPTIVE_TARGET</span></code>.  <strong>arbitrary_target</strong> is valid only if
<strong>target_type</strong> is <code class="xref c c-type docutils literal notranslate"><span class="pre">DAMON_ARBITRARY_TARGET</span></code>.</p>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.V4L.damon_set_targets">
int <code class="sig-name descname">damon_set_targets</code><span class="sig-paren">(</span>struct damon_ctx<em> *ctx</em>, unsigned long<em> *ids</em>, ssize_t<em> nr_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.V4L.damon_set_targets" title="Permalink to this definition">¶</a></dt>
<dd><p>Set monitoring targets.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">damon_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>monitoring context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*ids</span></code></dt><dd><p>array of target ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">nr_ids</span></code></dt><dd><p>number of entries in <strong>ids</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should not be called while the kdamond is running.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.V4L.damon_set_attrs">
int <code class="sig-name descname">damon_set_attrs</code><span class="sig-paren">(</span>struct damon_ctx<em> *ctx</em>, unsigned long<em> sample_int</em>, unsigned long<em> aggr_int</em>, unsigned long<em> regions_update_int</em>, unsigned long<em> min_nr_reg</em>, unsigned long<em> max_nr_reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.V4L.damon_set_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set attributes for the monitoring.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">damon_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>monitoring context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">sample_int</span></code></dt><dd><p>time interval between samplings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">aggr_int</span></code></dt><dd><p>time interval between aggregations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">regions_update_int</span></code></dt><dd><p>time interval between target regions update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min_nr_reg</span></code></dt><dd><p>minimal number of regions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_nr_reg</span></code></dt><dd><p>maximum number of regions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should not be called while the kdamond is running.
Every time interval is in micro-seconds.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.V4L.damon_nr_running_ctxs">
int <code class="sig-name descname">damon_nr_running_ctxs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.V4L.damon_nr_running_ctxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of currently running contexts.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<dl class="function">
<dt id="c.V4L.damon_start">
int <code class="sig-name descname">damon_start</code><span class="sig-paren">(</span>struct damon_ctx<em> **ctxs</em>, int<em> nr_ctxs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.V4L.damon_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts the monitorings for a given group of contexts.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">damon_ctx</span> <span class="pre">**ctxs</span></code></dt><dd><p>an array of the pointers for contexts to start monitoring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_ctxs</span></code></dt><dd><p>size of <strong>ctxs</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function starts a group of monitoring threads for a group of monitoring
contexts.  One thread per each context is created and run in parallel.  The
caller should handle synchronization between the threads by itself.  If a
group of threads that created by other ‘damon_start()’ call is currently
running, this function does nothing but returns -EBUSY.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.V4L.damon_stop">
int <code class="sig-name descname">damon_stop</code><span class="sig-paren">(</span>struct damon_ctx<em> **ctxs</em>, int<em> nr_ctxs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.V4L.damon_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops the monitorings for a given group of contexts.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">damon_ctx</span> <span class="pre">**ctxs</span></code></dt><dd><p>an array of the pointers for contexts to stop monitoring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_ctxs</span></code></dt><dd><p>size of <strong>ctxs</strong></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="eval.html" class="btn btn-neutral float-left" title="Evaluation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>