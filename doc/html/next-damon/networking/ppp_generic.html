

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PPP Generic Driver and Channel Interface &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>PPP Generic Driver and Channel Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/ppp_generic.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ppp-generic-driver-and-channel-interface">
<h1>PPP Generic Driver and Channel Interface<a class="headerlink" href="#ppp-generic-driver-and-channel-interface" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Paul Mackerras
<a class="reference external" href="mailto:paulus&#37;&#52;&#48;samba&#46;org">paulus<span>&#64;</span>samba<span>&#46;</span>org</a></p>
<blockquote>
<div>7 Feb 2002</div></blockquote>
</div></blockquote>
<p>The generic PPP driver in linux-2.4 provides an implementation of the
functionality which is of use in any PPP implementation, including:</p>
<ul class="simple">
<li>the network interface unit (ppp0 etc.)</li>
<li>the interface to the networking code</li>
<li>PPP multilink: splitting datagrams between multiple links, and
ordering and combining received fragments</li>
<li>the interface to pppd, via a /dev/ppp character device</li>
<li>packet compression and decompression</li>
<li>TCP/IP header compression and decompression</li>
<li>detecting network traffic for demand dialling and for idle timeouts</li>
<li>simple packet filtering</li>
</ul>
<p>For sending and receiving PPP frames, the generic PPP driver calls on
the services of PPP <code class="docutils literal notranslate"><span class="pre">channels</span></code>.  A PPP channel encapsulates a
mechanism for transporting PPP frames from one machine to another.  A
PPP channel implementation can be arbitrarily complex internally but
has a very simple interface with the generic PPP code: it merely has
to be able to send PPP frames, receive PPP frames, and optionally
handle ioctl requests.  Currently there are PPP channel
implementations for asynchronous serial ports, synchronous serial
ports, and for PPP over ethernet.</p>
<p>This architecture makes it possible to implement PPP multilink in a
natural and straightforward way, by allowing more than one channel to
be linked to each ppp network interface unit.  The generic layer is
responsible for splitting datagrams on transmit and recombining them
on receive.</p>
<div class="section" id="ppp-channel-api">
<h2>PPP channel API<a class="headerlink" href="#ppp-channel-api" title="Permalink to this headline">¶</a></h2>
<p>See include/linux/ppp_channel.h for the declaration of the types and
functions used to communicate between the generic PPP layer and PPP
channels.</p>
<p>Each channel has to provide two functions to the generic PPP layer,
via the ppp_channel.ops pointer:</p>
<ul class="simple">
<li>start_xmit() is called by the generic layer when it has a frame to
send.  The channel has the option of rejecting the frame for
flow-control reasons.  In this case, start_xmit() should return 0
and the channel should call the ppp_output_wakeup() function at a
later time when it can accept frames again, and the generic layer
will then attempt to retransmit the rejected frame(s).  If the frame
is accepted, the start_xmit() function should return 1.</li>
<li>ioctl() provides an interface which can be used by a user-space
program to control aspects of the channel’s behaviour.  This
procedure will be called when a user-space program does an ioctl
system call on an instance of /dev/ppp which is bound to the
channel.  (Usually it would only be pppd which would do this.)</li>
</ul>
<p>The generic PPP layer provides seven functions to channels:</p>
<ul class="simple">
<li>ppp_register_channel() is called when a channel has been created, to
notify the PPP generic layer of its presence.  For example, setting
a serial port to the PPPDISC line discipline causes the ppp_async
channel code to call this function.</li>
<li>ppp_unregister_channel() is called when a channel is to be
destroyed.  For example, the ppp_async channel code calls this when
a hangup is detected on the serial port.</li>
<li>ppp_output_wakeup() is called by a channel when it has previously
rejected a call to its start_xmit function, and can now accept more
packets.</li>
<li>ppp_input() is called by a channel when it has received a complete
PPP frame.</li>
<li>ppp_input_error() is called by a channel when it has detected that a
frame has been lost or dropped (for example, because of a FCS (frame
check sequence) error).</li>
<li>ppp_channel_index() returns the channel index assigned by the PPP
generic layer to this channel.  The channel should provide some way
(e.g. an ioctl) to transmit this back to user-space, as user-space
will need it to attach an instance of /dev/ppp to this channel.</li>
<li>ppp_unit_number() returns the unit number of the ppp network
interface to which this channel is connected, or -1 if the channel
is not connected.</li>
</ul>
<p>Connecting a channel to the ppp generic layer is initiated from the
channel code, rather than from the generic layer.  The channel is
expected to have some way for a user-level process to control it
independently of the ppp generic layer.  For example, with the
ppp_async channel, this is provided by the file descriptor to the
serial port.</p>
<p>Generally a user-level process will initialize the underlying
communications medium and prepare it to do PPP.  For example, with an
async tty, this can involve setting the tty speed and modes, issuing
modem commands, and then going through some sort of dialog with the
remote system to invoke PPP service there.  We refer to this process
as <code class="docutils literal notranslate"><span class="pre">discovery</span></code>.  Then the user-level process tells the medium to
become a PPP channel and register itself with the generic PPP layer.
The channel then has to report the channel number assigned to it back
to the user-level process.  From that point, the PPP negotiation code
in the PPP daemon (pppd) can take over and perform the PPP
negotiation, accessing the channel through the /dev/ppp interface.</p>
<p>At the interface to the PPP generic layer, PPP frames are stored in
skbuff structures and start with the two-byte PPP protocol number.
The frame does <em>not</em> include the 0xff <code class="docutils literal notranslate"><span class="pre">address</span></code> byte or the 0x03
<code class="docutils literal notranslate"><span class="pre">control</span></code> byte that are optionally used in async PPP.  Nor is there
any escaping of control characters, nor are there any FCS or framing
characters included.  That is all the responsibility of the channel
code, if it is needed for the particular medium.  That is, the skbuffs
presented to the start_xmit() function contain only the 2-byte
protocol number and the data, and the skbuffs presented to ppp_input()
must be in the same format.</p>
<p>The channel must provide an instance of a ppp_channel struct to
represent the channel.  The channel is free to use the <code class="docutils literal notranslate"><span class="pre">private</span></code> field
however it wishes.  The channel should initialize the <code class="docutils literal notranslate"><span class="pre">mtu</span></code> and
<code class="docutils literal notranslate"><span class="pre">hdrlen</span></code> fields before calling ppp_register_channel() and not change
them until after ppp_unregister_channel() returns.  The <code class="docutils literal notranslate"><span class="pre">mtu</span></code> field
represents the maximum size of the data part of the PPP frames, that
is, it does not include the 2-byte protocol number.</p>
<p>If the channel needs some headroom in the skbuffs presented to it for
transmission (i.e., some space free in the skbuff data area before the
start of the PPP frame), it should set the <code class="docutils literal notranslate"><span class="pre">hdrlen</span></code> field of the
ppp_channel struct to the amount of headroom required.  The generic
PPP layer will attempt to provide that much headroom but the channel
should still check if there is sufficient headroom and copy the skbuff
if there isn’t.</p>
<p>On the input side, channels should ideally provide at least 2 bytes of
headroom in the skbuffs presented to ppp_input().  The generic PPP
code does not require this but will be more efficient if this is done.</p>
</div>
<div class="section" id="buffering-and-flow-control">
<h2>Buffering and flow control<a class="headerlink" href="#buffering-and-flow-control" title="Permalink to this headline">¶</a></h2>
<p>The generic PPP layer has been designed to minimize the amount of data
that it buffers in the transmit direction.  It maintains a queue of
transmit packets for the PPP unit (network interface device) plus a
queue of transmit packets for each attached channel.  Normally the
transmit queue for the unit will contain at most one packet; the
exceptions are when pppd sends packets by writing to /dev/ppp, and
when the core networking code calls the generic layer’s start_xmit()
function with the queue stopped, i.e. when the generic layer has
called <a class="reference internal" href="kapi.html#c.netif_stop_queue" title="netif_stop_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_stop_queue()</span></code></a>, which only happens on a transmit timeout.
The start_xmit function always accepts and queues the packet which it
is asked to transmit.</p>
<p>Transmit packets are dequeued from the PPP unit transmit queue and
then subjected to TCP/IP header compression and packet compression
(Deflate or BSD-Compress compression), as appropriate.  After this
point the packets can no longer be reordered, as the decompression
algorithms rely on receiving compressed packets in the same order that
they were generated.</p>
<p>If multilink is not in use, this packet is then passed to the attached
channel’s start_xmit() function.  If the channel refuses to take
the packet, the generic layer saves it for later transmission.  The
generic layer will call the channel’s start_xmit() function again
when the channel calls  ppp_output_wakeup() or when the core
networking code calls the generic layer’s start_xmit() function
again.  The generic layer contains no timeout and retransmission
logic; it relies on the core networking code for that.</p>
<p>If multilink is in use, the generic layer divides the packet into one
or more fragments and puts a multilink header on each fragment.  It
decides how many fragments to use based on the length of the packet
and the number of channels which are potentially able to accept a
fragment at the moment.  A channel is potentially able to accept a
fragment if it doesn’t have any fragments currently queued up for it
to transmit.  The channel may still refuse a fragment; in this case
the fragment is queued up for the channel to transmit later.  This
scheme has the effect that more fragments are given to higher-
bandwidth channels.  It also means that under light load, the generic
layer will tend to fragment large packets across all the channels,
thus reducing latency, while under heavy load, packets will tend to be
transmitted as single fragments, thus reducing the overhead of
fragmentation.</p>
</div>
<div class="section" id="smp-safety">
<h2>SMP safety<a class="headerlink" href="#smp-safety" title="Permalink to this headline">¶</a></h2>
<p>The PPP generic layer has been designed to be SMP-safe.  Locks are
used around accesses to the internal data structures where necessary
to ensure their integrity.  As part of this, the generic layer
requires that the channels adhere to certain requirements and in turn
provides certain guarantees to the channels.  Essentially the channels
are required to provide the appropriate locking on the ppp_channel
structures that form the basis of the communication between the
channel and the generic layer.  This is because the channel provides
the storage for the ppp_channel structure, and so the channel is
required to provide the guarantee that this storage exists and is
valid at the appropriate times.</p>
<p>The generic layer requires these guarantees from the channel:</p>
<ul class="simple">
<li>The ppp_channel object must exist from the time that
ppp_register_channel() is called until after the call to
ppp_unregister_channel() returns.</li>
<li>No thread may be in a call to any of ppp_input(), ppp_input_error(),
ppp_output_wakeup(), ppp_channel_index() or ppp_unit_number() for a
channel at the time that ppp_unregister_channel() is called for that
channel.</li>
<li>ppp_register_channel() and ppp_unregister_channel() must be called
from process context, not interrupt or softirq/BH context.</li>
<li>The remaining generic layer functions may be called at softirq/BH
level but must not be called from a hardware interrupt handler.</li>
<li>The generic layer may call the channel start_xmit() function at
softirq/BH level but will not call it at interrupt level.  Thus the
start_xmit() function may not block.</li>
<li>The generic layer will only call the channel ioctl() function in
process context.</li>
</ul>
<p>The generic layer provides these guarantees to the channels:</p>
<ul class="simple">
<li>The generic layer will not call the start_xmit() function for a
channel while any thread is already executing in that function for
that channel.</li>
<li>The generic layer will not call the ioctl() function for a channel
while any thread is already executing in that function for that
channel.</li>
<li>By the time a call to ppp_unregister_channel() returns, no thread
will be executing in a call from the generic layer to that channel’s
start_xmit() or ioctl() function, and the generic layer will not
call either of those functions subsequently.</li>
</ul>
</div>
<div class="section" id="interface-to-pppd">
<h2>Interface to pppd<a class="headerlink" href="#interface-to-pppd" title="Permalink to this headline">¶</a></h2>
<p>The PPP generic layer exports a character device interface called
/dev/ppp.  This is used by pppd to control PPP interface units and
channels.  Although there is only one /dev/ppp, each open instance of
/dev/ppp acts independently and can be attached either to a PPP unit
or a PPP channel.  This is achieved using the file-&gt;private_data field
to point to a separate object for each open instance of /dev/ppp.  In
this way an effect similar to Solaris’ clone open is obtained,
allowing us to control an arbitrary number of PPP interfaces and
channels without having to fill up /dev with hundreds of device names.</p>
<p>When /dev/ppp is opened, a new instance is created which is initially
unattached.  Using an ioctl call, it can then be attached to an
existing unit, attached to a newly-created unit, or attached to an
existing channel.  An instance attached to a unit can be used to send
and receive PPP control frames, using the read() and write() system
calls, along with poll() if necessary.  Similarly, an instance
attached to a channel can be used to send and receive PPP frames on
that channel.</p>
<p>In multilink terms, the unit represents the bundle, while the channels
represent the individual physical links.  Thus, a PPP frame sent by a
write to the unit (i.e., to an instance of /dev/ppp attached to the
unit) will be subject to bundle-level compression and to fragmentation
across the individual links (if multilink is in use).  In contrast, a
PPP frame sent by a write to the channel will be sent as-is on that
channel, without any multilink header.</p>
<p>A channel is not initially attached to any unit.  In this state it can
be used for PPP negotiation but not for the transfer of data packets.
It can then be connected to a PPP unit with an ioctl call, which
makes it available to send and receive data packets for that unit.</p>
<p>The ioctl calls which are available on an instance of /dev/ppp depend
on whether it is unattached, attached to a PPP interface, or attached
to a PPP channel.  The ioctl calls which are available on an
unattached instance are:</p>
<ul class="simple">
<li>PPPIOCNEWUNIT creates a new PPP interface and makes this /dev/ppp
instance the “owner” of the interface.  The argument should point to
an int which is the desired unit number if &gt;= 0, or -1 to assign the
lowest unused unit number.  Being the owner of the interface means
that the interface will be shut down if this instance of /dev/ppp is
closed.</li>
<li>PPPIOCATTACH attaches this instance to an existing PPP interface.
The argument should point to an int containing the unit number.
This does not make this instance the owner of the PPP interface.</li>
<li>PPPIOCATTCHAN attaches this instance to an existing PPP channel.
The argument should point to an int containing the channel number.</li>
</ul>
<p>The ioctl calls available on an instance of /dev/ppp attached to a
channel are:</p>
<ul class="simple">
<li>PPPIOCCONNECT connects this channel to a PPP interface.  The
argument should point to an int containing the interface unit
number.  It will return an EINVAL error if the channel is already
connected to an interface, or ENXIO if the requested interface does
not exist.</li>
<li>PPPIOCDISCONN disconnects this channel from the PPP interface that
it is connected to.  It will return an EINVAL error if the channel
is not connected to an interface.</li>
<li>All other ioctl commands are passed to the channel ioctl() function.</li>
</ul>
<p>The ioctl calls that are available on an instance that is attached to
an interface unit are:</p>
<ul>
<li><p class="first">PPPIOCSMRU sets the MRU (maximum receive unit) for the interface.
The argument should point to an int containing the new MRU value.</p>
</li>
<li><p class="first">PPPIOCSFLAGS sets flags which control the operation of the
interface.  The argument should be a pointer to an int containing
the new flags value.  The bits in the flags value that can be set
are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>SC_COMP_TCP</td>
<td>enable transmit TCP header compression</td>
</tr>
<tr class="row-even"><td>SC_NO_TCP_CCID</td>
<td>disable connection-id compression for
TCP header compression</td>
</tr>
<tr class="row-odd"><td>SC_REJ_COMP_TCP</td>
<td>disable receive TCP header decompression</td>
</tr>
<tr class="row-even"><td>SC_CCP_OPEN</td>
<td>Compression Control Protocol (CCP) is
open, so inspect CCP packets</td>
</tr>
<tr class="row-odd"><td>SC_CCP_UP</td>
<td>CCP is up, may (de)compress packets</td>
</tr>
<tr class="row-even"><td>SC_LOOP_TRAFFIC</td>
<td>send IP traffic to pppd</td>
</tr>
<tr class="row-odd"><td>SC_MULTILINK</td>
<td>enable PPP multilink fragmentation on
transmitted packets</td>
</tr>
<tr class="row-even"><td>SC_MP_SHORTSEQ</td>
<td>expect short multilink sequence
numbers on received multilink fragments</td>
</tr>
<tr class="row-odd"><td>SC_MP_XSHORTSEQ</td>
<td>transmit short multilink sequence nos.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The values of these flags are defined in &lt;linux/ppp-ioctl.h&gt;.  Note
that the values of the SC_MULTILINK, SC_MP_SHORTSEQ and
SC_MP_XSHORTSEQ bits are ignored if the CONFIG_PPP_MULTILINK option
is not selected.</p>
</li>
<li><p class="first">PPPIOCGFLAGS returns the value of the status/control flags for the
interface unit.  The argument should point to an int where the ioctl
will store the flags value.  As well as the values listed above for
PPPIOCSFLAGS, the following bits may be set in the returned value:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>SC_COMP_RUN</td>
<td>CCP compressor is running</td>
</tr>
<tr class="row-even"><td>SC_DECOMP_RUN</td>
<td>CCP decompressor is running</td>
</tr>
<tr class="row-odd"><td>SC_DC_ERROR</td>
<td>CCP decompressor detected non-fatal error</td>
</tr>
<tr class="row-even"><td>SC_DC_FERROR</td>
<td>CCP decompressor detected fatal error</td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p class="first">PPPIOCSCOMPRESS sets the parameters for packet compression or
decompression.  The argument should point to a ppp_option_data
structure (defined in &lt;linux/ppp-ioctl.h&gt;), which contains a
pointer/length pair which should describe a block of memory
containing a CCP option specifying a compression method and its
parameters.  The ppp_option_data struct also contains a <code class="docutils literal notranslate"><span class="pre">transmit</span></code>
field.  If this is 0, the ioctl will affect the receive path,
otherwise the transmit path.</p>
</li>
<li><p class="first">PPPIOCGUNIT returns, in the int pointed to by the argument, the unit
number of this interface unit.</p>
</li>
<li><p class="first">PPPIOCSDEBUG sets the debug flags for the interface to the value in
the int pointed to by the argument.  Only the least significant bit
is used; if this is 1 the generic layer will print some debug
messages during its operation.  This is only intended for debugging
the generic PPP layer code; it is generally not helpful for working
out why a PPP connection is failing.</p>
</li>
<li><p class="first">PPPIOCGDEBUG returns the debug flags for the interface in the int
pointed to by the argument.</p>
</li>
<li><p class="first">PPPIOCGIDLE returns the time, in seconds, since the last data
packets were sent and received.  The argument should point to a
ppp_idle structure (defined in &lt;linux/ppp_defs.h&gt;).  If the
CONFIG_PPP_FILTER option is enabled, the set of packets which reset
the transmit and receive idle timers is restricted to those which
pass the <code class="docutils literal notranslate"><span class="pre">active</span></code> packet filter.
Two versions of this command exist, to deal with user space
expecting times as either 32-bit or 64-bit time_t seconds.</p>
</li>
<li><p class="first">PPPIOCSMAXCID sets the maximum connection-ID parameter (and thus the
number of connection slots) for the TCP header compressor and
decompressor.  The lower 16 bits of the int pointed to by the
argument specify the maximum connection-ID for the compressor.  If
the upper 16 bits of that int are non-zero, they specify the maximum
connection-ID for the decompressor, otherwise the decompressor’s
maximum connection-ID is set to 15.</p>
</li>
<li><p class="first">PPPIOCSNPMODE sets the network-protocol mode for a given network
protocol.  The argument should point to an npioctl struct (defined
in &lt;linux/ppp-ioctl.h&gt;).  The <code class="docutils literal notranslate"><span class="pre">protocol</span></code> field gives the PPP protocol
number for the protocol to be affected, and the <code class="docutils literal notranslate"><span class="pre">mode</span></code> field
specifies what to do with packets for that protocol:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>NPMODE_PASS</td>
<td>normal operation, transmit and receive packets</td>
</tr>
<tr class="row-even"><td>NPMODE_DROP</td>
<td>silently drop packets for this protocol</td>
</tr>
<tr class="row-odd"><td>NPMODE_ERROR</td>
<td>drop packets and return an error on transmit</td>
</tr>
<tr class="row-even"><td>NPMODE_QUEUE</td>
<td>queue up packets for transmit, drop received
packets</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>At present NPMODE_ERROR and NPMODE_QUEUE have the same effect as
NPMODE_DROP.</p>
</li>
<li><p class="first">PPPIOCGNPMODE returns the network-protocol mode for a given
protocol.  The argument should point to an npioctl struct with the
<code class="docutils literal notranslate"><span class="pre">protocol</span></code> field set to the PPP protocol number for the protocol of
interest.  On return the <code class="docutils literal notranslate"><span class="pre">mode</span></code> field will be set to the network-
protocol mode for that protocol.</p>
</li>
<li><p class="first">PPPIOCSPASS and PPPIOCSACTIVE set the <code class="docutils literal notranslate"><span class="pre">pass</span></code> and <code class="docutils literal notranslate"><span class="pre">active</span></code> packet
filters.  These ioctls are only available if the CONFIG_PPP_FILTER
option is selected.  The argument should point to a sock_fprog
structure (defined in &lt;linux/filter.h&gt;) containing the compiled BPF
instructions for the filter.  Packets are dropped if they fail the
<code class="docutils literal notranslate"><span class="pre">pass</span></code> filter; otherwise, if they fail the <code class="docutils literal notranslate"><span class="pre">active</span></code> filter they are
passed but they do not reset the transmit or receive idle timer.</p>
</li>
<li><p class="first">PPPIOCSMRRU enables or disables multilink processing for received
packets and sets the multilink MRRU (maximum reconstructed receive
unit).  The argument should point to an int containing the new MRRU
value.  If the MRRU value is 0, processing of received multilink
fragments is disabled.  This ioctl is only available if the
CONFIG_PPP_MULTILINK option is selected.</p>
</li>
</ul>
<p>Last modified: 7-feb-2002</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>