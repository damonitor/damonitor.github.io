

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Memory Hot(Un)Plug &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.13.0-rc6-mm1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Memory Hot(Un)Plug</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/admin-guide/mm/memory-hotplug.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memory-hot-un-plug">
<span id="admin-guide-memory-hotplug"></span><h1>Memory Hot(Un)Plug<a class="headerlink" href="#memory-hot-un-plug" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Created</dt>
<dd class="field-odd"><p>Jul 28 2007</p>
</dd>
<dt class="field-even">Updated</dt>
<dd class="field-even"><p>Add some details about locking internals:             Aug 20 2018</p>
</dd>
<dt class="field-odd">Updated</dt>
<dd class="field-odd"><p>Complete overhaul:                                    May 18 2021</p>
</dd>
</dl>
<p>This document describes generic Linux support for memory hot(un)plug with
a focus on System RAM, including ZONE_MOVABLE support.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#phases-of-memory-hotplug" id="id2">Phases of Memory Hotplug</a></p></li>
<li><p><a class="reference internal" href="#phases-of-memory-hotunplug" id="id3">Phases of Memory Hotunplug</a></p></li>
<li><p><a class="reference internal" href="#unit-of-memory-hot-un-plug" id="id4">Unit of Memory Hot(Un)Plug</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#memory-hotplug-notifications" id="id5">Memory Hotplug Notifications</a></p>
<ul>
<li><p><a class="reference internal" href="#acpi-notifications" id="id6">ACPI Notifications</a></p></li>
<li><p><a class="reference internal" href="#manual-probing" id="id7">Manual Probing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#onlining-and-offlining-memory-blocks" id="id8">Onlining and Offlining Memory Blocks</a></p>
<ul>
<li><p><a class="reference internal" href="#onlining-memory-blocks-manually" id="id9">Onlining Memory Blocks Manually</a></p></li>
<li><p><a class="reference internal" href="#onlining-memory-blocks-automatically" id="id10">Onlining Memory Blocks Automatically</a></p></li>
<li><p><a class="reference internal" href="#offlining-memory-blocks" id="id11">Offlining Memory Blocks</a></p></li>
<li><p><a class="reference internal" href="#observing-the-state-of-memory-blocks" id="id12">Observing the State of Memory Blocks</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#configuring-memory-hot-un-plug" id="id13">Configuring Memory Hot(Un)Plug</a></p>
<ul>
<li><p><a class="reference internal" href="#memory-hot-un-plug-configuration-via-sysfs" id="id14">Memory Hot(Un)Plug Configuration via Sysfs</a></p></li>
<li><p><a class="reference internal" href="#memory-block-configuration-via-sysfs" id="id15">Memory Block Configuration via Sysfs</a></p></li>
<li><p><a class="reference internal" href="#cmdline-parameters" id="id16">Cmdline Parameters</a></p></li>
<li><p><a class="reference internal" href="#module-parameters" id="id17">Module Parameters</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#zone-movable" id="id18">ZONE_MOVABLE</a></p>
<ul>
<li><p><a class="reference internal" href="#zone-imbalances" id="id19">Zone Imbalances</a></p></li>
<li><p><a class="reference internal" href="#considerations" id="id20">Considerations</a></p></li>
<li><p><a class="reference internal" href="#boot-memory-and-zone-movable" id="id21">Boot Memory and ZONE_MOVABLE</a></p></li>
<li><p><a class="reference internal" href="#memory-offlining-and-zone-movable" id="id22">Memory Offlining and ZONE_MOVABLE</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#locking-internals" id="id23">Locking Internals</a></p></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Memory hot(un)plug allows for increasing and decreasing the physical memory
available to a machine at runtime. In the simplest case, it consists of
physically plugging or unplugging a DIMM at runtime, coordinated with the
operating system.</p>
<p>Memory hot(un)plug is used for various purposes:</p>
<ol class="upperalpha simple">
<li><p>The physical memory available to a machine can be adjusted at runtime,
up- or downgrading the memory capacity. This dynamic memory
resizing, sometimes referred to as “capacity on demand”, is frequently
used with virtual machines and logical partitions.</p></li>
<li><p>Replacing hardware, such as DIMMs or whole NUMA nodes, without downtime.
One example is replacing failing memory modules.</p></li>
<li><p>Reducing memory consumption either by physically unplugging
memory modules or by logically unplugging (parts of) memory modules
from Linux.</p></li>
</ol>
<p>Further, the basic memory hot(un)plug infrastructure in Linux is nowadays
also used to expose PMEM, other performance-differentiated
memory and reserved memory regions as ordinary system RAM to Linux.</p>
<div class="section" id="phases-of-memory-hotplug">
<h3><a class="toc-backref" href="#id2">Phases of Memory Hotplug</a><a class="headerlink" href="#phases-of-memory-hotplug" title="Permalink to this headline">¶</a></h3>
<p>Memory hotplug consists of two phases:</p>
<ol class="arabic simple">
<li><p>Adding the memory to Linux</p></li>
<li><p>Onlining memory blocks</p></li>
</ol>
<p>In the first phase, metadata (such as the memmap) is allocated, page tables
for the direct mapping are allocated and initialized, and memory blocks
are created; the latter also creates sysfs files for managing
newly created memory blocks.</p>
<p>In the second phase, added memory is exposed to the page allocator. After this
phase, the memory is visible in memory statistics, such as free and total
memory, of the system.</p>
</div>
<div class="section" id="phases-of-memory-hotunplug">
<h3><a class="toc-backref" href="#id3">Phases of Memory Hotunplug</a><a class="headerlink" href="#phases-of-memory-hotunplug" title="Permalink to this headline">¶</a></h3>
<p>Memory hotunplug consists of two phases:</p>
<ol class="arabic simple">
<li><p>Offlining memory blocks</p></li>
<li><p>Removing the memory from Linux</p></li>
</ol>
<p>In the fist phase, memory is “hidden” from the page allocator again, for
example, by migrating busy memory to other memory locations and removing all
relevant free pages from the page allocator After this phase, the memory
is no longer visible in memory statistics of the system.</p>
<p>In the second phase, the memory blocks are removed, the direct map is torn
down, and metadata is freed.</p>
</div>
<div class="section" id="unit-of-memory-hot-un-plug">
<h3><a class="toc-backref" href="#id4">Unit of Memory Hot(Un)Plug</a><a class="headerlink" href="#unit-of-memory-hot-un-plug" title="Permalink to this headline">¶</a></h3>
<p>Memory hot(un)plug uses the SPARSEMEM memory model, which divides the physical
memory address space into chunks of the same size: memory sections. The size
of a memory section is architecture dependent. For example, x86_64 uses
128 MiB and ppc64 uses 16 MiB.</p>
<p>Memory sections are combined into chunks referred to as “memory blocks”. The
size of a memory block is architecture dependent and corresponds to the smallest
granularity that can be hot(un)plugged. The default size of a memory block is
the same as memory section size, unless an architecture specifies otherwise.</p>
<p>All memory blocks have the same size.</p>
</div>
</div>
<div class="section" id="memory-hotplug-notifications">
<h2><a class="toc-backref" href="#id5">Memory Hotplug Notifications</a><a class="headerlink" href="#memory-hotplug-notifications" title="Permalink to this headline">¶</a></h2>
<p>There are various ways how Linux is notified about memory hotplug events
such that it can start adding hotplugged memory. This description is
mostly limited to mechanisms present on physical machines; mechanisms specific
to virtual machines or logical partitions are not described.</p>
<div class="section" id="acpi-notifications">
<h3><a class="toc-backref" href="#id6">ACPI Notifications</a><a class="headerlink" href="#acpi-notifications" title="Permalink to this headline">¶</a></h3>
<p>Platforms that support ACPI, such as x86_64, can support memory hotplug
notifications via ACPI.</p>
<p>In general, a firmware supporting memory hotplug defines a memory class
object _HID “PNP0C80”. When notified about hotplug of a new memory device,
the ACPI driver will hotplug the memory to Linux.</p>
<p>If the firmware supports hotplug of NUMA nodes, it defines an object _HID
“ACPI0004”, “PNP0A05”, or “PNP0A06”. When notified about an hotplug event,
all assigned memory devices are added to Linux by the ACPI driver.</p>
<p>Similarly, Linux can be notified about requests to hotunplug a memory device
or a NUMA node via ACPI. The ACPI driver will try offlining all relevant memory
blocks, and, if successful, hotunplug the memory from Linux.</p>
</div>
<div class="section" id="manual-probing">
<h3><a class="toc-backref" href="#id7">Manual Probing</a><a class="headerlink" href="#manual-probing" title="Permalink to this headline">¶</a></h3>
<p>On some architectures, the firmware may not be able to notify the operating
system about a memory hotplug event. Instead, the memory has to be manually
probed from user space.</p>
<p>The probe interface is located at:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/memory/probe
</pre></div>
</div>
<p>Only complete memory blocks can be probed. Individual memory blocks are
probed by providing the physical start address of the memory block:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo addr &gt; /sys/devices/system/memory/probe
</pre></div>
</div>
<p>Which results in a memory block for the range [addr, addr + memory_block_size)
being created.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using the probe interface is discouraged as it is easy to crash the kernel,
because Linux cannot validate user input; this interface might be removed in
the future.</p>
</div>
</div>
</div>
<div class="section" id="onlining-and-offlining-memory-blocks">
<h2><a class="toc-backref" href="#id8">Onlining and Offlining Memory Blocks</a><a class="headerlink" href="#onlining-and-offlining-memory-blocks" title="Permalink to this headline">¶</a></h2>
<p>After a memory block has been created, Linux has to be instructed to actually
make use of that memory: the memory block has to be “online”.</p>
<p>Before a memory block can be removed, Linux has to stop using any memory
part of the memory block: the memory block has to be “offlined”.</p>
<p>The Linux kernel can be configured to automatically online added memory
blocks and drivers automatically trigger offlining of memory blocks
when trying hotunplug of memory. Memory blocks can only be removed once offlining
succeeded.</p>
<div class="section" id="onlining-memory-blocks-manually">
<h3><a class="toc-backref" href="#id9">Onlining Memory Blocks Manually</a><a class="headerlink" href="#onlining-memory-blocks-manually" title="Permalink to this headline">¶</a></h3>
<p>If auto-onlining of memory blocks isn’t enabled, user-space has to manually
trigger onlining of memory blocks. Often, udev rules are used to automate this
task in user space.</p>
<p>Onlining of a memory block can be triggered via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo online &gt; /sys/devices/system/memory/memoryXXX/state
</pre></div>
</div>
<p>Or alternatively:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo 1 &gt; /sys/devices/system/memory/memoryXXX/online
</pre></div>
</div>
<p>The kernel will select the target zone automatically, usually defaulting
to <code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> unless <code class="docutils literal notranslate"><span class="pre">movablecore=1</span></code> has been specified on the kernel
cmdline or if the memory block would intersect the ZONE_MOVABLE already.</p>
<p>One can explicitly request to associate it with ZONE_MOVABLE by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo online_movable &gt; /sys/devices/system/memory/memoryXXX/state
</pre></div>
</div>
<p>Or one can explicitly request a kernel zone (usually ZONE_NORMAL) by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo online_kernel &gt; /sys/devices/system/memory/memoryXXX/state
</pre></div>
</div>
<p>In any case, if offline succeeds, the state of the memory block is changed to
be “online”. If it fails, an error will be returned by the kernel.</p>
</div>
<div class="section" id="onlining-memory-blocks-automatically">
<h3><a class="toc-backref" href="#id10">Onlining Memory Blocks Automatically</a><a class="headerlink" href="#onlining-memory-blocks-automatically" title="Permalink to this headline">¶</a></h3>
<p>The kernel can be configured to try auto-onlining of newly added memory blocks.
If disabled, the memory blocks will stay offline until explicitly onlined
from user space.</p>
<p>The configured auto-online behavior can be observed via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% cat /sys/devices/system/memory/auto_online_blocks
</pre></div>
</div>
<p>Auto-onlining can be enabled by writing <code class="docutils literal notranslate"><span class="pre">online</span></code>, <code class="docutils literal notranslate"><span class="pre">online_kernel</span></code> or
<code class="docutils literal notranslate"><span class="pre">online_movable</span></code> to that file, like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo online &gt; /sys/devices/system/memory/auto_online_blocks
</pre></div>
</div>
<p>Modifying the auto-online behavior will only affect all subsequently
added memory blocks only.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In corner cases, auto-onlining can fail. The kernel won’t retry. Note that
auto-onlining is not expected to fail in default configurations.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>DLPAR on ppc64 ignores the <code class="docutils literal notranslate"><span class="pre">offline</span></code> setting and will still online added
memory blocks; if onlining fails, memory blocks are removed again.</p>
</div>
</div>
<div class="section" id="offlining-memory-blocks">
<h3><a class="toc-backref" href="#id11">Offlining Memory Blocks</a><a class="headerlink" href="#offlining-memory-blocks" title="Permalink to this headline">¶</a></h3>
<p>In the current implementation, Linux’s memory offlining will try migrating
all movable pages off the affected memory block. As most kernel allocations,
such as page tables, are unmovable, page migration can fail and, therefore,
inhibit memory offlining from succeeding.</p>
<p>Having the memory provided by memory block managed by ZONE_MOVABLE severely
increases memory offlining reliability; still, memory offlining can fail in
some corner cases.</p>
<p>Further, memory offlining might retry for a long time (or even forever),
until aborted by the user.</p>
<p>Offlining of a memory block can be triggered via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo offline &gt; /sys/devices/system/memory/memoryXXX/state
</pre></div>
</div>
<p>Or alternatively:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo 0 &gt; /sys/devices/system/memory/memoryXXX/online
</pre></div>
</div>
<p>If offline succeeds, the state of the memory block is changed to be “offline”.
If it fails, an error will be returned by the kernel.</p>
</div>
<div class="section" id="observing-the-state-of-memory-blocks">
<h3><a class="toc-backref" href="#id12">Observing the State of Memory Blocks</a><a class="headerlink" href="#observing-the-state-of-memory-blocks" title="Permalink to this headline">¶</a></h3>
<p>The state (online/offline/going-offline) of a memory block can be observed
either via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% cat /sys/device/system/memory/memoryXXX/state
</pre></div>
</div>
<p>Or alternatively (1/0) via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% cat /sys/device/system/memory/memoryXXX/online
</pre></div>
</div>
<p>For an online memory block, the managing zone van be observed via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% cat /sys/device/system/memory/memoryXXX/valid_zones
</pre></div>
</div>
</div>
</div>
<div class="section" id="configuring-memory-hot-un-plug">
<h2><a class="toc-backref" href="#id13">Configuring Memory Hot(Un)Plug</a><a class="headerlink" href="#configuring-memory-hot-un-plug" title="Permalink to this headline">¶</a></h2>
<p>There are various ways how admins can configure memory hot(un)plug and interact
with memory blocks, especially, to online them.</p>
<div class="section" id="memory-hot-un-plug-configuration-via-sysfs">
<h3><a class="toc-backref" href="#id14">Memory Hot(Un)Plug Configuration via Sysfs</a><a class="headerlink" href="#memory-hot-un-plug-configuration-via-sysfs" title="Permalink to this headline">¶</a></h3>
<p>Some memory hot(un)plug properties can be configured or inspected via sysfs in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/memory/
</pre></div>
</div>
<p>The following files are currently defined:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">auto_online_blocks</span></code></p></td>
<td><p>read-write: set or get the default state of new memory
blocks; configure auto-onlining.</p>
<p>See the <code class="docutils literal notranslate"><span class="pre">state</span></code> property of memory blocks for details.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">block_size_bytes</span></code></p></td>
<td><p>read-only: the size in bytes of a memory block.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">probe</span></code></p></td>
<td><p>write-only: add (probe) selected memory blocks manually
from user space by supplying the physical start address.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">uevent</span></code></p></td>
<td><p>read-write: generic udev file for device subsystems.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default of <code class="docutils literal notranslate"><span class="pre">auto_online_blocks</span></code> depends on
CONFIG_MEMORY_HOTPLUG_DEFAULT_ONLINE.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With CONFIG_MEMORY_FAILURE, two additional files <code class="docutils literal notranslate"><span class="pre">hard_offline_page</span></code> and
<code class="docutils literal notranslate"><span class="pre">soft_offline_page</span></code> are available to trigger hwpoisoning of pages, for
example, for testing purposes. Note that this functionality is not really
related to memory hot(un)plug or actual offlining of memory blocks.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">probe</span></code> is only available with CONFIG_ARCH_MEMORY_PROBE.</p>
</div>
</div>
<div class="section" id="memory-block-configuration-via-sysfs">
<h3><a class="toc-backref" href="#id15">Memory Block Configuration via Sysfs</a><a class="headerlink" href="#memory-block-configuration-via-sysfs" title="Permalink to this headline">¶</a></h3>
<p>Each memory block is represented as a memory block device that can be
onlined or offlined. All memory blocks have their device information located in
sysfs. Each present memory block is listed under
<code class="docutils literal notranslate"><span class="pre">/sys/devices/system/memory</span></code> as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/memory/memoryXXX
</pre></div>
</div>
<p>where XXX is the memory block id; the number of digits is variable.</p>
<p>A present memory block indicates that some memory in the range is present;
however, a memory block might span memory holes. A memory block spanning
memory holes cannot be offlined.</p>
<p>For example, assume 1 GiB memory block size. A device for a memory starting at
0x100000000 is <code class="docutils literal notranslate"><span class="pre">/sys/device/system/memory/memory4</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(0x100000000 / 1Gib = 4)
</pre></div>
</div>
<p>This device covers address range [0x100000000 … 0x140000000)</p>
<p>The following files are currently defined:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 76%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">online</span></code></p></td>
<td><p>read-write: simplified interface to trigger onlining /
offlining and to observe the state of a memory block.
When onlining, the zone is selected automatically.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">phys_device</span></code></p></td>
<td><p>read-only: legacy interface only ever used on s390x to
expose the covered storage increment.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">phys_index</span></code></p></td>
<td><p>read-only: the memory block id (XXX).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">removable</span></code></p></td>
<td><p>read-only: legacy interface that indicated whether a memory
block was likely to be offlineable or not. Nowadays, the
kernel return <code class="docutils literal notranslate"><span class="pre">1</span></code> if and only if it supports memory
offlining.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">state</span></code></p></td>
<td><p>read-write: advanced interface to trigger onlining /
offlining and to observe the state of a memory block.</p>
<p>When writing, <code class="docutils literal notranslate"><span class="pre">online</span></code>, <code class="docutils literal notranslate"><span class="pre">offline</span></code>, <code class="docutils literal notranslate"><span class="pre">online_kernel</span></code> and
<code class="docutils literal notranslate"><span class="pre">online_movable</span></code> are supported.</p>
<p><code class="docutils literal notranslate"><span class="pre">online_movable</span></code> specifies onlining to ZONE_MOVABLE.
<code class="docutils literal notranslate"><span class="pre">online_kernel</span></code> specifies onlining to the default kernel
zone for the memory block, such as ZONE_NORMAL.
<code class="docutils literal notranslate"><span class="pre">online</span></code> let’s the kernel select the zone automatically.</p>
<p>When reading, <code class="docutils literal notranslate"><span class="pre">online</span></code>, <code class="docutils literal notranslate"><span class="pre">offline</span></code> and <code class="docutils literal notranslate"><span class="pre">going-offline</span></code>
may be returned.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">uevent</span></code></p></td>
<td><p>read-write: generic uevent file for devices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">valid_zones</span></code></p></td>
<td><p>read-only: shows by which zone memory provided by an
online memory block is managed, and by which zone memory
provided by an offline memory block could be managed when
onlining.</p>
<p>For online memory blocks, <code class="docutils literal notranslate"><span class="pre">DMA</span></code>, <code class="docutils literal notranslate"><span class="pre">DMA32</span></code>, <code class="docutils literal notranslate"><span class="pre">Normal</span></code>,
<code class="docutils literal notranslate"><span class="pre">Movable</span></code> and <code class="docutils literal notranslate"><span class="pre">none</span></code> may be returned. <code class="docutils literal notranslate"><span class="pre">none</span></code> indicates
that memory provided by a memory block is managed by
multiple zones or spans multiple nodes; such memory blocks
cannot be offlined. <code class="docutils literal notranslate"><span class="pre">Movable</span></code> indicates ZONE_MOVABLE.
Other values indicate a kernel zone.</p>
<p>For offline memory blocks, the first column shows the
zone the kernel would select when onlining the memory block
right now without further specifying a zone.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">valid_zones</span></code> is only available with CONFIG_MEMORY_HOTREMOVE.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If CONFIG_NUMA is enabled the memoryXXX/ directories can also be accessed
via symbolic links located in the <code class="docutils literal notranslate"><span class="pre">/sys/devices/system/node/node*</span></code>
directories.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/node/node0/memory9 -&gt; ../../memory/memory9
</pre></div>
</div>
<p>A backlink will also be created:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/memory/memory9/node0 -&gt; ../../node/node0
</pre></div>
</div>
</div>
</div>
<div class="section" id="cmdline-parameters">
<h3><a class="toc-backref" href="#id16">Cmdline Parameters</a><a class="headerlink" href="#cmdline-parameters" title="Permalink to this headline">¶</a></h3>
<p>Some cmdline parameters affect memory hot(un)plug handling. The following
cmdline parameters are relevant:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">memhp_default_state</span></code></p></td>
<td><p>configure auto-onlining by essentially setting
<code class="docutils literal notranslate"><span class="pre">/sys/devices/system/memory/auto_online_blocks</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">movablecore</span></code></p></td>
<td><p>configure automatic zone selection of the kernel. When
set, the kernel will default to ZONE_MOVABLE, unless
other zones can be kept contiguous.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-parameters">
<h3><a class="toc-backref" href="#id17">Module Parameters</a><a class="headerlink" href="#module-parameters" title="Permalink to this headline">¶</a></h3>
<p>Instead of additional cmdline parameters or sysfs files, the <code class="docutils literal notranslate"><span class="pre">memory_hotplug</span></code>
subsystem now provides a dedicated namespace for module parameters. Module
parameters can be set via the cmdline by predicating them with
<code class="docutils literal notranslate"><span class="pre">memory_hotplug.</span></code> such as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>memory_hotplug.memmap_on_memory=1
</pre></div>
</div>
<p>and they can be observed (and some even modified at runtime) via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/modules/memory_hotplug/parameters/
</pre></div>
</div>
<p>The following module parameters are currently defined:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">memmap_on_memory</span></code></p></td>
<td><p>read-write: Allocate memory for the memmap from the
added memory block itself. Even if enabled, actual
support depends on various other system properties and
should only be regarded as a hint whether the behavior
would be desired.</p>
<p>While allocating the memmap from the memory block
itself makes memory hotplug less likely to fail and
keeps the memmap on the same NUMA node in any case, it
can fragment physical memory in a way that huge pages
in bigger granularity cannot be formed on hotplugged
memory.</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="zone-movable">
<h2><a class="toc-backref" href="#id18">ZONE_MOVABLE</a><a class="headerlink" href="#zone-movable" title="Permalink to this headline">¶</a></h2>
<p>ZONE_MOVABLE is an important mechanism for more reliable memory offlining.
Further, having system RAM managed by ZONE_MOVABLE instead of one of the
kernel zones can increase the number of possible transparent huge pages and
dynamically allocated huge pages.</p>
<p>Only movable allocations are served from ZONE_MOVABLE, resulting in
unmovable allocations being limited to the kernel zones. Without ZONE_MOVABLE,
there is absolutely no guarantee whether a memory block can be offlined
successfully.</p>
<div class="section" id="zone-imbalances">
<h3><a class="toc-backref" href="#id19">Zone Imbalances</a><a class="headerlink" href="#zone-imbalances" title="Permalink to this headline">¶</a></h3>
<p>Most kernel allocations are unmovable. Important examples include the memmap
(usually 1/64 of memory), page tables, and <a class="reference internal" href="../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>. Such allocations
can only be served from the kernel zones.</p>
<p>Most user space pages, such as anonymous memory, and page cache pages
are movable. Such allocations can be served from ZONE_MOVABLE and the kernel
zones.</p>
<p>Having too much system RAM managed by ZONE_MOVABLE is called a zone imbalance,
which can harm the system or degrade performance. As one example, the kernel
might crash because it runs out of free memory for unmovable allocations,
although there is still plenty of free memory left in ZONE_MOVABLE.</p>
<p>Usually, MOVABLE:KERNEL ratios of up to 3:1 or even 4:1 are fine. Ratios of 63:1
are definitely impossible due to the memmap overhead.</p>
<p>Actual safe zone ratios depend on the workload. Extreme cases, like excessive
long-term pinning of pages, might not be able to deal with ZONE_MOVABLE at all.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CMA memory part of a kernel zone essentially behaves like memory in
ZONE_MOVABLE and similar considerations apply, especially when combining
CMA with ZONE_MOVABLE.</p>
</div>
</div>
<div class="section" id="considerations">
<h3><a class="toc-backref" href="#id20">Considerations</a><a class="headerlink" href="#considerations" title="Permalink to this headline">¶</a></h3>
<p>We usually expect that a large portion of available system RAM will actually
be consumed by user space, either directly or indirectly via the page cache. In
the normal case, ZONE_MOVABLE can be used when allocating such pages just fine.</p>
<p>With that in mind, it makes sense that we can have a big portion of system RAM
managed by ZONE_MOVABLE. However, there are some things to consider when
using ZONE_MOVABLE, especially when fine-tuning zone ratios:</p>
<ul>
<li><p>Having a lot of offline memory blocks. Even offline memory blocks consume
memory for metadata and page tables in the direct map; having a lot of
offline memory blocks is not a typical case, though.</p></li>
<li><p>Memory ballooning. Some memory ballooning implementations, such as
the Hyper-V balloon, the XEN balloon, the vbox balloon and the VMWare
balloon with huge pages don’t support balloon compaction and, thereby
ZONE_MOVABLE.</p>
<p>Further, CONFIG_BALLOON_COMPACTION might be disabled. In that case, balloon
inflation will only perform unmovable allocations and silently create a
zone imbalance, usually triggered by inflation requests from the
hypervisor.</p>
</li>
<li><p>Gigantic pages are unmovable, resulting in user space consuming a
lot of unmovable memory.</p></li>
<li><p>Huge pages are unmovable when an architectures does not support huge
page migration, resulting in a similar issue as with gigantic pages.</p></li>
<li><p>Page tables are unmovable. Excessive swapping, mapping extremely large
files or ZONE_DEVICE memory can be problematic, although only
really relevant in corner cases. When we manage a lot of user space memory
that has been swapped out or is served from a file/pmem/… we still need
a lot of page tables to manage that memory once user space accessed that
memory once.</p></li>
<li><p>DAX: when we have a lot of ZONE_DEVICE memory added to the system as DAX
and we are not using an altmap to allocate the memmap from device memory
directly, we will have to allocate the memmap for this memory from the
kernel zones.</p></li>
<li><p>Long-term pinning of pages. Techniques that rely on long-term pinnings
(especially, RDMA and vfio/mdev) are fundamentally problematic with
ZONE_MOVABLE, and therefore, memory offlining. Pinned pages cannot reside
on ZONE_MOVABLE as that would turn these pages unmovable. Therefore, they
have to be migrated off that zone while pinning. Pinning a page can fail
even if there is plenty of free memory in ZONE_MOVABLE.</p>
<p>In addition, using ZONE_MOVABLE might make page pinning more expensive,
because of the page migration overhead.</p>
</li>
</ul>
</div>
<div class="section" id="boot-memory-and-zone-movable">
<h3><a class="toc-backref" href="#id21">Boot Memory and ZONE_MOVABLE</a><a class="headerlink" href="#boot-memory-and-zone-movable" title="Permalink to this headline">¶</a></h3>
<p>Without further configuration, all boot memory will be managed by kernel zones
when booting up in most configurations. ZONE_MOVABLE is not used as default.</p>
<p>However, there is a mechanism to configure that behavior during boot via the
cmdline: <code class="docutils literal notranslate"><span class="pre">kernelcore=</span></code> and <code class="docutils literal notranslate"><span class="pre">movablecore=</span></code>. See
<a class="reference internal" href="../kernel-parameters.html"><span class="doc">The kernel’s command-line parameters</span></a> for details.</p>
</div>
<div class="section" id="memory-offlining-and-zone-movable">
<h3><a class="toc-backref" href="#id22">Memory Offlining and ZONE_MOVABLE</a><a class="headerlink" href="#memory-offlining-and-zone-movable" title="Permalink to this headline">¶</a></h3>
<p>Even with ZONE_MOVABLE, there are some corner cases where offlining a memory
block might fail:</p>
<ul>
<li><p>Memory blocks with memory holes; this applies to memory blocks present during
boot and can apply to memory blocks hotplugged via the XEN balloon and the
Hyper-V balloon.</p></li>
<li><p>Mixed NUMA nodes and mixed zones within a single memory block prevent memory
offlining; this applies to memory blocks present during boot only.</p></li>
<li><p>Special memory blocks prevented by the system from getting offlined. Examples
include any memory available during boot on arm64 or memory blocks spanning
the crashkernel area on s390x; this usually applies to memory blocks present
during boot only.</p></li>
<li><p>Memory blocks overlapping with CMA areas cannot be offlined, this applies to
memory blocks present during boot only.</p></li>
<li><p>Concurrent activity that operates on the same physical memory area, such as
allocating gigantic pages, can result in temporary offlining failures.</p></li>
<li><p>Out of memory when dissolving huge pages, especially when freeing unused
vmemmap pages associated with each hugetlb page is enabled.</p>
<p>Offlining code may be able to migrate huge page contents, but may not be able
to dissolve the source huge page because it fails allocating (unmovable) pages
for the vmemmap, because the system might not have free memory in the kernel
zones left.</p>
<p>Users that depend on memory hotplug to succeed for movable zones should
carefully consider whether the memory savings gained from this feature are
worth the risk of possibly not being able to offline memory in certain
situations.</p>
</li>
</ul>
<p>Further, when running into out of memory situations while migrating pages, or
when still encountering permanently unmovable pages within ZONE_MOVABLE
(-&gt; BUG), memory offlining will keep retrying until it eventually succeeds.</p>
</div>
</div>
<div class="section" id="locking-internals">
<h2><a class="toc-backref" href="#id23">Locking Internals</a><a class="headerlink" href="#locking-internals" title="Permalink to this headline">¶</a></h2>
<p>When adding/removing memory that uses memory block devices (i.e. ordinary RAM),
the device_hotplug_lock should be held to:</p>
<ul class="simple">
<li><p>synchronize against online/offline requests (e.g. via sysfs). This way, memory
block devices can only be accessed (.online/.state attributes) by user
space once memory has been fully added. And when removing memory, we
know nobody is in critical sections.</p></li>
<li><p>synchronize against CPU hotplug and similar (e.g. relevant for ACPI and PPC)</p></li>
</ul>
<p>Especially, there is a possible lock inversion that is avoided using
device_hotplug_lock when adding memory and user space tries to online that
memory faster than expected:</p>
<ul class="simple">
<li><p>device_online() will first take the device_lock(), followed by
mem_hotplug_lock</p></li>
<li><p>add_memory_resource() will first take the mem_hotplug_lock, followed by
the device_lock() (while creating the devices, during bus_add_device()).</p></li>
</ul>
<p>As the device is visible to user space before taking the device_lock(), this
can result in a lock inversion.</p>
<p>onlining/offlining of memory should be done via device_online()/
device_offline() – to make sure it is properly synchronized to actions
via sysfs – while holding the device_hotplug_lock.</p>
<p>When adding/removing/onlining/offlining memory or adding/removing
heterogeneous/device memory, we should always hold the mem_hotplug_lock in
write mode to serialise memory hotplug (e.g. access to global/zone
variables).</p>
<p>In addition, mem_hotplug_lock (in contrast to device_hotplug_lock) in read
mode allows for a quite efficient get_online_mems/put_online_mems
implementation, so code accessing memory can protect from that memory
vanishing.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>