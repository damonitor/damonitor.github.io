

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Cache &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Cache</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/admin-guide/device-mapper/cache.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cache">
<h1>Cache<a class="headerlink" href="#cache" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>dm-cache is a device mapper target written by Joe Thornber, Heinz
Mauelshagen, and Mike Snitzer.</p>
<p>It aims to improve performance of a block device (eg, a spindle) by
dynamically migrating some of its data to a faster, smaller device
(eg, an SSD).</p>
<p>This device-mapper solution allows us to insert this caching at
different levels of the dm stack, for instance above the data device for
a thin-provisioning pool.  Caching solutions that are integrated more
closely with the virtual memory system should give better performance.</p>
<p>The target reuses the metadata library used in the thin-provisioning
library.</p>
<p>The decision as to what data to migrate and when is left to a plug-in
policy module.  Several of these have been written as we experiment,
and we hope other people will contribute others for specific io
scenarios (eg. a vm image server).</p>
</div>
<div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="docutils">
<dt>Migration</dt>
<dd>Movement of the primary copy of a logical block from one
device to the other.</dd>
<dt>Promotion</dt>
<dd>Migration from slow device to fast device.</dd>
<dt>Demotion</dt>
<dd>Migration from fast device to slow device.</dd>
</dl>
</div></blockquote>
<p>The origin device always contains a copy of the logical block, which
may be out of date or kept in sync with the copy on the cache device
(depending on policy).</p>
</div>
<div class="section" id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sub-devices">
<h3>Sub-devices<a class="headerlink" href="#sub-devices" title="Permalink to this headline">¶</a></h3>
<p>The target is constructed by passing three devices to it (along with
other parameters detailed later):</p>
<ol class="arabic simple">
<li>An origin device - the big, slow one.</li>
<li>A cache device - the small, fast one.</li>
<li>A small metadata device - records which blocks are in the cache,
which are dirty, and extra hints for use by the policy object.
This information could be put on the cache device, but having it
separate allows the volume manager to configure it differently,
e.g. as a mirror for extra robustness.  This metadata device may only
be used by a single cache device.</li>
</ol>
</div>
<div class="section" id="fixed-block-size">
<h3>Fixed block size<a class="headerlink" href="#fixed-block-size" title="Permalink to this headline">¶</a></h3>
<p>The origin is divided up into blocks of a fixed size.  This block size
is configurable when you first create the cache.  Typically we’ve been
using block sizes of 256KB - 1024KB.  The block size must be between 64
sectors (32KB) and 2097152 sectors (1GB) and a multiple of 64 sectors (32KB).</p>
<p>Having a fixed block size simplifies the target a lot.  But it is
something of a compromise.  For instance, a small part of a block may be
getting hit a lot, yet the whole block will be promoted to the cache.
So large block sizes are bad because they waste cache space.  And small
block sizes are bad because they increase the amount of metadata (both
in core and on disk).</p>
</div>
<div class="section" id="cache-operating-modes">
<h3>Cache operating modes<a class="headerlink" href="#cache-operating-modes" title="Permalink to this headline">¶</a></h3>
<p>The cache has three operating modes: writeback, writethrough and
passthrough.</p>
<p>If writeback, the default, is selected then a write to a block that is
cached will go only to the cache and the block will be marked dirty in
the metadata.</p>
<p>If writethrough is selected then a write to a cached block will not
complete until it has hit both the origin and cache devices.  Clean
blocks should remain clean.</p>
<p>If passthrough is selected, useful when the cache contents are not known
to be coherent with the origin device, then all reads are served from
the origin device (all reads miss the cache) and all writes are
forwarded to the origin device; additionally, write hits cause cache
block invalidates.  To enable passthrough mode the cache must be clean.
Passthrough mode allows a cache device to be activated without having to
worry about coherency.  Coherency that exists is maintained, although
the cache will gradually cool as writes take place.  If the coherency of
the cache can later be verified, or established through use of the
“invalidate_cblocks” message, the cache device can be transitioned to
writethrough or writeback mode while still warm.  Otherwise, the cache
contents can be discarded prior to transitioning to the desired
operating mode.</p>
<p>A simple cleaner policy is provided, which will clean (write back) all
dirty blocks in a cache.  Useful for decommissioning a cache or when
shrinking a cache.  Shrinking the cache’s fast device requires all cache
blocks, in the area of the cache being removed, to be clean.  If the
area being removed from the cache still contains dirty blocks the resize
will fail.  Care must be taken to never reduce the volume used for the
cache’s fast device until the cache is clean.  This is of particular
importance if writeback mode is used.  Writethrough and passthrough
modes already maintain a clean cache.  Future support to partially clean
the cache, above a specified threshold, will allow for keeping the cache
warm and in writeback mode during resize.</p>
</div>
<div class="section" id="migration-throttling">
<h3>Migration throttling<a class="headerlink" href="#migration-throttling" title="Permalink to this headline">¶</a></h3>
<p>Migrating data between the origin and cache device uses bandwidth.
The user can set a throttle to prevent more than a certain amount of
migration occurring at any one time.  Currently we’re not taking any
account of normal io traffic going to the devices.  More work needs
doing here to avoid migrating during those peak io moments.</p>
<p>For the time being, a message “migration_threshold &lt;#sectors&gt;”
can be used to set the maximum number of sectors being migrated,
the default being 2048 sectors (1MB).</p>
</div>
<div class="section" id="updating-on-disk-metadata">
<h3>Updating on-disk metadata<a class="headerlink" href="#updating-on-disk-metadata" title="Permalink to this headline">¶</a></h3>
<p>On-disk metadata is committed every time a FLUSH or FUA bio is written.
If no such requests are made then commits will occur every second.  This
means the cache behaves like a physical disk that has a volatile write
cache.  If power is lost you may lose some recent writes.  The metadata
should always be consistent in spite of any crash.</p>
<p>The ‘dirty’ state for a cache block changes far too frequently for us
to keep updating it on the fly.  So we treat it as a hint.  In normal
operation it will be written when the dm device is suspended.  If the
system crashes all cache blocks will be assumed dirty when restarted.</p>
</div>
<div class="section" id="per-block-policy-hints">
<h3>Per-block policy hints<a class="headerlink" href="#per-block-policy-hints" title="Permalink to this headline">¶</a></h3>
<p>Policy plug-ins can store a chunk of data per cache block.  It’s up to
the policy how big this chunk is, but it should be kept small.  Like the
dirty flags this data is lost if there’s a crash so a safe fallback
value should always be possible.</p>
<p>Policy hints affect performance, not correctness.</p>
</div>
<div class="section" id="policy-messaging">
<h3>Policy messaging<a class="headerlink" href="#policy-messaging" title="Permalink to this headline">¶</a></h3>
<p>Policies will have different tunables, specific to each one, so we
need a generic way of getting and setting these.  Device-mapper
messages are used.  Refer to cache-policies.txt.</p>
</div>
<div class="section" id="discard-bitset-resolution">
<h3>Discard bitset resolution<a class="headerlink" href="#discard-bitset-resolution" title="Permalink to this headline">¶</a></h3>
<p>We can avoid copying data during migration if we know the block has
been discarded.  A prime example of this is when mkfs discards the
whole block device.  We store a bitset tracking the discard state of
blocks.  However, we allow this bitset to have a different block size
from the cache blocks.  This is because we need to track the discard
state for all of the origin device (compare with the dirty bitset
which is just for the smaller cache device).</p>
</div>
</div>
<div class="section" id="target-interface">
<h2>Target interface<a class="headerlink" href="#target-interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="constructor">
<h3>Constructor<a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cache &lt;metadata dev&gt; &lt;cache dev&gt; &lt;origin dev&gt; &lt;block size&gt;
      &lt;#feature args&gt; [&lt;feature arg&gt;]*
      &lt;policy&gt; &lt;#policy args&gt; [policy args]*
</pre></div>
</div>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>metadata dev</td>
<td>fast device holding the persistent metadata</td>
</tr>
<tr class="row-even"><td>cache dev</td>
<td>fast device holding cached data blocks</td>
</tr>
<tr class="row-odd"><td>origin dev</td>
<td>slow device holding original data blocks</td>
</tr>
<tr class="row-even"><td>block size</td>
<td>cache unit size in sectors</td>
</tr>
<tr class="row-odd"><td>#feature args</td>
<td>number of feature arguments passed</td>
</tr>
<tr class="row-even"><td>feature args</td>
<td>writethrough or passthrough (The default is writeback.)</td>
</tr>
<tr class="row-odd"><td>policy</td>
<td>the replacement policy to use</td>
</tr>
<tr class="row-even"><td>#policy args</td>
<td>an even number of arguments corresponding to
key/value pairs passed to the policy</td>
</tr>
<tr class="row-odd"><td>policy args</td>
<td>key/value pairs passed to the policy
E.g. ‘sequential_threshold 1024’
See cache-policies.txt for details.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Optional feature arguments are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>writethrough</td>
<td>write through caching that prohibits cache block
content from being different from origin block content.
Without this argument, the default behaviour is to write
back cache block contents later for performance reasons,
so they may differ from the corresponding origin blocks.</td>
</tr>
<tr class="row-even"><td>passthrough</td>
<td>a degraded mode useful for various cache coherency
situations (e.g., rolling back snapshots of
underlying storage).     Reads and writes always go to
the origin.     If a write goes to a cached origin
block, then the cache block is invalidated.
To enable passthrough mode the cache must be clean.</td>
</tr>
<tr class="row-odd"><td>metadata2</td>
<td>use version 2 of the metadata.  This stores the dirty
bits in a separate btree, which improves speed of
shutting down the cache.</td>
</tr>
<tr class="row-even"><td>no_discard_passdown</td>
<td>disable passing down discards from the cache
to the origin’s data device.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>A policy called ‘default’ is always registered.  This is an alias for
the policy we currently think is giving best all round performance.</p>
<p>As the default policy could vary between kernels, if you are relying on
the characteristics of a specific policy, always request it by name.</p>
</div>
<div class="section" id="status">
<h3>Status<a class="headerlink" href="#status" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;metadata block size&gt; &lt;#used metadata blocks&gt;/&lt;#total metadata blocks&gt;
&lt;cache block size&gt; &lt;#used cache blocks&gt;/&lt;#total cache blocks&gt;
&lt;#read hits&gt; &lt;#read misses&gt; &lt;#write hits&gt; &lt;#write misses&gt;
&lt;#demotions&gt; &lt;#promotions&gt; &lt;#dirty&gt; &lt;#features&gt; &lt;features&gt;*
&lt;#core args&gt; &lt;core args&gt;* &lt;policy name&gt; &lt;#policy args&gt; &lt;policy args&gt;*
&lt;cache metadata mode&gt;
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>metadata block size</td>
<td>Fixed block size for each metadata block in
sectors</td>
</tr>
<tr class="row-even"><td>#used metadata blocks</td>
<td>Number of metadata blocks used</td>
</tr>
<tr class="row-odd"><td>#total metadata blocks</td>
<td>Total number of metadata blocks</td>
</tr>
<tr class="row-even"><td>cache block size</td>
<td>Configurable block size for the cache device
in sectors</td>
</tr>
<tr class="row-odd"><td>#used cache blocks</td>
<td>Number of blocks resident in the cache</td>
</tr>
<tr class="row-even"><td>#total cache blocks</td>
<td>Total number of cache blocks</td>
</tr>
<tr class="row-odd"><td>#read hits</td>
<td>Number of times a READ bio has been mapped
to the cache</td>
</tr>
<tr class="row-even"><td>#read misses</td>
<td>Number of times a READ bio has been mapped
to the origin</td>
</tr>
<tr class="row-odd"><td>#write hits</td>
<td>Number of times a WRITE bio has been mapped
to the cache</td>
</tr>
<tr class="row-even"><td>#write misses</td>
<td>Number of times a WRITE bio has been
mapped to the origin</td>
</tr>
<tr class="row-odd"><td>#demotions</td>
<td>Number of times a block has been removed
from the cache</td>
</tr>
<tr class="row-even"><td>#promotions</td>
<td>Number of times a block has been moved to
the cache</td>
</tr>
<tr class="row-odd"><td>#dirty</td>
<td>Number of blocks in the cache that differ
from the origin</td>
</tr>
<tr class="row-even"><td>#feature args</td>
<td>Number of feature args to follow</td>
</tr>
<tr class="row-odd"><td>feature args</td>
<td>‘writethrough’ (optional)</td>
</tr>
<tr class="row-even"><td>#core args</td>
<td>Number of core arguments (must be even)</td>
</tr>
<tr class="row-odd"><td>core args</td>
<td>Key/value pairs for tuning the core
e.g. migration_threshold</td>
</tr>
<tr class="row-even"><td>policy name</td>
<td>Name of the policy</td>
</tr>
<tr class="row-odd"><td>#policy args</td>
<td>Number of policy arguments to follow (must be even)</td>
</tr>
<tr class="row-even"><td>policy args</td>
<td>Key/value pairs e.g. sequential_threshold</td>
</tr>
<tr class="row-odd"><td>cache metadata mode</td>
<td><p class="first">ro if read-only, rw if read-write</p>
<p class="last">In serious cases where even a read-only mode is
deemed unsafe no further I/O will be permitted and
the status will just contain the string ‘Fail’.
The userspace recovery tools should then be used.</p>
</td>
</tr>
<tr class="row-even"><td>needs_check</td>
<td>‘needs_check’ if set, ‘-‘ if not set
A metadata operation has failed, resulting in the
needs_check flag being set in the metadata’s
superblock.  The metadata device must be
deactivated and checked/repaired before the
cache can be made fully operational again.
‘-‘ indicates needs_check is not set.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="messages">
<h3>Messages<a class="headerlink" href="#messages" title="Permalink to this headline">¶</a></h3>
<p>Policies will have different tunables, specific to each one, so we
need a generic way of getting and setting these.  Device-mapper
messages are used.  (A sysfs interface would also be possible.)</p>
<p>The message format is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;key&gt; &lt;value&gt;
</pre></div>
</div>
<p>E.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dmsetup message my_cache 0 sequential_threshold 1024
</pre></div>
</div>
<p>Invalidation is removing an entry from the cache without writing it
back.  Cache blocks can be invalidated via the invalidate_cblocks
message, which takes an arbitrary number of cblock ranges.  Each cblock
range’s end value is “one past the end”, meaning 5-10 expresses a range
of values from 5 to 9.  Each cblock must be expressed as a decimal
value, in the future a variant message that takes cblock ranges
expressed in hexadecimal may be needed to better support efficient
invalidation of larger caches.  The cache must be in passthrough mode
when invalidate_cblocks is used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>invalidate_cblocks [&lt;cblock&gt;|&lt;cblock begin&gt;-&lt;cblock end&gt;]*
</pre></div>
</div>
<p>E.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dmsetup message my_cache 0 invalidate_cblocks 2345 3456-4567 5678-6789
</pre></div>
</div>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>The test suite can be found here:</p>
<p><a class="reference external" href="https://github.com/jthornber/device-mapper-test-suite">https://github.com/jthornber/device-mapper-test-suite</a></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dmsetup create my_cache --table &#39;0 41943040 cache /dev/mapper/metadata \
        /dev/mapper/ssd /dev/mapper/origin 512 1 writeback default 0&#39;
dmsetup create my_cache --table &#39;0 41943040 cache /dev/mapper/metadata \
        /dev/mapper/ssd /dev/mapper/origin 1024 1 writeback \
        mq 4 sequential_threshold 1024 random_threshold 8&#39;
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>