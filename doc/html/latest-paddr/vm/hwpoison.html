

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hwpoison &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.13.0-rc6-mm1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>hwpoison</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/vm/hwpoison.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="hwpoison">
<h1>hwpoison<a class="headerlink" href="#hwpoison" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-is-hwpoison">
<h2>What is hwpoison?<a class="headerlink" href="#what-is-hwpoison" title="Permalink to this headline">¶</a></h2>
<p>Upcoming Intel CPUs have support for recovering from some memory errors
(<code class="docutils literal notranslate"><span class="pre">MCA</span> <span class="pre">recovery</span></code>). This requires the OS to declare a page “poisoned”,
kill the processes associated with it and avoid using it in the future.</p>
<p>This patchkit implements the necessary infrastructure in the VM.</p>
<p>To quote the overview comment:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>High level machine check handler. Handles pages reported by the
hardware as being corrupted usually due to a 2bit ECC memory or cache
failure.

This focusses on pages detected as corrupted in the background.
When the current CPU tries to consume corruption the currently
running process can just be killed directly instead. This implies
that if the error cannot be handled for some reason it&#39;s safe to
just ignore it because no corruption has been consumed yet. Instead
when that happens another machine check will happen.

Handles page cache pages in various states. The tricky part
here is that we can access any page asynchronous to other VM
users, because memory failures could happen anytime and anywhere,
possibly violating some of their assumptions. This is why this code
has to be extremely careful. Generally it tries to use normal locking
rules, as in get the standard locks, even if that means the
error handling takes potentially a long time.

Some of the operations here are somewhat inefficient and have non
linear algorithmic complexity, because the data structures have not
been optimized for this case. This is in particular the case
for the mapping from a vma to a process. Since this case is expected
to be rare we hope we can get away with this.
</pre></div>
</div>
<p>The code consists of a the high level handler in mm/memory-failure.c,
a new page poison bit and various checks in the VM to handle poisoned
pages.</p>
<p>The main target right now is KVM guests, but it works for all kinds
of applications. KVM support requires a recent qemu-kvm release.</p>
<p>For the KVM use there was need for a new signal type so that
KVM can inject the machine check into the guest with the proper
address. This in theory allows other applications to handle
memory failures too. The expection is that near all applications
won’t do that, but some very specialized ones might.</p>
</div>
<div class="section" id="failure-recovery-modes">
<h2>Failure recovery modes<a class="headerlink" href="#failure-recovery-modes" title="Permalink to this headline">¶</a></h2>
<p>There are two (actually three) modes memory failure recovery can be in:</p>
<dl class="simple">
<dt>vm.memory_failure_recovery sysctl set to zero:</dt><dd><p>All memory failures cause a panic. Do not attempt recovery.
(on x86 this can be also affected by the tolerant level of the
MCE subsystem)</p>
</dd>
<dt>early kill</dt><dd><p>(can be controlled globally and per process)
Send SIGBUS to the application as soon as the error is detected
This allows applications who can process memory errors in a gentle
way (e.g. drop affected object)
This is the mode used by KVM qemu.</p>
</dd>
<dt>late kill</dt><dd><p>Send SIGBUS when the application runs into the corrupted page.
This is best for memory error unaware applications and default
Note some pages are always handled as late kill.</p>
</dd>
</dl>
</div>
<div class="section" id="user-control">
<h2>User control<a class="headerlink" href="#user-control" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>vm.memory_failure_recovery</dt><dd><p>See sysctl.txt</p>
</dd>
<dt>vm.memory_failure_early_kill</dt><dd><p>Enable early kill mode globally</p>
</dd>
<dt>PR_MCE_KILL</dt><dd><p>Set early/late kill mode/revert to system default</p>
<dl>
<dt>arg1: PR_MCE_KILL_CLEAR:</dt><dd><p>Revert to system default</p>
</dd>
<dt>arg1: PR_MCE_KILL_SET:</dt><dd><p>arg2 defines thread specific mode</p>
<dl class="simple">
<dt>PR_MCE_KILL_EARLY:</dt><dd><p>Early kill</p>
</dd>
<dt>PR_MCE_KILL_LATE:</dt><dd><p>Late kill</p>
</dd>
<dt>PR_MCE_KILL_DEFAULT</dt><dd><p>Use system global default</p>
</dd>
</dl>
</dd>
</dl>
<p>Note that if you want to have a dedicated thread which handles
the SIGBUS(BUS_MCEERR_AO) on behalf of the process, you should
call prctl(PR_MCE_KILL_EARLY) on the designated thread. Otherwise,
the SIGBUS is sent to the main thread.</p>
</dd>
<dt>PR_MCE_KILL_GET</dt><dd><p>return current mode</p>
</dd>
</dl>
</div>
<div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>madvise(MADV_HWPOISON, ….) (as root) - Poison a page in the
process for testing</p></li>
<li><p>hwpoison-inject module through debugfs <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/hwpoison/</span></code></p>
<dl class="simple">
<dt>corrupt-pfn</dt><dd><p>Inject hwpoison fault at PFN echoed into this file. This does
some early filtering to avoid corrupted unintended pages in test suites.</p>
</dd>
<dt>unpoison-pfn</dt><dd><p>Software-unpoison page at PFN echoed into this file. This way
a page can be reused again.  This only works for Linux
injected failures, not for real memory failures.</p>
</dd>
</dl>
<p>Note these injection interfaces are not stable and might change between
kernel versions</p>
<dl>
<dt>corrupt-filter-dev-major, corrupt-filter-dev-minor</dt><dd><p>Only handle memory failures to pages associated with the file
system defined by block device major/minor.  -1U is the
wildcard value.  This should be only used for testing with
artificial injection.</p>
</dd>
<dt>corrupt-filter-memcg</dt><dd><p>Limit injection to pages owned by memgroup. Specified by inode
number of the memcg.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mkdir /sys/fs/cgroup/mem/hwpoison

usemem -m 100 -s 1000 &amp;
echo `jobs -p` &gt; /sys/fs/cgroup/mem/hwpoison/tasks

memcg_ino=$(ls -id /sys/fs/cgroup/mem/hwpoison | cut -f1 -d&#39; &#39;)
echo $memcg_ino &gt; /debug/hwpoison/corrupt-filter-memcg

page-types -p `pidof init`   --hwpoison  # shall do nothing
page-types -p `pidof usemem` --hwpoison  # poison its pages
</pre></div>
</div>
</dd>
<dt>corrupt-filter-flags-mask, corrupt-filter-flags-value</dt><dd><p>When specified, only poison pages if ((page_flags &amp; mask) ==
value).  This allows stress testing of many kinds of
pages. The page_flags are the same as in /proc/kpageflags. The
flag bits are defined in include/linux/kernel-page-flags.h and
documented in <a class="reference internal" href="../admin-guide/mm/pagemap.html"><span class="doc">Examining Process Page Tables</span></a></p>
</dd>
</dl>
</li>
<li><p>Architecture specific MCE injector</p>
<p>x86 has mce-inject, mce-test</p>
<p>Some portable hwpoison test programs in mce-test, see below.</p>
</li>
</ul>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt><a class="reference external" href="http://halobates.de/mce-lc09-2.pdf">http://halobates.de/mce-lc09-2.pdf</a></dt><dd><p>Overview presentation from LinuxCon 09</p>
</dd>
<dt>git://git.kernel.org/pub/scm/utils/cpu/mce/mce-test.git</dt><dd><p>Test suite (hwpoison specific portable tests in tsrc)</p>
</dd>
<dt>git://git.kernel.org/pub/scm/utils/cpu/mce/mce-inject.git</dt><dd><p>x86 specific injector</p>
</dd>
</dl>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Not all page types are supported and never will. Most kernel internal
objects cannot be recovered, only LRU pages for now.</p></li>
<li><p>Right now hugepage support is missing.</p></li>
</ul>
<p>—
Andi Kleen, Oct 2009</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>