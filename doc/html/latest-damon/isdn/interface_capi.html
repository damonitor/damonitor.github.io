

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel CAPI Interface to Hardware Drivers &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Kernel CAPI Interface to Hardware Drivers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/isdn/interface_capi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-capi-interface-to-hardware-drivers">
<h1>Kernel CAPI Interface to Hardware Drivers<a class="headerlink" href="#kernel-capi-interface-to-hardware-drivers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>From the CAPI 2.0 specification:
COMMON-ISDN-API (CAPI) is an application programming interface standard used
to access ISDN equipment connected to basic rate interfaces (BRI) and primary
rate interfaces (PRI).</p>
<p>Kernel CAPI operates as a dispatching layer between CAPI applications and CAPI
hardware drivers. Hardware drivers register ISDN devices (controllers, in CAPI
lingo) with Kernel CAPI to indicate their readiness to provide their service
to CAPI applications. CAPI applications also register with Kernel CAPI,
requesting association with a CAPI device. Kernel CAPI then dispatches the
application registration to an available device, forwarding it to the
corresponding hardware driver. Kernel CAPI then forwards CAPI messages in both
directions between the application and the hardware driver.</p>
<p>Format and semantics of CAPI messages are specified in the CAPI 2.0 standard.
This standard is freely available from <a class="reference external" href="https://www.capi.org">https://www.capi.org</a>.</p>
</div>
<div class="section" id="driver-and-device-registration">
<h2>2. Driver and Device Registration<a class="headerlink" href="#driver-and-device-registration" title="Permalink to this headline">¶</a></h2>
<p>CAPI drivers must register each of the ISDN devices they control with Kernel
CAPI by calling the Kernel CAPI function attach_capi_ctr() with a pointer to a
struct capi_ctr before they can be used. This structure must be filled with
the names of the driver and controller, and a number of callback function
pointers which are subsequently used by Kernel CAPI for communicating with the
driver. The registration can be revoked by calling the function
detach_capi_ctr() with a pointer to the same struct capi_ctr.</p>
<p>Before the device can be actually used, the driver must fill in the device
information fields ‘manu’, ‘version’, ‘profile’ and ‘serial’ in the capi_ctr
structure of the device, and signal its readiness by calling capi_ctr_ready().
From then on, Kernel CAPI may call the registered callback functions for the
device.</p>
<p>If the device becomes unusable for any reason (shutdown, disconnect …), the
driver has to call capi_ctr_down(). This will prevent further calls to the
callback functions by Kernel CAPI.</p>
</div>
<div class="section" id="application-registration-and-communication">
<h2>3. Application Registration and Communication<a class="headerlink" href="#application-registration-and-communication" title="Permalink to this headline">¶</a></h2>
<p>Kernel CAPI forwards registration requests from applications (calls to CAPI
operation CAPI_REGISTER) to an appropriate hardware driver by calling its
register_appl() callback function. A unique Application ID (ApplID, u16) is
allocated by Kernel CAPI and passed to register_appl() along with the
parameter structure provided by the application. This is analogous to the
open() operation on regular files or character devices.</p>
<p>After a successful return from register_appl(), CAPI messages from the
application may be passed to the driver for the device via calls to the
send_message() callback function. Conversely, the driver may call Kernel
CAPI’s capi_ctr_handle_message() function to pass a received CAPI message to
Kernel CAPI for forwarding to an application, specifying its ApplID.</p>
<p>Deregistration requests (CAPI operation CAPI_RELEASE) from applications are
forwarded as calls to the release_appl() callback function, passing the same
ApplID as with register_appl(). After return from release_appl(), no CAPI
messages for that application may be passed to or from the device anymore.</p>
</div>
<div class="section" id="data-structures">
<h2>4. Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="struct-capi-driver">
<h3>4.1 struct capi_driver<a class="headerlink" href="#struct-capi-driver" title="Permalink to this headline">¶</a></h3>
<p>This structure describes a Kernel CAPI driver itself. It is used in the
register_capi_driver() and unregister_capi_driver() functions, and contains
the following non-private fields, all to be set by the driver before calling
register_capi_driver():</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">name[32]</span></code></dt>
<dd>the name of the driver, as a zero-terminated ASCII string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">revision[32]</span></code></dt>
<dd>the revision number of the driver, as a zero-terminated ASCII string</dd>
</dl>
</div>
<div class="section" id="struct-capi-ctr">
<h3>4.2 struct capi_ctr<a class="headerlink" href="#struct-capi-ctr" title="Permalink to this headline">¶</a></h3>
<p>This structure describes an ISDN device (controller) handled by a Kernel CAPI
driver. After registration via the attach_capi_ctr() function it is passed to
all controller specific lower layer interface and callback functions to
identify the controller to operate on.</p>
<p>It contains the following non-private fields:</p>
<div class="section" id="to-be-set-by-the-driver-before-calling-attach-capi-ctr">
<h4>to be set by the driver before calling attach_capi_ctr():<a class="headerlink" href="#to-be-set-by-the-driver-before-calling-attach-capi-ctr" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt>
<dd>pointer to the driver module owning the device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*driverdata</span></code></dt>
<dd>an opaque pointer to driver specific data, not touched by Kernel CAPI</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">name[32]</span></code></dt>
<dd>the name of the controller, as a zero-terminated ASCII string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*driver_name</span></code></dt>
<dd>the name of the driver, as a zero-terminated ASCII string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*load_firmware)(struct</span> <span class="pre">capi_ctr</span> <span class="pre">*ctrlr,</span> <span class="pre">capiloaddata</span> <span class="pre">*ldata)</span></code></dt>
<dd><p class="first">(optional) pointer to a callback function for sending firmware and
configuration data to the device</p>
<p>The function may return before the operation has completed.</p>
<p>Completion must be signalled by a call to capi_ctr_ready().</p>
<p class="last">Return value: 0 on success, error code on error
Called in process context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*reset_ctr)(struct</span> <span class="pre">capi_ctr</span> <span class="pre">*ctrlr)</span></code></dt>
<dd><p class="first">(optional) pointer to a callback function for stopping the device,
releasing all registered applications</p>
<p>The function may return before the operation has completed.</p>
<p>Completion must be signalled by a call to capi_ctr_down().</p>
<p class="last">Called in process context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*register_appl)(struct</span> <span class="pre">capi_ctr</span> <span class="pre">*ctrlr,</span> <span class="pre">u16</span> <span class="pre">applid,</span> <span class="pre">capi_register_params</span> <span class="pre">*rparam)</span></code></dt>
<dd><p class="first">pointers to callback function for registration of
applications with the device</p>
<p class="last">Calls to these functions are serialized by Kernel CAPI so that only
one call to any of them is active at any time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*release_appl)(struct</span> <span class="pre">capi_ctr</span> <span class="pre">*ctrlr,</span> <span class="pre">u16</span> <span class="pre">applid)</span></code></dt>
<dd><p class="first">pointers to callback functions deregistration of
applications with the device</p>
<p class="last">Calls to these functions are serialized by Kernel CAPI so that only
one call to any of them is active at any time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span>&#160; <span class="pre">(*send_message)(struct</span> <span class="pre">capi_ctr</span> <span class="pre">*ctrlr,</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb)</span></code></dt>
<dd><p class="first">pointer to a callback function for sending a CAPI message to the
device</p>
<p>Return value: CAPI error code</p>
<p>If the method returns 0 (CAPI_NOERROR) the driver has taken ownership
of the skb and the caller may no longer access it. If it returns a
non-zero (error) value then ownership of the skb returns to the caller
who may reuse or free it.</p>
<p>The return value should only be used to signal problems with respect
to accepting or queueing the message. Errors occurring during the
actual processing of the message should be signaled with an
appropriate reply message.</p>
<p>May be called in process or interrupt context.</p>
<p class="last">Calls to this function are not serialized by Kernel CAPI, ie. it must
be prepared to be re-entered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*(*procinfo)(struct</span> <span class="pre">capi_ctr</span> <span class="pre">*ctrlr)</span></code></dt>
<dd>pointer to a callback function returning the entry for the device in
the CAPI controller info table, /proc/capi/controller</dd>
<dt>Note:</dt>
<dd>Callback functions except send_message() are never called in interrupt
context.</dd>
</dl>
</div>
<div class="section" id="to-be-filled-in-before-calling-capi-ctr-ready">
<h4>to be filled in before calling capi_ctr_ready():<a class="headerlink" href="#to-be-filled-in-before-calling-capi-ctr-ready" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">manu[CAPI_MANUFACTURER_LEN]</span></code></dt>
<dd>value to return for CAPI_GET_MANUFACTURER</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capi_version</span> <span class="pre">version</span></code></dt>
<dd>value to return for CAPI_GET_VERSION</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capi_profile</span> <span class="pre">profile</span></code></dt>
<dd>value to return for CAPI_GET_PROFILE</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">serial[CAPI_SERIAL_LEN]</span></code></dt>
<dd>value to return for CAPI_GET_SERIAL</dd>
</dl>
</div>
</div>
<div class="section" id="skbs">
<h3>4.3 SKBs<a class="headerlink" href="#skbs" title="Permalink to this headline">¶</a></h3>
<p>CAPI messages are passed between Kernel CAPI and the driver via send_message()
and capi_ctr_handle_message(), stored in the data portion of a socket buffer
(skb).  Each skb contains a single CAPI message coded according to the CAPI 2.0
standard.</p>
<p>For the data transfer messages, DATA_B3_REQ and DATA_B3_IND, the actual
payload data immediately follows the CAPI message itself within the same skb.
The Data and Data64 parameters are not used for processing. The Data64
parameter may be omitted by setting the length field of the CAPI message to 22
instead of 30.</p>
</div>
<div class="section" id="the-cmsg-structure">
<h3>4.4 The _cmsg Structure<a class="headerlink" href="#the-cmsg-structure" title="Permalink to this headline">¶</a></h3>
<p>(declared in &lt;linux/isdn/capiutil.h&gt;)</p>
<p>The _cmsg structure stores the contents of a CAPI 2.0 message in an easily
accessible form. It contains members for all possible CAPI 2.0 parameters,
including subparameters of the Additional Info and B Protocol structured
parameters, with the following exceptions:</p>
<ul class="simple">
<li>second Calling party number (CONNECT_IND)</li>
<li>Data64 (DATA_B3_REQ and DATA_B3_IND)</li>
<li>Sending complete (subparameter of Additional Info, CONNECT_REQ and INFO_REQ)</li>
<li>Global Configuration (subparameter of B Protocol, CONNECT_REQ, CONNECT_RESP
and SELECT_B_PROTOCOL_REQ)</li>
</ul>
<p>Only those parameters appearing in the message type currently being processed
are actually used. Unused members should be set to zero.</p>
<p>Members are named after the CAPI 2.0 standard names of the parameters they
represent. See &lt;linux/isdn/capiutil.h&gt; for the exact spelling. Member data
types are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>u8</td>
<td>for CAPI parameters of type ‘byte’</td>
</tr>
<tr class="row-even"><td>u16</td>
<td>for CAPI parameters of type ‘word’</td>
</tr>
<tr class="row-odd"><td>u32</td>
<td>for CAPI parameters of type ‘dword’</td>
</tr>
<tr class="row-even"><td>_cstruct</td>
<td>for CAPI parameters of type ‘struct’
The member is a pointer to a buffer containing the parameter in
CAPI encoding (length + content). It may also be NULL, which will
be taken to represent an empty (zero length) parameter.
Subparameters are stored in encoded form within the content part.</td>
</tr>
<tr class="row-odd"><td>_cmstruct</td>
<td>alternative representation for CAPI parameters of type ‘struct’
(used only for the ‘Additional Info’ and ‘B Protocol’ parameters)
The representation is a single byte containing one of the values:
CAPI_DEFAULT: The parameter is empty/absent.
CAPI_COMPOSE: The parameter is present.
Subparameter values are stored individually in the corresponding
_cmsg structure members.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="lower-layer-interface-functions">
<h2>5. Lower Layer Interface Functions<a class="headerlink" href="#lower-layer-interface-functions" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int attach_capi_ctr(struct capi_ctr *ctrlr)
int detach_capi_ctr(struct capi_ctr *ctrlr)
</pre></div>
</div>
<p>register/unregister a device (controller) with Kernel CAPI</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void capi_ctr_ready(struct capi_ctr *ctrlr)
void capi_ctr_down(struct capi_ctr *ctrlr)
</pre></div>
</div>
<p>signal controller ready/not ready</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void capi_ctr_handle_message(struct capi_ctr * ctrlr, u16 applid,
                             struct sk_buff *skb)
</pre></div>
</div>
<p>pass a received CAPI message to Kernel CAPI
for forwarding to the specified application</p>
</div>
<div class="section" id="helper-functions-and-macros">
<h2>6. Helper Functions and Macros<a class="headerlink" href="#helper-functions-and-macros" title="Permalink to this headline">¶</a></h2>
<p>Macros to extract/set element values from/in a CAPI message header
(from &lt;linux/isdn/capiutil.h&gt;):</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="41%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Get Macro</th>
<th class="head">Set Macro</th>
<th class="head">Element (Type)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CAPIMSG_LEN(m)</td>
<td>CAPIMSG_SETLEN(m, len)</td>
<td>Total Length (u16)</td>
</tr>
<tr class="row-odd"><td>CAPIMSG_APPID(m)</td>
<td>CAPIMSG_SETAPPID(m, applid)</td>
<td>ApplID (u16)</td>
</tr>
<tr class="row-even"><td>CAPIMSG_COMMAND(m)</td>
<td>CAPIMSG_SETCOMMAND(m,cmd)</td>
<td>Command (u8)</td>
</tr>
<tr class="row-odd"><td>CAPIMSG_SUBCOMMAND(m)</td>
<td>CAPIMSG_SETSUBCOMMAND(m, cmd)</td>
<td>Subcommand (u8)</td>
</tr>
<tr class="row-even"><td>CAPIMSG_CMD(m)</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>Command*256
+ Subcommand (u16)</td>
</tr>
<tr class="row-odd"><td>CAPIMSG_MSGID(m)</td>
<td>CAPIMSG_SETMSGID(m, msgid)</td>
<td>Message Number (u16)</td>
</tr>
<tr class="row-even"><td>CAPIMSG_CONTROL(m)</td>
<td>CAPIMSG_SETCONTROL(m, contr)</td>
<td>Controller/PLCI/NCCI
(u32)</td>
</tr>
<tr class="row-odd"><td>CAPIMSG_DATALEN(m)</td>
<td>CAPIMSG_SETDATALEN(m, len)</td>
<td>Data Length (u16)</td>
</tr>
</tbody>
</table>
<p>Library functions for working with _cmsg structures
(from &lt;linux/isdn/capiutil.h&gt;):</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*capi_cmd2str(u8</span> <span class="pre">Command,</span> <span class="pre">u8</span> <span class="pre">Subcommand)</span></code></dt>
<dd>Returns the CAPI 2.0 message name corresponding to the given command
and subcommand values, as a static ASCII string. The return value may
be NULL if the command/subcommand is not one of those defined in the
CAPI 2.0 standard.</dd>
</dl>
</div>
<div class="section" id="debugging">
<h2>7. Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h2>
<p>The module kernelcapi has a module parameter showcapimsgs controlling some
debugging output produced by the module. It can only be set when the module is
loaded, via a parameter “showcapimsgs=&lt;n&gt;” to the modprobe command, either on
the command line or in the configuration file.</p>
<p>If the lowest bit of showcapimsgs is set, kernelcapi logs controller and
application up and down events.</p>
<p>In addition, every registered CAPI controller has an associated traceflag
parameter controlling how CAPI messages sent from and to tha controller are
logged. The traceflag parameter is initialized with the value of the
showcapimsgs parameter when the controller is registered, but can later be
changed via the MANUFACTURER_REQ command KCAPI_CMD_TRACE.</p>
<p>If the value of traceflag is non-zero, CAPI messages are logged.
DATA_B3 messages are only logged if the value of traceflag is &gt; 2.</p>
<p>If the lowest bit of traceflag is set, only the command/subcommand and message
length are logged. Otherwise, kernelcapi logs a readable representation of
the entire message.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>