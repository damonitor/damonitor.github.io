

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Running nested guests with KVM &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Running nested guests with KVM</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/virt/kvm/running-nested-guests.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="running-nested-guests-with-kvm">
<h1>Running nested guests with KVM<a class="headerlink" href="#running-nested-guests-with-kvm" title="Permalink to this headline">¶</a></h1>
<p>A nested guest is the ability to run a guest inside another guest (it
can be KVM-based or a different hypervisor).  The straightforward
example is a KVM guest that in turn runs on a KVM guest (the rest of
this document is built on this example):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        .----------------.  .----------------.
        |                |  |                |
        |      L2        |  |      L2        |
        | (Nested Guest) |  | (Nested Guest) |
        |                |  |                |
        |----------------&#39;--&#39;----------------|
        |                                    |
        |       L1 (Guest Hypervisor)        |
        |          KVM (/dev/kvm)            |
        |                                    |
.------------------------------------------------------.
|                 L0 (Host Hypervisor)                 |
|                    KVM (/dev/kvm)                    |
|------------------------------------------------------|
|        Hardware (with virtualization extensions)     |
&#39;------------------------------------------------------&#39;
</pre></div>
</div>
<p>Terminology:</p>
<ul class="simple">
<li>L0 – level-0; the bare metal host, running KVM</li>
<li>L1 – level-1 guest; a VM running on L0; also called the “guest
hypervisor”, as it itself is capable of running KVM.</li>
<li>L2 – level-2 guest; a VM running on L1, this is the “nested guest”</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The above diagram is modelled after the x86 architecture;
s390x, ppc64 and other architectures are likely to have
a different design for nesting.</p>
<p>For example, s390x always has an LPAR (LogicalPARtition)
hypervisor running on bare metal, adding another layer and
resulting in at least four levels in a nested setup — L0 (bare
metal, running the LPAR hypervisor), L1 (host hypervisor), L2
(guest hypervisor), L3 (nested guest).</p>
<p class="last">This document will stick with the three-level terminology (L0,
L1, and L2) for all architectures; and will largely focus on
x86.</p>
</div>
<div class="section" id="use-cases">
<h2>Use Cases<a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h2>
<p>There are several scenarios where nested KVM can be useful, to name a
few:</p>
<ul class="simple">
<li>As a developer, you want to test your software on different operating
systems (OSes).  Instead of renting multiple VMs from a Cloud
Provider, using nested KVM lets you rent a large enough “guest
hypervisor” (level-1 guest).  This in turn allows you to create
multiple nested guests (level-2 guests), running different OSes, on
which you can develop and test your software.</li>
<li>Live migration of “guest hypervisors” and their nested guests, for
load balancing, disaster recovery, etc.</li>
<li>VM image creation tools (e.g. <code class="docutils literal notranslate"><span class="pre">virt-install</span></code>,  etc) often run
their own VM, and users expect these to work inside a VM.</li>
<li>Some OSes use virtualization internally for security (e.g. to let
applications run safely in isolation).</li>
</ul>
</div>
<div class="section" id="enabling-nested-x86">
<h2>Enabling “nested” (x86)<a class="headerlink" href="#enabling-nested-x86" title="Permalink to this headline">¶</a></h2>
<p>From Linux kernel v4.19 onwards, the <code class="docutils literal notranslate"><span class="pre">nested</span></code> KVM parameter is enabled
by default for Intel and AMD.  (Though your Linux distribution might
override this default.)</p>
<p>In case you are running a Linux kernel older than v4.19, to enable
nesting, set the <code class="docutils literal notranslate"><span class="pre">nested</span></code> KVM module parameter to <code class="docutils literal notranslate"><span class="pre">Y</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>.  To
persist this setting across reboots, you can add it in a config file, as
shown below:</p>
<ol class="arabic">
<li><p class="first">On the bare metal host (L0), list the kernel modules and ensure that
the KVM modules:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ lsmod | grep -i kvm
kvm_intel             133627  0
kvm                   435079  1 kvm_intel
</pre></div>
</div>
</li>
<li><p class="first">Show information for <code class="docutils literal notranslate"><span class="pre">kvm_intel</span></code> module:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ modinfo kvm_intel | grep -i nested
parm:           nested:bool
</pre></div>
</div>
</li>
<li><p class="first">For the nested KVM configuration to persist across reboots, place the
below in <code class="docutils literal notranslate"><span class="pre">/etc/modprobed/kvm_intel.conf</span></code> (create the file if it
doesn’t exist):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /etc/modprobe.d/kvm_intel.conf
options kvm-intel nested=y
</pre></div>
</div>
</li>
<li><p class="first">Unload and re-load the KVM Intel module:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo rmmod kvm-intel
$ sudo modprobe kvm-intel
</pre></div>
</div>
</li>
<li><p class="first">Verify if the <code class="docutils literal notranslate"><span class="pre">nested</span></code> parameter for KVM is enabled:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /sys/module/kvm_intel/parameters/nested
Y
</pre></div>
</div>
</li>
</ol>
<p>For AMD hosts, the process is the same as above, except that the module
name is <code class="docutils literal notranslate"><span class="pre">kvm-amd</span></code>.</p>
</div>
<div class="section" id="additional-nested-related-kernel-parameters-x86">
<h2>Additional nested-related kernel parameters (x86)<a class="headerlink" href="#additional-nested-related-kernel-parameters-x86" title="Permalink to this headline">¶</a></h2>
<p>If your hardware is sufficiently advanced (Intel Haswell processor or
higher, which has newer hardware virt extensions), the following
additional features will also be enabled by default: “Shadow VMCS
(Virtual Machine Control Structure)”, APIC Virtualization on your bare
metal host (L0).  Parameters for Intel hosts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /sys/module/kvm_intel/parameters/enable_shadow_vmcs
Y

$ cat /sys/module/kvm_intel/parameters/enable_apicv
Y

$ cat /sys/module/kvm_intel/parameters/ept
Y
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you suspect your L2 (i.e. nested guest) is running slower,
ensure the above are enabled (particularly
<code class="docutils literal notranslate"><span class="pre">enable_shadow_vmcs</span></code> and <code class="docutils literal notranslate"><span class="pre">ept</span></code>).</p>
</div>
</div>
<div class="section" id="starting-a-nested-guest-x86">
<h2>Starting a nested guest (x86)<a class="headerlink" href="#starting-a-nested-guest-x86" title="Permalink to this headline">¶</a></h2>
<p>Once your bare metal host (L0) is configured for nesting, you should be
able to start an L1 guest with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ qemu-kvm -cpu host [...]
</pre></div>
</div>
<p>The above will pass through the host CPU’s capabilities as-is to the
gues); or for better live migration compatibility, use a named CPU
model supported by QEMU. e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ qemu-kvm -cpu Haswell-noTSX-IBRS,vmx=on
</pre></div>
</div>
<p>then the guest hypervisor will subsequently be capable of running a
nested guest with accelerated KVM.</p>
</div>
<div class="section" id="enabling-nested-s390x">
<h2>Enabling “nested” (s390x)<a class="headerlink" href="#enabling-nested-s390x" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">On the host hypervisor (L0), enable the <code class="docutils literal notranslate"><span class="pre">nested</span></code> parameter on
s390x:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ rmmod kvm
$ modprobe kvm nested=1
</pre></div>
</div>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On s390x, the kernel parameter <code class="docutils literal notranslate"><span class="pre">hpage</span></code> is mutually exclusive
with the <code class="docutils literal notranslate"><span class="pre">nested</span></code> paramter — i.e. to be able to enable
<code class="docutils literal notranslate"><span class="pre">nested</span></code>, the <code class="docutils literal notranslate"><span class="pre">hpage</span></code> parameter <em>must</em> be disabled.</p>
</div>
<ol class="arabic" start="2">
<li><p class="first">The guest hypervisor (L1) must be provided with the <code class="docutils literal notranslate"><span class="pre">sie</span></code> CPU
feature — with QEMU, this can be done by using “host passthrough”
(via the command-line <code class="docutils literal notranslate"><span class="pre">-cpu</span> <span class="pre">host</span></code>).</p>
</li>
<li><p class="first">Now the KVM module can be loaded in the L1 (guest hypervisor):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ modprobe kvm
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="live-migration-with-nested-kvm">
<h2>Live migration with nested KVM<a class="headerlink" href="#live-migration-with-nested-kvm" title="Permalink to this headline">¶</a></h2>
<p>Migrating an L1 guest, with a  <em>live</em> nested guest in it, to another
bare metal host, works as of Linux kernel 5.3 and QEMU 4.2.0 for
Intel x86 systems, and even on older versions for s390x.</p>
<p>On AMD systems, once an L1 guest has started an L2 guest, the L1 guest
should no longer be migrated or saved (refer to QEMU documentation on
“savevm”/”loadvm”) until the L2 guest shuts down.  Attempting to migrate
or save-and-load an L1 guest while an L2 guest is running will result in
undefined behavior.  You might see a <code class="docutils literal notranslate"><span class="pre">kernel</span> <span class="pre">BUG!</span></code> entry in <code class="docutils literal notranslate"><span class="pre">dmesg</span></code>, a
kernel ‘oops’, or an outright kernel panic.  Such a migrated or loaded L1
guest can no longer be considered stable or secure, and must be restarted.
Migrating an L1 guest merely configured to support nesting, while not
actually running L2 guests, is expected to function normally even on AMD
systems but may fail once guests are started.</p>
<p>Migrating an L2 guest is always expected to succeed, so all the following
scenarios should work even on AMD systems:</p>
<ul class="simple">
<li>Migrating a nested guest (L2) to another L1 guest on the <em>same</em> bare
metal host.</li>
<li>Migrating a nested guest (L2) to another L1 guest on a <em>different</em>
bare metal host.</li>
<li>Migrating a nested guest (L2) to a bare metal host.</li>
</ul>
</div>
<div class="section" id="reporting-bugs-from-nested-setups">
<h2>Reporting bugs from nested setups<a class="headerlink" href="#reporting-bugs-from-nested-setups" title="Permalink to this headline">¶</a></h2>
<p>Debugging “nested” problems can involve sifting through log files across
L0, L1 and L2; this can result in tedious back-n-forth between the bug
reporter and the bug fixer.</p>
<ul class="simple">
<li>Mention that you are in a “nested” setup.  If you are running any kind
of “nesting” at all, say so.  Unfortunately, this needs to be called
out because when reporting bugs, people tend to forget to even
<em>mention</em> that they’re using nested virtualization.</li>
<li>Ensure you are actually running KVM on KVM.  Sometimes people do not
have KVM enabled for their guest hypervisor (L1), which results in
them running with pure emulation or what QEMU calls it as “TCG”, but
they think they’re running nested KVM.  Thus confusing “nested Virt”
(which could also mean, QEMU on KVM) with “nested KVM” (KVM on KVM).</li>
</ul>
<div class="section" id="information-to-collect-generic">
<h3>Information to collect (generic)<a class="headerlink" href="#information-to-collect-generic" title="Permalink to this headline">¶</a></h3>
<p>The following is not an exhaustive list, but a very good starting point:</p>
<blockquote>
<div><ul class="simple">
<li>Kernel, libvirt, and QEMU version from L0</li>
<li>Kernel, libvirt and QEMU version from L1</li>
<li>QEMU command-line of L1 – when using libvirt, you’ll find it here:
<code class="docutils literal notranslate"><span class="pre">/var/log/libvirt/qemu/instance.log</span></code></li>
<li>QEMU command-line of L2 – as above, when using libvirt, get the
complete libvirt-generated QEMU command-line</li>
<li><code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/sys/cpuinfo</span></code> from L0</li>
<li><code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/sys/cpuinfo</span></code> from L1</li>
<li><code class="docutils literal notranslate"><span class="pre">lscpu</span></code> from L0</li>
<li><code class="docutils literal notranslate"><span class="pre">lscpu</span></code> from L1</li>
<li>Full <code class="docutils literal notranslate"><span class="pre">dmesg</span></code> output from L0</li>
<li>Full <code class="docutils literal notranslate"><span class="pre">dmesg</span></code> output from L1</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="x86-specific-info-to-collect">
<h3>x86-specific info to collect<a class="headerlink" href="#x86-specific-info-to-collect" title="Permalink to this headline">¶</a></h3>
<p>Both the below commands, <code class="docutils literal notranslate"><span class="pre">x86info</span></code> and <code class="docutils literal notranslate"><span class="pre">dmidecode</span></code>, should be
available on most Linux distributions with the same name:</p>
<blockquote>
<div><ul class="simple">
<li>Output of: <code class="docutils literal notranslate"><span class="pre">x86info</span> <span class="pre">-a</span></code> from L0</li>
<li>Output of: <code class="docutils literal notranslate"><span class="pre">x86info</span> <span class="pre">-a</span></code> from L1</li>
<li>Output of: <code class="docutils literal notranslate"><span class="pre">dmidecode</span></code> from L0</li>
<li>Output of: <code class="docutils literal notranslate"><span class="pre">dmidecode</span></code> from L1</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="s390x-specific-info-to-collect">
<h3>s390x-specific info to collect<a class="headerlink" href="#s390x-specific-info-to-collect" title="Permalink to this headline">¶</a></h3>
<p>Along with the earlier mentioned generic details, the below is
also recommended:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">/proc/sysinfo</span></code> from L1; this will also include the info from L0</li>
</ul>
</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>