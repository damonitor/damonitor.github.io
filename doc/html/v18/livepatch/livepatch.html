

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Livepatch &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Livepatch</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/livepatch/livepatch.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="livepatch">
<h1>Livepatch<a class="headerlink" href="#livepatch" title="Permalink to this headline">¶</a></h1>
<p>This document outlines basic information about kernel livepatching.</p>
<div class="section" id="motivation">
<h2>1. Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>There are many situations where users are reluctant to reboot a system. It may
be because their system is performing complex scientific computations or under
heavy load during peak usage. In addition to keeping systems up and running,
users want to also have a stable and secure system. Livepatching gives users
both by allowing for function calls to be redirected; thus, fixing critical
functions without a system reboot.</p>
</div>
<div class="section" id="kprobes-ftrace-livepatching">
<h2>2. Kprobes, Ftrace, Livepatching<a class="headerlink" href="#kprobes-ftrace-livepatching" title="Permalink to this headline">¶</a></h2>
<p>There are multiple mechanisms in the Linux kernel that are directly related
to redirection of code execution; namely: kernel probes, function tracing,
and livepatching:</p>
<blockquote>
<div><ul class="simple">
<li>The kernel probes are the most generic. The code can be redirected by
putting a breakpoint instruction instead of any instruction.</li>
<li>The function tracer calls the code from a predefined location that is
close to the function entry point. This location is generated by the
compiler using the ‘-pg’ gcc option.</li>
<li>Livepatching typically needs to redirect the code at the very beginning
of the function entry before the function parameters or the stack
are in any way modified.</li>
</ul>
</div></blockquote>
<p>All three approaches need to modify the existing code at runtime. Therefore
they need to be aware of each other and not step over each other’s toes.
Most of these problems are solved by using the dynamic ftrace framework as
a base. A Kprobe is registered as a ftrace handler when the function entry
is probed, see CONFIG_KPROBES_ON_FTRACE. Also an alternative function from
a live patch is called with the help of a custom ftrace handler. But there are
some limitations, see below.</p>
</div>
<div class="section" id="consistency-model">
<h2>3. Consistency model<a class="headerlink" href="#consistency-model" title="Permalink to this headline">¶</a></h2>
<p>Functions are there for a reason. They take some input parameters, get or
release locks, read, process, and even write some data in a defined way,
have return values. In other words, each function has a defined semantic.</p>
<p>Many fixes do not change the semantic of the modified functions. For
example, they add a NULL pointer or a boundary check, fix a race by adding
a missing memory barrier, or add some locking around a critical section.
Most of these changes are self contained and the function presents itself
the same way to the rest of the system. In this case, the functions might
be updated independently one by one.</p>
<p>But there are more complex fixes. For example, a patch might change
ordering of locking in multiple functions at the same time. Or a patch
might exchange meaning of some temporary structures and update
all the relevant functions. In this case, the affected unit
(thread, whole kernel) need to start using all new versions of
the functions at the same time. Also the switch must happen only
when it is safe to do so, e.g. when the affected locks are released
or no data are stored in the modified structures at the moment.</p>
<p>The theory about how to apply functions a safe way is rather complex.
The aim is to define a so-called consistency model. It attempts to define
conditions when the new implementation could be used so that the system
stays consistent.</p>
<p>Livepatch has a consistency model which is a hybrid of kGraft and
kpatch:  it uses kGraft’s per-task consistency and syscall barrier
switching combined with kpatch’s stack trace switching.  There are also
a number of fallback options which make it quite flexible.</p>
<p>Patches are applied on a per-task basis, when the task is deemed safe to
switch over.  When a patch is enabled, livepatch enters into a
transition state where tasks are converging to the patched state.
Usually this transition state can complete in a few seconds.  The same
sequence occurs when a patch is disabled, except the tasks converge from
the patched state to the unpatched state.</p>
<p>An interrupt handler inherits the patched state of the task it
interrupts.  The same is true for forked tasks: the child inherits the
patched state of the parent.</p>
<p>Livepatch uses several complementary approaches to determine when it’s
safe to patch tasks:</p>
<ol class="arabic">
<li><p class="first">The first and most effective approach is stack checking of sleeping
tasks.  If no affected functions are on the stack of a given task,
the task is patched.  In most cases this will patch most or all of
the tasks on the first try.  Otherwise it’ll keep trying
periodically.  This option is only available if the architecture has
reliable stacks (HAVE_RELIABLE_STACKTRACE).</p>
</li>
<li><p class="first">The second approach, if needed, is kernel exit switching.  A
task is switched when it returns to user space from a system call, a
user space IRQ, or a signal.  It’s useful in the following cases:</p>
<ol class="loweralpha simple">
<li>Patching I/O-bound user tasks which are sleeping on an affected
function.  In this case you have to send SIGSTOP and SIGCONT to
force it to exit the kernel and be patched.</li>
<li>Patching CPU-bound user tasks.  If the task is highly CPU-bound
then it will get patched the next time it gets interrupted by an
IRQ.</li>
</ol>
</li>
<li><p class="first">For idle “swapper” tasks, since they don’t ever exit the kernel, they
instead have a klp_update_patch_state() call in the idle loop which
allows them to be patched before the CPU enters the idle state.</p>
<p>(Note there’s not yet such an approach for kthreads.)</p>
</li>
</ol>
<p>Architectures which don’t have HAVE_RELIABLE_STACKTRACE solely rely on
the second approach. It’s highly likely that some tasks may still be
running with an old version of the function, until that function
returns. In this case you would have to signal the tasks. This
especially applies to kthreads. They may not be woken up and would need
to be forced. See below for more information.</p>
<p>Unless we can come up with another way to patch kthreads, architectures
without HAVE_RELIABLE_STACKTRACE are not considered fully supported by
the kernel livepatching.</p>
<p>The /sys/kernel/livepatch/&lt;patch&gt;/transition file shows whether a patch
is in transition.  Only a single patch can be in transition at a given
time.  A patch can remain in transition indefinitely, if any of the tasks
are stuck in the initial patch state.</p>
<p>A transition can be reversed and effectively canceled by writing the
opposite value to the /sys/kernel/livepatch/&lt;patch&gt;/enabled file while
the transition is in progress.  Then all the tasks will attempt to
converge back to the original patch state.</p>
<p>There’s also a /proc/&lt;pid&gt;/patch_state file which can be used to
determine which tasks are blocking completion of a patching operation.
If a patch is in transition, this file shows 0 to indicate the task is
unpatched and 1 to indicate it’s patched.  Otherwise, if no patch is in
transition, it shows -1.  Any tasks which are blocking the transition
can be signaled with SIGSTOP and SIGCONT to force them to change their
patched state. This may be harmful to the system though. Sending a fake signal
to all remaining blocking tasks is a better alternative. No proper signal is
actually delivered (there is no data in signal pending structures). Tasks are
interrupted or woken up, and forced to change their patched state. The fake
signal is automatically sent every 15 seconds.</p>
<p>Administrator can also affect a transition through
/sys/kernel/livepatch/&lt;patch&gt;/force attribute. Writing 1 there clears
TIF_PATCH_PENDING flag of all tasks and thus forces the tasks to the patched
state. Important note! The force attribute is intended for cases when the
transition gets stuck for a long time because of a blocking task. Administrator
is expected to collect all necessary data (namely stack traces of such blocking
tasks) and request a clearance from a patch distributor to force the transition.
Unauthorized usage may cause harm to the system. It depends on the nature of the
patch, which functions are (un)patched, and which functions the blocking tasks
are sleeping in (/proc/&lt;pid&gt;/stack may help here). Removal (rmmod) of patch
modules is permanently disabled when the force feature is used. It cannot be
guaranteed there is no task sleeping in such module. It implies unbounded
reference count if a patch module is disabled and enabled in a loop.</p>
<p>Moreover, the usage of force may also affect future applications of live
patches and cause even more harm to the system. Administrator should first
consider to simply cancel a transition (see above). If force is used, reboot
should be planned and no more live patches applied.</p>
<div class="section" id="adding-consistency-model-support-to-new-architectures">
<h3>3.1 Adding consistency model support to new architectures<a class="headerlink" href="#adding-consistency-model-support-to-new-architectures" title="Permalink to this headline">¶</a></h3>
<p>For adding consistency model support to new architectures, there are a
few options:</p>
<ol class="arabic">
<li><p class="first">Add CONFIG_HAVE_RELIABLE_STACKTRACE.  This means porting objtool, and
for non-DWARF unwinders, also making sure there’s a way for the stack
tracing code to detect interrupts on the stack.</p>
</li>
<li><p class="first">Alternatively, ensure that every kthread has a call to
klp_update_patch_state() in a safe location.  Kthreads are typically
in an infinite loop which does some action repeatedly.  The safe
location to switch the kthread’s patch state would be at a designated
point in the loop where there are no locks taken and all data
structures are in a well-defined state.</p>
<p>The location is clear when using workqueues or the kthread worker
API.  These kthreads process independent actions in a generic loop.</p>
<p>It’s much more complicated with kthreads which have a custom loop.
There the safe location must be carefully selected on a case-by-case
basis.</p>
<p>In that case, arches without HAVE_RELIABLE_STACKTRACE would still be
able to use the non-stack-checking parts of the consistency model:</p>
<ol class="loweralpha simple">
<li>patching user tasks when they cross the kernel/user space
boundary; and</li>
<li>patching kthreads and idle tasks at their designated patch points.</li>
</ol>
<p>This option isn’t as good as option 1 because it requires signaling
user tasks and waking kthreads to patch them.  But it could still be
a good backup option for those architectures which don’t have
reliable stack traces yet.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="livepatch-module">
<h2>4. Livepatch module<a class="headerlink" href="#livepatch-module" title="Permalink to this headline">¶</a></h2>
<p>Livepatches are distributed using kernel modules, see
samples/livepatch/livepatch-sample.c.</p>
<p>The module includes a new implementation of functions that we want
to replace. In addition, it defines some structures describing the
relation between the original and the new implementation. Then there
is code that makes the kernel start using the new code when the livepatch
module is loaded. Also there is code that cleans up before the
livepatch module is removed. All this is explained in more details in
the next sections.</p>
<div class="section" id="new-functions">
<h3>4.1. New functions<a class="headerlink" href="#new-functions" title="Permalink to this headline">¶</a></h3>
<p>New versions of functions are typically just copied from the original
sources. A good practice is to add a prefix to the names so that they
can be distinguished from the original ones, e.g. in a backtrace. Also
they can be declared as static because they are not called directly
and do not need the global visibility.</p>
<p>The patch contains only functions that are really modified. But they
might want to access functions or data from the original source file
that may only be locally accessible. This can be solved by a special
relocation section in the generated livepatch module, see
Documentation/livepatch/module-elf-format.rst for more details.</p>
</div>
<div class="section" id="metadata">
<h3>4.2. Metadata<a class="headerlink" href="#metadata" title="Permalink to this headline">¶</a></h3>
<p>The patch is described by several structures that split the information
into three levels:</p>
<blockquote>
<div><ul>
<li><p class="first">struct klp_func is defined for each patched function. It describes
the relation between the original and the new implementation of a
particular function.</p>
<p>The structure includes the name, as a string, of the original function.
The function address is found via kallsyms at runtime.</p>
<p>Then it includes the address of the new function. It is defined
directly by assigning the function pointer. Note that the new
function is typically defined in the same source file.</p>
<p>As an optional parameter, the symbol position in the kallsyms database can
be used to disambiguate functions of the same name. This is not the
absolute position in the database, but rather the order it has been found
only for a particular object ( vmlinux or a kernel module ). Note that
kallsyms allows for searching symbols according to the object name.</p>
</li>
<li><p class="first">struct klp_object defines an array of patched functions (struct
klp_func) in the same object. Where the object is either vmlinux
(NULL) or a module name.</p>
<p>The structure helps to group and handle functions for each object
together. Note that patched modules might be loaded later than
the patch itself and the relevant functions might be patched
only when they are available.</p>
</li>
<li><p class="first">struct klp_patch defines an array of patched objects (struct
klp_object).</p>
<p>This structure handles all patched functions consistently and eventually,
synchronously. The whole patch is applied only when all patched
symbols are found. The only exception are symbols from objects
(kernel modules) that have not been loaded yet.</p>
<p>For more details on how the patch is applied on a per-task basis,
see the “Consistency model” section.</p>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="livepatch-life-cycle">
<h2>5. Livepatch life-cycle<a class="headerlink" href="#livepatch-life-cycle" title="Permalink to this headline">¶</a></h2>
<p>Livepatching can be described by five basic operations:
loading, enabling, replacing, disabling, removing.</p>
<p>Where the replacing and the disabling operations are mutually
exclusive. They have the same result for the given patch but
not for the system.</p>
<div class="section" id="loading">
<h3>5.1. Loading<a class="headerlink" href="#loading" title="Permalink to this headline">¶</a></h3>
<p>The only reasonable way is to enable the patch when the livepatch kernel
module is being loaded. For this, klp_enable_patch() has to be called
in the <a class="reference internal" href="../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> callback. There are two main reasons:</p>
<p>First, only the module has an easy access to the related struct klp_patch.</p>
<p>Second, the error code might be used to refuse loading the module when
the patch cannot get enabled.</p>
</div>
<div class="section" id="enabling">
<h3>5.2. Enabling<a class="headerlink" href="#enabling" title="Permalink to this headline">¶</a></h3>
<p>The livepatch gets enabled by calling klp_enable_patch() from
the <a class="reference internal" href="../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> callback. The system will start using the new
implementation of the patched functions at this stage.</p>
<p>First, the addresses of the patched functions are found according to their
names. The special relocations, mentioned in the section “New functions”,
are applied. The relevant entries are created under
/sys/kernel/livepatch/&lt;name&gt;. The patch is rejected when any above
operation fails.</p>
<p>Second, livepatch enters into a transition state where tasks are converging
to the patched state. If an original function is patched for the first
time, a function specific struct klp_ops is created and an universal
ftrace handler is registered<a class="footnote-reference" href="#id2" id="id1">[1]</a>. This stage is indicated by a value of ‘1’
in /sys/kernel/livepatch/&lt;name&gt;/transition. For more information about
this process, see the “Consistency model” section.</p>
<p>Finally, once all tasks have been patched, the ‘transition’ value changes
to ‘0’.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">Note that functions might be patched multiple times. The ftrace handler
is registered only once for a given function. Further patches just add
an entry to the list (see field <cite>func_stack</cite>) of the struct klp_ops.
The right implementation is selected by the ftrace handler, see
the “Consistency model” section.</p>
<p class="last">That said, it is highly recommended to use cumulative livepatches
because they help keeping the consistency of all changes. In this case,
functions might be patched two times only during the transition period.</p>
</td></tr>
</tbody>
</table>
</div>
<div class="section" id="replacing">
<h3>5.3. Replacing<a class="headerlink" href="#replacing" title="Permalink to this headline">¶</a></h3>
<p>All enabled patches might get replaced by a cumulative patch that
has the .replace flag set.</p>
<p>Once the new patch is enabled and the ‘transition’ finishes then
all the functions (struct klp_func) associated with the replaced
patches are removed from the corresponding struct klp_ops. Also
the ftrace handler is unregistered and the struct klp_ops is
freed when the related function is not modified by the new patch
and func_stack list becomes empty.</p>
<p>See Documentation/livepatch/cumulative-patches.rst for more details.</p>
</div>
<div class="section" id="disabling">
<h3>5.4. Disabling<a class="headerlink" href="#disabling" title="Permalink to this headline">¶</a></h3>
<p>Enabled patches might get disabled by writing ‘0’ to
/sys/kernel/livepatch/&lt;name&gt;/enabled.</p>
<p>First, livepatch enters into a transition state where tasks are converging
to the unpatched state. The system starts using either the code from
the previously enabled patch or even the original one. This stage is
indicated by a value of ‘1’ in /sys/kernel/livepatch/&lt;name&gt;/transition.
For more information about this process, see the “Consistency model”
section.</p>
<p>Second, once all tasks have been unpatched, the ‘transition’ value changes
to ‘0’. All the functions (struct klp_func) associated with the to-be-disabled
patch are removed from the corresponding struct klp_ops. The ftrace handler
is unregistered and the struct klp_ops is freed when the func_stack list
becomes empty.</p>
<p>Third, the sysfs interface is destroyed.</p>
</div>
<div class="section" id="removing">
<h3>5.5. Removing<a class="headerlink" href="#removing" title="Permalink to this headline">¶</a></h3>
<p>Module removal is only safe when there are no users of functions provided
by the module. This is the reason why the force feature permanently
disables the removal. Only when the system is successfully transitioned
to a new patch state (patched/unpatched) without being forced it is
guaranteed that no task sleeps or runs in the old code.</p>
</div>
</div>
<div class="section" id="sysfs">
<h2>6. Sysfs<a class="headerlink" href="#sysfs" title="Permalink to this headline">¶</a></h2>
<p>Information about the registered patches can be found under
/sys/kernel/livepatch. The patches could be enabled and disabled
by writing there.</p>
<p>/sys/kernel/livepatch/&lt;patch&gt;/force attributes allow administrator to affect a
patching operation.</p>
<p>See Documentation/ABI/testing/sysfs-kernel-livepatch for more details.</p>
</div>
<div class="section" id="limitations">
<h2>7. Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>The current Livepatch implementation has several limitations:</p>
<blockquote>
<div><ul>
<li><p class="first">Only functions that can be traced could be patched.</p>
<p>Livepatch is based on the dynamic ftrace. In particular, functions
implementing ftrace or the livepatch ftrace handler could not be
patched. Otherwise, the code would end up in an infinite loop. A
potential mistake is prevented by marking the problematic functions
by “notrace”.</p>
</li>
<li><p class="first">Livepatch works reliably only when the dynamic ftrace is located at
the very beginning of the function.</p>
<p>The function need to be redirected before the stack or the function
parameters are modified in any way. For example, livepatch requires
using -fentry gcc compiler option on x86_64.</p>
<p>One exception is the PPC port. It uses relative addressing and TOC.
Each function has to handle TOC and save LR before it could call
the ftrace handler. This operation has to be reverted on return.
Fortunately, the generic ftrace code has the same problem and all
this is handled on the ftrace level.</p>
</li>
<li><p class="first">Kretprobes using the ftrace framework conflict with the patched
functions.</p>
<p>Both kretprobes and livepatches use a ftrace handler that modifies
the return address. The first user wins. Either the probe or the patch
is rejected when the handler is already in use by the other.</p>
</li>
<li><p class="first">Kprobes in the original function are ignored when the code is
redirected to the new implementation.</p>
<p>There is a work in progress to add warnings about this situation.</p>
</li>
</ul>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>