

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Linux Journalling API &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The Linux Journalling API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/journalling.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-linux-journalling-api">
<h1>The Linux Journalling API<a class="headerlink" href="#the-linux-journalling-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="section" id="details">
<h3>Details<a class="headerlink" href="#details" title="Permalink to this headline">¶</a></h3>
<p>The journalling layer is easy to use. You need to first of all create a
journal_t data structure. There are two calls to do this dependent on
how you decide to allocate the physical media on which the journal
resides. The <a class="reference internal" href="#c.jbd2_journal_init_inode" title="jbd2_journal_init_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_init_inode()</span></code></a> call is for journals stored in
filesystem inodes, or the <a class="reference internal" href="#c.jbd2_journal_init_dev" title="jbd2_journal_init_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_init_dev()</span></code></a> call can be used
for journal stored on a raw device (in a continuous range of blocks). A
journal_t is a typedef for a struct pointer, so when you are finally
finished make sure you call <a class="reference internal" href="#c.jbd2_journal_destroy" title="jbd2_journal_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_destroy()</span></code></a> on it to free up
any used kernel memory.</p>
<p>Once you have got your journal_t object you need to ‘mount’ or load the
journal file. The journalling layer expects the space for the journal
was already allocated and initialized properly by the userspace tools.
When loading the journal you must call <a class="reference internal" href="#c.jbd2_journal_load" title="jbd2_journal_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_load()</span></code></a> to process
journal contents. If the client file system detects the journal contents
does not need to be processed (or even need not have valid contents), it
may call <a class="reference internal" href="#c.jbd2_journal_wipe" title="jbd2_journal_wipe"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_wipe()</span></code></a> to clear the journal contents before
calling <a class="reference internal" href="#c.jbd2_journal_load" title="jbd2_journal_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_load()</span></code></a>.</p>
<p>Note that jbd2_journal_wipe(..,0) calls
<a class="reference internal" href="#c.jbd2_journal_skip_recovery" title="jbd2_journal_skip_recovery"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_skip_recovery()</span></code></a> for you if it detects any outstanding
transactions in the journal and similarly <a class="reference internal" href="#c.jbd2_journal_load" title="jbd2_journal_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_load()</span></code></a> will
call <a class="reference internal" href="#c.jbd2_journal_recover" title="jbd2_journal_recover"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_recover()</span></code></a> if necessary. I would advise reading
<code class="xref c c-func docutils literal notranslate"><span class="pre">ext4_load_journal()</span></code> in fs/ext4/super.c for examples on this stage.</p>
<p>Now you can go ahead and start modifying the underlying filesystem.
Almost.</p>
<p>You still need to actually journal your filesystem changes, this is done
by wrapping them into transactions. Additionally you also need to wrap
the modification of each of the buffers with calls to the journal layer,
so it knows what the modifications you are actually making are. To do
this use <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_start()</span></code></a> which returns a transaction handle.</p>
<p><a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_start()</span></code></a> and its counterpart <a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_stop()</span></code></a>,
which indicates the end of a transaction are nestable calls, so you can
reenter a transaction if necessary, but remember you must call
<a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_stop()</span></code></a> the same number of times as
<a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_start()</span></code></a> before the transaction is completed (or more
accurately leaves the update phase). Ext4/VFS makes use of this feature to
simplify handling of inode dirtying, quota support, etc.</p>
<p>Inside each transaction you need to wrap the modifications to the
individual buffers (blocks). Before you start to modify a buffer you
need to call <a class="reference internal" href="#c.jbd2_journal_get_create_access" title="jbd2_journal_get_create_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_get_create_access()</span></code></a> /
<a class="reference internal" href="#c.jbd2_journal_get_write_access" title="jbd2_journal_get_write_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_get_write_access()</span></code></a> /
<a class="reference internal" href="#c.jbd2_journal_get_undo_access" title="jbd2_journal_get_undo_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_get_undo_access()</span></code></a> as appropriate, this allows the
journalling layer to copy the unmodified
data if it needs to. After all the buffer may be part of a previously
uncommitted transaction. At this point you are at last ready to modify a
buffer, and once you are have done so you need to call
<a class="reference internal" href="#c.jbd2_journal_dirty_metadata" title="jbd2_journal_dirty_metadata"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_dirty_metadata()</span></code></a>. Or if you’ve asked for access to a
buffer you now know is now longer required to be pushed back on the
device you can call <a class="reference internal" href="#c.jbd2_journal_forget" title="jbd2_journal_forget"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_forget()</span></code></a> in much the same way as you
might have used <code class="xref c c-func docutils literal notranslate"><span class="pre">bforget()</span></code> in the past.</p>
<p>A <a class="reference internal" href="#c.jbd2_journal_flush" title="jbd2_journal_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_flush()</span></code></a> may be called at any time to commit and
checkpoint all your transactions.</p>
<p>Then at umount time , in your <code class="xref c c-func docutils literal notranslate"><span class="pre">put_super()</span></code> you can then call
<a class="reference internal" href="#c.jbd2_journal_destroy" title="jbd2_journal_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_destroy()</span></code></a> to clean up your in-core journal object.</p>
<p>Unfortunately there a couple of ways the journal layer can cause a
deadlock. The first thing to note is that each task can only have a
single outstanding transaction at any one time, remember nothing commits
until the outermost <a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_stop()</span></code></a>. This means you must complete
the transaction at the end of each file/inode/address etc. operation you
perform, so that the journalling system isn’t re-entered on another
journal. Since transactions can’t be nested/batched across differing
journals, and another filesystem other than yours (say ext4) may be
modified in a later syscall.</p>
<p>The second case to bear in mind is that <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_start()</span></code></a> can block
if there isn’t enough space in the journal for your transaction (based
on the passed nblocks param) - when it blocks it merely(!) needs to wait
for transactions to complete and be committed from other tasks, so
essentially we are waiting for <a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_stop()</span></code></a>. So to avoid
deadlocks you must treat <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_start()</span></code></a> /
<a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_stop()</span></code></a> as if they were semaphores and include them in
your semaphore ordering rules to prevent
deadlocks. Note that <a class="reference internal" href="#c.jbd2_journal_extend" title="jbd2_journal_extend"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_extend()</span></code></a> has similar blocking
behaviour to <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_start()</span></code></a> so you can deadlock here just as
easily as on <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_start()</span></code></a>.</p>
<p>Try to reserve the right number of blocks the first time. ;-). This will
be the maximum number of blocks you are going to touch in this
transaction. I advise having a look at at least ext4_jbd.h to see the
basis on which ext4 uses to make these decisions.</p>
<p>Another wriggle to watch out for is your on-disk block allocation
strategy. Why? Because, if you do a delete, you need to ensure you
haven’t reused any of the freed blocks until the transaction freeing
these blocks commits. If you reused these blocks and crash happens,
there is no way to restore the contents of the reallocated blocks at the
end of the last fully committed transaction. One simple way of doing
this is to mark blocks as free in internal in-memory block allocation
structures only after the transaction freeing them commits. Ext4 uses
journal commit callback for this purpose.</p>
<p>With journal commit callbacks you can ask the journalling layer to call
a callback function when the transaction is finally committed to disk,
so that you can do some of your own management. You ask the journalling
layer for calling the callback by simply setting
<code class="docutils literal notranslate"><span class="pre">journal-&gt;j_commit_callback</span></code> function pointer and that function is
called after each transaction commit. You can also use
<code class="docutils literal notranslate"><span class="pre">transaction-&gt;t_private_list</span></code> for attaching entries to a transaction
that need processing when the transaction commits.</p>
<p>JBD2 also provides a way to block all transaction updates via
<a class="reference internal" href="#c.jbd2_journal_lock_updates" title="jbd2_journal_lock_updates"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_lock_updates()</span></code></a> /
<a class="reference internal" href="#c.jbd2_journal_unlock_updates" title="jbd2_journal_unlock_updates"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_unlock_updates()</span></code></a>. Ext4 uses this when it wants a
window with a clean and stable fs for a moment. E.g.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>jbd2_journal_lock_updates() //stop new stuff happening..
jbd2_journal_flush()        // checkpoint everything.
..do stuff on stable fs
jbd2_journal_unlock_updates() // carry on with filesystem use.
</pre></div>
</div>
<p>The opportunities for abuse and DOS attacks with this should be obvious,
if you allow unprivileged userspace to trigger codepaths containing
these calls.</p>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>Using the journal is a matter of wrapping the different context changes,
being each mount, each modification (transaction) and each changed
buffer to tell the journalling layer about them.</p>
</div>
</div>
<div class="section" id="data-types">
<h2>Data Types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h2>
<p>The journalling layer uses typedefs to ‘hide’ the concrete definitions
of the structures used. As a client of the JBD2 layer you can just rely
on the using the pointer as a magic cookie of some sort. Obviously the
hiding is not enforced as this is ‘C’.</p>
<div class="section" id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.handle_t">
typedef <code class="descname">handle_t</code><a class="headerlink" href="#c.handle_t" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle_t type represents a single atomic update being performed by some process.</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>All filesystem modifications made by the process go
through this handle.  Recursive operations (such as quota operations)
are gathered into a single update.</p>
<p>The buffer credits field is used to account for journaled buffers
being modified by the running process.  To ensure that there is
enough log space for all outstanding operations, we need to limit the
number of outstanding buffers possible at any time.  When the
operation completes, any buffer credits not used are credited back to
the transaction, so that at all times we know how many buffers the
outstanding updates on a transaction might possibly touch.</p>
<p>This is an opaque datatype.</p>
<dl class="type">
<dt id="c.journal_t">
typedef <code class="descname">journal_t</code><a class="headerlink" href="#c.journal_t" title="Permalink to this definition">¶</a></dt>
<dd><p>The journal_t maintains all of the journaling state information for a single filesystem.</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>journal_t is linked to from the fs superblock structure.</p>
<p>We use the journal_t to keep track of all outstanding transaction
activity on the filesystem, and to manage the state of the log
writing process.</p>
<p>This is an opaque datatype.</p>
<dl class="type">
<dt id="c.jbd2_inode">
struct <code class="descname">jbd2_inode</code><a class="headerlink" href="#c.jbd2_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>The jbd_inode type is the structure linking inodes in ordered mode present in a transaction so that we can sync them during commit.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct jbd2_inode {
  transaction_t *i_transaction;
  transaction_t *i_next_transaction;
  struct list_head i_list;
  struct inode *i_vfs_inode;
  unsigned long i_flags;
  loff_t i_dirty_start;
  loff_t i_dirty_end;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">i_transaction</span></code></dt>
<dd>Which transaction does this inode belong to? Either the running
transaction or the committing one. [j_list_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_next_transaction</span></code></dt>
<dd>Pointer to the running transaction modifying inode’s data in case
there is already a committing transaction touching it. [j_list_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_list</span></code></dt>
<dd>List of inodes in the i_transaction [j_list_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_vfs_inode</span></code></dt>
<dd>VFS inode this inode belongs to [constant for lifetime of structure]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_flags</span></code></dt>
<dd>Flags of inode [j_list_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_dirty_start</span></code></dt>
<dd>Offset in bytes where the dirty range for this inode starts.
[j_list_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_dirty_end</span></code></dt>
<dd>Inclusive offset in bytes where the dirty range for this inode
ends. [j_list_lock]</dd>
</dl>
<dl class="type">
<dt id="c.jbd2_journal_handle">
struct <code class="descname">jbd2_journal_handle</code><a class="headerlink" href="#c.jbd2_journal_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle_s type is the concrete type associated with handle_t.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct jbd2_journal_handle {
  union {
    transaction_t *h_transaction;
    journal_t *h_journal;
  };
  handle_t *h_rsv_handle;
  int h_total_credits;
  int h_revoke_credits;
  int h_revoke_credits_requested;
  int h_ref;
  int h_err;
  unsigned int    h_sync:         1;
  unsigned int    h_jdata:        1;
  unsigned int    h_reserved:     1;
  unsigned int    h_aborted:      1;
  unsigned int    h_type:         8;
  unsigned int    h_line_no:      16;
  unsigned long           h_start_jiffies;
  unsigned int            h_requested_credits;
  unsigned int            saved_alloc_context;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_transaction</span></code></dt>
<dd>Which compound transaction is this update a part of?</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_journal</span></code></dt>
<dd>Which journal handle belongs to - used iff h_reserved set.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_rsv_handle</span></code></dt>
<dd>Handle reserved for finishing the logical operation.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_total_credits</span></code></dt>
<dd>Number of remaining buffers we are allowed to add to
journal. These are dirty buffers and revoke descriptor blocks.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_revoke_credits</span></code></dt>
<dd>Number of remaining revoke records available for handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_revoke_credits_requested</span></code></dt>
<dd>Holds <strong>h_revoke_credits</strong> after handle is started.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_ref</span></code></dt>
<dd>Reference count on this handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_err</span></code></dt>
<dd>Field for caller’s use to track errors through large fs operations.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_sync</span></code></dt>
<dd>Flag for sync-on-close.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_jdata</span></code></dt>
<dd>Flag to force data journaling.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_reserved</span></code></dt>
<dd>Flag for handle for reserved credits.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_aborted</span></code></dt>
<dd>Flag indicating fatal error on handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_type</span></code></dt>
<dd>For handle statistics.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_line_no</span></code></dt>
<dd>For handle statistics.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_start_jiffies</span></code></dt>
<dd>Handle Start time.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h_requested_credits</span></code></dt>
<dd>Holds <strong>h_total_credits</strong> after handle is started.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">saved_alloc_context</span></code></dt>
<dd>Saved context while transaction is open.</dd>
</dl>
<dl class="type">
<dt id="c.journal_s">
struct <code class="descname">journal_s</code><a class="headerlink" href="#c.journal_s" title="Permalink to this definition">¶</a></dt>
<dd><p>The journal_s type is the concrete type associated with journal_t.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct journal_s {
  unsigned long           j_flags;
  int j_errno;
  struct buffer_head      *j_sb_buffer;
  journal_superblock_t *j_superblock;
  int j_format_version;
  rwlock_t j_state_lock;
  int j_barrier_count;
  struct mutex            j_barrier;
  transaction_t *j_running_transaction;
  transaction_t *j_committing_transaction;
  transaction_t *j_checkpoint_transactions;
  wait_queue_head_t j_wait_transaction_locked;
  wait_queue_head_t j_wait_done_commit;
  wait_queue_head_t j_wait_commit;
  wait_queue_head_t j_wait_updates;
  wait_queue_head_t j_wait_reserved;
  struct mutex            j_checkpoint_mutex;
  struct buffer_head      *j_chkpt_bhs[JBD2_NR_BATCH];
  unsigned long           j_head;
  unsigned long           j_tail;
  unsigned long           j_free;
  unsigned long           j_first;
  unsigned long           j_last;
  struct block_device     *j_dev;
  int j_blocksize;
  unsigned long long      j_blk_offset;
  char j_devname[BDEVNAME_SIZE+24];
  struct block_device     *j_fs_dev;
  unsigned int            j_maxlen;
  atomic_t j_reserved_credits;
  spinlock_t j_list_lock;
  struct inode            *j_inode;
  tid_t j_tail_sequence;
  tid_t j_transaction_sequence;
  tid_t j_commit_sequence;
  tid_t j_commit_request;
  __u8 j_uuid[16];
  struct task_struct      *j_task;
  int j_max_transaction_buffers;
  int j_revoke_records_per_block;
  unsigned long           j_commit_interval;
  struct timer_list       j_commit_timer;
  spinlock_t j_revoke_lock;
  struct jbd2_revoke_table_s *j_revoke;
  struct jbd2_revoke_table_s *j_revoke_table[2];
  struct buffer_head      **j_wbuf;
  int j_wbufsize;
  pid_t j_last_sync_writer;
  u64 j_average_commit_time;
  u32 j_min_batch_time;
  u32 j_max_batch_time;
  void (*j_commit_callback)(journal_t *, transaction_t *);
  spinlock_t j_history_lock;
  struct proc_dir_entry   *j_proc_entry;
  struct transaction_stats_s j_stats;
  unsigned int            j_failed_commit;
  void *j_private;
  struct crypto_shash *j_chksum_driver;
  __u32 j_csum_seed;
#ifdef CONFIG_DEBUG_LOCK_ALLOC;
  struct lockdep_map      j_trans_commit_map;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">j_flags</span></code></dt>
<dd>General journaling state flags [j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_errno</span></code></dt>
<dd>Is there an outstanding uncleared error on the journal (from a prior
abort)? [j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_sb_buffer</span></code></dt>
<dd>The first part of the superblock buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_superblock</span></code></dt>
<dd>The second part of the superblock buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_format_version</span></code></dt>
<dd>Version of the superblock format.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_state_lock</span></code></dt>
<dd>Protect the various scalars in the journal.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_barrier_count</span></code></dt>
<dd>Number of processes waiting to create a barrier lock [j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_barrier</span></code></dt>
<dd>The barrier lock itself.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_running_transaction</span></code></dt>
<dd>Transactions: The current running transaction…
[j_state_lock] [caller holding open handle]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_committing_transaction</span></code></dt>
<dd>the transaction we are pushing to disk
[j_state_lock] [caller holding open handle]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_checkpoint_transactions</span></code></dt>
<dd>… and a linked circular list of all transactions waiting for
checkpointing. [j_list_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_wait_transaction_locked</span></code></dt>
<dd>Wait queue for waiting for a locked transaction to start committing,
or for a barrier lock to be released.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_wait_done_commit</span></code></dt>
<dd>Wait queue for waiting for commit to complete.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_wait_commit</span></code></dt>
<dd>Wait queue to trigger commit.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_wait_updates</span></code></dt>
<dd>Wait queue to wait for updates to complete.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_wait_reserved</span></code></dt>
<dd>Wait queue to wait for reserved buffer credits to drop.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_checkpoint_mutex</span></code></dt>
<dd>Semaphore for locking against concurrent checkpoints.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_chkpt_bhs</span></code></dt>
<dd>List of buffer heads used by the checkpoint routine.  This
was moved from jbd2_log_do_checkpoint() to reduce stack
usage.  Access to this array is controlled by the
<strong>j_checkpoint_mutex</strong>.  [j_checkpoint_mutex]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_head</span></code></dt>
<dd>Journal head: identifies the first unused block in the journal.
[j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_tail</span></code></dt>
<dd>Journal tail: identifies the oldest still-used block in the journal.
[j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_free</span></code></dt>
<dd>Journal free: how many free blocks are there in the journal?
[j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_first</span></code></dt>
<dd>The block number of the first usable block in the journal
[j_state_lock].</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_last</span></code></dt>
<dd>The block number one beyond the last usable block in the journal
[j_state_lock].</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_dev</span></code></dt>
<dd>Device where we store the journal.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_blocksize</span></code></dt>
<dd>Block size for the location where we store the journal.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_blk_offset</span></code></dt>
<dd>Starting block offset into the device where we store the journal.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_devname</span></code></dt>
<dd>Journal device name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_fs_dev</span></code></dt>
<dd>Device which holds the client fs.  For internal journal this will be
equal to j_dev.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_maxlen</span></code></dt>
<dd>Total maximum capacity of the journal region on disk.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_reserved_credits</span></code></dt>
<dd>Number of buffers reserved from the running transaction.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_list_lock</span></code></dt>
<dd>Protects the buffer lists and internal buffer state.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_inode</span></code></dt>
<dd>Optional inode where we store the journal.  If present, all
journal block numbers are mapped into this inode via <a class="reference internal" href="api-summary.html#c.bmap" title="bmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">bmap()</span></code></a>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_tail_sequence</span></code></dt>
<dd>Sequence number of the oldest transaction in the log [j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_transaction_sequence</span></code></dt>
<dd>Sequence number of the next transaction to grant [j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_commit_sequence</span></code></dt>
<dd>Sequence number of the most recently committed transaction
[j_state_lock].</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_commit_request</span></code></dt>
<dd>Sequence number of the most recent transaction wanting commit
[j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_uuid</span></code></dt>
<dd>Journal uuid: identifies the object (filesystem, LVM volume etc)
backed by this journal.  This will eventually be replaced by an array
of uuids, allowing us to index multiple devices within a single
journal and to perform atomic updates across them.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_task</span></code></dt>
<dd>Pointer to the current commit thread for this journal.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_max_transaction_buffers</span></code></dt>
<dd>Maximum number of metadata buffers to allow in a single compound
commit transaction.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_revoke_records_per_block</span></code></dt>
<dd>Number of revoke records that fit in one descriptor block.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_commit_interval</span></code></dt>
<dd>What is the maximum transaction lifetime before we begin a commit?</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_commit_timer</span></code></dt>
<dd>The timer used to wakeup the commit thread.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_revoke_lock</span></code></dt>
<dd>Protect the revoke table.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_revoke</span></code></dt>
<dd>The revoke table - maintains the list of revoked blocks in the
current transaction.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_revoke_table</span></code></dt>
<dd>Alternate revoke tables for j_revoke.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_wbuf</span></code></dt>
<dd>Array of bhs for jbd2_journal_commit_transaction.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_wbufsize</span></code></dt>
<dd>Size of <strong>j_wbuf</strong> array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_last_sync_writer</span></code></dt>
<dd>The pid of the last person to run a synchronous operation
through the journal.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_average_commit_time</span></code></dt>
<dd>The average amount of time in nanoseconds it takes to commit a
transaction to disk. [j_state_lock]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_min_batch_time</span></code></dt>
<dd>Minimum time that we should wait for additional filesystem operations
to get batched into a synchronous handle in microseconds.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_max_batch_time</span></code></dt>
<dd>Maximum time that we should wait for additional filesystem operations
to get batched into a synchronous handle in microseconds.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_commit_callback</span></code></dt>
<dd>This function is called when a transaction is closed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_history_lock</span></code></dt>
<dd>Protect the transactions statistics history.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_proc_entry</span></code></dt>
<dd>procfs entry for the jbd statistics directory.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_stats</span></code></dt>
<dd>Overall statistics.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_failed_commit</span></code></dt>
<dd>Failed journal commit ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_private</span></code></dt>
<dd>An opaque pointer to fs-private information.  ext3 puts its
superblock pointer here.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_chksum_driver</span></code></dt>
<dd>Reference to checksum algorithm driver via cryptoapi.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_csum_seed</span></code></dt>
<dd>Precomputed journal UUID checksum for seeding other checksums.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">j_trans_commit_map</span></code></dt>
<dd>Lockdep entity to track transaction commit dependencies. Handles
hold this “lock” for read, when we wait for commit, we acquire the
“lock” for writing. This matches the properties of jbd2 journalling
where the running transaction has to wait for all handles to be
dropped to commit that transaction and also acquiring a handle may
require transaction commit to finish.</dd>
</dl>
</div>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<p>The functions here are split into two groups those that affect a journal
as a whole, and those which are used to manage transactions</p>
<div class="section" id="journal-level">
<h3>Journal Level<a class="headerlink" href="#journal-level" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.jbd2_journal_force_commit_nested">
int <code class="descname">jbd2_journal_force_commit_nested</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_force_commit_nested" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to force
Returns true if progress was made.</dd>
</dl>
<p><strong>Description</strong></p>
<p>transaction.  This is used for forcing out undo-protected data which contains
bitmaps, when the fs is running out of space.</p>
<dl class="function">
<dt id="c.jbd2_journal_force_commit">
int <code class="descname">jbd2_journal_force_commit</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_force_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>force any uncommitted transactions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to force</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller want unconditional commit. We can only force the running transaction
if we don’t have an active handle, otherwise, we will deadlock.</p>
<dl class="function">
<dt id="c.jbd2_journal_init_dev">
<a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> * <code class="descname">jbd2_journal_init_dev</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct block_device *<em>&nbsp;fs_dev</em>, unsigned long long<em>&nbsp;start</em>, int<em>&nbsp;len</em>, int<em>&nbsp;blocksize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_init_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>creates and initialises a journal structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>Block device on which to create the journal</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">fs_dev</span></code></dt>
<dd>Device which hold journalled filesystem for this journal.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>Block nr Start of journal.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>Length of the journal in blocks.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">blocksize</span></code></dt>
<dd>blocksize of journalling device</dd>
</dl>
<p><strong>Return</strong></p>
<p>a newly created journal_t *</p>
<blockquote>
<div>jbd2_journal_init_dev creates a journal which maps a fixed contiguous
range of blocks on an arbitrary block device.</div></blockquote>
<dl class="function">
<dt id="c.jbd2_journal_init_inode">
<a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> * <code class="descname">jbd2_journal_init_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_init_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a journal which maps to a inode.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>An inode to create the journal in</dd>
</dl>
<p><strong>Description</strong></p>
<p>jbd2_journal_init_inode creates a journal which maps an on-disk inode as
the journal.  The inode must exist already, must support <a class="reference internal" href="api-summary.html#c.bmap" title="bmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">bmap()</span></code></a> and
must have all data blocks preallocated.</p>
<dl class="function">
<dt id="c.jbd2_journal_update_sb_errno">
void <code class="descname">jbd2_journal_update_sb_errno</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_update_sb_errno" title="Permalink to this definition">¶</a></dt>
<dd><p>Update error in the journal.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>The journal to update.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update a journal’s errno.  Write updated superblock to disk waiting for IO
to complete.</p>
<dl class="function">
<dt id="c.jbd2_journal_load">
int <code class="descname">jbd2_journal_load</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read journal from disk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a journal_t structure which tells us which disk blocks contain
a journal, read the journal from disk to initialise the in-memory
structures.</p>
<dl class="function">
<dt id="c.jbd2_journal_destroy">
int <code class="descname">jbd2_journal_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a journal_t structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a journal_t structure once it is no longer in use by the
journaled object.
Return &lt;0 if we couldn’t clean up the journal.</p>
<dl class="function">
<dt id="c.jbd2_journal_check_used_features">
int <code class="descname">jbd2_journal_check_used_features</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, unsigned long<em>&nbsp;compat</em>, unsigned long<em>&nbsp;ro</em>, unsigned long<em>&nbsp;incompat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_check_used_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if features specified are used.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to check.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">compat</span></code></dt>
<dd>bitmask of compatible features</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ro</span></code></dt>
<dd>bitmask of features that force read-only mount</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">incompat</span></code></dt>
<dd>bitmask of incompatible features</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the journal uses all of a given set of
features.  Return true (non-zero) if it does.</p>
<dl class="function">
<dt id="c.jbd2_journal_check_available_features">
int <code class="descname">jbd2_journal_check_available_features</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, unsigned long<em>&nbsp;compat</em>, unsigned long<em>&nbsp;ro</em>, unsigned long<em>&nbsp;incompat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_check_available_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Check feature set in journalling layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to check.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">compat</span></code></dt>
<dd>bitmask of compatible features</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ro</span></code></dt>
<dd>bitmask of features that force read-only mount</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">incompat</span></code></dt>
<dd>bitmask of incompatible features</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the journaling code supports the use of
all of a given set of features on this journal.  Return true</p>
<dl class="function">
<dt id="c.jbd2_journal_set_features">
int <code class="descname">jbd2_journal_set_features</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, unsigned long<em>&nbsp;compat</em>, unsigned long<em>&nbsp;ro</em>, unsigned long<em>&nbsp;incompat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_set_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a given journal feature in the superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">compat</span></code></dt>
<dd>bitmask of compatible features</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ro</span></code></dt>
<dd>bitmask of features that force read-only mount</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">incompat</span></code></dt>
<dd>bitmask of incompatible features</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark a given journal feature as present on the
superblock.  Returns true if the requested features could be set.</p>
<dl class="function">
<dt id="c.jbd2_journal_flush">
int <code class="descname">jbd2_journal_flush</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush journal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush all data for a given journal to disk and empty the journal.
Filesystems can use this when remounting readonly to ensure that
recovery does not need to happen on remount.</p>
<dl class="function">
<dt id="c.jbd2_journal_wipe">
int <code class="descname">jbd2_journal_wipe</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, int<em>&nbsp;write</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_wipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Wipe journal contents</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd>flag (see below)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wipe out all of the contents of a journal, safely.  This will produce
a warning if the journal contains any valid recovery information.
Must be called between journal_init_*() and <a class="reference internal" href="#c.jbd2_journal_load" title="jbd2_journal_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_load()</span></code></a>.</p>
<p>If ‘write’ is non-zero, then we wipe out the journal on disk; otherwise
we merely suppress recovery.</p>
<dl class="function">
<dt id="c.jbd2_journal_abort">
void <code class="descname">jbd2_journal_abort</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, int<em>&nbsp;errno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown the journal immediately.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>the journal to shutdown.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">errno</span></code></dt>
<dd>an error number to record in the journal indicating
the reason for the shutdown.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a complete, immediate shutdown of the ENTIRE
journal (not of a single transaction).  This operation cannot be
undone without closing and reopening the journal.</p>
<p>The jbd2_journal_abort function is intended to support higher level error
recovery mechanisms such as the ext2/ext3 remount-readonly error
mode.</p>
<p>Journal abort has very specific semantics.  Any existing dirty,
unjournaled buffers in the main filesystem will still be written to
disk by bdflush, but the journaling mechanism will be suspended
immediately and no further transaction commits will be honoured.</p>
<p>Any dirty, journaled buffers will be written back to disk without
hitting the journal.  Atomicity cannot be guaranteed on an aborted
filesystem, but we _do_ attempt to leave as much data as possible
behind for fsck to use for cleanup.</p>
<p>Any attempt to get a new transaction handle on a journal which is in
ABORT state will just result in an -EROFS error return.  A
jbd2_journal_stop on an existing handle will return -EIO if we have
entered abort state during the update.</p>
<p>Recursive transactions are not disturbed by journal abort until the
final jbd2_journal_stop, which will receive the -EIO error.</p>
<p>Finally, the jbd2_journal_abort call allows the caller to supply an errno
which will be recorded (if possible) in the journal superblock.  This
allows a client to record failure conditions in the middle of a
transaction without having to complete the transaction to record the
failure to disk.  ext3_error, for example, now uses this
functionality.</p>
<dl class="function">
<dt id="c.jbd2_journal_errno">
int <code class="descname">jbd2_journal_errno</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_errno" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the journal’s error state.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to examine.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the errno number set with <a class="reference internal" href="#c.jbd2_journal_abort" title="jbd2_journal_abort"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_abort()</span></code></a>, the last
time the journal was mounted - if the journal was stopped
without calling abort this will be 0.</p>
<p>If the journal has been aborted on this mount time -EROFS will
be returned.</p>
<dl class="function">
<dt id="c.jbd2_journal_clear_err">
int <code class="descname">jbd2_journal_clear_err</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_clear_err" title="Permalink to this definition">¶</a></dt>
<dd><p>clears the journal’s error state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>An error must be cleared or acked to take a FS out of readonly
mode.</p>
<dl class="function">
<dt id="c.jbd2_journal_ack_err">
void <code class="descname">jbd2_journal_ack_err</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_ack_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Ack journal err.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>An error must be cleared or acked to take a FS out of readonly
mode.</p>
<dl class="function">
<dt id="c.jbd2_journal_recover">
int <code class="descname">jbd2_journal_recover</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_recover" title="Permalink to this definition">¶</a></dt>
<dd><p>recovers a on-disk journal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>the journal to recover</dd>
</dl>
<p><strong>Description</strong></p>
<p>The primary function for recovering the log contents when mounting a
journaled device.</p>
<p>Recovery is done in three passes.  In the first pass, we look for the
end of the log.  In the second, we assemble the list of revoke
blocks.  In the third and final pass, we replay any un-revoked blocks
in the log.</p>
<dl class="function">
<dt id="c.jbd2_journal_skip_recovery">
int <code class="descname">jbd2_journal_skip_recovery</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_skip_recovery" title="Permalink to this definition">¶</a></dt>
<dd><p>Start journal and wipe exiting records</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to startup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locate any valid recovery information from the journal and set up the
journal structures in memory to ignore it (presumably because the
caller has evidence that it is out of date).
This function doesn’t appear to be exported..</p>
<p>We perform one pass over the journal to allow us to tell the user how
much recovery information is being erased, and to let us initialise
the journal transaction sequence numbers to the next unused ID.</p>
</div>
<div class="section" id="transasction-level">
<h3>Transasction Level<a class="headerlink" href="#transasction-level" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.jbd2_journal_start">
<a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> * <code class="descname">jbd2_journal_start</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, int<em>&nbsp;nblocks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a new handle.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to start transaction on.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nblocks</span></code></dt>
<dd>number of block buffer we might modify</dd>
</dl>
<p><strong>Description</strong></p>
<p>We make sure that the transaction can guarantee at least nblocks of
modified buffers in the log.  We block until the log can guarantee
that much space. Additionally, if rsv_blocks &gt; 0, we also create another
handle with rsv_blocks reserved blocks in the journal. This handle is
stored in h_rsv_handle. It is not attached to any particular transaction
and thus doesn’t block transaction commit. If the caller uses this reserved
handle, it has to set h_rsv_handle to NULL as otherwise <a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_stop()</span></code></a>
on the parent handle will dispose the reserved one. Reserved handle has to
be converted to a normal handle using <a class="reference internal" href="#c.jbd2_journal_start_reserved" title="jbd2_journal_start_reserved"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_start_reserved()</span></code></a> before
it can be used.</p>
<p>Return a pointer to a newly allocated handle, or an ERR_PTR() value
on failure.</p>
<dl class="function">
<dt id="c.jbd2_journal_start_reserved">
int <code class="descname">jbd2_journal_start_reserved</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;line_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_start_reserved" title="Permalink to this definition">¶</a></dt>
<dd><p>start reserved handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle to start</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>for handle statistics</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">line_no</span></code></dt>
<dd>for handle statistics</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start handle that has been previously reserved with jbd2_journal_reserve().
This attaches <strong>handle</strong> to the running transaction (or creates one if there’s
not transaction running). Unlike <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_start()</span></code></a> this function cannot
block on journal commit, checkpointing, or similar stuff. It can block on
memory allocation or frozen journal though.</p>
<p>Return 0 on success, non-zero on error - handle is freed in that case.</p>
<dl class="function">
<dt id="c.jbd2_journal_extend">
int <code class="descname">jbd2_journal_extend</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, int<em>&nbsp;nblocks</em>, int<em>&nbsp;revoke_records</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_extend" title="Permalink to this definition">¶</a></dt>
<dd><p>extend buffer credits.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle to ‘extend’</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nblocks</span></code></dt>
<dd>nr blocks to try to extend by.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">revoke_records</span></code></dt>
<dd>number of revoke records to try to extend by.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some transactions, such as large extends and truncates, can be done
atomically all at once or in several stages.  The operation requests
a credit for a number of buffer modifications in advance, but can
extend its credit if it needs more.</p>
<p>jbd2_journal_extend tries to give the running handle more buffer credits.
It does not guarantee that allocation - this is a best-effort only.
The calling process MUST be able to deal cleanly with a failure to
extend here.</p>
<p>Return 0 on success, non-zero on failure.</p>
<p>return code &lt; 0 implies an error
return code &gt; 0 implies normal transaction-full status.</p>
<dl class="function">
<dt id="c.jbd2__journal_restart">
int <code class="descname">jbd2__journal_restart</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, int<em>&nbsp;nblocks</em>, int<em>&nbsp;revoke_records</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2__journal_restart" title="Permalink to this definition">¶</a></dt>
<dd><p>restart a handle .</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle to restart</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nblocks</span></code></dt>
<dd>nr credits requested</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">revoke_records</span></code></dt>
<dd>number of revoke record credits requested</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for start_this_handle)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart a handle for a multi-transaction filesystem
operation.</p>
<p>If the <a class="reference internal" href="#c.jbd2_journal_extend" title="jbd2_journal_extend"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_extend()</span></code></a> call above fails to grant new buffer credits
to a running handle, a call to jbd2_journal_restart will commit the
handle’s transaction so far and reattach the handle to a new
transaction capable of guaranteeing the requested number of
credits. We preserve reserved handle if there’s any attached to the
passed in handle.</p>
<dl class="function">
<dt id="c.jbd2_journal_lock_updates">
void <code class="descname">jbd2_journal_lock_updates</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_lock_updates" title="Permalink to this definition">¶</a></dt>
<dd><p>establish a transaction barrier.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to establish a barrier on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks out any further updates from being started, and blocks
until all existing updates have completed, returning only once the
journal is in a quiescent state with no updates running.</p>
<p>The journal lock should not be held on entry.</p>
<dl class="function">
<dt id="c.jbd2_journal_unlock_updates">
void <code class="descname">jbd2_journal_unlock_updates</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_unlock_updates" title="Permalink to this definition">¶</a></dt>
<dd><p>release barrier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to release the barrier on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a transaction barrier obtained with <a class="reference internal" href="#c.jbd2_journal_lock_updates" title="jbd2_journal_lock_updates"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_lock_updates()</span></code></a>.</p>
<p>Should be called without the journal lock held.</p>
<dl class="function">
<dt id="c.jbd2_journal_get_write_access">
int <code class="descname">jbd2_journal_get_write_access</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_get_write_access" title="Permalink to this definition">¶</a></dt>
<dd><p>notify intent to modify a buffer for metadata (not data) update.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction to add buffer modifications to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>bh to be used for metadata writes</dd>
</dl>
<p><strong>Return</strong></p>
<p>error code or 0 on success.</p>
<p>In full data journalling mode the buffer may be of type BJ_AsyncData,
because we’re <code class="docutils literal notranslate"><span class="pre">write()ing</span></code> a buffer which is also part of a shared mapping.</p>
<dl class="function">
<dt id="c.jbd2_journal_get_create_access">
int <code class="descname">jbd2_journal_get_create_access</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_get_create_access" title="Permalink to this definition">¶</a></dt>
<dd><p>notify intent to use newly created bh</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction to new buffer to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>new buffer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this if you create a new bh.</p>
<dl class="function">
<dt id="c.jbd2_journal_get_undo_access">
int <code class="descname">jbd2_journal_get_undo_access</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_get_undo_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify intent to modify metadata with non-rewindable consequences</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>buffer to undo</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sometimes there is a need to distinguish between metadata which has
been committed to disk and that which has not.  The ext3fs code uses
this for freeing and allocating space, we have to make sure that we
do not reuse freed space until the deallocation has been committed,
since if we overwrote that space we would make the delete
un-rewindable in case of a crash.</p>
<p>To deal with that, jbd2_journal_get_undo_access requests write access to a
buffer for parts of non-rewindable operations such as delete
operations on the bitmaps.  The journaling code must keep a copy of
the buffer’s contents prior to the undo_access call until such time
as we know that the buffer has definitely been committed to disk.</p>
<p>We never need to know which transaction the committed data is part
of, buffers touched here are guaranteed to be dirtied later and so
will be committed to a new transaction in due course, at which point
we can discard the old committed data pointer.</p>
<p>Returns error number or 0 on success.</p>
<dl class="function">
<dt id="c.jbd2_journal_set_triggers">
void <code class="descname">jbd2_journal_set_triggers</code><span class="sig-paren">(</span>struct buffer_head *<em>&nbsp;bh</em>, struct jbd2_buffer_trigger_type *<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_set_triggers" title="Permalink to this definition">¶</a></dt>
<dd><p>Add triggers for commit writeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>buffer to trigger on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">jbd2_buffer_trigger_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>struct jbd2_buffer_trigger_type containing the trigger(s).</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set any triggers on this journal_head.  This is always safe, because
triggers for a committing buffer will be saved off, and triggers for
a running transaction will match the buffer in that transaction.</p>
<p>Call with NULL to clear the triggers.</p>
<dl class="function">
<dt id="c.jbd2_journal_dirty_metadata">
int <code class="descname">jbd2_journal_dirty_metadata</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_dirty_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a buffer as containing dirty metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction to add buffer to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>buffer to mark</dd>
</dl>
<p><strong>Description</strong></p>
<p>mark dirty metadata which needs to be journaled as part of the current
transaction.</p>
<p>The buffer must have previously had <a class="reference internal" href="#c.jbd2_journal_get_write_access" title="jbd2_journal_get_write_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">jbd2_journal_get_write_access()</span></code></a>
called so that it has a valid journal_head attached to the buffer
head.</p>
<p>The buffer is placed on the transaction’s metadata list and is marked
as belonging to the transaction.</p>
<p>Returns error number or 0 on success.</p>
<p>Special care needs to be taken if the buffer already belongs to the
current committing transaction (in which case we should have frozen
data present for that commit).  In that case, we don’t relink the
buffer: that only gets done when the old transaction finally
completes its commit.</p>
<dl class="function">
<dt id="c.jbd2_journal_forget">
int <code class="descname">jbd2_journal_forget</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_forget" title="Permalink to this definition">¶</a></dt>
<dd><p>bforget() for potentially-journaled buffers.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>bh to ‘forget’</dd>
</dl>
<p><strong>Description</strong></p>
<p>We can only do the bforget if there are no commits pending against the
buffer.  If the buffer is dirty in the current running transaction we
can safely unlink it.</p>
<p>bh may not be a journalled buffer at all - it may be a non-JBD
buffer which came off the hashtable.  Check for this.</p>
<p>Decrements bh-&gt;b_count by one.</p>
<p>Allow this call even if the handle has aborted — it may be part of
the caller’s cleanup after an abort.</p>
<dl class="function">
<dt id="c.jbd2_journal_stop">
int <code class="descname">jbd2_journal_stop</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>complete a transaction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction to complete.</dd>
</dl>
<p><strong>Description</strong></p>
<p>All done for a particular handle.</p>
<p>There is not much action needed here.  We just return any remaining
buffer credits to the transaction and remove the handle.  The only
complication is that we need to start a commit operation if the
filesystem is marked for synchronous update.</p>
<p>jbd2_journal_stop itself will not usually return an error, but it may
do so in unusual circumstances.  In particular, expect it to
return -EIO if a jbd2_journal_abort has been executed since the
transaction began.</p>
<dl class="function">
<dt id="c.jbd2_journal_try_to_free_buffers">
int <code class="descname">jbd2_journal_try_to_free_buffers</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, struct page *<em>&nbsp;page</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_try_to_free_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>try to free page buffers.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal for operation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>to try and free</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>we use the mask to detect how hard should we try to release
buffers. If __GFP_DIRECT_RECLAIM and __GFP_FS is set, we wait for commit
code to release the buffers.</dd>
</dl>
<p><strong>Description</strong></p>
<p>For all the buffers on this page,
if they are fully written out ordered data, move them onto BUF_CLEAN
so try_to_free_buffers() can reap them.</p>
<p>This function returns non-zero if we wish try_to_free_buffers()
to be called. We do this if the page is releasable by try_to_free_buffers().
We also do it if the page has locked or dirty buffers and the caller wants
us to perform sync or async writeout.</p>
<p>This complicates JBD locking somewhat.  We aren’t protected by the
BKL here.  We wish to remove the buffer from its committing or
running transaction’s -&gt;t_datalist via __jbd2_journal_unfile_buffer.</p>
<p>This may <em>change</em> the value of transaction_t-&gt;t_datalist, so anyone
who looks at t_datalist needs to lock against this function.</p>
<p>Even worse, someone may be doing a jbd2_journal_dirty_data on this
buffer.  So we need to lock against that.  jbd2_journal_dirty_data()
will come out of the lock with the buffer dirty, which makes it
ineligible for release here.</p>
<p>Who else is affected by this?  hmm…  Really the only contender
is do_get_write_access() - it could be looking at the buffer while
journal_try_to_free_buffer() is changing its state.  But that
cannot happen because we never reallocate freed data as metadata
while the data is part of a transaction.  Yes?</p>
<p>Return 0 on failure, 1 on success</p>
<dl class="function">
<dt id="c.jbd2_journal_invalidatepage">
int <code class="descname">jbd2_journal_invalidatepage</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;offset</em>, unsigned int<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_invalidatepage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to use for flush…</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page to flush</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>start of the range to invalidate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">length</span></code></dt>
<dd>length of the range to invalidate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reap page buffers containing data after in the specified range in page.
Can return -EBUSY if buffers are part of the committing transaction and
the page is straddling i_size. Caller then has to wait for current commit
and try again.</p>
</div>
</div>
<div class="section" id="see-also">
<h2>See also<a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://kernel.org/pub/linux/kernel/people/sct/ext3/journal-design.ps.gz">Journaling the Linux ext2fs Filesystem, LinuxExpo 98, Stephen
Tweedie</a></p>
<p><a class="reference external" href="http://olstrans.sourceforge.net/release/OLS2000-ext3/OLS2000-ext3.html">Ext3 Journalling FileSystem, OLS 2000, Dr. Stephen
Tweedie</a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>