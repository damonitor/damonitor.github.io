

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel Samepage Merging &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.14.0-rc1-mm1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Kernel Samepage Merging</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/vm/ksm.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-samepage-merging">
<span id="ksm"></span><h1>Kernel Samepage Merging<a class="headerlink" href="#kernel-samepage-merging" title="Permalink to this headline">¶</a></h1>
<p>KSM is a memory-saving de-duplication feature, enabled by CONFIG_KSM=y,
added to the Linux kernel in 2.6.32.  See <code class="docutils literal notranslate"><span class="pre">mm/ksm.c</span></code> for its implementation,
and <a class="reference external" href="http://lwn.net/Articles/306704/">http://lwn.net/Articles/306704/</a> and <a class="reference external" href="https://lwn.net/Articles/330589/">https://lwn.net/Articles/330589/</a></p>
<p>The userspace interface of KSM is described in <a class="reference internal" href="../admin-guide/mm/ksm.html#admin-guide-ksm"><span class="std std-ref"><a class="reference internal" href="../admin-guide/mm/ksm.html"><span class="doc">Kernel Samepage Merging</span></a></span></a></p>
<div class="section" id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>A few notes about the KSM scanning process,
to make it easier to understand the data structures below:</p>
<p>In order to reduce excessive scanning, KSM sorts the memory pages by their
contents into a data structure that holds pointers to the pages’ locations.</p>
<p>Since the contents of the pages may change at any moment, KSM cannot just
insert the pages into a normal sorted tree and expect it to find anything.
Therefore KSM uses two data structures - the stable and the unstable tree.</p>
<p>The stable tree holds pointers to all the merged pages (ksm pages), sorted
by their contents.  Because each such page is write-protected, searching on
this tree is fully assured to be working (except when pages are unmapped),
and therefore this tree is called the stable tree.</p>
<p>The stable tree node includes information required for reverse
mapping from a KSM page to virtual addresses that map this page.</p>
<p>In order to avoid large latencies of the rmap walks on KSM pages,
KSM maintains two types of nodes in the stable tree:</p>
<ul class="simple">
<li><p>the regular nodes that keep the reverse mapping structures in a
linked list</p></li>
<li><p>the “chains” that link nodes (“dups”) that represent the same
write protected memory content, but each “dup” corresponds to a
different KSM page copy of that content</p></li>
</ul>
<p>Internally, the regular nodes, “dups” and “chains” are represented
using the same struct stable_node structure.</p>
<p>In addition to the stable tree, KSM uses a second data structure called the
unstable tree: this tree holds pointers to pages which have been found to
be “unchanged for a period of time”.  The unstable tree sorts these pages
by their contents, but since they are not write-protected, KSM cannot rely
upon the unstable tree to work correctly - the unstable tree is liable to
be corrupted as its contents are modified, and so it is called unstable.</p>
<p>KSM solves this problem by several techniques:</p>
<ol class="arabic simple">
<li><p>The unstable tree is flushed every time KSM completes scanning all
memory areas, and then the tree is rebuilt again from the beginning.</p></li>
<li><p>KSM will only insert into the unstable tree, pages whose hash value
has not changed since the previous scan of all memory areas.</p></li>
<li><p>The unstable tree is a RedBlack Tree - so its balancing is based on the
colors of the nodes and not on their contents, assuring that even when
the tree gets “corrupted” it won’t get out of balance, so scanning time
remains the same (also, searching and inserting nodes in an rbtree uses
the same algorithm, so we have no overhead when we flush and rebuild).</p></li>
<li><p>KSM never flushes the stable tree, which means that even if it were to
take 10 attempts to find a page in the unstable tree, once it is found,
it is secured in the stable tree.  (When we scan a new page, we first
compare it against the stable tree, and then against the unstable tree.)</p></li>
</ol>
<p>If the merge_across_nodes tunable is unset, then KSM maintains multiple
stable trees and multiple unstable trees: one of each for each NUMA node.</p>
</div>
<div class="section" id="reverse-mapping">
<h3>Reverse mapping<a class="headerlink" href="#reverse-mapping" title="Permalink to this headline">¶</a></h3>
<p>KSM maintains reverse mapping information for KSM pages in the stable
tree.</p>
<p>If a KSM page is shared between less than <code class="docutils literal notranslate"><span class="pre">max_page_sharing</span></code> VMAs,
the node of the stable tree that represents such KSM page points to a
list of struct rmap_item and the <code class="docutils literal notranslate"><span class="pre">page-&gt;mapping</span></code> of the
KSM page points to the stable tree node.</p>
<p>When the sharing passes this threshold, KSM adds a second dimension to
the stable tree. The tree node becomes a “chain” that links one or
more “dups”. Each “dup” keeps reverse mapping information for a KSM
page with <code class="docutils literal notranslate"><span class="pre">page-&gt;mapping</span></code> pointing to that “dup”.</p>
<p>Every “chain” and all “dups” linked into a “chain” enforce the
invariant that they represent the same write protected memory content,
even if each “dup” will be pointed by a different KSM page copy of
that content.</p>
<p>This way the stable tree lookup computational complexity is unaffected
if compared to an unlimited list of reverse mappings. It is still
enforced that there cannot be KSM page content duplicates in the
stable tree itself.</p>
<p>The deduplication limit enforced by <code class="docutils literal notranslate"><span class="pre">max_page_sharing</span></code> is required
to avoid the virtual memory rmap lists to grow too large. The rmap
walk has O(N) complexity where N is the number of rmap_items
(i.e. virtual mappings) that are sharing the page, which is in turn
capped by <code class="docutils literal notranslate"><span class="pre">max_page_sharing</span></code>. So this effectively spreads the linear
O(N) computational complexity from rmap walk context over different
KSM pages. The ksmd walk over the stable_node “chains” is also O(N),
but N is the number of stable_node “dups”, not the number of
rmap_items, so it has not a significant impact on ksmd performance. In
practice the best stable_node “dup” candidate will be kept and found
at the head of the “dups” list.</p>
<p>High values of <code class="docutils literal notranslate"><span class="pre">max_page_sharing</span></code> result in faster memory merging
(because there will be fewer stable_node dups queued into the
stable_node chain-&gt;hlist to check for pruning) and higher
deduplication factor at the expense of slower worst case for rmap
walks for any KSM page which can happen during swapping, compaction,
NUMA balancing and page migration.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">stable_node_dups/stable_node_chains</span></code> ratio is also affected by the
<code class="docutils literal notranslate"><span class="pre">max_page_sharing</span></code> tunable, and an high ratio may indicate fragmentation
in the stable_node dups, which could be solved by introducing
fragmentation algorithms in ksmd which would refile rmap_items from
one stable_node dup to another stable_node dup, in order to free up
stable_node “dups” with few rmap_items in them, but that may increase
the ksmd CPU usage and possibly slowdown the readonly computations on
the KSM pages of the applications.</p>
<p>The whole list of stable_node “dups” linked in the stable_node
“chains” is scanned periodically in order to prune stale stable_nodes.
The frequency of such scans is defined by
<code class="docutils literal notranslate"><span class="pre">stable_node_chains_prune_millisecs</span></code> sysfs tunable.</p>
</div>
<div class="section" id="reference">
<h3>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.V4L.mm_slot">
struct <code class="sig-name descname">mm_slot</code><a class="headerlink" href="#c.V4L.mm_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>ksm information per mm that is being scanned</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mm_slot {
  struct hlist_node link;
  struct list_head mm_list;
  struct rmap_item *rmap_list;
  struct mm_struct *mm;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">link</span></code></dt><dd><p>link to the mm_slots hash list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm_list</span></code></dt><dd><p>link into the mm_slots list, rooted in ksm_mm_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rmap_list</span></code></dt><dd><p>head for this mm_slot’s singly-linked list of rmap_items</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm</span></code></dt><dd><p>the mm that this information is valid for</p>
</dd>
</dl>
<dl class="type">
<dt id="c.V4L.ksm_scan">
struct <code class="sig-name descname">ksm_scan</code><a class="headerlink" href="#c.V4L.ksm_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>cursor for scanning</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ksm_scan {
  struct mm_slot *mm_slot;
  unsigned long address;
  struct rmap_item **rmap_list;
  unsigned long seqnr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mm_slot</span></code></dt><dd><p>the current mm_slot we are scanning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">address</span></code></dt><dd><p>the next address inside that to be scanned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rmap_list</span></code></dt><dd><p>link to the next rmap to be scanned in the rmap_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seqnr</span></code></dt><dd><p>count of completed full scans (needed when removing unstable node)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There is only the one ksm_scan instance of this cursor structure.</p>
<dl class="type">
<dt id="c.V4L.stable_node">
struct <code class="sig-name descname">stable_node</code><a class="headerlink" href="#c.V4L.stable_node" title="Permalink to this definition">¶</a></dt>
<dd><p>node of the stable rbtree</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct stable_node {
  union {
    struct rb_node node;
    struct {
      struct list_head *head;
      struct {
        struct hlist_node hlist_dup;
        struct list_head list;
      };
    };
  };
  struct hlist_head hlist;
  union {
    unsigned long kpfn;
    unsigned long chain_prune_time;
  };
#define STABLE_NODE_CHAIN -1024;
  int rmap_hlist_len;
#ifdef CONFIG_NUMA;
  int nid;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>rb node of this ksm page in the stable tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>(overlaying parent) <code class="xref c c-type docutils literal notranslate"><span class="pre">migrate_nodes</span></code> indicates temporarily on that list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hlist_dup</span></code></dt><dd><p>linked into the stable_node-&gt;hlist with a stable_node chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>linked into migrate_nodes, pending placement in the proper node tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hlist</span></code></dt><dd><p>hlist head of rmap_items using this ksm page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kpfn</span></code></dt><dd><p>page frame number of this ksm page (perhaps temporarily on wrong nid)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chain_prune_time</span></code></dt><dd><p>time of the last full garbage collection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rmap_hlist_len</span></code></dt><dd><p>number of rmap_item entries in hlist or STABLE_NODE_CHAIN</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nid</span></code></dt><dd><p>NUMA node id of stable tree in which linked (may not match kpfn)</p>
</dd>
</dl>
<dl class="type">
<dt id="c.V4L.rmap_item">
struct <code class="sig-name descname">rmap_item</code><a class="headerlink" href="#c.V4L.rmap_item" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse mapping item for virtual addresses</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rmap_item {
  struct rmap_item *rmap_list;
  union {
    struct anon_vma *anon_vma;
#ifdef CONFIG_NUMA;
    int nid;
#endif;
  };
  struct mm_struct *mm;
  unsigned long address;
  unsigned int oldchecksum;
  union {
    struct rb_node node;
    struct {
      struct stable_node *head;
      struct hlist_node hlist;
    };
  };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rmap_list</span></code></dt><dd><p>next rmap_item in mm_slot’s singly-linked rmap_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">anon_vma</span></code></dt><dd><p>pointer to anon_vma for this mm,address, when in stable tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nid</span></code></dt><dd><p>NUMA node id of unstable tree in which linked (may not match page)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm</span></code></dt><dd><p>the memory structure this rmap_item is pointing into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">address</span></code></dt><dd><p>the virtual address this rmap_item tracks (+ flags in low bits)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oldchecksum</span></code></dt><dd><p>previous checksum of the page at that virtual address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>rb node of this rmap_item in the unstable tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>pointer to stable_node heading this list in the stable tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hlist</span></code></dt><dd><p>link into hlist of rmap_items hanging off that stable_node</p>
</dd>
</dl>
<p>–
Izik Eidus,
Hugh Dickins, 17 Nov 2009</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>