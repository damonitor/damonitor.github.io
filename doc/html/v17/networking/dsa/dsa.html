

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Architecture &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Architecture</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/networking/dsa/dsa.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="architecture">
<h1>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h1>
<p>This document describes the <strong>Distributed Switch Architecture (DSA)</strong> subsystem
design principles, limitations, interactions with other subsystems, and how to
develop drivers for this subsystem as well as a TODO for developers interested
in joining the effort.</p>
<div class="section" id="design-principles">
<h2>Design principles<a class="headerlink" href="#design-principles" title="Permalink to this headline">¶</a></h2>
<p>The Distributed Switch Architecture is a subsystem which was primarily designed
to support Marvell Ethernet switches (MV88E6xxx, a.k.a Linkstreet product line)
using Linux, but has since evolved to support other vendors as well.</p>
<p>The original philosophy behind this design was to be able to use unmodified
Linux tools such as bridge, iproute2, ifconfig to work transparently whether
they configured/queried a switch port network device or a regular network
device.</p>
<p>An Ethernet switch is typically comprised of multiple front-panel ports, and one
or more CPU or management port. The DSA subsystem currently relies on the
presence of a management port connected to an Ethernet controller capable of
receiving Ethernet frames from the switch. This is a very common setup for all
kinds of Ethernet switches found in Small Home and Office products: routers,
gateways, or even top-of-the rack switches. This host Ethernet controller will
be later referred to as “master” and “cpu” in DSA terminology and code.</p>
<p>The D in DSA stands for Distributed, because the subsystem has been designed
with the ability to configure and manage cascaded switches on top of each other
using upstream and downstream Ethernet links between switches. These specific
ports are referred to as “dsa” ports in DSA terminology and code. A collection
of multiple switches connected to each other is called a “switch tree”.</p>
<p>For each front-panel port, DSA will create specialized network devices which are
used as controlling and data-flowing endpoints for use by the Linux networking
stack. These specialized network interfaces are referred to as “slave” network
interfaces in DSA terminology and code.</p>
<p>The ideal case for using DSA is when an Ethernet switch supports a “switch tag”
which is a hardware feature making the switch insert a specific tag for each
Ethernet frames it received to/from specific ports to help the management
interface figure out:</p>
<ul class="simple">
<li>what port is this frame coming from</li>
<li>what was the reason why this frame got forwarded</li>
<li>how to send CPU originated traffic to specific ports</li>
</ul>
<p>The subsystem does support switches not capable of inserting/stripping tags, but
the features might be slightly limited in that case (traffic separation relies
on Port-based VLAN IDs).</p>
<p>Note that DSA does not currently create network interfaces for the “cpu” and
“dsa” ports because:</p>
<ul class="simple">
<li>the “cpu” port is the Ethernet switch facing side of the management
controller, and as such, would create a duplication of feature, since you
would get two interfaces for the same conduit: master netdev, and “cpu” netdev</li>
<li>the “dsa” port(s) are just conduits between two or more switches, and as such
cannot really be used as proper network interfaces either, only the
downstream, or the top-most upstream interface makes sense with that model</li>
</ul>
<div class="section" id="switch-tagging-protocols">
<h3>Switch tagging protocols<a class="headerlink" href="#switch-tagging-protocols" title="Permalink to this headline">¶</a></h3>
<p>DSA currently supports 5 different tagging protocols, and a tag-less mode as
well. The different protocols are implemented in:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">net/dsa/tag_trailer.c</span></code>: Marvell’s 4 trailer tag mode (legacy)</li>
<li><code class="docutils literal notranslate"><span class="pre">net/dsa/tag_dsa.c</span></code>: Marvell’s original DSA tag</li>
<li><code class="docutils literal notranslate"><span class="pre">net/dsa/tag_edsa.c</span></code>: Marvell’s enhanced DSA tag</li>
<li><code class="docutils literal notranslate"><span class="pre">net/dsa/tag_brcm.c</span></code>: Broadcom’s 4 bytes tag</li>
<li><code class="docutils literal notranslate"><span class="pre">net/dsa/tag_qca.c</span></code>: Qualcomm’s 2 bytes tag</li>
</ul>
<p>The exact format of the tag protocol is vendor specific, but in general, they
all contain something which:</p>
<ul class="simple">
<li>identifies which port the Ethernet frame came from/should be sent to</li>
<li>provides a reason why this frame was forwarded to the management interface</li>
</ul>
</div>
<div class="section" id="master-network-devices">
<h3>Master network devices<a class="headerlink" href="#master-network-devices" title="Permalink to this headline">¶</a></h3>
<p>Master network devices are regular, unmodified Linux network device drivers for
the CPU/management Ethernet interface. Such a driver might occasionally need to
know whether DSA is enabled (e.g.: to enable/disable specific offload features),
but the DSA subsystem has been proven to work with industry standard drivers:
<code class="docutils literal notranslate"><span class="pre">e1000e,</span></code> <code class="docutils literal notranslate"><span class="pre">mv643xx_eth</span></code> etc. without having to introduce modifications to these
drivers. Such network devices are also often referred to as conduit network
devices since they act as a pipe between the host processor and the hardware
Ethernet switch.</p>
</div>
<div class="section" id="networking-stack-hooks">
<h3>Networking stack hooks<a class="headerlink" href="#networking-stack-hooks" title="Permalink to this headline">¶</a></h3>
<p>When a master netdev is used with DSA, a small hook is placed in in the
networking stack is in order to have the DSA subsystem process the Ethernet
switch specific tagging protocol. DSA accomplishes this by registering a
specific (and fake) Ethernet type (later becoming <code class="docutils literal notranslate"><span class="pre">skb-&gt;protocol</span></code>) with the
networking stack, this is also known as a <code class="docutils literal notranslate"><span class="pre">ptype</span></code> or <code class="docutils literal notranslate"><span class="pre">packet_type</span></code>. A typical
Ethernet Frame receive sequence looks like this:</p>
<p>Master network device (e.g.: e1000e):</p>
<ol class="arabic">
<li><p class="first">Receive interrupt fires:</p>
<blockquote>
<div><ul class="simple">
<li>receive function is invoked</li>
<li>basic packet processing is done: getting length, status etc.</li>
<li>packet is prepared to be processed by the Ethernet layer by calling
<code class="docutils literal notranslate"><span class="pre">eth_type_trans</span></code></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">net/ethernet/eth.c:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth_type_trans(skb, dev)
        if (dev-&gt;dsa_ptr != NULL)
                -&gt; skb-&gt;protocol = ETH_P_XDSA
</pre></div>
</div>
</li>
<li><p class="first">drivers/net/ethernet/*:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>netif_receive_skb(skb)
        -&gt; iterate over registered packet_type
                -&gt; invoke handler for ETH_P_XDSA, calls dsa_switch_rcv()
</pre></div>
</div>
</li>
<li><p class="first">net/dsa/dsa.c:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-&gt; dsa_switch_rcv()
        -&gt; invoke switch tag specific protocol handler in &#39;net/dsa/tag_*.c&#39;
</pre></div>
</div>
</li>
<li><p class="first">net/dsa/tag_*.c:</p>
<blockquote>
<div><ul class="simple">
<li>inspect and strip switch tag protocol to determine originating port</li>
<li>locate per-port network device</li>
<li>invoke <code class="docutils literal notranslate"><span class="pre">eth_type_trans()</span></code> with the DSA slave network device</li>
<li>invoked <code class="docutils literal notranslate"><span class="pre">netif_receive_skb()</span></code></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>Past this point, the DSA slave network devices get delivered regular Ethernet
frames that can be processed by the networking stack.</p>
</div>
<div class="section" id="slave-network-devices">
<h3>Slave network devices<a class="headerlink" href="#slave-network-devices" title="Permalink to this headline">¶</a></h3>
<p>Slave network devices created by DSA are stacked on top of their master network
device, each of these network interfaces will be responsible for being a
controlling and data-flowing end-point for each front-panel port of the switch.
These interfaces are specialized in order to:</p>
<ul class="simple">
<li>insert/remove the switch tag protocol (if it exists) when sending traffic
to/from specific switch ports</li>
<li>query the switch for ethtool operations: statistics, link state,
Wake-on-LAN, register dumps…</li>
<li>external/internal PHY management: link, auto-negotiation etc.</li>
</ul>
<p>These slave network devices have custom net_device_ops and ethtool_ops function
pointers which allow DSA to introduce a level of layering between the networking
stack/ethtool, and the switch driver implementation.</p>
<p>Upon frame transmission from these slave network devices, DSA will look up which
switch tagging protocol is currently registered with these network devices, and
invoke a specific transmit routine which takes care of adding the relevant
switch tag in the Ethernet frames.</p>
<p>These frames are then queued for transmission using the master network device
<code class="docutils literal notranslate"><span class="pre">ndo_start_xmit()</span></code> function, since they contain the appropriate switch tag, the
Ethernet switch will be able to process these incoming frames from the
management interface and delivers these frames to the physical switch port.</p>
</div>
<div class="section" id="graphical-representation">
<h3>Graphical representation<a class="headerlink" href="#graphical-representation" title="Permalink to this headline">¶</a></h3>
<p>Summarized, this is basically how DSA looks like from a network device
perspective:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        |---------------------------
        | CPU network device (eth0)|
        ----------------------------
        | &lt;tag added by switch     |
        |                          |
        |                          |
        |        tag added by CPU&gt; |
|--------------------------------------------|
|            Switch driver                   |
|--------------------------------------------|
          ||        ||         ||
      |-------|  |-------|  |-------|
      | sw0p0 |  | sw0p1 |  | sw0p2 |
      |-------|  |-------|  |-------|
</pre></div>
</div>
</div>
<div class="section" id="slave-mdio-bus">
<h3>Slave MDIO bus<a class="headerlink" href="#slave-mdio-bus" title="Permalink to this headline">¶</a></h3>
<p>In order to be able to read to/from a switch PHY built into it, DSA creates a
slave MDIO bus which allows a specific switch driver to divert and intercept
MDIO reads/writes towards specific PHY addresses. In most MDIO-connected
switches, these functions would utilize direct or indirect PHY addressing mode
to return standard MII registers from the switch builtin PHYs, allowing the PHY
library and/or to return link status, link partner pages, auto-negotiation
results etc..</p>
<p>For Ethernet switches which have both external and internal MDIO busses, the
slave MII bus can be utilized to mux/demux MDIO reads and writes towards either
internal or external MDIO devices this switch might be connected to: internal
PHYs, external PHYs, or even external switches.</p>
</div>
<div class="section" id="data-structures">
<h3>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h3>
<p>DSA data structures are defined in <code class="docutils literal notranslate"><span class="pre">include/net/dsa.h</span></code> as well as
<code class="docutils literal notranslate"><span class="pre">net/dsa/dsa_priv.h</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dsa_chip_data</span></code>: platform data configuration for a given switch device,
this structure describes a switch device’s parent device, its address, as
well as various properties of its ports: names/labels, and finally a routing
table indication (when cascading switches)</li>
<li><code class="docutils literal notranslate"><span class="pre">dsa_platform_data</span></code>: platform device configuration data which can reference
a collection of dsa_chip_data structure if multiples switches are cascaded,
the master network device this switch tree is attached to needs to be
referenced</li>
<li><code class="docutils literal notranslate"><span class="pre">dsa_switch_tree</span></code>: structure assigned to the master network device under
<code class="docutils literal notranslate"><span class="pre">dsa_ptr</span></code>, this structure references a dsa_platform_data structure as well as
the tagging protocol supported by the switch tree, and which receive/transmit
function hooks should be invoked, information about the directly attached
switch is also provided: CPU port. Finally, a collection of dsa_switch are
referenced to address individual switches in the tree.</li>
<li><code class="docutils literal notranslate"><span class="pre">dsa_switch</span></code>: structure describing a switch device in the tree, referencing
a <code class="docutils literal notranslate"><span class="pre">dsa_switch_tree</span></code> as a backpointer, slave network devices, master network
device, and a reference to the backing``dsa_switch_ops``</li>
<li><code class="docutils literal notranslate"><span class="pre">dsa_switch_ops</span></code>: structure referencing function pointers, see below for a
full description.</li>
</ul>
</div>
</div>
<div class="section" id="design-limitations">
<h2>Design limitations<a class="headerlink" href="#design-limitations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="limits-on-the-number-of-devices-and-ports">
<h3>Limits on the number of devices and ports<a class="headerlink" href="#limits-on-the-number-of-devices-and-ports" title="Permalink to this headline">¶</a></h3>
<p>DSA currently limits the number of maximum switches within a tree to 4
(<code class="docutils literal notranslate"><span class="pre">DSA_MAX_SWITCHES</span></code>), and the number of ports per switch to 12 (<code class="docutils literal notranslate"><span class="pre">DSA_MAX_PORTS</span></code>).
These limits could be extended to support larger configurations would this need
arise.</p>
</div>
<div class="section" id="lack-of-cpu-dsa-network-devices">
<h3>Lack of CPU/DSA network devices<a class="headerlink" href="#lack-of-cpu-dsa-network-devices" title="Permalink to this headline">¶</a></h3>
<p>DSA does not currently create slave network devices for the CPU or DSA ports, as
described before. This might be an issue in the following cases:</p>
<ul class="simple">
<li>inability to fetch switch CPU port statistics counters using ethtool, which
can make it harder to debug MDIO switch connected using xMII interfaces</li>
<li>inability to configure the CPU port link parameters based on the Ethernet
controller capabilities attached to it: <a class="reference external" href="http://patchwork.ozlabs.org/patch/509806/">http://patchwork.ozlabs.org/patch/509806/</a></li>
<li>inability to configure specific VLAN IDs / trunking VLANs between switches
when using a cascaded setup</li>
</ul>
</div>
<div class="section" id="common-pitfalls-using-dsa-setups">
<h3>Common pitfalls using DSA setups<a class="headerlink" href="#common-pitfalls-using-dsa-setups" title="Permalink to this headline">¶</a></h3>
<p>Once a master network device is configured to use DSA (dev-&gt;dsa_ptr becomes
non-NULL), and the switch behind it expects a tagging protocol, this network
interface can only exclusively be used as a conduit interface. Sending packets
directly through this interface (e.g.: opening a socket using this interface)
will not make us go through the switch tagging protocol transmit function, so
the Ethernet switch on the other end, expecting a tag will typically drop this
frame.</p>
<p>Slave network devices check that the master network device is UP before allowing
you to administratively bring UP these slave network devices. A common
configuration mistake is forgetting to bring UP the master network device first.</p>
</div>
</div>
<div class="section" id="interactions-with-other-subsystems">
<h2>Interactions with other subsystems<a class="headerlink" href="#interactions-with-other-subsystems" title="Permalink to this headline">¶</a></h2>
<p>DSA currently leverages the following subsystems:</p>
<ul class="simple">
<li>MDIO/PHY library: <code class="docutils literal notranslate"><span class="pre">drivers/net/phy/phy.c</span></code>, <code class="docutils literal notranslate"><span class="pre">mdio_bus.c</span></code></li>
<li>Switchdev:<code class="docutils literal notranslate"><span class="pre">net/switchdev/*</span></code></li>
<li>Device Tree for various of_* functions</li>
</ul>
<div class="section" id="mdio-phy-library">
<h3>MDIO/PHY library<a class="headerlink" href="#mdio-phy-library" title="Permalink to this headline">¶</a></h3>
<p>Slave network devices exposed by DSA may or may not be interfacing with PHY
devices (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code> as defined in <code class="docutils literal notranslate"><span class="pre">include/linux/phy.h)</span></code>, but the DSA
subsystem deals with all possible combinations:</p>
<ul class="simple">
<li>internal PHY devices, built into the Ethernet switch hardware</li>
<li>external PHY devices, connected via an internal or external MDIO bus</li>
<li>internal PHY devices, connected via an internal MDIO bus</li>
<li>special, non-autonegotiated or non MDIO-managed PHY devices: SFPs, MoCA; a.k.a
fixed PHYs</li>
</ul>
<p>The PHY configuration is done by the <code class="docutils literal notranslate"><span class="pre">dsa_slave_phy_setup()</span></code> function and the
logic basically looks like this:</p>
<ul class="simple">
<li>if Device Tree is used, the PHY device is looked up using the standard
“phy-handle” property, if found, this PHY device is created and registered
using <code class="docutils literal notranslate"><span class="pre">of_phy_connect()</span></code></li>
<li>if Device Tree is used, and the PHY device is “fixed”, that is, conforms to
the definition of a non-MDIO managed PHY as defined in
<code class="docutils literal notranslate"><span class="pre">Documentation/devicetree/bindings/net/fixed-link.txt</span></code>, the PHY is registered
and connected transparently using the special fixed MDIO bus driver</li>
<li>finally, if the PHY is built into the switch, as is very common with
standalone switch packages, the PHY is probed using the slave MII bus created
by DSA</li>
</ul>
</div>
<div class="section" id="switchdev">
<h3>SWITCHDEV<a class="headerlink" href="#switchdev" title="Permalink to this headline">¶</a></h3>
<p>DSA directly utilizes SWITCHDEV when interfacing with the bridge layer, and
more specifically with its VLAN filtering portion when configuring VLANs on top
of per-port slave network devices. Since DSA primarily deals with
MDIO-connected switches, although not exclusively, SWITCHDEV’s
prepare/abort/commit phases are often simplified into a prepare phase which
checks whether the operation is supported by the DSA switch driver, and a commit
phase which applies the changes.</p>
<p>As of today, the only SWITCHDEV objects supported by DSA are the FDB and VLAN
objects.</p>
</div>
<div class="section" id="device-tree">
<h3>Device Tree<a class="headerlink" href="#device-tree" title="Permalink to this headline">¶</a></h3>
<p>DSA features a standardized binding which is documented in
<code class="docutils literal notranslate"><span class="pre">Documentation/devicetree/bindings/net/dsa/dsa.txt</span></code>. PHY/MDIO library helper
functions such as <code class="docutils literal notranslate"><span class="pre">of_get_phy_mode()</span></code>, <code class="docutils literal notranslate"><span class="pre">of_phy_connect()</span></code> are also used to query
per-port PHY specific details: interface connection, MDIO bus location etc..</p>
</div>
</div>
<div class="section" id="driver-development">
<h2>Driver development<a class="headerlink" href="#driver-development" title="Permalink to this headline">¶</a></h2>
<p>DSA switch drivers need to implement a dsa_switch_ops structure which will
contain the various members described below.</p>
<p><code class="docutils literal notranslate"><span class="pre">register_switch_driver()</span></code> registers this dsa_switch_ops in its internal list
of drivers to probe for. <code class="docutils literal notranslate"><span class="pre">unregister_switch_driver()</span></code> does the exact opposite.</p>
<p>Unless requested differently by setting the priv_size member accordingly, DSA
does not allocate any driver private context space.</p>
<div class="section" id="switch-configuration">
<h3>Switch configuration<a class="headerlink" href="#switch-configuration" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">tag_protocol</span></code>: this is to indicate what kind of tagging protocol is supported,
should be a valid value from the <code class="docutils literal notranslate"><span class="pre">dsa_tag_protocol</span></code> enum</li>
<li><code class="docutils literal notranslate"><span class="pre">probe</span></code>: probe routine which will be invoked by the DSA platform device upon
registration to test for the presence/absence of a switch device. For MDIO
devices, it is recommended to issue a read towards internal registers using
the switch pseudo-PHY and return whether this is a supported device. For other
buses, return a non-NULL string</li>
<li><code class="docutils literal notranslate"><span class="pre">setup</span></code>: setup function for the switch, this function is responsible for setting
up the <code class="docutils literal notranslate"><span class="pre">dsa_switch_ops</span></code> private structure with all it needs: register maps,
interrupts, mutexes, locks etc.. This function is also expected to properly
configure the switch to separate all network interfaces from each other, that
is, they should be isolated by the switch hardware itself, typically by creating
a Port-based VLAN ID for each port and allowing only the CPU port and the
specific port to be in the forwarding vector. Ports that are unused by the
platform should be disabled. Past this function, the switch is expected to be
fully configured and ready to serve any kind of request. It is recommended
to issue a software reset of the switch during this setup function in order to
avoid relying on what a previous software agent such as a bootloader/firmware
may have previously configured.</li>
</ul>
</div>
<div class="section" id="phy-devices-and-link-management">
<h3>PHY devices and link management<a class="headerlink" href="#phy-devices-and-link-management" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">get_phy_flags</span></code>: Some switches are interfaced to various kinds of Ethernet PHYs,
if the PHY library PHY driver needs to know about information it cannot obtain
on its own (e.g.: coming from switch memory mapped registers), this function
should return a 32-bits bitmask of “flags”, that is private between the switch
driver and the Ethernet PHY driver in <code class="docutils literal notranslate"><span class="pre">drivers/net/phy/\*</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">phy_read</span></code>: Function invoked by the DSA slave MDIO bus when attempting to read
the switch port MDIO registers. If unavailable, return 0xffff for each read.
For builtin switch Ethernet PHYs, this function should allow reading the link
status, auto-negotiation results, link partner pages etc..</li>
<li><code class="docutils literal notranslate"><span class="pre">phy_write</span></code>: Function invoked by the DSA slave MDIO bus when attempting to write
to the switch port MDIO registers. If unavailable return a negative error
code.</li>
<li><code class="docutils literal notranslate"><span class="pre">adjust_link</span></code>: Function invoked by the PHY library when a slave network device
is attached to a PHY device. This function is responsible for appropriately
configuring the switch port link parameters: speed, duplex, pause based on
what the <code class="docutils literal notranslate"><span class="pre">phy_device</span></code> is providing.</li>
<li><code class="docutils literal notranslate"><span class="pre">fixed_link_update</span></code>: Function invoked by the PHY library, and specifically by
the fixed PHY driver asking the switch driver for link parameters that could
not be auto-negotiated, or obtained by reading the PHY registers through MDIO.
This is particularly useful for specific kinds of hardware such as QSGMII,
MoCA or other kinds of non-MDIO managed PHYs where out of band link
information is obtained</li>
</ul>
</div>
<div class="section" id="ethtool-operations">
<h3>Ethtool operations<a class="headerlink" href="#ethtool-operations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">get_strings</span></code>: ethtool function used to query the driver’s strings, will
typically return statistics strings, private flags strings etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">get_ethtool_stats</span></code>: ethtool function used to query per-port statistics and
return their values. DSA overlays slave network devices general statistics:
RX/TX counters from the network device, with switch driver specific statistics
per port</li>
<li><code class="docutils literal notranslate"><span class="pre">get_sset_count</span></code>: ethtool function used to query the number of statistics items</li>
<li><code class="docutils literal notranslate"><span class="pre">get_wol</span></code>: ethtool function used to obtain Wake-on-LAN settings per-port, this
function may, for certain implementations also query the master network device
Wake-on-LAN settings if this interface needs to participate in Wake-on-LAN</li>
<li><code class="docutils literal notranslate"><span class="pre">set_wol</span></code>: ethtool function used to configure Wake-on-LAN settings per-port,
direct counterpart to set_wol with similar restrictions</li>
<li><code class="docutils literal notranslate"><span class="pre">set_eee</span></code>: ethtool function which is used to configure a switch port EEE (Green
Ethernet) settings, can optionally invoke the PHY library to enable EEE at the
PHY level if relevant. This function should enable EEE at the switch port MAC
controller and data-processing logic</li>
<li><code class="docutils literal notranslate"><span class="pre">get_eee</span></code>: ethtool function which is used to query a switch port EEE settings,
this function should return the EEE state of the switch port MAC controller
and data-processing logic as well as query the PHY for its currently configured
EEE settings</li>
<li><code class="docutils literal notranslate"><span class="pre">get_eeprom_len</span></code>: ethtool function returning for a given switch the EEPROM
length/size in bytes</li>
<li><code class="docutils literal notranslate"><span class="pre">get_eeprom</span></code>: ethtool function returning for a given switch the EEPROM contents</li>
<li><code class="docutils literal notranslate"><span class="pre">set_eeprom</span></code>: ethtool function writing specified data to a given switch EEPROM</li>
<li><code class="docutils literal notranslate"><span class="pre">get_regs_len</span></code>: ethtool function returning the register length for a given
switch</li>
<li><code class="docutils literal notranslate"><span class="pre">get_regs</span></code>: ethtool function returning the Ethernet switch internal register
contents. This function might require user-land code in ethtool to
pretty-print register values and registers</li>
</ul>
</div>
<div class="section" id="power-management">
<h3>Power management<a class="headerlink" href="#power-management" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">suspend</span></code>: function invoked by the DSA platform device when the system goes to
suspend, should quiesce all Ethernet switch activities, but keep ports
participating in Wake-on-LAN active as well as additional wake-up logic if
supported</li>
<li><code class="docutils literal notranslate"><span class="pre">resume</span></code>: function invoked by the DSA platform device when the system resumes,
should resume all Ethernet switch activities and re-configure the switch to be
in a fully active state</li>
<li><code class="docutils literal notranslate"><span class="pre">port_enable</span></code>: function invoked by the DSA slave network device ndo_open
function when a port is administratively brought up, this function should be
fully enabling a given switch port. DSA takes care of marking the port with
<code class="docutils literal notranslate"><span class="pre">BR_STATE_BLOCKING</span></code> if the port is a bridge member, or <code class="docutils literal notranslate"><span class="pre">BR_STATE_FORWARDING</span></code> if it
was not, and propagating these changes down to the hardware</li>
<li><code class="docutils literal notranslate"><span class="pre">port_disable</span></code>: function invoked by the DSA slave network device ndo_close
function when a port is administratively brought down, this function should be
fully disabling a given switch port. DSA takes care of marking the port with
<code class="docutils literal notranslate"><span class="pre">BR_STATE_DISABLED</span></code> and propagating changes to the hardware if this port is
disabled while being a bridge member</li>
</ul>
</div>
<div class="section" id="bridge-layer">
<h3>Bridge layer<a class="headerlink" href="#bridge-layer" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">port_bridge_join</span></code>: bridge layer function invoked when a given switch port is
added to a bridge, this function should be doing the necessary at the switch
level to permit the joining port from being added to the relevant logical
domain for it to ingress/egress traffic with other members of the bridge.</li>
<li><code class="docutils literal notranslate"><span class="pre">port_bridge_leave</span></code>: bridge layer function invoked when a given switch port is
removed from a bridge, this function should be doing the necessary at the
switch level to deny the leaving port from ingress/egress traffic from the
remaining bridge members. When the port leaves the bridge, it should be aged
out at the switch hardware for the switch to (re) learn MAC addresses behind
this port.</li>
<li><code class="docutils literal notranslate"><span class="pre">port_stp_state_set</span></code>: bridge layer function invoked when a given switch port STP
state is computed by the bridge layer and should be propagated to switch
hardware to forward/block/learn traffic. The switch driver is responsible for
computing a STP state change based on current and asked parameters and perform
the relevant ageing based on the intersection results</li>
</ul>
</div>
<div class="section" id="bridge-vlan-filtering">
<h3>Bridge VLAN filtering<a class="headerlink" href="#bridge-vlan-filtering" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">port_vlan_filtering</span></code>: bridge layer function invoked when the bridge gets
configured for turning on or off VLAN filtering. If nothing specific needs to
be done at the hardware level, this callback does not need to be implemented.
When VLAN filtering is turned on, the hardware must be programmed with
rejecting 802.1Q frames which have VLAN IDs outside of the programmed allowed
VLAN ID map/rules.  If there is no PVID programmed into the switch port,
untagged frames must be rejected as well. When turned off the switch must
accept any 802.1Q frames irrespective of their VLAN ID, and untagged frames are
allowed.</li>
<li><code class="docutils literal notranslate"><span class="pre">port_vlan_prepare</span></code>: bridge layer function invoked when the bridge prepares the
configuration of a VLAN on the given port. If the operation is not supported
by the hardware, this function should return <code class="docutils literal notranslate"><span class="pre">-EOPNOTSUPP</span></code> to inform the bridge
code to fallback to a software implementation. No hardware setup must be done
in this function. See port_vlan_add for this and details.</li>
<li><code class="docutils literal notranslate"><span class="pre">port_vlan_add</span></code>: bridge layer function invoked when a VLAN is configured
(tagged or untagged) for the given switch port</li>
<li><code class="docutils literal notranslate"><span class="pre">port_vlan_del</span></code>: bridge layer function invoked when a VLAN is removed from the
given switch port</li>
<li><code class="docutils literal notranslate"><span class="pre">port_vlan_dump</span></code>: bridge layer function invoked with a switchdev callback
function that the driver has to call for each VLAN the given port is a member
of. A switchdev object is used to carry the VID and bridge flags.</li>
<li><code class="docutils literal notranslate"><span class="pre">port_fdb_add</span></code>: bridge layer function invoked when the bridge wants to install a
Forwarding Database entry, the switch hardware should be programmed with the
specified address in the specified VLAN Id in the forwarding database
associated with this VLAN ID. If the operation is not supported, this
function should return <code class="docutils literal notranslate"><span class="pre">-EOPNOTSUPP</span></code> to inform the bridge code to fallback to
a software implementation.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">VLAN ID 0 corresponds to the port private database, which, in the context
of DSA, would be its port-based VLAN, used by the associated bridge device.</p>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">port_fdb_del</span></code>: bridge layer function invoked when the bridge wants to remove a
Forwarding Database entry, the switch hardware should be programmed to delete
the specified MAC address from the specified VLAN ID if it was mapped into
this port forwarding database</li>
<li><code class="docutils literal notranslate"><span class="pre">port_fdb_dump</span></code>: bridge layer function invoked with a switchdev callback
function that the driver has to call for each MAC address known to be behind
the given port. A switchdev object is used to carry the VID and FDB info.</li>
<li><code class="docutils literal notranslate"><span class="pre">port_mdb_prepare</span></code>: bridge layer function invoked when the bridge prepares the
installation of a multicast database entry. If the operation is not supported,
this function should return <code class="docutils literal notranslate"><span class="pre">-EOPNOTSUPP</span></code> to inform the bridge code to fallback
to a software implementation. No hardware setup must be done in this function.
See <code class="docutils literal notranslate"><span class="pre">port_fdb_add</span></code> for this and details.</li>
<li><code class="docutils literal notranslate"><span class="pre">port_mdb_add</span></code>: bridge layer function invoked when the bridge wants to install
a multicast database entry, the switch hardware should be programmed with the
specified address in the specified VLAN ID in the forwarding database
associated with this VLAN ID.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">VLAN ID 0 corresponds to the port private database, which, in the context
of DSA, would be its port-based VLAN, used by the associated bridge device.</p>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">port_mdb_del</span></code>: bridge layer function invoked when the bridge wants to remove a
multicast database entry, the switch hardware should be programmed to delete
the specified MAC address from the specified VLAN ID if it was mapped into
this port forwarding database.</li>
<li><code class="docutils literal notranslate"><span class="pre">port_mdb_dump</span></code>: bridge layer function invoked with a switchdev callback
function that the driver has to call for each MAC address known to be behind
the given port. A switchdev object is used to carry the VID and MDB info.</li>
</ul>
</div>
</div>
<div class="section" id="todo">
<h2>TODO<a class="headerlink" href="#todo" title="Permalink to this headline">¶</a></h2>
<div class="section" id="making-switchdev-and-dsa-converge-towards-an-unified-codebase">
<h3>Making SWITCHDEV and DSA converge towards an unified codebase<a class="headerlink" href="#making-switchdev-and-dsa-converge-towards-an-unified-codebase" title="Permalink to this headline">¶</a></h3>
<p>SWITCHDEV properly takes care of abstracting the networking stack with offload
capable hardware, but does not enforce a strict switch device driver model. On
the other DSA enforces a fairly strict device driver model, and deals with most
of the switch specific. At some point we should envision a merger between these
two subsystems and get the best of both worlds.</p>
</div>
<div class="section" id="other-hanging-fruits">
<h3>Other hanging fruits<a class="headerlink" href="#other-hanging-fruits" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>making the number of ports fully dynamic and not dependent on <code class="docutils literal notranslate"><span class="pre">DSA_MAX_PORTS</span></code></li>
<li>allowing more than one CPU/management interface:
<a class="reference external" href="http://comments.gmane.org/gmane.linux.network/365657">http://comments.gmane.org/gmane.linux.network/365657</a></li>
<li>porting more drivers from other vendors:
<a class="reference external" href="http://comments.gmane.org/gmane.linux.network/365510">http://comments.gmane.org/gmane.linux.network/365510</a></li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>