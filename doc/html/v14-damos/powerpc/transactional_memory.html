

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Transactional Memory support &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Transactional Memory support</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/powerpc/transactional_memory.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="transactional-memory-support">
<h1>Transactional Memory support<a class="headerlink" href="#transactional-memory-support" title="Permalink to this headline">¶</a></h1>
<p>POWER kernel support for this feature is currently limited to supporting
its use by user programs.  It is not currently used by the kernel itself.</p>
<p>This file aims to sum up how it is supported by Linux and what behaviour you
can expect from your user programs.</p>
<div class="section" id="basic-overview">
<h2>Basic overview<a class="headerlink" href="#basic-overview" title="Permalink to this headline">¶</a></h2>
<p>Hardware Transactional Memory is supported on POWER8 processors, and is a
feature that enables a different form of atomic memory access.  Several new
instructions are presented to delimit transactions; transactions are
guaranteed to either complete atomically or roll back and undo any partial
changes.</p>
<p>A simple transaction looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>begin_move_money:
  tbegin
  beq   abort_handler

  ld    r4, SAVINGS_ACCT(r3)
  ld    r5, CURRENT_ACCT(r3)
  subi  r5, r5, 1
  addi  r4, r4, 1
  std   r4, SAVINGS_ACCT(r3)
  std   r5, CURRENT_ACCT(r3)

  tend

  b     continue

abort_handler:
  ... test for odd failures ...

  /* Retry the transaction if it failed because it conflicted with
   * someone else: */
  b     begin_move_money
</pre></div>
</div>
<p>The ‘tbegin’ instruction denotes the start point, and ‘tend’ the end point.
Between these points the processor is in ‘Transactional’ state; any memory
references will complete in one go if there are no conflicts with other
transactional or non-transactional accesses within the system.  In this
example, the transaction completes as though it were normal straight-line code
IF no other processor has touched SAVINGS_ACCT(r3) or CURRENT_ACCT(r3); an
atomic move of money from the current account to the savings account has been
performed.  Even though the normal ld/std instructions are used (note no
lwarx/stwcx), either <em>both</em> SAVINGS_ACCT(r3) and CURRENT_ACCT(r3) will be
updated, or neither will be updated.</p>
<p>If, in the meantime, there is a conflict with the locations accessed by the
transaction, the transaction will be aborted by the CPU.  Register and memory
state will roll back to that at the ‘tbegin’, and control will continue from
‘tbegin+4’.  The branch to abort_handler will be taken this second time; the
abort handler can check the cause of the failure, and retry.</p>
<p>Checkpointed registers include all GPRs, FPRs, VRs/VSRs, LR, CCR/CR, CTR, FPCSR
and a few other status/flag regs; see the ISA for details.</p>
</div>
<div class="section" id="causes-of-transaction-aborts">
<h2>Causes of transaction aborts<a class="headerlink" href="#causes-of-transaction-aborts" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Conflicts with cache lines used by other processors</li>
<li>Signals</li>
<li>Context switches</li>
<li>See the ISA for full documentation of everything that will abort transactions.</li>
</ul>
</div>
<div class="section" id="syscalls">
<h2>Syscalls<a class="headerlink" href="#syscalls" title="Permalink to this headline">¶</a></h2>
<p>Syscalls made from within an active transaction will not be performed and the
transaction will be doomed by the kernel with the failure code TM_CAUSE_SYSCALL
| TM_CAUSE_PERSISTENT.</p>
<p>Syscalls made from within a suspended transaction are performed as normal and
the transaction is not explicitly doomed by the kernel.  However, what the
kernel does to perform the syscall may result in the transaction being doomed
by the hardware.  The syscall is performed in suspended mode so any side
effects will be persistent, independent of transaction success or failure.  No
guarantees are provided by the kernel about which syscalls will affect
transaction success.</p>
<p>Care must be taken when relying on syscalls to abort during active transactions
if the calls are made via a library.  Libraries may cache values (which may
give the appearance of success) or perform operations that cause transaction
failure before entering the kernel (which may produce different failure codes).
Examples are glibc’s getpid() and lazy symbol resolution.</p>
</div>
<div class="section" id="signals">
<h2>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h2>
<p>Delivery of signals (both sync and async) during transactions provides a second
thread state (ucontext/mcontext) to represent the second transactional register
state.  Signal delivery ‘treclaim’s to capture both register states, so signals
abort transactions.  The usual ucontext_t passed to the signal handler
represents the checkpointed/original register state; the signal appears to have
arisen at ‘tbegin+4’.</p>
<p>If the sighandler ucontext has uc_link set, a second ucontext has been
delivered.  For future compatibility the MSR.TS field should be checked to
determine the transactional state – if so, the second ucontext in uc-&gt;uc_link
represents the active transactional registers at the point of the signal.</p>
<p>For 64-bit processes, uc-&gt;uc_mcontext.regs-&gt;msr is a full 64-bit MSR and its TS
field shows the transactional mode.</p>
<p>For 32-bit processes, the mcontext’s MSR register is only 32 bits; the top 32
bits are stored in the MSR of the second ucontext, i.e. in
uc-&gt;uc_link-&gt;uc_mcontext.regs-&gt;msr.  The top word contains the transactional
state TS.</p>
<p>However, basic signal handlers don’t need to be aware of transactions
and simply returning from the handler will deal with things correctly:</p>
<p>Transaction-aware signal handlers can read the transactional register state
from the second ucontext.  This will be necessary for crash handlers to
determine, for example, the address of the instruction causing the SIGSEGV.</p>
<p>Example signal handler:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  void crash_handler(int sig, siginfo_t *si, void *uc)
  {
    ucontext_t *ucp = uc;
    ucontext_t *transactional_ucp = ucp-&gt;uc_link;

    if (ucp_link) {
      u64 msr = ucp-&gt;uc_mcontext.regs-&gt;msr;
      /* May have transactional ucontext! */
#ifndef __powerpc64__
      msr |= ((u64)transactional_ucp-&gt;uc_mcontext.regs-&gt;msr) &lt;&lt; 32;
#endif
      if (MSR_TM_ACTIVE(msr)) {
         /* Yes, we crashed during a transaction.  Oops. */
 fprintf(stderr, &quot;Transaction to be restarted at 0x%llx, but &quot;
                         &quot;crashy instruction was at 0x%llx\n&quot;,
                         ucp-&gt;uc_mcontext.regs-&gt;nip,
                         transactional_ucp-&gt;uc_mcontext.regs-&gt;nip);
      }
    }

    fix_the_problem(ucp-&gt;dar);
  }
</pre></div>
</div>
<p>When in an active transaction that takes a signal, we need to be careful with
the stack.  It’s possible that the stack has moved back up after the tbegin.
The obvious case here is when the tbegin is called inside a function that
returns before a tend.  In this case, the stack is part of the checkpointed
transactional memory state.  If we write over this non transactionally or in
suspend, we are in trouble because if we get a tm abort, the program counter and
stack pointer will be back at the tbegin but our in memory stack won’t be valid
anymore.</p>
<p>To avoid this, when taking a signal in an active transaction, we need to use
the stack pointer from the checkpointed state, rather than the speculated
state.  This ensures that the signal context (written tm suspended) will be
written below the stack required for the rollback.  The transaction is aborted
because of the treclaim, so any memory written between the tbegin and the
signal will be rolled back anyway.</p>
<p>For signals taken in non-TM or suspended mode, we use the
normal/non-checkpointed stack pointer.</p>
<p>Any transaction initiated inside a sighandler and suspended on return
from the sighandler to the kernel will get reclaimed and discarded.</p>
</div>
<div class="section" id="failure-cause-codes-used-by-kernel">
<h2>Failure cause codes used by kernel<a class="headerlink" href="#failure-cause-codes-used-by-kernel" title="Permalink to this headline">¶</a></h2>
<p>These are defined in &lt;asm/reg.h&gt;, and distinguish different reasons why the
kernel aborted a transaction:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>TM_CAUSE_RESCHED</td>
<td>Thread was rescheduled.</td>
</tr>
<tr class="row-even"><td>TM_CAUSE_TLBI</td>
<td>Software TLB invalid.</td>
</tr>
<tr class="row-odd"><td>TM_CAUSE_FAC_UNAV</td>
<td>FP/VEC/VSX unavailable trap.</td>
</tr>
<tr class="row-even"><td>TM_CAUSE_SYSCALL</td>
<td>Syscall from active transaction.</td>
</tr>
<tr class="row-odd"><td>TM_CAUSE_SIGNAL</td>
<td>Signal delivered.</td>
</tr>
<tr class="row-even"><td>TM_CAUSE_MISC</td>
<td>Currently unused.</td>
</tr>
<tr class="row-odd"><td>TM_CAUSE_ALIGNMENT</td>
<td>Alignment fault.</td>
</tr>
<tr class="row-even"><td>TM_CAUSE_EMULATE</td>
<td>Emulation that touched memory.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>These can be checked by the user program’s abort handler as TEXASR[0:7].  If
bit 7 is set, it indicates that the error is consider persistent.  For example
a TM_CAUSE_ALIGNMENT will be persistent while a TM_CAUSE_RESCHED will not.</p>
</div>
<div class="section" id="gdb">
<h2>GDB<a class="headerlink" href="#gdb" title="Permalink to this headline">¶</a></h2>
<p>GDB and ptrace are not currently TM-aware.  If one stops during a transaction,
it looks like the transaction has just started (the checkpointed state is
presented).  The transaction cannot then be continued and will take the failure
handler route.  Furthermore, the transactional 2nd register state will be
inaccessible.  GDB can currently be used on programs using TM, but not sensibly
in parts within transactions.</p>
</div>
<div class="section" id="power9">
<h2>POWER9<a class="headerlink" href="#power9" title="Permalink to this headline">¶</a></h2>
<p>TM on POWER9 has issues with storing the complete register state. This
is described in this commit:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>commit 4bb3c7a0208fc13ca70598efd109901a7cd45ae7
Author: Paul Mackerras &lt;paulus@ozlabs.org&gt;
Date:   Wed Mar 21 21:32:01 2018 +1100
KVM: PPC: Book3S HV: Work around transactional memory bugs in POWER9
</pre></div>
</div>
<p>To account for this different POWER9 chips have TM enabled in
different ways.</p>
<p>On POWER9N DD2.01 and below, TM is disabled. ie
HWCAP2[PPC_FEATURE2_HTM] is not set.</p>
<p>On POWER9N DD2.1 TM is configured by firmware to always abort a
transaction when tm suspend occurs. So tsuspend will cause a
transaction to be aborted and rolled back. Kernel exceptions will also
cause the transaction to be aborted and rolled back and the exception
will not occur. If userspace constructs a sigcontext that enables TM
suspend, the sigcontext will be rejected by the kernel. This mode is
advertised to users with HWCAP2[PPC_FEATURE2_HTM_NO_SUSPEND] set.
HWCAP2[PPC_FEATURE2_HTM] is not set in this mode.</p>
<p>On POWER9N DD2.2 and above, KVM and POWERVM emulate TM for guests (as
described in commit 4bb3c7a0208f), hence TM is enabled for guests
ie. HWCAP2[PPC_FEATURE2_HTM] is set for guest userspace. Guests that
makes heavy use of TM suspend (tsuspend or kernel suspend) will result
in traps into the hypervisor and hence will suffer a performance
degradation. Host userspace has TM disabled
ie. HWCAP2[PPC_FEATURE2_HTM] is not set. (although we make enable it
at some point in the future if we bring the emulation into host
userspace context switching).</p>
<p>POWER9C DD1.2 and above are only available with POWERVM and hence
Linux only runs as a guest. On these systems TM is emulated like on
POWER9N DD2.2.</p>
<p>Guest migration from POWER8 to POWER9 will work with POWER9N DD2.2 and
POWER9C DD1.2. Since earlier POWER9 processors don’t support TM
emulation, migration from POWER8 to POWER9 is not supported there.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>