

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>rfkill - RF kill switch support &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>rfkill - RF kill switch support</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/rfkill.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="rfkill-rf-kill-switch-support">
<h1><a class="toc-backref" href="#id1">rfkill - RF kill switch support</a><a class="headerlink" href="#rfkill-rf-kill-switch-support" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rfkill-rf-kill-switch-support" id="id1">rfkill - RF kill switch support</a><ul>
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#implementation-details" id="id3">Implementation details</a></li>
<li><a class="reference internal" href="#kernel-api" id="id4">Kernel API</a></li>
<li><a class="reference internal" href="#userspace-support" id="id5">Userspace support</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The rfkill subsystem provides a generic interface for disabling any radio
transmitter in the system. When a transmitter is blocked, it shall not
radiate any power.</p>
<p>The subsystem also provides the ability to react on button presses and
disable all transmitters of a certain type (or all). This is intended for
situations where transmitters need to be turned off, for example on
aircraft.</p>
<p>The rfkill subsystem has a concept of “hard” and “soft” block, which
differ little in their meaning (block == transmitters off) but rather in
whether they can be changed or not:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>hard block</dt>
<dd>read-only radio block that cannot be overridden by software</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>soft block</dt>
<dd>writable radio block (need not be readable) that is set by
the system software.</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The rfkill subsystem has two parameters, rfkill.default_state and
rfkill.master_switch_mode, which are documented in
admin-guide/kernel-parameters.rst.</p>
</div>
<div class="section" id="implementation-details">
<h2><a class="toc-backref" href="#id3">Implementation details</a><a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>The rfkill subsystem is composed of three main components:</p>
<blockquote>
<div><ul class="simple">
<li>the rfkill core,</li>
<li>the deprecated rfkill-input module (an input layer handler, being
replaced by userspace policy code) and</li>
<li>the rfkill drivers.</li>
</ul>
</div></blockquote>
<p>The rfkill core provides API for kernel drivers to register their radio
transmitter with the kernel, methods for turning it on and off, and letting
the system know about hardware-disabled states that may be implemented on
the device.</p>
<p>The rfkill core code also notifies userspace of state changes, and provides
ways for userspace to query the current states. See the “Userspace support”
section below.</p>
<p>When the device is hard-blocked (either by a call to rfkill_set_hw_state()
or from query_hw_block), set_block() will be invoked for additional software
block, but drivers can ignore the method call since they can use the return
value of the function rfkill_set_hw_state() to sync the software state
instead of keeping track of calls to set_block(). In fact, drivers should
use the return value of rfkill_set_hw_state() unless the hardware actually
keeps track of soft and hard block separately.</p>
</div>
<div class="section" id="kernel-api">
<h2><a class="toc-backref" href="#id4">Kernel API</a><a class="headerlink" href="#kernel-api" title="Permalink to this headline">¶</a></h2>
<p>Drivers for radio transmitters normally implement an rfkill driver.</p>
<p>Platform drivers might implement input devices if the rfkill button is just
that, a button. If that button influences the hardware then you need to
implement an rfkill driver instead. This also applies if the platform provides
a way to turn on/off the transmitter(s).</p>
<p>For some platforms, it is possible that the hardware state changes during
suspend/hibernation, in which case it will be necessary to update the rfkill
core with the current state at resume time.</p>
<p>To create an rfkill driver, driver’s Kconfig needs to have:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>depends on RFKILL || !RFKILL
</pre></div>
</div>
<p>to ensure the driver cannot be built-in when rfkill is modular. The !RFKILL
case allows the driver to be built when rfkill is not configured, in which
case all rfkill API can still be used but will be provided by static inlines
which compile to almost nothing.</p>
<p>Calling rfkill_set_hw_state() when a state change happens is required from
rfkill drivers that control devices that can be hard-blocked unless they also
assign the poll_hw_block() callback (then the rfkill core will poll the
device). Don’t do this unless you cannot get the event in any other way.</p>
<p>rfkill provides per-switch LED triggers, which can be used to drive LEDs
according to the switch state (LED_FULL when blocked, LED_OFF otherwise).</p>
</div>
<div class="section" id="userspace-support">
<h2><a class="toc-backref" href="#id5">Userspace support</a><a class="headerlink" href="#userspace-support" title="Permalink to this headline">¶</a></h2>
<p>The recommended userspace interface to use is /dev/rfkill, which is a misc
character device that allows userspace to obtain and set the state of rfkill
devices and sets of devices. It also notifies userspace about device addition
and removal. The API is a simple read/write API that is defined in
linux/rfkill.h, with one ioctl that allows turning off the deprecated input
handler in the kernel for the transition period.</p>
<p>Except for the one ioctl, communication with the kernel is done via read()
and write() of instances of ‘struct rfkill_event’. In this structure, the
soft and hard block are properly separated (unlike sysfs, see below) and
userspace is able to get a consistent snapshot of all rfkill devices in the
system. Also, it is possible to switch all rfkill drivers (or all drivers of
a specified type) into a state which also updates the default state for
hotplugged devices.</p>
<p>After an application opens /dev/rfkill, it can read the current state of all
devices. Changes can be obtained by either polling the descriptor for
hotplug or state change events or by listening for uevents emitted by the
rfkill core framework.</p>
<p>Additionally, each rfkill device is registered in sysfs and emits uevents.</p>
<p>rfkill devices issue uevents (with an action of “change”), with the following
environment variables set:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RFKILL_NAME
RFKILL_STATE
RFKILL_TYPE
</pre></div>
</div>
<p>The content of these variables corresponds to the “name”, “state” and
“type” sysfs files explained above.</p>
<p>For further details consult Documentation/ABI/stable/sysfs-class-rfkill.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>