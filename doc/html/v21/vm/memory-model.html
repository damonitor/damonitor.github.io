

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Physical Memory Model &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="When do you need to notify inside page table lock ?" href="mmu_notifier.html" />
    <link rel="prev" title="Kernel Samepage Merging" href="ksm.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Device Tree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Memory Management Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#user-guides-for-mm-features">User guides for MM features</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#kernel-developers-mm-documentation">Kernel developers MM documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="active_mm.html">Active MM</a></li>
<li class="toctree-l3"><a class="reference internal" href="balance.html">Memory Balancing</a></li>
<li class="toctree-l3"><a class="reference internal" href="cleancache.html">Cleancache</a></li>
<li class="toctree-l3"><a class="reference internal" href="free_page_reporting.html">Free Page Reporting</a></li>
<li class="toctree-l3"><a class="reference internal" href="frontswap.html">Frontswap</a></li>
<li class="toctree-l3"><a class="reference internal" href="highmem.html">High Memory Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="hmm.html">Heterogeneous Memory Management (HMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hwpoison.html">hwpoison</a></li>
<li class="toctree-l3"><a class="reference internal" href="hugetlbfs_reserv.html">Hugetlbfs Reservation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ksm.html">Kernel Samepage Merging</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Physical Memory Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#flatmem">FLATMEM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#discontigmem">DISCONTIGMEM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsemem">SPARSEMEM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zone-device">ZONE_DEVICE</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mmu_notifier.html">When do you need to notify inside page table lock ?</a></li>
<li class="toctree-l3"><a class="reference internal" href="numa.html">What is NUMA?</a></li>
<li class="toctree-l3"><a class="reference internal" href="overcommit-accounting.html">Overcommit Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_migration.html">Page migration</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_frags.html">Page fragments</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_owner.html">page owner: Tracking about who allocated each page</a></li>
<li class="toctree-l3"><a class="reference internal" href="remap_file_pages.html">remap_file_pages() system call</a></li>
<li class="toctree-l3"><a class="reference internal" href="slub.html">Short users guide for SLUB</a></li>
<li class="toctree-l3"><a class="reference internal" href="split_page_table_lock.html">Split page table lock</a></li>
<li class="toctree-l3"><a class="reference internal" href="transhuge.html">Transparent Hugepage Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="unevictable-lru.html">Unevictable LRU Infrastructure</a></li>
<li class="toctree-l3"><a class="reference internal" href="z3fold.html">z3fold</a></li>
<li class="toctree-l3"><a class="reference internal" href="zsmalloc.html">zsmalloc</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nios2/nios2.html">Linux on the Nios II architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Data Structures and Algorithms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Linux Memory Management Documentation</a> &raquo;</li>
        
      <li>Physical Memory Model</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/vm/memory-model.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="physical-memory-model">
<span id="id1"></span><h1>Physical Memory Model<a class="headerlink" href="#physical-memory-model" title="Permalink to this headline">¶</a></h1>
<p>Physical memory in a system may be addressed in different ways. The
simplest case is when the physical memory starts at address 0 and
spans a contiguous range up to the maximal address. It could be,
however, that this range contains small holes that are not accessible
for the CPU. Then there could be several contiguous ranges at
completely distinct addresses. And, don’t forget about NUMA, where
different memory banks are attached to different CPUs.</p>
<p>Linux abstracts this diversity using one of the three memory models:
FLATMEM, DISCONTIGMEM and SPARSEMEM. Each architecture defines what
memory models it supports, what the default memory model is and
whether it is possible to manually override that default.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>At time of this writing, DISCONTIGMEM is considered deprecated,
although it is still in use by several architectures.</p>
</div>
<p>All the memory models track the status of physical page frames using
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> arranged in one or more arrays.</p>
<p>Regardless of the selected memory model, there exists one-to-one
mapping between the physical page frame number (PFN) and the
corresponding <cite>struct page</cite>.</p>
<p>Each memory model defines <code class="xref c c-func docutils literal notranslate"><span class="pre">pfn_to_page()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">page_to_pfn()</span></code>
helpers that allow the conversion from PFN to <cite>struct page</cite> and vice
versa.</p>
<div class="section" id="flatmem">
<h2>FLATMEM<a class="headerlink" href="#flatmem" title="Permalink to this headline">¶</a></h2>
<p>The simplest memory model is FLATMEM. This model is suitable for
non-NUMA systems with contiguous, or mostly contiguous, physical
memory.</p>
<p>In the FLATMEM memory model, there is a global <cite>mem_map</cite> array that
maps the entire physical memory. For most architectures, the holes
have entries in the <cite>mem_map</cite> array. The <cite>struct page</cite> objects
corresponding to the holes are never fully initialized.</p>
<p>To allocate the <cite>mem_map</cite> array, architecture specific setup code should
call <a class="reference internal" href="../core-api/mm-api.html#c.free_area_init" title="free_area_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_area_init()</span></code></a> function. Yet, the mappings array is not
usable until the call to <a class="reference internal" href="../core-api/boot-time-mm.html#c.memblock_free_all" title="memblock_free_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">memblock_free_all()</span></code></a> that hands all the
memory to the page allocator.</p>
<p>If an architecture enables <cite>CONFIG_ARCH_HAS_HOLES_MEMORYMODEL</cite> option,
it may free parts of the <cite>mem_map</cite> array that do not cover the
actual physical pages. In such case, the architecture specific
<code class="xref c c-func docutils literal notranslate"><span class="pre">pfn_valid()</span></code> implementation should take the holes in the
<cite>mem_map</cite> into account.</p>
<p>With FLATMEM, the conversion between a PFN and the <cite>struct page</cite> is
straightforward: <cite>PFN - ARCH_PFN_OFFSET</cite> is an index to the
<cite>mem_map</cite> array.</p>
<p>The <cite>ARCH_PFN_OFFSET</cite> defines the first page frame number for
systems with physical memory starting at address different from 0.</p>
</div>
<div class="section" id="discontigmem">
<h2>DISCONTIGMEM<a class="headerlink" href="#discontigmem" title="Permalink to this headline">¶</a></h2>
<p>The DISCONTIGMEM model treats the physical memory as a collection of
<cite>nodes</cite> similarly to how Linux NUMA support does. For each node Linux
constructs an independent memory management subsystem represented by
<cite>struct pglist_data</cite> (or <cite>pg_data_t</cite> for short). Among other
things, <cite>pg_data_t</cite> holds the <cite>node_mem_map</cite> array that maps
physical pages belonging to that node. The <cite>node_start_pfn</cite> field of
<cite>pg_data_t</cite> is the number of the first page frame belonging to that
node.</p>
<p>The architecture setup code should call <code class="xref c c-func docutils literal notranslate"><span class="pre">free_area_init_node()</span></code> for
each node in the system to initialize the <cite>pg_data_t</cite> object and its
<cite>node_mem_map</cite>.</p>
<p>Every <cite>node_mem_map</cite> behaves exactly as FLATMEM’s <cite>mem_map</cite> -
every physical page frame in a node has a <cite>struct page</cite> entry in the
<cite>node_mem_map</cite> array. When DISCONTIGMEM is enabled, a portion of the
<cite>flags</cite> field of the <cite>struct page</cite> encodes the node number of the
node hosting that page.</p>
<p>The conversion between a PFN and the <cite>struct page</cite> in the
DISCONTIGMEM model became slightly more complex as it has to determine
which node hosts the physical page and which <cite>pg_data_t</cite> object
holds the <cite>struct page</cite>.</p>
<p>Architectures that support DISCONTIGMEM provide <code class="xref c c-func docutils literal notranslate"><span class="pre">pfn_to_nid()</span></code>
to convert PFN to the node number. The opposite conversion helper
<code class="xref c c-func docutils literal notranslate"><span class="pre">page_to_nid()</span></code> is generic as it uses the node number encoded in
page-&gt;flags.</p>
<p>Once the node number is known, the PFN can be used to index
appropriate <cite>node_mem_map</cite> array to access the <cite>struct page</cite> and
the offset of the <cite>struct page</cite> from the <cite>node_mem_map</cite> plus
<cite>node_start_pfn</cite> is the PFN of that page.</p>
</div>
<div class="section" id="sparsemem">
<h2>SPARSEMEM<a class="headerlink" href="#sparsemem" title="Permalink to this headline">¶</a></h2>
<p>SPARSEMEM is the most versatile memory model available in Linux and it
is the only memory model that supports several advanced features such
as hot-plug and hot-remove of the physical memory, alternative memory
maps for non-volatile memory devices and deferred initialization of
the memory map for larger systems.</p>
<p>The SPARSEMEM model presents the physical memory as a collection of
sections. A section is represented with <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_section</span></code>
that contains <cite>section_mem_map</cite> that is, logically, a pointer to an
array of struct pages. However, it is stored with some other magic
that aids the sections management. The section size and maximal number
of section is specified using <cite>SECTION_SIZE_BITS</cite> and
<cite>MAX_PHYSMEM_BITS</cite> constants defined by each architecture that
supports SPARSEMEM. While <cite>MAX_PHYSMEM_BITS</cite> is an actual width of a
physical address that an architecture supports, the
<cite>SECTION_SIZE_BITS</cite> is an arbitrary value.</p>
<p>The maximal number of sections is denoted <cite>NR_MEM_SECTIONS</cite> and
defined as</p>
<div class="math">
<p><img src="../_images/math/d99368220bfdedf1a888b1c09eb7236a8c87d079.png" alt="NR\_MEM\_SECTIONS = 2 ^ {(MAX\_PHYSMEM\_BITS - SECTION\_SIZE\_BITS)}"/></p>
</div><p>The <cite>mem_section</cite> objects are arranged in a two-dimensional array
called <cite>mem_sections</cite>. The size and placement of this array depend
on <cite>CONFIG_SPARSEMEM_EXTREME</cite> and the maximal possible number of
sections:</p>
<ul class="simple">
<li><p>When <cite>CONFIG_SPARSEMEM_EXTREME</cite> is disabled, the <cite>mem_sections</cite>
array is static and has <cite>NR_MEM_SECTIONS</cite> rows. Each row holds a
single <cite>mem_section</cite> object.</p></li>
<li><p>When <cite>CONFIG_SPARSEMEM_EXTREME</cite> is enabled, the <cite>mem_sections</cite>
array is dynamically allocated. Each row contains PAGE_SIZE worth of
<cite>mem_section</cite> objects and the number of rows is calculated to fit
all the memory sections.</p></li>
</ul>
<p>The architecture setup code should call <code class="xref c c-func docutils literal notranslate"><span class="pre">memory_present()</span></code> for
each active memory range or use <code class="xref c c-func docutils literal notranslate"><span class="pre">memblocks_present()</span></code> or
<a class="reference internal" href="../core-api/mm-api.html#c.sparse_memory_present_with_active_regions" title="sparse_memory_present_with_active_regions"><code class="xref c c-func docutils literal notranslate"><span class="pre">sparse_memory_present_with_active_regions()</span></code></a> wrappers to
initialize the memory sections. Next, the actual memory maps should be
set up using <code class="xref c c-func docutils literal notranslate"><span class="pre">sparse_init()</span></code>.</p>
<p>With SPARSEMEM there are two possible ways to convert a PFN to the
corresponding <cite>struct page</cite> - a “classic sparse” and “sparse
vmemmap”. The selection is made at build time and it is determined by
the value of <cite>CONFIG_SPARSEMEM_VMEMMAP</cite>.</p>
<p>The classic sparse encodes the section number of a page in page-&gt;flags
and uses high bits of a PFN to access the section that maps that page
frame. Inside a section, the PFN is the index to the array of pages.</p>
<p>The sparse vmemmap uses a virtually mapped memory map to optimize
pfn_to_page and page_to_pfn operations. There is a global <cite>struct
page *vmemmap</cite> pointer that points to a virtually contiguous array of
<cite>struct page</cite> objects. A PFN is an index to that array and the the
offset of the <cite>struct page</cite> from <cite>vmemmap</cite> is the PFN of that
page.</p>
<p>To use vmemmap, an architecture has to reserve a range of virtual
addresses that will map the physical pages containing the memory
map and make sure that <cite>vmemmap</cite> points to that range. In addition,
the architecture should implement <code class="xref c c-func docutils literal notranslate"><span class="pre">vmemmap_populate()</span></code> method
that will allocate the physical memory and create page tables for the
virtual memory map. If an architecture does not have any special
requirements for the vmemmap mappings, it can use default
<code class="xref c c-func docutils literal notranslate"><span class="pre">vmemmap_populate_basepages()</span></code> provided by the generic memory
management.</p>
<p>The virtually mapped memory map allows storing <cite>struct page</cite> objects
for persistent memory devices in pre-allocated storage on those
devices. This storage is represented with <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vmem_altmap</span></code>
that is eventually passed to vmemmap_populate() through a long chain
of function calls. The vmemmap_populate() implementation may use the
<cite>vmem_altmap</cite> along with <code class="xref c c-func docutils literal notranslate"><span class="pre">altmap_alloc_block_buf()</span></code> helper to
allocate memory map on the persistent memory device.</p>
</div>
<div class="section" id="zone-device">
<h2>ZONE_DEVICE<a class="headerlink" href="#zone-device" title="Permalink to this headline">¶</a></h2>
<p>The <cite>ZONE_DEVICE</cite> facility builds upon <cite>SPARSEMEM_VMEMMAP</cite> to offer
<cite>struct page</cite> <cite>mem_map</cite> services for device driver identified physical
address ranges. The “device” aspect of <cite>ZONE_DEVICE</cite> relates to the fact
that the page objects for these address ranges are never marked online,
and that a reference must be taken against the device, not just the page
to keep the memory pinned for active use. <cite>ZONE_DEVICE</cite>, via
<code class="xref c c-func docutils literal notranslate"><span class="pre">devm_memremap_pages()</span></code>, performs just enough memory hotplug to
turn on <code class="xref c c-func docutils literal notranslate"><span class="pre">pfn_to_page()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">page_to_pfn()</span></code>, and
<code class="xref c c-func docutils literal notranslate"><span class="pre">get_user_pages()</span></code> service for the given range of pfns. Since the
page reference count never drops below 1 the page is never tracked as
free memory and the page’s <cite>struct list_head lru</cite> space is repurposed
for back referencing to the host device / driver that mapped the memory.</p>
<p>While <cite>SPARSEMEM</cite> presents memory as a collection of sections,
optionally collected into memory blocks, <cite>ZONE_DEVICE</cite> users have a need
for smaller granularity of populating the <cite>mem_map</cite>. Given that
<cite>ZONE_DEVICE</cite> memory is never marked online it is subsequently never
subject to its memory ranges being exposed through the sysfs memory
hotplug api on memory block boundaries. The implementation relies on
this lack of user-api constraint to allow sub-section sized memory
ranges to be specified to <code class="xref c c-func docutils literal notranslate"><span class="pre">arch_add_memory()</span></code>, the top-half of
memory hotplug. Sub-section support allows for 2MB as the cross-arch
common alignment granularity for <code class="xref c c-func docutils literal notranslate"><span class="pre">devm_memremap_pages()</span></code>.</p>
<p>The users of <cite>ZONE_DEVICE</cite> are:</p>
<ul class="simple">
<li><p>pmem: Map platform persistent memory to be used as a direct-I/O target
via DAX mappings.</p></li>
<li><p>hmm: Extend <cite>ZONE_DEVICE</cite> with <cite>-&gt;page_fault()</cite> and <cite>-&gt;page_free()</cite>
event callbacks to allow a device-driver to coordinate memory management
events related to device-memory, typically GPU memory. See
Documentation/vm/hmm.rst.</p></li>
<li><p>p2pdma: Create <cite>struct page</cite> objects to allow peer devices in a
PCI/-E topology to coordinate direct-DMA operations between themselves,
i.e. bypass host memory.</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mmu_notifier.html" class="btn btn-neutral float-right" title="When do you need to notify inside page table lock ?" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ksm.html" class="btn btn-neutral float-left" title="Kernel Samepage Merging" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>