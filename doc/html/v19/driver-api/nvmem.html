

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>NVMEM Subsystem &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>NVMEM Subsystem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/nvmem.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="nvmem-subsystem">
<h1>NVMEM Subsystem<a class="headerlink" href="#nvmem-subsystem" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>Srinivas Kandagatla &lt;<a class="reference external" href="mailto:srinivas&#46;kandagatla&#37;&#52;&#48;linaro&#46;org">srinivas<span>&#46;</span>kandagatla<span>&#64;</span>linaro<span>&#46;</span>org</a>&gt;</div></blockquote>
<p>This document explains the NVMEM Framework along with the APIs provided,
and how to use it.</p>
<div class="section" id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><em>NVMEM</em> is the abbreviation for Non Volatile Memory layer. It is used to
retrieve configuration of SOC or Device specific data from non volatile
memories like eeprom, efuses and so on.</p>
<p>Before this framework existed, NVMEM drivers like eeprom were stored in
drivers/misc, where they all had to duplicate pretty much the same code to
register a sysfs file, allow in-kernel users to access the content of the
devices they were driving, etc.</p>
<p>This was also a problem as far as other in-kernel users were involved, since
the solutions used were pretty much different from one driver to another, there
was a rather big abstraction leak.</p>
<p>This framework aims at solve these problems. It also introduces DT
representation for consumer devices to go get the data they require (MAC
Addresses, SoC/Revision ID, part numbers, and so on) from the NVMEMs. This
framework is based on regmap, so that most of the abstraction available in
regmap can be reused, across multiple types of buses.</p>
<div class="section" id="nvmem-providers">
<h3>NVMEM Providers<a class="headerlink" href="#nvmem-providers" title="Permalink to this headline">¶</a></h3>
<p>NVMEM provider refers to an entity that implements methods to initialize, read
and write the non-volatile memory.</p>
</div>
</div>
<div class="section" id="registering-unregistering-the-nvmem-provider">
<h2>2. Registering/Unregistering the NVMEM provider<a class="headerlink" href="#registering-unregistering-the-nvmem-provider" title="Permalink to this headline">¶</a></h2>
<p>A NVMEM provider can register with NVMEM core by supplying relevant
nvmem configuration to nvmem_register(), on success core would return a valid
nvmem_device pointer.</p>
<p>nvmem_unregister(nvmem) is used to unregister a previously registered provider.</p>
<p>For example, a simple qfprom case:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct nvmem_config econfig = {
      .name = &quot;qfprom&quot;,
      .owner = THIS_MODULE,
};

static int qfprom_probe(struct platform_device *pdev)
{
      ...
      econfig.dev = &amp;pdev-&gt;dev;
      nvmem = nvmem_register(&amp;econfig);
      ...
}
</pre></div>
</div>
<p>It is mandatory that the NVMEM provider has a regmap associated with its
struct device. Failure to do would return error code from nvmem_register().</p>
<p>Users of board files can define and register nvmem cells using the
nvmem_cell_table struct:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct nvmem_cell_info foo_nvmem_cells[] = {
      {
              .name           = &quot;macaddr&quot;,
              .offset         = 0x7f00,
              .bytes          = ETH_ALEN,
      }
};

static struct nvmem_cell_table foo_nvmem_cell_table = {
      .nvmem_name             = &quot;i2c-eeprom&quot;,
      .cells                  = foo_nvmem_cells,
      .ncells                 = ARRAY_SIZE(foo_nvmem_cells),
};

nvmem_add_cell_table(&amp;foo_nvmem_cell_table);
</pre></div>
</div>
<p>Additionally it is possible to create nvmem cell lookup entries and register
them with the nvmem framework from machine code as shown in the example below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct nvmem_cell_lookup foo_nvmem_lookup = {
      .nvmem_name             = &quot;i2c-eeprom&quot;,
      .cell_name              = &quot;macaddr&quot;,
      .dev_id                 = &quot;foo_mac.0&quot;,
      .con_id                 = &quot;mac-address&quot;,
};

nvmem_add_cell_lookups(&amp;foo_nvmem_lookup, 1);
</pre></div>
</div>
<div class="section" id="nvmem-consumers">
<h3>NVMEM Consumers<a class="headerlink" href="#nvmem-consumers" title="Permalink to this headline">¶</a></h3>
<p>NVMEM consumers are the entities which make use of the NVMEM provider to
read from and to NVMEM.</p>
</div>
</div>
<div class="section" id="nvmem-cell-based-consumer-apis">
<h2>3. NVMEM cell based consumer APIs<a class="headerlink" href="#nvmem-cell-based-consumer-apis" title="Permalink to this headline">¶</a></h2>
<p>NVMEM cells are the data entries/fields in the NVMEM.
The NVMEM framework provides 3 APIs to read/write NVMEM cells:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nvmem_cell *nvmem_cell_get(struct device *dev, const char *name);
struct nvmem_cell *devm_nvmem_cell_get(struct device *dev, const char *name);

void nvmem_cell_put(struct nvmem_cell *cell);
void devm_nvmem_cell_put(struct device *dev, struct nvmem_cell *cell);

void *nvmem_cell_read(struct nvmem_cell *cell, ssize_t *len);
int nvmem_cell_write(struct nvmem_cell *cell, void *buf, ssize_t len);
</pre></div>
</div>
<p><cite>*nvmem_cell_get()</cite> apis will get a reference to nvmem cell for a given id,
and nvmem_cell_read/write() can then read or write to the cell.
Once the usage of the cell is finished the consumer should call
<cite>*nvmem_cell_put()</cite> to free all the allocation memory for the cell.</p>
</div>
<div class="section" id="direct-nvmem-device-based-consumer-apis">
<h2>4. Direct NVMEM device based consumer APIs<a class="headerlink" href="#direct-nvmem-device-based-consumer-apis" title="Permalink to this headline">¶</a></h2>
<p>In some instances it is necessary to directly read/write the NVMEM.
To facilitate such consumers NVMEM framework provides below apis:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nvmem_device *nvmem_device_get(struct device *dev, const char *name);
struct nvmem_device *devm_nvmem_device_get(struct device *dev,
                                         const char *name);
struct nvmem_device *nvmem_device_find(void *data,
                      int (*match)(struct device *dev, const void *data));
void nvmem_device_put(struct nvmem_device *nvmem);
int nvmem_device_read(struct nvmem_device *nvmem, unsigned int offset,
                    size_t bytes, void *buf);
int nvmem_device_write(struct nvmem_device *nvmem, unsigned int offset,
                     size_t bytes, void *buf);
int nvmem_device_cell_read(struct nvmem_device *nvmem,
                         struct nvmem_cell_info *info, void *buf);
int nvmem_device_cell_write(struct nvmem_device *nvmem,
                          struct nvmem_cell_info *info, void *buf);
</pre></div>
</div>
<p>Before the consumers can read/write NVMEM directly, it should get hold
of nvmem_controller from one of the <cite>*nvmem_device_get()</cite> api.</p>
<p>The difference between these apis and cell based apis is that these apis always
take nvmem_device as parameter.</p>
</div>
<div class="section" id="releasing-a-reference-to-the-nvmem">
<h2>5. Releasing a reference to the NVMEM<a class="headerlink" href="#releasing-a-reference-to-the-nvmem" title="Permalink to this headline">¶</a></h2>
<p>When a consumer no longer needs the NVMEM, it has to release the reference
to the NVMEM it has obtained using the APIs mentioned in the above section.
The NVMEM framework provides 2 APIs to release a reference to the NVMEM:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void nvmem_cell_put(struct nvmem_cell *cell);
void devm_nvmem_cell_put(struct device *dev, struct nvmem_cell *cell);
void nvmem_device_put(struct nvmem_device *nvmem);
void devm_nvmem_device_put(struct device *dev, struct nvmem_device *nvmem);
</pre></div>
</div>
<p>Both these APIs are used to release a reference to the NVMEM and
devm_nvmem_cell_put and devm_nvmem_device_put destroys the devres associated
with this NVMEM.</p>
<div class="section" id="userspace">
<h3>Userspace<a class="headerlink" href="#userspace" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="userspace-binary-interface">
<h2>6. Userspace binary interface<a class="headerlink" href="#userspace-binary-interface" title="Permalink to this headline">¶</a></h2>
<p>Userspace can read/write the raw NVMEM file located at:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/bus/nvmem/devices/*/nvmem
</pre></div>
</div>
<p>ex:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>hexdump /sys/bus/nvmem/devices/qfprom0/nvmem

0000000 0000 0000 0000 0000 0000 0000 0000 0000
*
00000a0 db10 2240 0000 e000 0c00 0c00 0000 0c00
0000000 0000 0000 0000 0000 0000 0000 0000 0000
...
*
0001000
</pre></div>
</div>
</div>
<div class="section" id="devicetree-binding">
<h2>7. DeviceTree Binding<a class="headerlink" href="#devicetree-binding" title="Permalink to this headline">¶</a></h2>
<p>See Documentation/devicetree/bindings/nvmem/nvmem.txt</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>