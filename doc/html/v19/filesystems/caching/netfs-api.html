

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>FS-Cache Network Filesystem API &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>FS-Cache Network Filesystem API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/filesystems/caching/netfs-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fs-cache-network-filesystem-api">
<h1>FS-Cache Network Filesystem API<a class="headerlink" href="#fs-cache-network-filesystem-api" title="Permalink to this headline">¶</a></h1>
<p>There’s an API by which a network filesystem can make use of the FS-Cache
facilities.  This is based around a number of principles:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Caches can store a number of different object types.  There are two main
object types: indices and files.  The first is a special type used by
FS-Cache to make finding objects faster and to make retiring of groups of
objects easier.</li>
<li>Every index, file or other object is represented by a cookie.  This cookie
may or may not have anything associated with it, but the netfs doesn’t
need to care.</li>
<li>Barring the top-level index (one entry per cached netfs), the index
hierarchy for each netfs is structured according the whim of the netfs.</li>
</ol>
</div></blockquote>
<p>This API is declared in &lt;linux/fscache.h&gt;.</p>
<div class="section" id="network-filesystem-definition">
<h2>Network Filesystem Definition<a class="headerlink" href="#network-filesystem-definition" title="Permalink to this headline">¶</a></h2>
<p>FS-Cache needs a description of the network filesystem.  This is specified
using a record of the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_netfs {
        uint32_t                        version;
        const char                      *name;
        struct fscache_cookie           *primary_index;
        ...
};
</pre></div>
</div>
<p>This first two fields should be filled in before registration, and the third
will be filled in by the registration function; any other fields should just be
ignored and are for internal use only.</p>
<p>The fields are:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The name of the netfs (used as the key in the toplevel index).</li>
<li>The version of the netfs (if the name matches but the version doesn’t, the
entire in-cache hierarchy for this netfs will be scrapped and begun
afresh).</li>
<li>The cookie representing the primary index will be allocated according to
another parameter passed into the registration function.</li>
</ol>
</div></blockquote>
<p>For example, kAFS (linux/fs/afs/) uses the following definitions to describe
itself:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_netfs afs_cache_netfs = {
        .version        = 0,
        .name           = &quot;afs&quot;,
};
</pre></div>
</div>
</div>
<div class="section" id="index-definition">
<h2>Index Definition<a class="headerlink" href="#index-definition" title="Permalink to this headline">¶</a></h2>
<p>Indices are used for two purposes:</p>
<blockquote>
<div><ol class="arabic simple">
<li>To aid the finding of a file based on a series of keys (such as AFS’s
“cell”, “volume ID”, “vnode ID”).</li>
<li>To make it easier to discard a subset of all the files cached based around
a particular key - for instance to mirror the removal of an AFS volume.</li>
</ol>
</div></blockquote>
<p>However, since it’s unlikely that any two netfs’s are going to want to define
their index hierarchies in quite the same way, FS-Cache tries to impose as few
restraints as possible on how an index is structured and where it is placed in
the tree.  The netfs can even mix indices and data files at the same level, but
it’s not recommended.</p>
<p>Each index entry consists of a key of indeterminate length plus some auxiliary
data, also of indeterminate length.</p>
<p>There are some limits on indices:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Any index containing non-index objects should be restricted to a single
cache.  Any such objects created within an index will be created in the
first cache only.  The cache in which an index is created can be
controlled by cache tags (see below).</li>
<li>The entry data must be atomically journallable, so it is limited to about
400 bytes at present.  At least 400 bytes will be available.</li>
<li>The depth of the index tree should be judged with care as the search
function is recursive.  Too many layers will run the kernel out of stack.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="object-definition">
<h2>Object Definition<a class="headerlink" href="#object-definition" title="Permalink to this headline">¶</a></h2>
<p>To define an object, a structure of the following type should be filled out:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_cookie_def
{
        uint8_t name[16];
        uint8_t type;

        struct fscache_cache_tag *(*select_cache)(
                const void *parent_netfs_data,
                const void *cookie_netfs_data);

        enum fscache_checkaux (*check_aux)(void *cookie_netfs_data,
                                           const void *data,
                                           uint16_t datalen,
                                           loff_t object_size);

        void (*get_context)(void *cookie_netfs_data, void *context);

        void (*put_context)(void *cookie_netfs_data, void *context);

        void (*mark_pages_cached)(void *cookie_netfs_data,
                                  struct address_space *mapping,
                                  struct pagevec *cached_pvec);
};
</pre></div>
</div>
<p>This has the following fields:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">The type of the object [mandatory].</p>
<p>This is one of the following values:</p>
<blockquote>
<div><dl class="docutils">
<dt>FSCACHE_COOKIE_TYPE_INDEX</dt>
<dd><p class="first last">This defines an index, which is a special FS-Cache type.</p>
</dd>
<dt>FSCACHE_COOKIE_TYPE_DATAFILE</dt>
<dd><p class="first last">This defines an ordinary data file.</p>
</dd>
<dt>Any other value between 2 and 255</dt>
<dd><p class="first last">This defines an extraordinary object such as an XATTR.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">The name of the object type (NUL terminated unless all 16 chars are used)
[optional].</p>
</li>
<li><p class="first">A function to select the cache in which to store an index [optional].</p>
<p>This function is invoked when an index needs to be instantiated in a cache
during the instantiation of a non-index object.  Only the immediate index
parent for the non-index object will be queried.  Any indices above that
in the hierarchy may be stored in multiple caches.  This function does not
need to be supplied for any non-index object or any index that will only
have index children.</p>
<p>If this function is not supplied or if it returns NULL then the first
cache in the parent’s list will be chosen, or failing that, the first
cache in the master list.</p>
</li>
<li><p class="first">A function to check the auxiliary data [optional].</p>
<p>This function will be called to check that a match found in the cache for
this object is valid.  For instance with AFS it could check the auxiliary
data against the data version number returned by the server to determine
whether the index entry in a cache is still valid.</p>
<p>If this function is absent, it will be assumed that matching objects in a
cache are always valid.</p>
<p>The function is also passed the cache’s idea of the object size and may
use this to manage coherency also.</p>
<p>If present, the function should return one of the following values:</p>
<blockquote>
<div><dl class="docutils">
<dt>FSCACHE_CHECKAUX_OKAY</dt>
<dd><ul class="first last simple">
<li>the entry is okay as is</li>
</ul>
</dd>
<dt>FSCACHE_CHECKAUX_NEEDS_UPDATE</dt>
<dd><ul class="first last simple">
<li>the entry requires update</li>
</ul>
</dd>
<dt>FSCACHE_CHECKAUX_OBSOLETE</dt>
<dd><ul class="first last simple">
<li>the entry should be deleted</li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>This function can also be used to extract data from the auxiliary data in
the cache and copy it into the netfs’s structures.</p>
</li>
<li><p class="first">A pair of functions to manage contexts for the completion callback
[optional].</p>
<p>The cache read/write functions are passed a context which is then passed
to the I/O completion callback function.  To ensure this context remains
valid until after the I/O completion is called, two functions may be
provided: one to get an extra reference on the context, and one to drop a
reference to it.</p>
<p>If the context is not used or is a type of object that won’t go out of
scope, then these functions are not required.  These functions are not
required for indices as indices may not contain data.  These functions may
be called in interrupt context and so may not sleep.</p>
</li>
<li><p class="first">A function to mark a page as retaining cache metadata [optional].</p>
<p>This is called by the cache to indicate that it is retaining in-memory
information for this page and that the netfs should uncache the page when
it has finished.  This does not indicate whether there’s data on the disk
or not.  Note that several pages at once may be presented for marking.</p>
<p>The PG_fscache bit is set on the pages before this function would be
called, so the function need not be provided if this is sufficient.</p>
<p>This function is not required for indices as they’re not permitted data.</p>
</li>
<li><p class="first">A function to unmark all the pages retaining cache metadata [mandatory].</p>
<p>This is called by FS-Cache to indicate that a backing store is being
unbound from a cookie and that all the marks on the pages should be
cleared to prevent confusion.  Note that the cache will have torn down all
its tracking information so that the pages don’t need to be explicitly
uncached.</p>
<p>This function is not required for indices as they’re not permitted data.</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="network-filesystem-un-registration">
<h2>Network Filesystem (Un)registration<a class="headerlink" href="#network-filesystem-un-registration" title="Permalink to this headline">¶</a></h2>
<p>The first step is to declare the network filesystem to the cache.  This also
involves specifying the layout of the primary index (for AFS, this would be the
“cell” level).</p>
<p>The registration function is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_register_netfs(struct fscache_netfs *netfs);
</pre></div>
</div>
<p>It just takes a pointer to the netfs definition.  It returns 0 or an error as
appropriate.</p>
<p>For kAFS, registration is done as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ret = fscache_register_netfs(&amp;afs_cache_netfs);
</pre></div>
</div>
<p>The last step is, of course, unregistration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_unregister_netfs(struct fscache_netfs *netfs);
</pre></div>
</div>
</div>
<div class="section" id="cache-tag-lookup">
<h2>Cache Tag Lookup<a class="headerlink" href="#cache-tag-lookup" title="Permalink to this headline">¶</a></h2>
<p>FS-Cache permits the use of more than one cache.  To permit particular index
subtrees to be bound to particular caches, the second step is to look up cache
representation tags.  This step is optional; it can be left entirely up to
FS-Cache as to which cache should be used.  The problem with doing that is that
FS-Cache will always pick the first cache that was registered.</p>
<p>To get the representation for a named tag:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_cache_tag *fscache_lookup_cache_tag(const char *name);
</pre></div>
</div>
<p>This takes a text string as the name and returns a representation of a tag.  It
will never return an error.  It may return a dummy tag, however, if it runs out
of memory; this will inhibit caching with this tag.</p>
<p>Any representation so obtained must be released by passing it to this function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_release_cache_tag(struct fscache_cache_tag *tag);
</pre></div>
</div>
<p>The tag will be retrieved by FS-Cache when it calls the object definition
operation select_cache().</p>
</div>
<div class="section" id="index-registration">
<h2>Index Registration<a class="headerlink" href="#index-registration" title="Permalink to this headline">¶</a></h2>
<p>The third step is to inform FS-Cache about part of an index hierarchy that can
be used to locate files.  This is done by requesting a cookie for each index in
the path to the file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_cookie *
fscache_acquire_cookie(struct fscache_cookie *parent,
                       const struct fscache_object_def *def,
                       const void *index_key,
                       size_t index_key_len,
                       const void *aux_data,
                       size_t aux_data_len,
                       void *netfs_data,
                       loff_t object_size,
                       bool enable);
</pre></div>
</div>
<p>This function creates an index entry in the index represented by parent,
filling in the index entry by calling the operations pointed to by def.</p>
<p>A unique key that represents the object within the parent must be pointed to by
index_key and is of length index_key_len.</p>
<p>An optional blob of auxiliary data that is to be stored within the cache can be
pointed to with aux_data and should be of length aux_data_len.  This would
typically be used for storing coherency data.</p>
<p>The netfs may pass an arbitrary value in netfs_data and this will be presented
to it in the event of any calling back.  This may also be used in tracing or
logging of messages.</p>
<p>The cache tracks the size of the data attached to an object and this set to be
object_size.  For indices, this should be 0.  This value will be passed to the
-&gt;check_aux() callback.</p>
<p>Note that this function never returns an error - all errors are handled
internally.  It may, however, return NULL to indicate no cookie.  It is quite
acceptable to pass this token back to this function as the parent to another
acquisition (or even to the relinquish cookie, read page and write page
functions - see below).</p>
<p>Note also that no indices are actually created in a cache until a non-index
object needs to be created somewhere down the hierarchy.  Furthermore, an index
may be created in several different caches independently at different times.
This is all handled transparently, and the netfs doesn’t see any of it.</p>
<p>A cookie will be created in the disabled state if enabled is false.  A cookie
must be enabled to do anything with it.  A disabled cookie can be enabled by
calling fscache_enable_cookie() (see below).</p>
<p>For example, with AFS, a cell would be added to the primary index.  This index
entry would have a dependent inode containing volume mappings within this cell:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cell-&gt;cache =
        fscache_acquire_cookie(afs_cache_netfs.primary_index,
                               &amp;afs_cell_cache_index_def,
                               cell-&gt;name, strlen(cell-&gt;name),
                               NULL, 0,
                               cell, 0, true);
</pre></div>
</div>
<p>And then a particular volume could be added to that index by ID, creating
another index for vnodes (AFS inode equivalents):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>volume-&gt;cache =
        fscache_acquire_cookie(volume-&gt;cell-&gt;cache,
                               &amp;afs_volume_cache_index_def,
                               &amp;volume-&gt;vid, sizeof(volume-&gt;vid),
                               NULL, 0,
                               volume, 0, true);
</pre></div>
</div>
</div>
<div class="section" id="data-file-registration">
<h2>Data File Registration<a class="headerlink" href="#data-file-registration" title="Permalink to this headline">¶</a></h2>
<p>The fourth step is to request a data file be created in the cache.  This is
identical to index cookie acquisition.  The only difference is that the type in
the object definition should be something other than index type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vnode-&gt;cache =
        fscache_acquire_cookie(volume-&gt;cache,
                               &amp;afs_vnode_cache_object_def,
                               &amp;key, sizeof(key),
                               &amp;aux, sizeof(aux),
                               vnode, vnode-&gt;status.size, true);
</pre></div>
</div>
</div>
<div class="section" id="miscellaneous-object-registration">
<h2>Miscellaneous Object Registration<a class="headerlink" href="#miscellaneous-object-registration" title="Permalink to this headline">¶</a></h2>
<p>An optional step is to request an object of miscellaneous type be created in
the cache.  This is almost identical to index cookie acquisition.  The only
difference is that the type in the object definition should be something other
than index type.  While the parent object could be an index, it’s more likely
it would be some other type of object such as a data file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xattr-&gt;cache =
        fscache_acquire_cookie(vnode-&gt;cache,
                               &amp;afs_xattr_cache_object_def,
                               &amp;xattr-&gt;name, strlen(xattr-&gt;name),
                               NULL, 0,
                               xattr, strlen(xattr-&gt;val), true);
</pre></div>
</div>
<p>Miscellaneous objects might be used to store extended attributes or directory
entries for example.</p>
</div>
<div class="section" id="setting-the-data-file-size">
<h2>Setting the Data File Size<a class="headerlink" href="#setting-the-data-file-size" title="Permalink to this headline">¶</a></h2>
<p>The fifth step is to set the physical attributes of the file, such as its size.
This doesn’t automatically reserve any space in the cache, but permits the
cache to adjust its metadata for data tracking appropriately:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_attr_changed(struct fscache_cookie *cookie);
</pre></div>
</div>
<p>The cache will return -ENOBUFS if there is no backing cache or if there is no
space to allocate any extra metadata required in the cache.</p>
<p>Note that attempts to read or write data pages in the cache over this size may
be rebuffed with -ENOBUFS.</p>
<p>This operation schedules an attribute adjustment to happen asynchronously at
some point in the future, and as such, it may happen after the function returns
to the caller.  The attribute adjustment excludes read and write operations.</p>
</div>
<div class="section" id="page-alloc-read-write">
<h2>Page alloc/read/write<a class="headerlink" href="#page-alloc-read-write" title="Permalink to this headline">¶</a></h2>
<p>And the sixth step is to store and retrieve pages in the cache.  There are
three functions that are used to do this.</p>
<p>Note:</p>
<blockquote>
<div><ol class="arabic simple">
<li>A page should not be re-read or re-allocated without uncaching it first.</li>
<li>A read or allocated page must be uncached when the netfs page is released
from the pagecache.</li>
<li>A page should only be written to the cache if previous read or allocated.</li>
</ol>
</div></blockquote>
<p>This permits the cache to maintain its page tracking in proper order.</p>
<div class="section" id="page-read">
<h3>PAGE READ<a class="headerlink" href="#page-read" title="Permalink to this headline">¶</a></h3>
<p>Firstly, the netfs should ask FS-Cache to examine the caches and read the
contents cached for a particular page of a particular file if present, or else
allocate space to store the contents if not:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef
void (*fscache_rw_complete_t)(struct page *page,
                              void *context,
                              int error);

int fscache_read_or_alloc_page(struct fscache_cookie *cookie,
                               struct page *page,
                               fscache_rw_complete_t end_io_func,
                               void *context,
                               gfp_t gfp);
</pre></div>
</div>
<p>The cookie argument must specify a cookie for an object that isn’t an index,
the page specified will have the data loaded into it (and is also used to
specify the page number), and the gfp argument is used to control how any
memory allocations made are satisfied.</p>
<p>If the cookie indicates the inode is not cached:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The function will return -ENOBUFS.</li>
</ol>
</div></blockquote>
<p>Else if there’s a copy of the page resident in the cache:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">The mark_pages_cached() cookie operation will be called on that page.</p>
</li>
<li><p class="first">The function will submit a request to read the data from the cache’s
backing device directly into the page specified.</p>
</li>
<li><p class="first">The function will return 0.</p>
</li>
<li><p class="first">When the read is complete, end_io_func() will be invoked with:</p>
<blockquote>
<div><ul class="simple">
<li>The netfs data supplied when the cookie was created.</li>
<li>The page descriptor.</li>
<li>The context argument passed to the above function.  This will be
maintained with the get_context/put_context functions mentioned above.</li>
<li>An argument that’s 0 on success or negative for an error code.</li>
</ul>
</div></blockquote>
<p>If an error occurs, it should be assumed that the page contains no usable
data.  fscache_readpages_cancel() may need to be called.</p>
<p>end_io_func() will be called in process context if the read is results in
an error, but it might be called in interrupt context if the read is
successful.</p>
</li>
</ol>
</div></blockquote>
<p>Otherwise, if there’s not a copy available in cache, but the cache may be able
to store the page:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The mark_pages_cached() cookie operation will be called on that page.</li>
<li>A block may be reserved in the cache and attached to the object at the
appropriate place.</li>
<li>The function will return -ENODATA.</li>
</ol>
</div></blockquote>
<p>This function may also return -ENOMEM or -EINTR, in which case it won’t have
read any data from the cache.</p>
</div>
<div class="section" id="page-allocate">
<h3>Page Allocate<a class="headerlink" href="#page-allocate" title="Permalink to this headline">¶</a></h3>
<p>Alternatively, if there’s not expected to be any data in the cache for a page
because the file has been extended, a block can simply be allocated instead:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_alloc_page(struct fscache_cookie *cookie,
                       struct page *page,
                       gfp_t gfp);
</pre></div>
</div>
<p>This is similar to the fscache_read_or_alloc_page() function, except that it
never reads from the cache.  It will return 0 if a block has been allocated,
rather than -ENODATA as the other would.  One or the other must be performed
before writing to the cache.</p>
<p>The mark_pages_cached() cookie operation will be called on the page if
successful.</p>
</div>
<div class="section" id="page-write">
<h3>Page Write<a class="headerlink" href="#page-write" title="Permalink to this headline">¶</a></h3>
<p>Secondly, if the netfs changes the contents of the page (either due to an
initial download or if a user performs a write), then the page should be
written back to the cache:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_write_page(struct fscache_cookie *cookie,
                       struct page *page,
                       loff_t object_size,
                       gfp_t gfp);
</pre></div>
</div>
<p>The cookie argument must specify a data file cookie, the page specified should
contain the data to be written (and is also used to specify the page number),
object_size is the revised size of the object and the gfp argument is used to
control how any memory allocations made are satisfied.</p>
<p>The page must have first been read or allocated successfully and must not have
been uncached before writing is performed.</p>
<p>If the cookie indicates the inode is not cached then:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The function will return -ENOBUFS.</li>
</ol>
</div></blockquote>
<p>Else if space can be allocated in the cache to hold this page:</p>
<blockquote>
<div><ol class="arabic simple">
<li>PG_fscache_write will be set on the page.</li>
<li>The function will submit a request to write the data to cache’s backing
device directly from the page specified.</li>
<li>The function will return 0.</li>
<li>When the write is complete PG_fscache_write is cleared on the page and
anyone waiting for that bit will be woken up.</li>
</ol>
</div></blockquote>
<p>Else if there’s no space available in the cache, -ENOBUFS will be returned.  It
is also possible for the PG_fscache_write bit to be cleared when no write took
place if unforeseen circumstances arose (such as a disk error).</p>
<p>Writing takes place asynchronously.</p>
</div>
<div class="section" id="multiple-page-read">
<h3>Multiple Page Read<a class="headerlink" href="#multiple-page-read" title="Permalink to this headline">¶</a></h3>
<p>A facility is provided to read several pages at once, as requested by the
readpages() address space operation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_read_or_alloc_pages(struct fscache_cookie *cookie,
                                struct address_space *mapping,
                                struct list_head *pages,
                                int *nr_pages,
                                fscache_rw_complete_t end_io_func,
                                void *context,
                                gfp_t gfp);
</pre></div>
</div>
<p>This works in a similar way to fscache_read_or_alloc_page(), except:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Any page it can retrieve data for is removed from pages and nr_pages and
dispatched for reading to the disk.  Reads of adjacent pages on disk may
be merged for greater efficiency.</p>
</li>
<li><p class="first">The mark_pages_cached() cookie operation will be called on several pages
at once if they’re being read or allocated.</p>
</li>
<li><p class="first">If there was an general error, then that error will be returned.</p>
<p>Else if some pages couldn’t be allocated or read, then -ENOBUFS will be
returned.</p>
<p>Else if some pages couldn’t be read but were allocated, then -ENODATA will
be returned.</p>
<p>Otherwise, if all pages had reads dispatched, then 0 will be returned, the
list will be empty and <code class="docutils literal notranslate"><span class="pre">*nr_pages</span></code> will be 0.</p>
</li>
<li><p class="first">end_io_func will be called once for each page being read as the reads
complete.  It will be called in process context if error != 0, but it may
be called in interrupt context if there is no error.</p>
</li>
</ol>
</div></blockquote>
<p>Note that a return of -ENODATA, -ENOBUFS or any other error does not preclude
some of the pages being read and some being allocated.  Those pages will have
been marked appropriately and will need uncaching.</p>
</div>
<div class="section" id="cancellation-of-unread-pages">
<h3>Cancellation of Unread Pages<a class="headerlink" href="#cancellation-of-unread-pages" title="Permalink to this headline">¶</a></h3>
<p>If one or more pages are passed to fscache_read_or_alloc_pages() but not then
read from the cache and also not read from the underlying filesystem then
those pages will need to have any marks and reservations removed.  This can be
done by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_readpages_cancel(struct fscache_cookie *cookie,
                              struct list_head *pages);
</pre></div>
</div>
<p>prior to returning to the caller.  The cookie argument should be as passed to
fscache_read_or_alloc_pages().  Every page in the pages list will be examined
and any that have PG_fscache set will be uncached.</p>
</div>
</div>
<div class="section" id="page-uncaching">
<h2>Page Uncaching<a class="headerlink" href="#page-uncaching" title="Permalink to this headline">¶</a></h2>
<p>To uncache a page, this function should be called:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_uncache_page(struct fscache_cookie *cookie,
                          struct page *page);
</pre></div>
</div>
<p>This function permits the cache to release any in-memory representation it
might be holding for this netfs page.  This function must be called once for
each page on which the read or write page functions above have been called to
make sure the cache’s in-memory tracking information gets torn down.</p>
<p>Note that pages can’t be explicitly deleted from the a data file.  The whole
data file must be retired (see the relinquish cookie function below).</p>
<p>Furthermore, note that this does not cancel the asynchronous read or write
operation started by the read/alloc and write functions, so the page
invalidation functions must use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool fscache_check_page_write(struct fscache_cookie *cookie,
                              struct page *page);
</pre></div>
</div>
<p>to see if a page is being written to the cache, and:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_wait_on_page_write(struct fscache_cookie *cookie,
                                struct page *page);
</pre></div>
</div>
<p>to wait for it to finish if it is.</p>
<p>When releasepage() is being implemented, a special FS-Cache function exists to
manage the heuristics of coping with vmscan trying to eject pages, which may
conflict with the cache trying to write pages to the cache (which may itself
need to allocate memory):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool fscache_maybe_release_page(struct fscache_cookie *cookie,
                                struct page *page,
                                gfp_t gfp);
</pre></div>
</div>
<p>This takes the netfs cookie, and the page and gfp arguments as supplied to
releasepage().  It will return false if the page cannot be released yet for
some reason and if it returns true, the page has been uncached and can now be
released.</p>
<p>To make a page available for release, this function may wait for an outstanding
storage request to complete, or it may attempt to cancel the storage request -
in which case the page will not be stored in the cache this time.</p>
<div class="section" id="bulk-image-page-uncache">
<h3>Bulk Image Page Uncache<a class="headerlink" href="#bulk-image-page-uncache" title="Permalink to this headline">¶</a></h3>
<p>A convenience routine is provided to perform an uncache on all the pages
attached to an inode.  This assumes that the pages on the inode correspond on a
1:1 basis with the pages in the cache:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,
                                     struct inode *inode);
</pre></div>
</div>
<p>This takes the netfs cookie that the pages were cached with and the inode that
the pages are attached to.  This function will wait for pages to finish being
written to the cache and for the cache to finish with the page generally.  No
error is returned.</p>
</div>
</div>
<div class="section" id="index-and-data-file-consistency">
<h2>Index and Data File consistency<a class="headerlink" href="#index-and-data-file-consistency" title="Permalink to this headline">¶</a></h2>
<p>To find out whether auxiliary data for an object is up to data within the
cache, the following function can be called:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_check_consistency(struct fscache_cookie *cookie,
                              const void *aux_data);
</pre></div>
</div>
<p>This will call back to the netfs to check whether the auxiliary data associated
with a cookie is correct; if aux_data is non-NULL, it will update the auxiliary
data buffer first.  It returns 0 if it is and -ESTALE if it isn’t; it may also
return -ENOMEM and -ERESTARTSYS.</p>
<p>To request an update of the index data for an index or other object, the
following function should be called:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_update_cookie(struct fscache_cookie *cookie,
                           const void *aux_data);
</pre></div>
</div>
<p>This function will update the cookie’s auxiliary data buffer from aux_data if
that is non-NULL and then schedule this to be stored on disk.  The update
method in the parent index definition will be called to transfer the data.</p>
<p>Note that partial updates may happen automatically at other times, such as when
data blocks are added to a data file object.</p>
</div>
<div class="section" id="cookie-enablement">
<h2>Cookie Enablement<a class="headerlink" href="#cookie-enablement" title="Permalink to this headline">¶</a></h2>
<p>Cookies exist in one of two states: enabled and disabled.  If a cookie is
disabled, it ignores all attempts to acquire child cookies; check, update or
invalidate its state; allocate, read or write backing pages - though it is
still possible to uncache pages and relinquish the cookie.</p>
<p>The initial enablement state is set by fscache_acquire_cookie(), but the cookie
can be enabled or disabled later.  To disable a cookie, call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_disable_cookie(struct fscache_cookie *cookie,
                            const void *aux_data,
                            bool invalidate);
</pre></div>
</div>
<p>If the cookie is not already disabled, this locks the cookie against other
enable and disable ops, marks the cookie as being disabled, discards or
invalidates any backing objects and waits for cessation of activity on any
associated object before unlocking the cookie.</p>
<p>All possible failures are handled internally.  The caller should consider
calling fscache_uncache_all_inode_pages() afterwards to make sure all page
markings are cleared up.</p>
<p>Cookies can be enabled or reenabled with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_enable_cookie(struct fscache_cookie *cookie,
                           const void *aux_data,
                           loff_t object_size,
                           bool (*can_enable)(void *data),
                           void *data)
</pre></div>
</div>
<p>If the cookie is not already enabled, this locks the cookie against other
enable and disable ops, invokes can_enable() and, if the cookie is not an index
cookie, will begin the procedure of acquiring backing objects.</p>
<p>The optional can_enable() function is passed the data argument and returns a
ruling as to whether or not enablement should actually be permitted to begin.</p>
<p>All possible failures are handled internally.  The cookie will only be marked
as enabled if provisional backing objects are allocated.</p>
<p>The object’s data size is updated from object_size and is passed to the
-&gt;check_aux() function.</p>
<p>In both cases, the cookie’s auxiliary data buffer is updated from aux_data if
that is non-NULL inside the enablement lock before proceeding.</p>
</div>
<div class="section" id="miscellaneous-cookie-operations">
<h2>Miscellaneous Cookie operations<a class="headerlink" href="#miscellaneous-cookie-operations" title="Permalink to this headline">¶</a></h2>
<p>There are a number of operations that can be used to control cookies:</p>
<blockquote>
<div><blockquote>
<div><ul>
<li><p class="first">Cookie pinning:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_pin_cookie(struct fscache_cookie *cookie);
void fscache_unpin_cookie(struct fscache_cookie *cookie);
</pre></div>
</div>
</li>
</ul>
<p>These operations permit data cookies to be pinned into the cache and to
have the pinning removed.  They are not permitted on index cookies.</p>
<p>The pinning function will return 0 if successful, -ENOBUFS in the cookie
isn’t backed by a cache, -EOPNOTSUPP if the cache doesn’t support pinning,
-ENOSPC if there isn’t enough space to honour the operation, -ENOMEM or
-EIO if there’s any other problem.</p>
</div></blockquote>
<ul>
<li><p class="first">Data space reservation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_reserve_space(struct fscache_cookie *cookie, loff_t size);
</pre></div>
</div>
<p>This permits a netfs to request cache space be reserved to store up to the
given amount of a file.  It is permitted to ask for more than the current
size of the file to allow for future file expansion.</p>
<p>If size is given as zero then the reservation will be cancelled.</p>
<p>The function will return 0 if successful, -ENOBUFS in the cookie isn’t
backed by a cache, -EOPNOTSUPP if the cache doesn’t support reservations,
-ENOSPC if there isn’t enough space to honour the operation, -ENOMEM or
-EIO if there’s any other problem.</p>
<p>Note that this doesn’t pin an object in a cache; it can still be culled to
make space if it’s not in use.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="cookie-unregistration">
<h2>Cookie Unregistration<a class="headerlink" href="#cookie-unregistration" title="Permalink to this headline">¶</a></h2>
<p>To get rid of a cookie, this function should be called:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_relinquish_cookie(struct fscache_cookie *cookie,
                               const void *aux_data,
                               bool retire);
</pre></div>
</div>
<p>If retire is non-zero, then the object will be marked for recycling, and all
copies of it will be removed from all active caches in which it is present.
Not only that but all child objects will also be retired.</p>
<p>If retire is zero, then the object may be available again when next the
acquisition function is called.  Retirement here will overrule the pinning on a
cookie.</p>
<p>The cookie’s auxiliary data will be updated from aux_data if that is non-NULL
so that the cache can lazily update it on disk.</p>
<p>One very important note - relinquish must NOT be called for a cookie unless all
the cookies for “child” indices, objects and pages have been relinquished
first.</p>
</div>
<div class="section" id="index-invalidation">
<h2>Index Invalidation<a class="headerlink" href="#index-invalidation" title="Permalink to this headline">¶</a></h2>
<p>There is no direct way to invalidate an index subtree.  To do this, the caller
should relinquish and retire the cookie they have, and then acquire a new one.</p>
</div>
<div class="section" id="data-file-invalidation">
<h2>Data File Invalidation<a class="headerlink" href="#data-file-invalidation" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it will be necessary to invalidate an object that contains data.
Typically this will be necessary when the server tells the netfs of a foreign
change - at which point the netfs has to throw away all the state it had for an
inode and reload from the server.</p>
<p>To indicate that a cache object should be invalidated, the following function
can be called:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_invalidate(struct fscache_cookie *cookie);
</pre></div>
</div>
<p>This can be called with spinlocks held as it defers the work to a thread pool.
All extant storage, retrieval and attribute change ops at this point are
cancelled and discarded.  Some future operations will be rejected until the
cache has had a chance to insert a barrier in the operations queue.  After
that, operations will be queued again behind the invalidation operation.</p>
<p>The invalidation operation will perform an attribute change operation and an
auxiliary data update operation as it is very likely these will have changed.</p>
<p>Using the following function, the netfs can wait for the invalidation operation
to have reached a point at which it can start submitting ordinary operations
once again:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void fscache_wait_on_invalidate(struct fscache_cookie *cookie);
</pre></div>
</div>
</div>
<div class="section" id="fs-cache-specific-page-flag">
<h2>FS-cache Specific Page Flag<a class="headerlink" href="#fs-cache-specific-page-flag" title="Permalink to this headline">¶</a></h2>
<p>FS-Cache makes use of a page flag, PG_private_2, for its own purpose.  This is
given the alternative name PG_fscache.</p>
<p>PG_fscache is used to indicate that the page is known by the cache, and that
the cache must be informed if the page is going to go away.  It’s an indication
to the netfs that the cache has an interest in this page, where an interest may
be a pointer to it, resources allocated or reserved for it, or I/O in progress
upon it.</p>
<p>The netfs can use this information in methods such as releasepage() to
determine whether it needs to uncache a page or update it.</p>
<p>Furthermore, if this bit is set, releasepage() and invalidatepage() operations
will be called on a page to get rid of it, even if PG_private is not set.  This
allows caching to attempted on a page before <a class="reference internal" href="../../core-api/mm-api.html#c.read_cache_pages" title="read_cache_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">read_cache_pages()</span></code></a> to be called
after fscache_read_or_alloc_pages() as the former will try and release pages it
was given under certain circumstances.</p>
<p>This bit does not overlap with such as PG_private.  This means that FS-Cache
can be used with a filesystem that uses the block buffering code.</p>
<p>There are a number of operations defined on this flag:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int PageFsCache(struct page *page);
void SetPageFsCache(struct page *page)
void ClearPageFsCache(struct page *page)
int TestSetPageFsCache(struct page *page)
int TestClearPageFsCache(struct page *page)
</pre></div>
</div>
<p>These functions are bit test, bit set, bit clear, bit test and set and bit
test and clear operations on PG_fscache.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>