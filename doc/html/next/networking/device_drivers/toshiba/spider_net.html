

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Spidernet Device Driver &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
      <li>The Spidernet Device Driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/networking/device_drivers/toshiba/spider_net.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-spidernet-device-driver">
<h1>The Spidernet Device Driver<a class="headerlink" href="#the-spidernet-device-driver" title="Permalink to this headline">¶</a></h1>
<p>Written by Linas Vepstas &lt;<a class="reference external" href="mailto:linas&#37;&#52;&#48;austin&#46;ibm&#46;com">linas<span>&#64;</span>austin<span>&#46;</span>ibm<span>&#46;</span>com</a>&gt;</p>
<p>Version of 7 June 2007</p>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>This document sketches the structure of portions of the spidernet
device driver in the Linux kernel tree. The spidernet is a gigabit
ethernet device built into the Toshiba southbridge commonly used
in the SONY Playstation 3 and the IBM QS20 Cell blade.</p>
</div>
<div class="section" id="the-structure-of-the-rx-ring">
<h2>The Structure of the RX Ring.<a class="headerlink" href="#the-structure-of-the-rx-ring" title="Permalink to this headline">¶</a></h2>
<p>The receive (RX) ring is a circular linked list of RX descriptors,
together with three pointers into the ring that are used to manage its
contents.</p>
<p>The elements of the ring are called “descriptors” or “descrs”; they
describe the received data. This includes a pointer to a buffer
containing the received data, the buffer size, and various status bits.</p>
<p>There are three primary states that a descriptor can be in: “empty”,
“full” and “not-in-use”.  An “empty” or “ready” descriptor is ready
to receive data from the hardware. A “full” descriptor has data in it,
and is waiting to be emptied and processed by the OS. A “not-in-use”
descriptor is neither empty or full; it is simply not ready. It may
not even have a data buffer in it, or is otherwise unusable.</p>
<p>During normal operation, on device startup, the OS (specifically, the
spidernet device driver) allocates a set of RX descriptors and RX
buffers. These are all marked “empty”, ready to receive data. This
ring is handed off to the hardware, which sequentially fills in the
buffers, and marks them “full”. The OS follows up, taking the full
buffers, processing them, and re-marking them empty.</p>
<p>This filling and emptying is managed by three pointers, the “head”
and “tail” pointers, managed by the OS, and a hardware current
descriptor pointer (GDACTDPA). The GDACTDPA points at the descr
currently being filled. When this descr is filled, the hardware
marks it full, and advances the GDACTDPA by one.  Thus, when there is
flowing RX traffic, every descr behind it should be marked “full”,
and everything in front of it should be “empty”.  If the hardware
discovers that the current descr is not empty, it will signal an
interrupt, and halt processing.</p>
<p>The tail pointer tails or trails the hardware pointer. When the
hardware is ahead, the tail pointer will be pointing at a “full”
descr. The OS will process this descr, and then mark it “not-in-use”,
and advance the tail pointer.  Thus, when there is flowing RX traffic,
all of the descrs in front of the tail pointer should be “full”, and
all of those behind it should be “not-in-use”. When RX traffic is not
flowing, then the tail pointer can catch up to the hardware pointer.
The OS will then note that the current tail is “empty”, and halt
processing.</p>
<p>The head pointer (somewhat mis-named) follows after the tail pointer.
When traffic is flowing, then the head pointer will be pointing at
a “not-in-use” descr. The OS will perform various housekeeping duties
on this descr. This includes allocating a new data buffer and
dma-mapping it so as to make it visible to the hardware. The OS will
then mark the descr as “empty”, ready to receive data. Thus, when there
is flowing RX traffic, everything in front of the head pointer should
be “not-in-use”, and everything behind it should be “empty”. If no
RX traffic is flowing, then the head pointer can catch up to the tail
pointer, at which point the OS will notice that the head descr is
“empty”, and it will halt processing.</p>
<p>Thus, in an idle system, the GDACTDPA, tail and head pointers will
all be pointing at the same descr, which should be “empty”. All of the
other descrs in the ring should be “empty” as well.</p>
<p>The show_rx_chain() routine will print out the locations of the
GDACTDPA, tail and head pointers. It will also summarize the contents
of the ring, starting at the tail pointer, and listing the status
of the descrs that follow.</p>
<p>A typical example of the output, for a nearly idle system, might be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>net eth1: Total number of descrs=256
net eth1: Chain tail located at descr=20
net eth1: Chain head is at 20
net eth1: HW curr desc (GDACTDPA) is at 21
net eth1: Have 1 descrs with stat=x40800101
net eth1: HW next desc (GDACNEXTDA) is at 22
net eth1: Last 255 descrs with stat=xa0800000
</pre></div>
</div>
<p>In the above, the hardware has filled in one descr, number 20. Both
head and tail are pointing at 20, because it has not yet been emptied.
Meanwhile, hw is pointing at 21, which is free.</p>
<p>The “Have nnn decrs” refers to the descr starting at the tail: in this
case, nnn=1 descr, starting at descr 20. The “Last nnn descrs” refers
to all of the rest of the descrs, from the last status change. The “nnn”
is a count of how many descrs have exactly the same status.</p>
<p>The status x4… corresponds to “full” and status xa… corresponds
to “empty”. The actual value printed is RXCOMST_A.</p>
<p>In the device driver source code, a different set of names are
used for these same concepts, so that:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;empty&quot; == SPIDER_NET_DESCR_CARDOWNED == 0xa
&quot;full&quot;  == SPIDER_NET_DESCR_FRAME_END == 0x4
&quot;not in use&quot; == SPIDER_NET_DESCR_NOT_IN_USE == 0xf
</pre></div>
</div>
</div>
<div class="section" id="the-rx-ram-full-bug-feature">
<h2>The RX RAM full bug/feature<a class="headerlink" href="#the-rx-ram-full-bug-feature" title="Permalink to this headline">¶</a></h2>
<p>As long as the OS can empty out the RX buffers at a rate faster than
the hardware can fill them, there is no problem. If, for some reason,
the OS fails to empty the RX ring fast enough, the hardware GDACTDPA
pointer will catch up to the head, notice the not-empty condition,
ad stop. However, RX packets may still continue arriving on the wire.
The spidernet chip can save some limited number of these in local RAM.
When this local ram fills up, the spider chip will issue an interrupt
indicating this (GHIINT0STS will show ERRINT, and the GRMFLLINT bit
will be set in GHIINT1STS).  When the RX ram full condition occurs,
a certain bug/feature is triggered that has to be specially handled.
This section describes the special handling for this condition.</p>
<p>When the OS finally has a chance to run, it will empty out the RX ring.
In particular, it will clear the descriptor on which the hardware had
stopped. However, once the hardware has decided that a certain
descriptor is invalid, it will not restart at that descriptor; instead
it will restart at the next descr. This potentially will lead to a
deadlock condition, as the tail pointer will be pointing at this descr,
which, from the OS point of view, is empty; the OS will be waiting for
this descr to be filled. However, the hardware has skipped this descr,
and is filling the next descrs. Since the OS doesn’t see this, there
is a potential deadlock, with the OS waiting for one descr to fill,
while the hardware is waiting for a different set of descrs to become
empty.</p>
<p>A call to show_rx_chain() at this point indicates the nature of the
problem. A typical print when the network is hung shows the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>net eth1: Spider RX RAM full, incoming packets might be discarded!
net eth1: Total number of descrs=256
net eth1: Chain tail located at descr=255
net eth1: Chain head is at 255
net eth1: HW curr desc (GDACTDPA) is at 0
net eth1: Have 1 descrs with stat=xa0800000
net eth1: HW next desc (GDACNEXTDA) is at 1
net eth1: Have 127 descrs with stat=x40800101
net eth1: Have 1 descrs with stat=x40800001
net eth1: Have 126 descrs with stat=x40800101
net eth1: Last 1 descrs with stat=xa0800000
</pre></div>
</div>
<p>Both the tail and head pointers are pointing at descr 255, which is
marked xa… which is “empty”. Thus, from the OS point of view, there
is nothing to be done. In particular, there is the implicit assumption
that everything in front of the “empty” descr must surely also be empty,
as explained in the last section. The OS is waiting for descr 255 to
become non-empty, which, in this case, will never happen.</p>
<p>The HW pointer is at descr 0. This descr is marked 0x4.. or “full”.
Since its already full, the hardware can do nothing more, and thus has
halted processing. Notice that descrs 0 through 254 are all marked
“full”, while descr 254 and 255 are empty. (The “Last 1 descrs” is
descr 254, since tail was at 255.) Thus, the system is deadlocked,
and there can be no forward progress; the OS thinks there’s nothing
to do, and the hardware has nowhere to put incoming data.</p>
<p>This bug/feature is worked around with the spider_net_resync_head_ptr()
routine. When the driver receives RX interrupts, but an examination
of the RX chain seems to show it is empty, then it is probable that
the hardware has skipped a descr or two (sometimes dozens under heavy
network conditions). The spider_net_resync_head_ptr() subroutine will
search the ring for the next full descr, and the driver will resume
operations there.  Since this will leave “holes” in the ring, there
is also a spider_net_resync_tail_ptr() that will skip over such holes.</p>
<p>As of this writing, the spider_net_resync() strategy seems to work very
well, even under heavy network loads.</p>
</div>
<div class="section" id="the-tx-ring">
<h2>The TX ring<a class="headerlink" href="#the-tx-ring" title="Permalink to this headline">¶</a></h2>
<p>The TX ring uses a low-watermark interrupt scheme to make sure that
the TX queue is appropriately serviced for large packet sizes.</p>
<p>For packet sizes greater than about 1KBytes, the kernel can fill
the TX ring quicker than the device can drain it. Once the ring
is full, the netdev is stopped. When there is room in the ring,
the netdev needs to be reawakened, so that more TX packets are placed
in the ring. The hardware can empty the ring about four times per jiffy,
so its not appropriate to wait for the poll routine to refill, since
the poll routine runs only once per jiffy.  The low-watermark mechanism
marks a descr about 1/4th of the way from the bottom of the queue, so
that an interrupt is generated when the descr is processed. This
interrupt wakes up the netdev, which can then refill the queue.
For large packets, this mechanism generates a relatively small number
of interrupts, about 1K/sec. For smaller packets, this will drop to zero
interrupts, as the hardware can empty the queue faster than the kernel
can fill it.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>