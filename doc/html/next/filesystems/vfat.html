

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>VFAT &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>VFAT</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/vfat.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vfat">
<h1>VFAT<a class="headerlink" href="#vfat" title="Permalink to this headline">¶</a></h1>
<div class="section" id="using-vfat">
<h2>USING VFAT<a class="headerlink" href="#using-vfat" title="Permalink to this headline">¶</a></h2>
<p>To use the vfat filesystem, use the filesystem type ‘vfat’.  i.e.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t vfat /dev/fd0 /mnt
</pre></div>
</div>
<p>No special partition formatter is required,
‘mkdosfs’ will work fine if you want to format from within Linux.</p>
</div>
<div class="section" id="vfat-mount-options">
<h2>VFAT MOUNT OPTIONS<a class="headerlink" href="#vfat-mount-options" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><strong>uid=###</strong></dt>
<dd>Set the owner of all files on this filesystem.
The default is the uid of current process.</dd>
<dt><strong>gid=###</strong></dt>
<dd>Set the group of all files on this filesystem.
The default is the gid of current process.</dd>
<dt><strong>umask=###</strong></dt>
<dd>The permission mask (for files and directories, see <em>umask(1)</em>).
The default is the umask of current process.</dd>
<dt><strong>dmask=###</strong></dt>
<dd>The permission mask for the directory.
The default is the umask of current process.</dd>
<dt><strong>fmask=###</strong></dt>
<dd>The permission mask for files.
The default is the umask of current process.</dd>
<dt><strong>allow_utime=###</strong></dt>
<dd><p class="first">This option controls the permission check of mtime/atime.</p>
<blockquote>
<div><p><strong>-20</strong>: If current process is in group of file’s group ID,
you can change timestamp.</p>
<p><strong>-2</strong>: Other users can change timestamp.</p>
</div></blockquote>
<p>The default is set from dmask option. If the directory is
writable, utime(2) is also allowed. i.e. ~dmask &amp; 022.</p>
<p class="last">Normally utime(2) checks current process is owner of
the file, or it has CAP_FOWNER capability. But FAT
filesystem doesn’t have uid/gid on disk, so normal
check is too unflexible. With this option you can
relax it.</p>
</dd>
<dt><strong>codepage=###</strong></dt>
<dd>Sets the codepage number for converting to shortname
characters on FAT filesystem.
By default, FAT_DEFAULT_CODEPAGE setting is used.</dd>
<dt><strong>iocharset=&lt;name&gt;</strong></dt>
<dd><p class="first">Character set to use for converting between the
encoding is used for user visible filename and 16 bit
Unicode characters. Long filenames are stored on disk
in Unicode format, but Unix for the most part doesn’t
know how to deal with Unicode.
By default, FAT_DEFAULT_IOCHARSET setting is used.</p>
<p class="last">There is also an option of doing UTF-8 translations
with the utf8 option.</p>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">iocharset=utf8</span></code> is not recommended. If unsure, you should consider
the utf8 option instead.</p>
</div>
<dl class="docutils">
<dt><strong>utf8=&lt;bool&gt;</strong></dt>
<dd>UTF-8 is the filesystem safe version of Unicode that
is used by the console. It can be enabled or disabled
for the filesystem with this option.
If ‘uni_xlate’ gets set, UTF-8 gets disabled.
By default, FAT_DEFAULT_UTF8 setting is used.</dd>
<dt><strong>uni_xlate=&lt;bool&gt;</strong></dt>
<dd>Translate unhandled Unicode characters to special
escaped sequences.  This would let you backup and
restore filenames that are created with any Unicode
characters.  Until Linux supports Unicode for real,
this gives you an alternative.  Without this option,
a ‘?’ is used when no translation is possible.  The
escape character is ‘:’ because it is otherwise
illegal on the vfat filesystem.  The escape sequence
that gets used is ‘:’ and the four digits of hexadecimal
unicode.</dd>
<dt><strong>nonumtail=&lt;bool&gt;</strong></dt>
<dd>When creating 8.3 aliases, normally the alias will
end in ‘~1’ or tilde followed by some number.  If this
option is set, then if the filename is
“longfilename.txt” and “longfile.txt” does not
currently exist in the directory, longfile.txt will
be the short alias instead of longfi~1.txt.</dd>
<dt><strong>usefree</strong></dt>
<dd>Use the “free clusters” value stored on FSINFO. It will
be used to determine number of free clusters without
scanning disk. But it’s not used by default, because
recent Windows don’t update it correctly in some
case. If you are sure the “free clusters” on FSINFO is
correct, by this option you can avoid scanning disk.</dd>
<dt><strong>quiet</strong></dt>
<dd>Stops printing certain warning messages.</dd>
<dt><strong>check=s|r|n</strong></dt>
<dd><p class="first">Case sensitivity checking setting.</p>
<p><strong>s</strong>: strict, case sensitive</p>
<p><strong>r</strong>: relaxed, case insensitive</p>
<p class="last"><strong>n</strong>: normal, default setting, currently case insensitive</p>
</dd>
<dt><strong>nocase</strong></dt>
<dd>This was deprecated for vfat. Use <code class="docutils literal notranslate"><span class="pre">shortname=win95</span></code> instead.</dd>
<dt><strong>shortname=lower|win95|winnt|mixed</strong></dt>
<dd><p class="first">Shortname display/create setting.</p>
<p><strong>lower</strong>: convert to lowercase for display,
emulate the Windows 95 rule for create.</p>
<p><strong>win95</strong>: emulate the Windows 95 rule for display/create.</p>
<p><strong>winnt</strong>: emulate the Windows NT rule for display/create.</p>
<p><strong>mixed</strong>: emulate the Windows NT rule for display,
emulate the Windows 95 rule for create.</p>
<p class="last">Default setting is <cite>mixed</cite>.</p>
</dd>
<dt><strong>tz=UTC</strong></dt>
<dd>Interpret timestamps as UTC rather than local time.
This option disables the conversion of timestamps
between local time (as used by Windows on FAT) and UTC
(which Linux uses internally).  This is particularly
useful when mounting devices (like digital cameras)
that are set to UTC in order to avoid the pitfalls of
local time.</dd>
<dt><strong>time_offset=minutes</strong></dt>
<dd>Set offset for conversion of timestamps from local time
used by FAT to UTC. I.e. &lt;minutes&gt; minutes will be subtracted
from each timestamp to convert it to UTC used internally by
Linux. This is useful when time zone set in <code class="docutils literal notranslate"><span class="pre">sys_tz</span></code> is
not the time zone used by the filesystem. Note that this
option still does not provide correct time stamps in all
cases in presence of DST - time stamps in a different DST
setting will be off by one hour.</dd>
<dt><strong>showexec</strong></dt>
<dd>If set, the execute permission bits of the file will be
allowed only if the extension part of the name is .EXE,
.COM, or .BAT. Not set by default.</dd>
<dt><strong>debug</strong></dt>
<dd>Can be set, but unused by the current implementation.</dd>
<dt><strong>sys_immutable</strong></dt>
<dd>If set, ATTR_SYS attribute on FAT is handled as
IMMUTABLE flag on Linux. Not set by default.</dd>
<dt><strong>flush</strong></dt>
<dd>If set, the filesystem will try to flush to disk more
early than normal. Not set by default.</dd>
<dt><strong>rodir</strong></dt>
<dd><p class="first">FAT has the ATTR_RO (read-only) attribute. On Windows,
the ATTR_RO of the directory will just be ignored,
and is used only by applications as a flag (e.g. it’s set
for the customized folder).</p>
<p class="last">If you want to use ATTR_RO as read-only flag even for
the directory, set this option.</p>
</dd>
<dt><strong>errors=panic|continue|remount-ro</strong></dt>
<dd>specify FAT behavior on critical errors: panic, continue
without doing anything or remount the partition in
read-only mode (default behavior).</dd>
<dt><strong>discard</strong></dt>
<dd>If set, issues discard/TRIM commands to the block
device when blocks are freed. This is useful for SSD devices
and sparse/thinly-provisoned LUNs.</dd>
<dt><strong>nfs=stale_rw|nostale_ro</strong></dt>
<dd><p class="first">Enable this only if you want to export the FAT filesystem
over NFS.</p>
<blockquote>
<div><p><strong>stale_rw</strong>: This option maintains an index (cache) of directory
<em>inodes</em> by <em>i_logstart</em> which is used by the nfs-related code to
improve look-ups. Full file operations (read/write) over NFS is
supported but with cache eviction at NFS server, this could
result in ESTALE issues.</p>
<p><strong>nostale_ro</strong>: This option bases the <em>inode</em> number and filehandle
on the on-disk location of a file in the MS-DOS directory entry.
This ensures that ESTALE will not be returned after a file is
evicted from the inode cache. However, it means that operations
such as rename, create and unlink could cause filehandles that
previously pointed at one file to point at a different file,
potentially causing data corruption. For this reason, this
option also mounts the filesystem readonly.</p>
</div></blockquote>
<p class="last">To maintain backward compatibility, <code class="docutils literal notranslate"><span class="pre">'-o</span> <span class="pre">nfs'</span></code> is also accepted,
defaulting to “stale_rw”.</p>
</dd>
<dt><strong>dos1xfloppy  &lt;bool&gt;: 0,1,yes,no,true,false</strong></dt>
<dd>If set, use a fallback default BIOS Parameter Block
configuration, determined by backing device size. These static
parameters match defaults assumed by DOS 1.x for 160 kiB,
180 kiB, 320 kiB, and 360 kiB floppies and floppy images.</dd>
</dl>
</div>
<div class="section" id="limitation">
<h2>LIMITATION<a class="headerlink" href="#limitation" title="Permalink to this headline">¶</a></h2>
<p>The fallocated region of file is discarded at umount/evict time
when using fallocate with FALLOC_FL_KEEP_SIZE.
So, User should assume that fallocated region can be discarded at
last close if there is memory pressure resulting in eviction of
the inode from the memory. As a result, for any dependency on
the fallocated region, user should make sure to recheck fallocate
after reopening the file.</p>
</div>
<div class="section" id="todo">
<h2>TODO<a class="headerlink" href="#todo" title="Permalink to this headline">¶</a></h2>
<p>Need to get rid of the raw scanning stuff.  Instead, always use
a get next directory entry approach.  The only thing left that uses
raw scanning is the directory renaming code.</p>
</div>
<div class="section" id="possible-problems">
<h2>POSSIBLE PROBLEMS<a class="headerlink" href="#possible-problems" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>vfat_valid_longname does not properly checked reserved names.</li>
<li>When a volume name is the same as a directory name in the root
directory of the filesystem, the directory name sometimes shows
up as an empty file.</li>
<li>autoconv option does not work correctly.</li>
</ul>
</div>
<div class="section" id="test-suite">
<h2>TEST SUITE<a class="headerlink" href="#test-suite" title="Permalink to this headline">¶</a></h2>
<p>If you plan to make any modifications to the vfat filesystem, please
get the test suite that comes with the vfat distribution at</p>
<p><a class="reference external" href="http://web.archive.org/web/*/http://bmrc.berkeley.edu/people/chaffee/vfat.html">http://web.archive.org/web/*/http://bmrc.berkeley.edu/people/chaffee/vfat.html</a></p>
<p>This tests quite a few parts of the vfat filesystem and additional
tests for new features or untested features would be appreciated.</p>
</div>
<div class="section" id="notes-on-the-structure-of-the-vfat-filesystem">
<h2>NOTES ON THE STRUCTURE OF THE VFAT FILESYSTEM<a class="headerlink" href="#notes-on-the-structure-of-the-vfat-filesystem" title="Permalink to this headline">¶</a></h2>
<p>This documentation was provided by Galen C. Hunt <a class="reference external" href="mailto:gchunt&#37;&#52;&#48;cs&#46;rochester&#46;edu">gchunt<span>&#64;</span>cs<span>&#46;</span>rochester<span>&#46;</span>edu</a> and
lightly annotated by Gordon Chaffee.</p>
<p>This document presents a very rough, technical overview of my
knowledge of the extended FAT file system used in Windows NT 3.5 and
Windows 95.  I don’t guarantee that any of the following is correct,
but it appears to be so.</p>
<p>The extended FAT file system is almost identical to the FAT
file system used in DOS versions up to and including <em>6.223410239847</em>
:-).  The significant change has been the addition of long file names.
These names support up to 255 characters including spaces and lower
case characters as opposed to the traditional 8.3 short names.</p>
<p>Here is the description of the traditional FAT entry in the current
Windows 95 filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct directory { // Short 8.3 names
        unsigned char name[8];          // file name
        unsigned char ext[3];           // file extension
        unsigned char attr;             // attribute byte
        unsigned char lcase;            // Case for base and extension
        unsigned char ctime_ms;         // Creation time, milliseconds
        unsigned char ctime[2];         // Creation time
        unsigned char cdate[2];         // Creation date
        unsigned char adate[2];         // Last access date
        unsigned char reserved[2];      // reserved values (ignored)
        unsigned char time[2];          // time stamp
        unsigned char date[2];          // date stamp
        unsigned char start[2];         // starting cluster number
        unsigned char size[4];          // size of the file
};
</pre></div>
</div>
<p>The lcase field specifies if the base and/or the extension of an 8.3
name should be capitalized.  This field does not seem to be used by
Windows 95 but it is used by Windows NT.  The case of filenames is not
completely compatible from Windows NT to Windows 95.  It is not completely
compatible in the reverse direction, however.  Filenames that fit in
the 8.3 namespace and are written on Windows NT to be lowercase will
show up as uppercase on Windows 95.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that the <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> values are actually little
endian integer values.  The descriptions of the fields in this
structure are public knowledge and can be found elsewhere.</p>
</div>
<p>With the extended FAT system, Microsoft has inserted extra
directory entries for any files with extended names.  (Any name which
legally fits within the old 8.3 encoding scheme does not have extra
entries.)  I call these extra entries slots.  Basically, a slot is a
specially formatted directory entry which holds up to 13 characters of
a file’s extended name.  Think of slots as additional labeling for the
directory entry of the file to which they correspond.  Microsoft
prefers to refer to the 8.3 entry for a file as its alias and the
extended slot directory entries as the file name.</p>
<p>The C structure for a slot directory entry follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slot { // Up to 13 characters of a long name
        unsigned char id;               // sequence number for slot
        unsigned char name0_4[10];      // first 5 characters in name
        unsigned char attr;             // attribute byte
        unsigned char reserved;         // always 0
        unsigned char alias_checksum;   // checksum for 8.3 alias
        unsigned char name5_10[12];     // 6 more characters in name
        unsigned char start[2];         // starting cluster number
        unsigned char name11_12[4];     // last 2 characters in name
};
</pre></div>
</div>
<p>If the layout of the slots looks a little odd, it’s only
because of Microsoft’s efforts to maintain compatibility with old
software.  The slots must be disguised to prevent old software from
panicking.  To this end, a number of measures are taken:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The attribute byte for a slot directory entry is always set
to 0x0f.  This corresponds to an old directory entry with
attributes of “hidden”, “system”, “read-only”, and “volume
label”.  Most old software will ignore any directory
entries with the “volume label” bit set.  Real volume label
entries don’t have the other three bits set.</li>
<li>The starting cluster is always set to 0, an impossible
value for a DOS file.</li>
</ol>
</div></blockquote>
<p>Because the extended FAT system is backward compatible, it is
possible for old software to modify directory entries.  Measures must
be taken to ensure the validity of slots.  An extended FAT system can
verify that a slot does in fact belong to an 8.3 directory entry by
the following:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Positioning.  Slots for a file always immediately proceed
their corresponding 8.3 directory entry.  In addition, each
slot has an id which marks its order in the extended file
name.  Here is a very abbreviated view of an 8.3 directory
entry and its corresponding long name slots for the file
“My Big File.Extension which is long”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;proceeding files...&gt;
&lt;slot #3, id = 0x43, characters = &quot;h is long&quot;&gt;
&lt;slot #2, id = 0x02, characters = &quot;xtension whic&quot;&gt;
&lt;slot #1, id = 0x01, characters = &quot;My Big File.E&quot;&gt;
&lt;directory entry, name = &quot;MYBIGFIL.EXT&quot;&gt;
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that the slots are stored from last to first.  Slots
are numbered from 1 to N.  The Nth slot is <code class="docutils literal notranslate"><span class="pre">or'ed</span></code> with
0x40 to mark it as the last one.</p>
</div>
</li>
<li><p class="first">Checksum.  Each slot has an alias_checksum value.  The
checksum is calculated from the 8.3 name using the
following algorithm:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (sum = i = 0; i &lt; 11; i++) {
        sum = (((sum&amp;1)&lt;&lt;7)|((sum&amp;0xfe)&gt;&gt;1)) + name[i]
}
</pre></div>
</div>
</li>
<li><p class="first">If there is free space in the final slot, a Unicode <code class="docutils literal notranslate"><span class="pre">NULL</span> <span class="pre">(0x0000)</span></code>
is stored after the final character.  After that, all unused
characters in the final slot are set to Unicode 0xFFFF.</p>
</li>
</ol>
</div></blockquote>
<p>Finally, note that the extended name is stored in Unicode.  Each Unicode
character takes either two or four bytes, UTF-16LE encoded.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>