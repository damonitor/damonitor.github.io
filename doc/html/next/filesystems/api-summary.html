

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux Filesystems API summary &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Linux Filesystems API summary</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/api-summary.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-filesystems-api-summary">
<h1>Linux Filesystems API summary<a class="headerlink" href="#linux-filesystems-api-summary" title="Permalink to this headline">¶</a></h1>
<p>This section contains API-level documentation, mostly taken from the source
code itself.</p>
<div class="section" id="the-linux-vfs">
<h2>The Linux VFS<a class="headerlink" href="#the-linux-vfs" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-filesystem-types">
<h3>The Filesystem types<a class="headerlink" href="#the-filesystem-types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.positive_aop_returns">
enum <code class="descname">positive_aop_returns</code><a class="headerlink" href="#c.positive_aop_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>aop return codes with specific semantics</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">AOP_WRITEPAGE_ACTIVATE</span></code></dt>
<dd>Informs the caller that page writeback has
completed, that the page is still locked, and
should be considered active.  The VM uses this hint
to return the page to the active list – it won’t
be a candidate for writeback again in the near
future.  Other callers must be careful to unlock
the page if they get this return.  Returned by
writepage();</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AOP_TRUNCATED_PAGE</span></code></dt>
<dd>The AOP method that was handed a locked page has
unlocked it and the page might have been truncated.
The caller should back up to acquiring a new page and
trying again.  The aop will be taking reasonable
precautions not to livelock.  If the caller held a page
reference, it should drop it before retrying.  Returned
by readpage().</dd>
</dl>
<p><strong>Description</strong></p>
<p>address_space_operation functions return these large constants to indicate
special semantics to the caller.  These are much larger than the bytes in a
page to allow for functions that return the number of bytes operated on in a
given page.</p>
<dl class="type">
<dt id="c.address_space">
struct <code class="descname">address_space</code><a class="headerlink" href="#c.address_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Contents of a cacheable, mappable object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct address_space {
  struct inode            *host;
  struct xarray           i_pages;
  gfp_t gfp_mask;
  atomic_t i_mmap_writable;
#ifdef CONFIG_READ_ONLY_THP_FOR_FS;
  atomic_t nr_thps;
#endif;
  struct rb_root_cached   i_mmap;
  struct rw_semaphore     i_mmap_rwsem;
  unsigned long           nrpages;
  unsigned long           nrexceptional;
  pgoff_t writeback_index;
  const struct address_space_operations *a_ops;
  unsigned long           flags;
  errseq_t wb_err;
  spinlock_t private_lock;
  struct list_head        private_list;
  void *private_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">host</span></code></dt>
<dd>Owner, either the inode or the block_device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_pages</span></code></dt>
<dd>Cached pages.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_mask</span></code></dt>
<dd>Memory allocation flags to use for allocating pages.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_mmap_writable</span></code></dt>
<dd>Number of VM_SHARED mappings.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_thps</span></code></dt>
<dd>Number of THPs in the pagecache (non-shmem only).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_mmap</span></code></dt>
<dd>Tree of private and shared mappings.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_mmap_rwsem</span></code></dt>
<dd>Protects <strong>i_mmap</strong> and <strong>i_mmap_writable</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nrpages</span></code></dt>
<dd>Number of page entries, protected by the i_pages lock.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nrexceptional</span></code></dt>
<dd>Shadow or DAX entries, protected by the i_pages lock.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writeback_index</span></code></dt>
<dd>Writeback starts here.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">a_ops</span></code></dt>
<dd>Methods.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>Error bits and flags (AS_*).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wb_err</span></code></dt>
<dd>The most recent error which has occurred.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_lock</span></code></dt>
<dd>For use by the owner of the address_space.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_list</span></code></dt>
<dd>For use by the owner of the address_space.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt>
<dd>For use by the owner of the address_space.</dd>
</dl>
<dl class="function">
<dt id="c.sb_end_write">
void <code class="descname">sb_end_write</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_end_write" title="Permalink to this definition">¶</a></dt>
<dd><p>drop write access to a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we wrote to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement number of writers to the filesystem. Wake up possible waiters
wanting to freeze the filesystem.</p>
<dl class="function">
<dt id="c.sb_end_pagefault">
void <code class="descname">sb_end_pagefault</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_end_pagefault" title="Permalink to this definition">¶</a></dt>
<dd><p>drop write access to a superblock from a page fault</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we wrote to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement number of processes handling write page fault to the filesystem.
Wake up possible waiters wanting to freeze the filesystem.</p>
<dl class="function">
<dt id="c.sb_end_intwrite">
void <code class="descname">sb_end_intwrite</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_end_intwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>drop write access to a superblock for internal fs purposes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we wrote to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement fs-internal number of writers to the filesystem.  Wake up possible
waiters wanting to freeze the filesystem.</p>
<dl class="function">
<dt id="c.sb_start_write">
void <code class="descname">sb_start_write</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_start_write" title="Permalink to this definition">¶</a></dt>
<dd><p>get write access to a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we write to</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a process wants to write data or metadata to a file system (i.e. dirty
a page or an inode), it should embed the operation in a <a class="reference internal" href="#c.sb_start_write" title="sb_start_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_start_write()</span></code></a> -
<a class="reference internal" href="#c.sb_end_write" title="sb_end_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_end_write()</span></code></a> pair to get exclusion against file system freezing. This
function increments number of writers preventing freezing. If the file
system is already frozen, the function waits until the file system is
thawed.</p>
<p>Since freeze protection behaves as a lock, users have to preserve
ordering of freeze protection and other filesystem locks. Generally,
freeze protection should be the outermost lock. In particular, we have:</p>
<dl class="docutils">
<dt>sb_start_write</dt>
<dd>-&gt; i_mutex                 (write path, truncate, directory ops, …)
-&gt; s_umount                (freeze_super, thaw_super)</dd>
</dl>
<dl class="function">
<dt id="c.sb_start_pagefault">
void <code class="descname">sb_start_pagefault</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_start_pagefault" title="Permalink to this definition">¶</a></dt>
<dd><p>get write access to a superblock from a page fault</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we write to</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a process starts handling write page fault, it should embed the
operation into <a class="reference internal" href="#c.sb_start_pagefault" title="sb_start_pagefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_start_pagefault()</span></code></a> - <a class="reference internal" href="#c.sb_end_pagefault" title="sb_end_pagefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_end_pagefault()</span></code></a> pair to get
exclusion against file system freezing. This is needed since the page fault
is going to dirty a page. This function increments number of running page
faults preventing freezing. If the file system is already frozen, the
function waits until the file system is thawed.</p>
<p>Since page fault freeze protection behaves as a lock, users have to preserve
ordering of freeze protection and other filesystem locks. It is advised to
put <a class="reference internal" href="#c.sb_start_pagefault" title="sb_start_pagefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">sb_start_pagefault()</span></code></a> close to mmap_lock in lock ordering. Page fault
handling code implies lock dependency:</p>
<dl class="docutils">
<dt>mmap_lock</dt>
<dd>-&gt; sb_start_pagefault</dd>
</dl>
<dl class="function">
<dt id="c.filemap_set_wb_err">
void <code class="descname">filemap_set_wb_err</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a> *<em>&nbsp;mapping</em>, int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_set_wb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>set a writeback error on an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping in which to set writeback error</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">err</span></code></dt>
<dd>error to be set in mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>When writeback fails in some way, we must record that error so that
userspace can be informed when fsync and the like are called.  We endeavor
to report errors on any file that was open at the time of the error.  Some
internal callers also need to know when writeback errors have occurred.</p>
<p>When a writeback error occurs, most filesystems will want to call
filemap_set_wb_err to record the error in the mapping so that it will be
automatically reported whenever fsync is called on the file.</p>
<dl class="function">
<dt id="c.filemap_check_wb_err">
int <code class="descname">filemap_check_wb_err</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a> *<em>&nbsp;mapping</em>, errseq_t<em>&nbsp;since</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_check_wb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>has an error occurred since the mark was sampled?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to check for writeback errors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">errseq_t</span> <span class="pre">since</span></code></dt>
<dd>previously-sampled errseq_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grab the errseq_t value from the mapping, and see if it has changed “since”
the given value was sampled.</p>
<p>If it has then report the latest error set, otherwise return 0.</p>
<dl class="function">
<dt id="c.filemap_sample_wb_err">
errseq_t <code class="descname">filemap_sample_wb_err</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a> *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_sample_wb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>sample the current errseq_t to test for later errors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to be sampled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writeback errors are always reported relative to a particular sample point
in the past. This function provides those sample points.</p>
<dl class="function">
<dt id="c.file_sample_sb_err">
errseq_t <code class="descname">file_sample_sb_err</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_sample_sb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>sample the current errseq_t to test for later errors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Grab the most current superblock-level errseq_t value for the given
struct file.</p>
</div>
<div class="section" id="the-directory-cache">
<h3>The Directory Cache<a class="headerlink" href="#the-directory-cache" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.d_find_any_alias">
struct dentry * <code class="descname">d_find_any_alias</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_find_any_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>find any alias for a given inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to find an alias for</dd>
</dl>
<p><strong>Description</strong></p>
<p>If any aliases exist for the given inode, take and return a
reference for one of them.  If no aliases exist, return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="function">
<dt id="c.shrink_dcache_sb">
void <code class="descname">shrink_dcache_sb</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.shrink_dcache_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>shrink dcache for a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shrink the dcache for the specified super block. This is used to free
the dcache before unmounting a file system.</p>
<dl class="function">
<dt id="c.path_has_submounts">
int <code class="descname">path_has_submounts</code><span class="sig-paren">(</span>const struct path *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_has_submounts" title="Permalink to this definition">¶</a></dt>
<dd><p>check for mounts over a dentry in the current namespace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>path to check.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the parent or its subdirectories contain
a mount point in the current namespace.</p>
<dl class="function">
<dt id="c.shrink_dcache_parent">
void <code class="descname">shrink_dcache_parent</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.shrink_dcache_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>prune dcache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of entries to prune</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prune the dcache to remove unused children of the parent dentry.</p>
<dl class="function">
<dt id="c.d_invalidate">
void <code class="descname">d_invalidate</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>detach submounts, prune dcache, and drop</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry to invalidate (aka detach, prune and drop)</dd>
</dl>
<dl class="function">
<dt id="c.d_alloc">
struct dentry * <code class="descname">d_alloc</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;parent</em>, const struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a dcache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of entry to allocate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>qstr of the name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a dentry. It returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is insufficient memory
available. On a success the dentry is returned. The name passed in is
copied and the copy passed in may be reused after this call.</p>
<dl class="function">
<dt id="c.d_instantiate">
void <code class="descname">d_instantiate</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;entry</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_instantiate" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in inode information for a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>dentry to complete</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to attach to this dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in inode information in the entry.</p>
<p>This turns negative dentries into productive full members
of society.</p>
<p>NOTE! This assumes that the inode count has been incremented
(or otherwise set) by the caller to indicate that it is now
in use by the dcache.</p>
<dl class="function">
<dt id="c.d_obtain_alias">
struct dentry * <code class="descname">d_obtain_alias</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_obtain_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>find or allocate a DISCONNECTED dentry for a given inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to allocate the dentry for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain a dentry for an inode resulting from NFS filehandle conversion or
similar open by handle operations.  The returned dentry may be anonymous,
or may have a full name (if the inode was already in the cache).</p>
<p>When called on a directory inode, we must ensure that the inode only ever
has one dentry.  If a dentry is found, that is returned instead of
allocating a new one.</p>
<p>On successful return, the reference to the inode has been transferred
to the dentry.  In case of an error the reference on the inode is released.
To make it easier to use in export operations a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or IS_ERR inode may
be passed in and the error will be propagated to the return value,
with a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <strong>inode</strong> replaced by ERR_PTR(-ESTALE).</p>
<dl class="function">
<dt id="c.d_obtain_root">
struct dentry * <code class="descname">d_obtain_root</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_obtain_root" title="Permalink to this definition">¶</a></dt>
<dd><p>find or allocate a dentry for a given inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to allocate the dentry for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain an IS_ROOT dentry for the root of a filesystem.</p>
<p>We must ensure that directory inodes only ever have one dentry.  If a
dentry is found, that is returned instead of allocating a new one.</p>
<p>On successful return, the reference to the inode has been transferred
to the dentry.  In case of an error the reference on the inode is
released.  A <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or IS_ERR inode may be passed in and will be the
error will be propagate to the return value, with a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <strong>inode</strong>
replaced by ERR_PTR(-ESTALE).</p>
<dl class="function">
<dt id="c.d_add_ci">
struct dentry * <code class="descname">d_add_ci</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct inode *<em>&nbsp;inode</em>, struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_add_ci" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup or allocate new dentry with case-exact name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>the negative dentry that was passed to the parent’s lookup func</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode case-insensitive lookup has found</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the case-exact name to be associated with the returned dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is to avoid filling the dcache with case-insensitive names to the
same inode, only the actual correct case is stored in the dcache for
case-insensitive filesystems.</p>
<p>For a case-insensitive lookup match and if the the case-exact dentry
already exists in in the dcache, use it and return it.</p>
<p>If no entry exists with the exact case name, allocate new dentry with
the exact case, and return the spliced entry.</p>
<dl class="function">
<dt id="c.d_lookup">
struct dentry * <code class="descname">d_lookup</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;parent</em>, const struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>search for a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent dentry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>qstr of name we wish to find</dd>
</dl>
<p><strong>Return</strong></p>
<p>dentry, or NULL</p>
<p><strong>Description</strong></p>
<p>d_lookup searches the children of the parent dentry for the name in
question. If the dentry is found its reference count is incremented and the
dentry is returned. The caller must use dput to free the entry when it has
finished using it. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if the dentry does not exist.</p>
<dl class="function">
<dt id="c.d_hash_and_lookup">
struct dentry * <code class="descname">d_hash_and_lookup</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dir</em>, struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_hash_and_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>hash the qstr then search for a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>Directory to search in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>qstr of name we wish to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>On lookup failure NULL is returned; on bad name - ERR_PTR(-error)</p>
<dl class="function">
<dt id="c.d_delete">
void <code class="descname">d_delete</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry to delete</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the dentry into a negative dentry if possible, otherwise
remove it from the hash queues so it can be deleted later</p>
<dl class="function">
<dt id="c.d_rehash">
void <code class="descname">d_rehash</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_rehash" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry back to the hash</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>dentry to add to the hash</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a dentry to the hash according to its name.</p>
<dl class="function">
<dt id="c.d_add">
void <code class="descname">d_add</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;entry</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add dentry to hash queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>dentry to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>The inode to attach to this dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds the entry to the hash queues and initializes <strong>inode</strong>.
The entry was actually filled in earlier during <a class="reference internal" href="#c.d_alloc" title="d_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_alloc()</span></code></a>.</p>
<dl class="function">
<dt id="c.d_exact_alias">
struct dentry * <code class="descname">d_exact_alias</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;entry</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_exact_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>find and hash an exact unhashed alias</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>dentry to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>The inode to go with this dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an unhashed dentry with the same name/parent and desired
inode already exists, hash and return it.  Otherwise, return
NULL.</p>
<p>Parent directory should be locked.</p>
<dl class="function">
<dt id="c.d_splice_alias">
struct dentry * <code class="descname">d_splice_alias</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_splice_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>splice a disconnected dentry into the tree if one exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode which may have a disconnected dentry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>a negative dentry which we want to point to the inode.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If inode is a directory and has an IS_ROOT alias, then d_move that in
place of the given dentry and return it, else simply d_add the inode
to the dentry and return NULL.</p>
<p>If a non-IS_ROOT directory is found, the filesystem is corrupt, and
we should error out: directories can’t have multiple aliases.</p>
<p>This is needed in the lookup routine of any filesystem that is exportable
(via knfsd) so that we can build dcache paths to directories effectively.</p>
<p>If a dentry was found and moved, then it is returned.  Otherwise NULL
is returned.  This matches the expected return value of -&gt;lookup.</p>
<p>Cluster filesystems may call this function with a negative, hashed dentry.
In that case, we know that the inode will be a regular file, and also this
will only occur during atomic_open. So we need to check for the dentry
being already hashed only in the final case.</p>
<dl class="function">
<dt id="c.is_subdir">
bool <code class="descname">is_subdir</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;new_dentry</em>, struct dentry *<em>&nbsp;old_dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_subdir" title="Permalink to this definition">¶</a></dt>
<dd><p>is new dentry a subdirectory of old_dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">new_dentry</span></code></dt>
<dd>new dentry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">old_dentry</span></code></dt>
<dd>old dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if new_dentry is a subdirectory of the parent (at any depth).
Returns false otherwise.
Caller must ensure that “new_dentry” is pinned before calling <a class="reference internal" href="#c.is_subdir" title="is_subdir"><code class="xref c c-func docutils literal notranslate"><span class="pre">is_subdir()</span></code></a></p>
<dl class="function">
<dt id="c.dget_dlock">
struct dentry * <code class="descname">dget_dlock</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dget_dlock" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd><p class="first">dentry to get a reference to</p>
<p class="last">Given a dentry or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer increment the reference count
if appropriate and return the dentry. A dentry will not be
destroyed when it has references.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.d_unhashed">
int <code class="descname">d_unhashed</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_unhashed" title="Permalink to this definition">¶</a></dt>
<dd><p>is dentry hashed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd><p class="first">entry to check</p>
<p class="last">Returns true if the dentry passed is not currently hashed.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.d_really_is_negative">
bool <code class="descname">d_really_is_negative</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_really_is_negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a dentry is really negative (ignoring fallthroughs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the dentry represents either an absent name or a name that
doesn’t map to an inode (ie. -&gt;d_inode is NULL).  The dentry could represent
a true miss, a whiteout that isn’t represented by a 0,0 chardev or a
fallthrough marker in an opaque directory.</p>
<p>Note!  (1) This should be used <em>only</em> by a filesystem to examine its own
dentries.  It should not be used to look at some other filesystem’s
dentries.  (2) It should also be used in combination with <a class="reference internal" href="#c.d_inode" title="d_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_inode()</span></code></a> to get
the inode.  (3) The dentry may have something attached to -&gt;d_lower and the
type field of the flags may be set to something other than miss or whiteout.</p>
<dl class="function">
<dt id="c.d_really_is_positive">
bool <code class="descname">d_really_is_positive</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_really_is_positive" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a dentry is really positive (ignoring fallthroughs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the dentry represents a name that maps to an inode
(ie. -&gt;d_inode is not NULL).  The dentry might still represent a whiteout if
that is represented on medium as a 0,0 chardev.</p>
<p>Note!  (1) This should be used <em>only</em> by a filesystem to examine its own
dentries.  It should not be used to look at some other filesystem’s
dentries.  (2) It should also be used in combination with <a class="reference internal" href="#c.d_inode" title="d_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_inode()</span></code></a> to get
the inode.</p>
<dl class="function">
<dt id="c.d_inode">
struct inode * <code class="descname">d_inode</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the actual inode of this dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper normal filesystems should use to get at their own inodes
in their own dentries and ignore the layering superimposed upon them.</p>
<dl class="function">
<dt id="c.d_inode_rcu">
struct inode * <code class="descname">d_inode_rcu</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_inode_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the actual inode of this dentry with READ_ONCE()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper normal filesystems should use to get at their own inodes
in their own dentries and ignore the layering superimposed upon them.</p>
<dl class="function">
<dt id="c.d_backing_inode">
struct inode * <code class="descname">d_backing_inode</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;upper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_backing_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get upper or lower inode we should be using</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">upper</span></code></dt>
<dd>The upper layer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper that should be used to get at the inode that will be used
if this dentry were to be opened as a file.  The inode may be on the upper
dentry or it may be on a lower dentry pinned by the upper.</p>
<p>Normal filesystems should not use this to access their own inodes.</p>
<dl class="function">
<dt id="c.d_backing_dentry">
struct dentry * <code class="descname">d_backing_dentry</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;upper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_backing_dentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get upper or lower dentry we should be using</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">upper</span></code></dt>
<dd>The upper layer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper that should be used to get the dentry of the inode that
will be used if this dentry were opened as a file.  It may be the upper
dentry or it may be a lower dentry pinned by the upper.</p>
<p>Normal filesystems should not use this to access their own dentries.</p>
<dl class="function">
<dt id="c.d_real">
struct dentry * <code class="descname">d_real</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, const struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>the dentry to query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to select the dentry from multiple layers (can be NULL)</dd>
</dl>
<p><strong>Description</strong></p>
<p>If dentry is on a union/overlay, then return the underlying, real dentry.
Otherwise return the dentry itself.</p>
<p>See also: Documentation/filesystems/vfs.rst</p>
<dl class="function">
<dt id="c.d_real_inode">
struct inode * <code class="descname">d_real_inode</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_real_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>If dentry is on a union/overlay, then return the underlying, real inode.
Otherwise return <a class="reference internal" href="#c.d_inode" title="d_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_inode()</span></code></a>.</p>
</div>
<div class="section" id="inode-handling">
<h3>Inode Handling<a class="headerlink" href="#inode-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.inode_init_always">
int <code class="descname">inode_init_always</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_init_always" title="Permalink to this definition">¶</a></dt>
<dd><p>perform inode structure initialisation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock inode belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to initialise</dd>
</dl>
<p><strong>Description</strong></p>
<p>These are initializations that need to be done on every inode
allocation as the fields are not initialised by slab allocation.</p>
<dl class="function">
<dt id="c.drop_nlink">
void <code class="descname">drop_nlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drop_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly drop an inode’s link count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.  In cases
where we are attempting to track writes to the
filesystem, a decrement to zero means an imminent
write when the file is truncated and actually unlinked
on the filesystem.</p>
<dl class="function">
<dt id="c.clear_nlink">
void <code class="descname">clear_nlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly zero an inode’s link count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.  See
<a class="reference internal" href="#c.drop_nlink" title="drop_nlink"><code class="xref c c-func docutils literal notranslate"><span class="pre">drop_nlink()</span></code></a> for why we care about i_nlink hitting zero.</p>
<dl class="function">
<dt id="c.set_nlink">
void <code class="descname">set_nlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, unsigned int<em>&nbsp;nlink</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly set an inode’s link count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nlink</span></code></dt>
<dd>new nlink (should be non-zero)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.</p>
<dl class="function">
<dt id="c.inc_nlink">
void <code class="descname">inc_nlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inc_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly increment an inode’s link count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.  Currently,
it is only here for parity with dec_nlink().</p>
<dl class="function">
<dt id="c.inode_sb_list_add">
void <code class="descname">inode_sb_list_add</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_sb_list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add inode to the superblock list of inodes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to add</dd>
</dl>
<dl class="function">
<dt id="c.__insert_inode_hash">
void <code class="descname">__insert_inode_hash</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, unsigned long<em>&nbsp;hashval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__insert_inode_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>hash an inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>unhashed inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd><p class="first">unsigned long value used to locate this object in the
inode_hashtable.</p>
<blockquote class="last">
<div>Add an inode to the inode hash for this superblock.</div></blockquote>
</dd>
</dl>
<dl class="function">
<dt id="c.__remove_inode_hash">
void <code class="descname">__remove_inode_hash</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__remove_inode_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an inode from the hash</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd><p class="first">inode to unhash</p>
<p class="last">Remove an inode from the superblock.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.evict_inodes">
void <code class="descname">evict_inodes</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.evict_inodes" title="Permalink to this definition">¶</a></dt>
<dd><p>evict all evictable inodes for a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock to operate on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure that no inodes with zero refcount are retained.  This is
called by superblock shutdown after having SB_ACTIVE flag removed,
so any inode reaching zero refcount during or after that call will
be immediately evicted.</p>
<dl class="function">
<dt id="c.new_inode">
struct inode * <code class="descname">new_inode</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.new_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd><p class="first">superblock</p>
<p class="last">Allocates a new inode for given superblock. The default gfp_mask
for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE.
If HIGHMEM pages are unsuitable or it is known that pages allocated
for the page cache are not reclaimable or migratable,
mapping_set_gfp_mask() must be called with suitable flags on the
newly created inode’s mapping</p>
</dd>
</dl>
<dl class="function">
<dt id="c.unlock_new_inode">
void <code class="descname">unlock_new_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_new_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>clear the I_NEW state and wake up any waiters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>new inode to unlock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when the inode is fully initialised to clear the new state of the
inode and wake up anyone waiting for the inode to finish initialisation.</p>
<dl class="function">
<dt id="c.lock_two_nondirectories">
void <code class="descname">lock_two_nondirectories</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode1</em>, struct inode *<em>&nbsp;inode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_two_nondirectories" title="Permalink to this definition">¶</a></dt>
<dd><p>take two i_mutexes on non-directory objects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode1</span></code></dt>
<dd>first inode to lock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode2</span></code></dt>
<dd>second inode to lock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock any non-NULL argument that is not a directory.
Zero, one or two objects may be locked by this function.</p>
<dl class="function">
<dt id="c.unlock_two_nondirectories">
void <code class="descname">unlock_two_nondirectories</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode1</em>, struct inode *<em>&nbsp;inode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_two_nondirectories" title="Permalink to this definition">¶</a></dt>
<dd><p>release locks from <a class="reference internal" href="#c.lock_two_nondirectories" title="lock_two_nondirectories"><code class="xref c c-func docutils literal notranslate"><span class="pre">lock_two_nondirectories()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode1</span></code></dt>
<dd>first inode to unlock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode2</span></code></dt>
<dd>second inode to unlock</dd>
</dl>
<dl class="function">
<dt id="c.inode_insert5">
struct inode * <code class="descname">inode_insert5</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, unsigned long<em>&nbsp;hashval</em>, int (<em>*test</em>)(struct inode *, void *), int (*set) (struct inode *, void *), void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_insert5" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode from a mounted file system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>pre-allocated inode to use for insert to cache</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>hash value (usually inode number) to get</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>callback used for comparisons between inodes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">set</span></code></dt>
<dd>callback used to initialize a new struct inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque data pointer to pass to <strong>test</strong> and <strong>set</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
and if present it is return it with an increased reference count. This is
a variant of <a class="reference internal" href="#c.iget5_locked" title="iget5_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget5_locked()</span></code></a> for callers that don’t want to fail on memory
allocation of inode.</p>
<p>If the inode is not in cache, insert the pre-allocated inode to cache and
return it locked, hashed, and with the I_NEW flag set. The file system gets
to fill it in before unlocking it via <a class="reference internal" href="#c.unlock_new_inode" title="unlock_new_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">unlock_new_inode()</span></code></a>.</p>
<p>Note both <strong>test</strong> and <strong>set</strong> are called with the inode_hash_lock held, so can’t
sleep.</p>
<dl class="function">
<dt id="c.iget5_locked">
struct inode * <code class="descname">iget5_locked</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;hashval</em>, int (<em>*test</em>)(struct inode *, void *), int (*set) (struct inode *, void *), void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iget5_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode from a mounted file system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>hash value (usually inode number) to get</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>callback used for comparisons between inodes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">set</span></code></dt>
<dd>callback used to initialize a new struct inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque data pointer to pass to <strong>test</strong> and <strong>set</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
and if present it is return it with an increased reference count. This is
a generalized version of <a class="reference internal" href="#c.iget_locked" title="iget_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget_locked()</span></code></a> for file systems where the inode
number is not sufficient for unique identification of an inode.</p>
<p>If the inode is not in cache, allocate a new inode and return it locked,
hashed, and with the I_NEW flag set. The file system gets to fill it in
before unlocking it via <a class="reference internal" href="#c.unlock_new_inode" title="unlock_new_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">unlock_new_inode()</span></code></a>.</p>
<p>Note both <strong>test</strong> and <strong>set</strong> are called with the inode_hash_lock held, so can’t
sleep.</p>
<dl class="function">
<dt id="c.iget_locked">
struct inode * <code class="descname">iget_locked</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;ino</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iget_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode from a mounted file system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ino</span></code></dt>
<dd>inode number to get</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>ino</strong> in the inode cache and if present
return it with an increased reference count. This is for file systems
where the inode number is sufficient for unique identification of an inode.</p>
<p>If the inode is not in cache, allocate a new inode and return it locked,
hashed, and with the I_NEW flag set.  The file system gets to fill it in
before unlocking it via <a class="reference internal" href="#c.unlock_new_inode" title="unlock_new_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">unlock_new_inode()</span></code></a>.</p>
<dl class="function">
<dt id="c.iunique">
ino_t <code class="descname">iunique</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, ino_t<em>&nbsp;max_reserved</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iunique" title="Permalink to this definition">¶</a></dt>
<dd><p>get a unique inode number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ino_t</span> <span class="pre">max_reserved</span></code></dt>
<dd><p class="first">highest reserved inode number</p>
<p>Obtain an inode number that is unique on the system for a given
superblock. This is used by file systems that have no natural
permanent inode numbering system. An inode number is returned that
is higher than the reserved limit but unique.</p>
<p class="last">BUGS:
With a large number of inodes live on the file system this function
currently becomes quite slow.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.ilookup5_nowait">
struct inode * <code class="descname">ilookup5_nowait</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;hashval</em>, int (<em>*test</em>)(struct inode *, void *), void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilookup5_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system to search</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>hash value (usually inode number) to search for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>callback used for comparisons between inodes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque data pointer to pass to <strong>test</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache.
If the inode is in the cache, the inode is returned with an incremented
reference count.</p>
<p>Note2: <strong>test</strong> is called with the inode_hash_lock held, so can’t sleep.</p>
<p><strong>Note</strong></p>
<p>I_NEW is not waited upon so you have to be very careful what you do
with the returned inode.  You probably should be using <a class="reference internal" href="#c.ilookup5" title="ilookup5"><code class="xref c c-func docutils literal notranslate"><span class="pre">ilookup5()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.ilookup5">
struct inode * <code class="descname">ilookup5</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;hashval</em>, int (<em>*test</em>)(struct inode *, void *), void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilookup5" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system to search</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>hash value (usually inode number) to search for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>callback used for comparisons between inodes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque data pointer to pass to <strong>test</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
and if the inode is in the cache, return the inode with an incremented
reference count.  Waits on I_NEW before returning the inode.
returned with an incremented reference count.</p>
<p>This is a generalized version of <a class="reference internal" href="#c.ilookup" title="ilookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">ilookup()</span></code></a> for file systems where the
inode number is not sufficient for unique identification of an inode.</p>
<p><strong>Note</strong></p>
<p><strong>test</strong> is called with the inode_hash_lock held, so can’t sleep.</p>
<dl class="function">
<dt id="c.ilookup">
struct inode * <code class="descname">ilookup</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;ino</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilookup" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system to search</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ino</span></code></dt>
<dd>inode number to search for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode <strong>ino</strong> in the inode cache, and if the inode is in the
cache, the inode is returned with an incremented reference count.</p>
<dl class="function">
<dt id="c.find_inode_nowait">
struct inode * <code class="descname">find_inode_nowait</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;hashval</em>, int (<em>*match</em>)(struct inode *, unsigned long, void *), void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_inode_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>find an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system to search</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>hash value (usually inode number) to search for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">unsigned</span> <span class="pre">long,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">match</span></code></dt>
<dd>callback used for comparisons between inodes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque data pointer to pass to <strong>match</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode
cache, where the helper function <strong>match</strong> will return 0 if the inode
does not match, 1 if the inode does match, and -1 if the search
should be stopped.  The <strong>match</strong> function must be responsible for
taking the i_lock spin_lock and checking i_state for an inode being
freed or being initialized, and incrementing the reference count
before returning 1.  It also must not sleep, since it is called with
the inode_hash_lock spinlock held.</p>
<p>This is a even more generalized version of <a class="reference internal" href="#c.ilookup5" title="ilookup5"><code class="xref c c-func docutils literal notranslate"><span class="pre">ilookup5()</span></code></a> when the
function must never block — find_inode() can block in
__wait_on_freeing_inode() — or when the caller can not increment
the reference count because the resulting <a class="reference internal" href="#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a> might cause an
inode eviction.  The tradeoff is that the <strong>match</strong> funtion must be
very carefully implemented.</p>
<dl class="function">
<dt id="c.find_inode_rcu">
struct inode * <code class="descname">find_inode_rcu</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;hashval</em>, int (<em>*test</em>)(struct inode *, void *), void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_inode_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>Super block of file system to search</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>Key to hash</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>Function to test match on an inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data for test function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
where the helper function <strong>test</strong> will return 0 if the inode does not match
and 1 if it does.  The <strong>test</strong> function must be responsible for taking the
i_lock spin_lock and checking i_state for an inode being freed or being
initialized.</p>
<p>If successful, this will return the inode for which the <strong>test</strong> function
returned 1 and NULL otherwise.</p>
<p>The <strong>test</strong> function is not permitted to take a ref on any inode presented.
It is also not permitted to sleep.</p>
<p>The caller must hold the RCU read lock.</p>
<dl class="function">
<dt id="c.find_inode_by_ino_rcu">
struct inode * <code class="descname">find_inode_by_ino_rcu</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;ino</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_inode_by_ino_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>Super block of file system to search</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ino</span></code></dt>
<dd>The inode number to match</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
where the helper function <strong>test</strong> will return 0 if the inode does not match
and 1 if it does.  The <strong>test</strong> function must be responsible for taking the
i_lock spin_lock and checking i_state for an inode being freed or being
initialized.</p>
<p>If successful, this will return the inode for which the <strong>test</strong> function
returned 1 and NULL otherwise.</p>
<p>The <strong>test</strong> function is not permitted to take a ref on any inode presented.
It is also not permitted to sleep.</p>
<p>The caller must hold the RCU read lock.</p>
<dl class="function">
<dt id="c.iput">
void <code class="descname">iput</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iput" title="Permalink to this definition">¶</a></dt>
<dd><p>put an inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd><p class="first">inode to put</p>
<p>Puts an inode, dropping its usage count. If the inode use count hits
zero, the inode is then freed and may also be destroyed.</p>
<p class="last">Consequently, <a class="reference internal" href="#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a> can sleep.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.bmap">
int <code class="descname">bmap</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, sector_t *<em>&nbsp;block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bmap" title="Permalink to this definition">¶</a></dt>
<dd><p>find a block number in a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode owning the block number being requested</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">*</span> <span class="pre">block</span></code></dt>
<dd><p class="first">pointer containing the block to find</p>
<p>Replaces the value in <code class="docutils literal notranslate"><span class="pre">*block</span></code> with the block number on the device holding
corresponding to the requested block number in the file.
That is, asked for block 4 of inode 1 the function will replace the
4 in <code class="docutils literal notranslate"><span class="pre">*block</span></code>, with disk block relative to the disk start that holds that
block of the file.</p>
<p class="last">Returns -EINVAL in case of error, 0 otherwise. If mapping falls into a
hole, returns 0 and <code class="docutils literal notranslate"><span class="pre">*block</span></code> is also set to 0.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.file_update_time">
int <code class="descname">file_update_time</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_update_time" title="Permalink to this definition">¶</a></dt>
<dd><p>update mtime and ctime time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd><p class="first">file accessed</p>
<p class="last">Update the mtime and ctime members of an inode and mark the inode
for writeback.  Note that this function is meant exclusively for
usage in the file write path of filesystems, and filesystems may
choose to explicitly ignore update via this function with the
S_NOCMTIME inode flag, e.g. for network filesystem where these
timestamps are handled by the server.  This can return an error for
file systems who need to allocate space in order to update an inode.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.inode_init_owner">
void <code class="descname">inode_init_owner</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, const struct inode *<em>&nbsp;dir</em>, umode_t<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_init_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Init uid,gid,mode for new inode according to posix standards</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>New inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>Directory inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>mode of the new inode</dd>
</dl>
<dl class="function">
<dt id="c.inode_owner_or_capable">
bool <code class="descname">inode_owner_or_capable</code><span class="sig-paren">(</span>const struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_owner_or_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>check current task permissions to inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode being checked</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if current either has CAP_FOWNER in a namespace with the
inode owner uid mapped, or owns the file.</p>
<dl class="function">
<dt id="c.inode_dio_wait">
void <code class="descname">inode_dio_wait</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_dio_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for outstanding DIO requests to finish</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Waits for all pending direct I/O requests to finish so that we can
proceed with a truncate or equivalent operation.</p>
<p>Must be called under a lock that serializes taking new references
to i_dio_count, usually by inode-&gt;i_mutex.</p>
<dl class="function">
<dt id="c.timestamp_truncate">
struct timespec64 <code class="descname">timestamp_truncate</code><span class="sig-paren">(</span>struct timespec64<em>&nbsp;t</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.timestamp_truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Truncate timespec to a granularity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">t</span></code></dt>
<dd>Timespec</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode being updated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncate a timespec to the granularity supported by the fs
containing the inode. Always rounds down. gran must
not be 0 nor greater than a second (NSEC_PER_SEC, or 10^9 ns).</p>
<dl class="function">
<dt id="c.current_time">
struct timespec64 <code class="descname">current_time</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.current_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return FS time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the current time truncated to the time granularity supported by
the fs.</p>
<p>Note that inode and inode-&gt;sb cannot be NULL.
Otherwise, the function warns and returns time without truncation.</p>
<dl class="function">
<dt id="c.make_bad_inode">
void <code class="descname">make_bad_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.make_bad_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>mark an inode bad due to an I/O error</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd><p class="first">Inode to mark bad</p>
<p class="last">When an inode cannot be read due to a media or remote network
failure this function makes the inode “bad” and causes I/O operations
on it to fail from this point on.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.is_bad_inode">
bool <code class="descname">is_bad_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_bad_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>is an inode errored</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd><p class="first">inode to test</p>
<p class="last">Returns true if the inode in question has been marked as bad.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.iget_failed">
void <code class="descname">iget_failed</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iget_failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark an under-construction inode as dead and release it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>The inode to discard</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark an under-construction inode as dead and release it.</p>
</div>
<div class="section" id="registration-and-superblocks">
<h3>Registration and Superblocks<a class="headerlink" href="#registration-and-superblocks" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.deactivate_locked_super">
void <code class="descname">deactivate_locked_super</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.deactivate_locked_super" title="Permalink to this definition">¶</a></dt>
<dd><p>drop an active reference to superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd><p class="first">superblock to deactivate</p>
<p>Drops an active reference to superblock, converting it into a temporary
one if there is no other active references left.  In that case we
tell fs driver to shut it down and drop the temporary reference we
had just acquired.</p>
<p class="last">Caller holds exclusive lock on superblock; that lock is released.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.deactivate_super">
void <code class="descname">deactivate_super</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.deactivate_super" title="Permalink to this definition">¶</a></dt>
<dd><p>drop an active reference to superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd><p class="first">superblock to deactivate</p>
<p class="last">Variant of <a class="reference internal" href="#c.deactivate_locked_super" title="deactivate_locked_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">deactivate_locked_super()</span></code></a>, except that superblock is <em>not</em>
locked by caller.  If we are going to drop the final active reference,
lock will be acquired prior to that.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.generic_shutdown_super">
void <code class="descname">generic_shutdown_super</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_shutdown_super" title="Permalink to this definition">¶</a></dt>
<dd><p>common helper for -&gt;kill_sb()</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd><p class="first">superblock to kill</p>
<p><a class="reference internal" href="#c.generic_shutdown_super" title="generic_shutdown_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_shutdown_super()</span></code></a> does all fs-independent work on superblock
shutdown.  Typical -&gt;kill_sb() should pick all fs-specific objects
that need destruction out of superblock, call <a class="reference internal" href="#c.generic_shutdown_super" title="generic_shutdown_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_shutdown_super()</span></code></a>
and release aforementioned objects.  Note: dentries and inodes _are_
taken care of and do not need specific handling.</p>
<p class="last">Upon calling this function, the filesystem may no longer alter or
rearrange the set of dentries belonging to this super_block, nor may it
change the attachments of dentries to inodes.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sget_fc">
struct super_block * <code class="descname">sget_fc</code><span class="sig-paren">(</span>struct fs_context *<em>&nbsp;fc</em>, int (<em>*test</em>)(struct super_block *, struct fs_context *), int (*set) (struct super_block *, struct fs_context *)<span class="sig-paren">)</span><a class="headerlink" href="#c.sget_fc" title="Permalink to this definition">¶</a></dt>
<dd><p>Find or create a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*</span> <span class="pre">fc</span></code></dt>
<dd>Filesystem context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>Comparison callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*)</span> <span class="pre">set</span></code></dt>
<dd>Setup callback</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find or create a superblock using the parameters stored in the filesystem
context and the two callback functions.</p>
<p>If an extant superblock is matched, then that will be returned with an
elevated reference count that the caller must transfer or discard.</p>
<p>If no match is made, a new superblock will be allocated and basic
initialisation will be performed (s_type, s_fs_info and s_id will be set and
the set() callback will be invoked), the superblock will be published and it
will be returned in a partially constructed state with SB_BORN and SB_ACTIVE
as yet unset.</p>
<dl class="function">
<dt id="c.sget">
struct super_block * <code class="descname">sget</code><span class="sig-paren">(</span>struct file_system_type *<em>&nbsp;type</em>, int (<em>*test</em>)(struct super_block *,void *), int (*set) (struct super_block *,void *), int<em>&nbsp;flags</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sget" title="Permalink to this definition">¶</a></dt>
<dd><p>find or create a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>filesystem type superblock should belong to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>comparison callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,void</span> <span class="pre">*)</span> <span class="pre">set</span></code></dt>
<dd>setup callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>mount flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>argument to each of them</dd>
</dl>
<dl class="function">
<dt id="c.iterate_supers_type">
void <code class="descname">iterate_supers_type</code><span class="sig-paren">(</span>struct file_system_type *<em>&nbsp;type</em>, void (<em>*f</em>)(struct super_block *, void *), void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iterate_supers_type" title="Permalink to this definition">¶</a></dt>
<dd><p>call function for superblocks of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>fs type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">f</span></code></dt>
<dd>function to call</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd><p class="first">argument to pass to it</p>
<p class="last">Scans the superblock list and calls given function, passing it
locked superblock and given argument.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.get_super">
struct super_block * <code class="descname">get_super</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_super" title="Permalink to this definition">¶</a></dt>
<dd><p>get the superblock of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd><p class="first">device to get the superblock for</p>
<p class="last">Scans the superblock list and finds the superblock of the file system
mounted on the device given. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if no match is found.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.get_super_thawed">
struct super_block * <code class="descname">get_super_thawed</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_super_thawed" title="Permalink to this definition">¶</a></dt>
<dd><p>get thawed superblock of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd><p class="first">device to get the superblock for</p>
<p class="last">Scans the superblock list and finds the superblock of the file system
mounted on the device. The superblock is returned once it is thawed
(or immediately if it was not frozen). <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if no match
is found.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.get_super_exclusive_thawed">
struct super_block * <code class="descname">get_super_exclusive_thawed</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_super_exclusive_thawed" title="Permalink to this definition">¶</a></dt>
<dd><p>get thawed superblock of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd><p class="first">device to get the superblock for</p>
<p class="last">Scans the superblock list and finds the superblock of the file system
mounted on the device. The superblock is returned once it is thawed
(or immediately if it was not frozen) and s_umount semaphore is held
in exclusive mode. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if no match is found.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.get_anon_bdev">
int <code class="descname">get_anon_bdev</code><span class="sig-paren">(</span>dev_t *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_anon_bdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a block device for filesystems which don’t have one.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>Pointer to a dev_t.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filesystems which don’t use real block devices can call this function
to allocate a virtual block device.</p>
<p><strong>Context</strong></p>
<p>Any context.  Frequently called while holding sb_lock.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EMFILE if there are no anonymous bdevs left
or -ENOMEM if memory allocation failed.</p>
<dl class="function">
<dt id="c.vfs_get_super">
int <code class="descname">vfs_get_super</code><span class="sig-paren">(</span>struct fs_context *<em>&nbsp;fc</em>, enum vfs_get_super_keying<em>&nbsp;keying</em>, int (<em>*fill_super</em>)(struct super_block *sb, struct fs_context *fc)<span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_get_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a superblock with a search key set in s_fs_info.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*</span> <span class="pre">fc</span></code></dt>
<dd>The filesystem context holding the parameters</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vfs_get_super_keying</span> <span class="pre">keying</span></code></dt>
<dd>How to distinguish superblocks</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*sb,</span> <span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*fc)</span> <span class="pre">fill_super</span></code></dt>
<dd>Helper to initialise a new superblock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a superblock and create a new one if not found.  The search
criterion is controlled by <strong>keying</strong>.  If the search fails, a new superblock
is created and <strong>fill_super()</strong> is called to initialise it.</p>
<p><strong>keying</strong> can take one of a number of values:</p>
<ol class="arabic simple">
<li>vfs_get_single_super - Only one superblock of this type may exist on the
system.  This is typically used for special system filesystems.</li>
<li>vfs_get_keyed_super - Multiple superblocks may exist, but they must have
distinct keys (where the key is in s_fs_info).  Searching for the same
key again will turn up the superblock for that key.</li>
<li>vfs_get_independent_super - Multiple superblocks may exist and are
unkeyed.  Each call will get a new superblock.</li>
</ol>
<p>A permissions check is made by <a class="reference internal" href="#c.sget_fc" title="sget_fc"><code class="xref c c-func docutils literal notranslate"><span class="pre">sget_fc()</span></code></a> unless we’re getting a superblock
for a kernel-internal mount or a submount.</p>
<dl class="function">
<dt id="c.get_tree_bdev">
int <code class="descname">get_tree_bdev</code><span class="sig-paren">(</span>struct fs_context *<em>&nbsp;fc</em>, int (<em>*fill_super</em>)(struct super_block *, struct fs_context *)<span class="sig-paren">)</span><a class="headerlink" href="#c.get_tree_bdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a superblock based on a single block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*</span> <span class="pre">fc</span></code></dt>
<dd>The filesystem context holding the parameters</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*)</span> <span class="pre">fill_super</span></code></dt>
<dd>Helper to initialise a new superblock</dd>
</dl>
<dl class="function">
<dt id="c.vfs_get_tree">
int <code class="descname">vfs_get_tree</code><span class="sig-paren">(</span>struct fs_context *<em>&nbsp;fc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_get_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mountable root</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*</span> <span class="pre">fc</span></code></dt>
<dd>The superblock configuration context.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The filesystem is invoked to get or create a superblock which can then later
be used for mounting.  The filesystem places a pointer to the root to be
used for mounting in <strong>fc-&gt;root</strong>.</p>
<dl class="function">
<dt id="c.freeze_super">
int <code class="descname">freeze_super</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.freeze_super" title="Permalink to this definition">¶</a></dt>
<dd><p>lock the filesystem and force it into a consistent state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super to lock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Syncs the super to make sure the filesystem is consistent and calls the fs’s
freeze_fs.  Subsequent calls to this without first thawing the fs will return
-EBUSY.</p>
<p>During this function, sb-&gt;s_writers.frozen goes through these values:</p>
<p>SB_UNFROZEN: File system is normal, all writes progress as usual.</p>
<p>SB_FREEZE_WRITE: The file system is in the process of being frozen.  New
writes should be blocked, though page faults are still allowed. We wait for
all writes to complete and then proceed to the next stage.</p>
<p>SB_FREEZE_PAGEFAULT: Freezing continues. Now also page faults are blocked
but internal fs threads can still modify the filesystem (although they
should not dirty new pages or inodes), writeback can run etc. After waiting
for all running page faults we sync the filesystem which will clean all
dirty pages and inodes (no new dirty pages or inodes can be created when
sync is running).</p>
<p>SB_FREEZE_FS: The file system is frozen. Now all internal sources of fs
modification are blocked (e.g. XFS preallocation truncation on inode
reclaim). This is usually implemented by blocking new transactions for
filesystems that have them and need this additional guard. After all
internal writers are finished we call -&gt;freeze_fs() to finish filesystem
freezing. Then we transition to SB_FREEZE_COMPLETE state. This state is
mostly auxiliary for filesystems to verify they do not modify frozen fs.</p>
<p>sb-&gt;s_writers.frozen is protected by sb-&gt;s_umount.</p>
</div>
<div class="section" id="file-locks">
<h3>File Locks<a class="headerlink" href="#file-locks" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.locks_delete_block">
int <code class="descname">locks_delete_block</code><span class="sig-paren">(</span>struct file_lock *<em>&nbsp;waiter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_delete_block" title="Permalink to this definition">¶</a></dt>
<dd><p>stop waiting for a file lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">waiter</span></code></dt>
<dd><p class="first">the lock which was waiting</p>
<p class="last">lockd/nfsd need to disconnect the lock while working on it.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.posix_lock_file">
int <code class="descname">posix_lock_file</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct file_lock *<em>&nbsp;fl</em>, struct file_lock *<em>&nbsp;conflock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_lock_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a POSIX-style lock to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>The file to apply the lock to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">conflock</span></code></dt>
<dd>Place to return a copy of the conflicting lock, if found.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a POSIX style lock to a file.
We merge adjacent &amp; overlapping locks whenever possible.
POSIX locks are sorted by owner task, then by starting address</p>
<p>Note that if called with an FL_EXISTS argument, the caller may determine
whether or not a lock was successfully freed by testing the return
value for -ENOENT.</p>
<dl class="function">
<dt id="c.locks_mandatory_area">
int <code class="descname">locks_mandatory_area</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;filp</em>, loff_t<em>&nbsp;start</em>, loff_t<em>&nbsp;end</em>, unsigned char<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_mandatory_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for a conflicting lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the file to check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>how the file was opened (if it was)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt>
<dd>first byte in the file to check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt>
<dd>lastbyte in the file to check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">type</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">F_WRLCK</span></code> for a write lock, else <code class="docutils literal notranslate"><span class="pre">F_RDLCK</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Searches the inode’s list of locks to find any POSIX locks which conflict.</p>
<dl class="function">
<dt id="c.__break_lease">
int <code class="descname">__break_lease</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, unsigned int<em>&nbsp;mode</em>, unsigned int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__break_lease" title="Permalink to this definition">¶</a></dt>
<dd><p>revoke all outstanding leases on file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode of the file to return</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt>
<dd>O_RDONLY: break only write leases; O_WRONLY or O_RDWR:
break all leases</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd><p class="first">FL_LEASE: break leases and delegations; FL_DELEG: break
only delegations</p>
<blockquote class="last">
<div>break_lease (inlined for speed) has checked there already is at least
some kind of lock (maybe a lease) on this file.  Leases are broken on
a call to open() or truncate().  This function can sleep unless you
specified <code class="docutils literal notranslate"><span class="pre">O_NONBLOCK</span></code> to your open().</div></blockquote>
</dd>
</dl>
<dl class="function">
<dt id="c.lease_get_mtime">
void <code class="descname">lease_get_mtime</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct timespec64 *<em>&nbsp;time</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lease_get_mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>update modified time of an inode with exclusive lease</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">time</span></code></dt>
<dd>pointer to a timespec which contains the last modified time</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is to force NFS clients to flush their caches for files with
exclusive leases.  The justification is that if someone has an
exclusive lease, then they could be modifying it.</p>
<dl class="function">
<dt id="c.generic_setlease">
int <code class="descname">generic_setlease</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, long<em>&nbsp;arg</em>, struct file_lock **<em>&nbsp;flp</em>, void **<em>&nbsp;priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_setlease" title="Permalink to this definition">¶</a></dt>
<dd><p>sets a lease on an open file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>type of lease to obtain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">**</span> <span class="pre">flp</span></code></dt>
<dd>input - file_lock to use, output - file_lock inserted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">priv</span></code></dt>
<dd><p class="first">private data for lm_setup (may be NULL if lm_setup
doesn’t require it)</p>
<blockquote class="last">
<div>The (input) flp-&gt;fl_lmops-&gt;lm_break function is required
by break_lease().</div></blockquote>
</dd>
</dl>
<dl class="function">
<dt id="c.vfs_setlease">
int <code class="descname">vfs_setlease</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, long<em>&nbsp;arg</em>, struct file_lock **<em>&nbsp;lease</em>, void **<em>&nbsp;priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_setlease" title="Permalink to this definition">¶</a></dt>
<dd><p>sets a lease on an open file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>type of lease to obtain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">**</span> <span class="pre">lease</span></code></dt>
<dd>file_lock to use when adding a lease</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">priv</span></code></dt>
<dd>private info for lm_setup when adding a lease (may be
NULL if lm_setup doesn’t require it)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this to establish a lease on the file. The “lease” argument is not
used for F_UNLCK requests and may be NULL. For commands that set or alter
an existing lease, the <code class="docutils literal notranslate"><span class="pre">(*lease)-&gt;fl_lmops-&gt;lm_break</span></code> operation must be
set; if not, this function will return -ENOLCK (and generate a scary-looking
stack trace).</p>
<p>The “priv” pointer is passed directly to the lm_setup function as-is. It
may be NULL if the lm_setup operation doesn’t require it.</p>
<dl class="function">
<dt id="c.locks_lock_inode_wait">
int <code class="descname">locks_lock_inode_wait</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_lock_inode_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a lock to an inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode of the file to apply to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply a POSIX or FLOCK style lock request to an inode.</p>
<dl class="function">
<dt id="c.vfs_test_lock">
int <code class="descname">vfs_test_lock</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_test_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>test file byte range lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>The file to test lock for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to test; also used to hold result</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ERRNO on failure.  Indicates presence of conflicting lock by
setting conf-&gt;fl_type to something other than F_UNLCK.</p>
<dl class="function">
<dt id="c.vfs_lock_file">
int <code class="descname">vfs_lock_file</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, unsigned int<em>&nbsp;cmd</em>, struct file_lock *<em>&nbsp;fl</em>, struct file_lock *<em>&nbsp;conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_lock_file" title="Permalink to this definition">¶</a></dt>
<dd><p>file byte range lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>The file to apply the lock to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>type of locking operation (F_SETLK, F_GETLK, etc.)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt>
<dd>Place to return a copy of the conflicting lock, if found.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A caller that doesn’t care about the conflicting lock may pass NULL
as the final argument.</p>
<p>If the filesystem defines a private -&gt;lock() method, then <strong>conf</strong> will
be left unchanged; so a caller that cares should initialize it to
some acceptable default.</p>
<p>To avoid blocking kernel daemons, such as lockd, that need to acquire POSIX
locks, the -&gt;lock() interface may return asynchronously, before the lock has
been granted or denied by the underlying filesystem, if (and only if)
lm_grant is set. Callers expecting -&gt;lock() to return asynchronously
will only use F_SETLK, not F_SETLKW; they will set FL_SLEEP if (and only if)
the request is for a blocking lock. When -&gt;lock() does return asynchronously,
it must return FILE_LOCK_DEFERRED, and call -&gt;lm_grant() when the lock
request completes.
If the request is for non-blocking lock the file system should return
FILE_LOCK_DEFERRED then try to get the lock and call the callback routine
with the result. If the request timed out the callback routine will return a
nonzero return code and the file system should release the lock. The file
system is also responsible to keep a corresponding posix lock when it
grants a lock so the VFS can find out which locks are locally held and do
the correct lock cleanup when required.
The underlying filesystem must not drop the kernel lock or call
-&gt;lm_grant() before returning to the caller with a FILE_LOCK_DEFERRED
return code.</p>
<dl class="function">
<dt id="c.vfs_cancel_lock">
int <code class="descname">vfs_cancel_lock</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_cancel_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>file byte range unblock lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>The file to apply the unblock to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be unblocked</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by lock managers to cancel blocked requests</p>
<dl class="function">
<dt id="c.posix_lock_inode_wait">
int <code class="descname">posix_lock_inode_wait</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_lock_inode_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a POSIX-style lock to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode of file to which lock request should be applied</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply a POSIX style lock request to an inode.</p>
<dl class="function">
<dt id="c.locks_mandatory_locked">
int <code class="descname">locks_mandatory_locked</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_mandatory_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for an active lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>the file to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Searches the inode’s list of locks to find any POSIX locks which conflict.
This function is called from locks_verify_locked() only.</p>
<dl class="function">
<dt id="c.fcntl_getlease">
int <code class="descname">fcntl_getlease</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fcntl_getlease" title="Permalink to this definition">¶</a></dt>
<dd><p>Enquire what lease is currently active</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd><p class="first">the file</p>
<p>The value returned by this function will be one of
(if no lease break is pending):</p>
<p><code class="docutils literal notranslate"><span class="pre">F_RDLCK</span></code> to indicate a shared lease is held.</p>
<p><code class="docutils literal notranslate"><span class="pre">F_WRLCK</span></code> to indicate an exclusive lease is held.</p>
<p><code class="docutils literal notranslate"><span class="pre">F_UNLCK</span></code> to indicate no lease is held.</p>
<p>(if a lease break is pending):</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">F_RDLCK</span></code> to indicate an exclusive lease needs to be</dt>
<dd>changed to a shared lease (or removed).</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">F_UNLCK</span></code> to indicate the lease needs to be removed.</p>
<p class="last">XXX: sfr &amp; willy disagree over whether F_INPROGRESS
should be returned to userspace.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.check_conflicting_open">
int <code class="descname">check_conflicting_open</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, const long<em>&nbsp;arg</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_conflicting_open" title="Permalink to this definition">¶</a></dt>
<dd><p>see if the given file points to an inode that has an existing open that would conflict with the desired lease.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file to check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>type of lease that we’re trying to acquire</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>current lock flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if there’s an existing open fd on this file that would
conflict with the lease we’re trying to set.</p>
<dl class="function">
<dt id="c.fcntl_setlease">
int <code class="descname">fcntl_setlease</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;fd</em>, struct file *<em>&nbsp;filp</em>, long<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fcntl_setlease" title="Permalink to this definition">¶</a></dt>
<dd><p>sets a lease on an open file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>open file descriptor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd><p class="first">type of lease to obtain</p>
<p class="last">Call this fcntl to establish a lease on the file.
Note that you also need to call <code class="docutils literal notranslate"><span class="pre">F_SETSIG</span></code> to
receive a signal when the lease is broken.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.flock_lock_inode_wait">
int <code class="descname">flock_lock_inode_wait</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flock_lock_inode_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a FLOCK-style lock to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode of the file to apply to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply a FLOCK style lock request to an inode.</p>
<dl class="function">
<dt id="c.sys_flock">
long <code class="descname">sys_flock</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;fd</em>, unsigned int<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_flock" title="Permalink to this definition">¶</a></dt>
<dd><p>flock() system call.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>the file descriptor to lock.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd><p class="first">the type of lock to apply.</p>
<p>Apply a <code class="docutils literal notranslate"><span class="pre">FL_FLOCK</span></code> style lock to an open file descriptor.
The <strong>cmd</strong> can be one of:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">LOCK_SH</span></code> – a shared lock.</li>
<li><code class="docutils literal notranslate"><span class="pre">LOCK_EX</span></code> – an exclusive lock.</li>
<li><code class="docutils literal notranslate"><span class="pre">LOCK_UN</span></code> – remove an existing lock.</li>
<li><code class="docutils literal notranslate"><span class="pre">LOCK_MAND</span></code> – a ‘mandatory’ flock.
This exists to emulate Windows Share Modes.</li>
</ul>
<p class="last"><code class="docutils literal notranslate"><span class="pre">LOCK_MAND</span></code> can be combined with <code class="docutils literal notranslate"><span class="pre">LOCK_READ</span></code> or <code class="docutils literal notranslate"><span class="pre">LOCK_WRITE</span></code> to allow other
processes read and write access respectively.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.locks_translate_pid">
pid_t <code class="descname">locks_translate_pid</code><span class="sig-paren">(</span>struct file_lock *<em>&nbsp;fl</em>, struct pid_namespace *<em>&nbsp;ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_translate_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>translate a file_lock’s fl_pid number into a namespace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The file_lock who’s fl_pid should be translated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pid_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>The namespace into which the pid should be translated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to tranlate a fl_pid into a namespace virtual pid number</p>
</div>
<div class="section" id="other-functions">
<h3>Other Functions<a class="headerlink" href="#other-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.mpage_readahead">
void <code class="descname">mpage_readahead</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.readahead_control" title="readahead_control">readahead_control</a> *<em>&nbsp;rac</em>, get_block_t<em>&nbsp;get_block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mpage_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>start reads against pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*</span> <span class="pre">rac</span></code></dt>
<dd>Describes which pages to read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_block_t</span> <span class="pre">get_block</span></code></dt>
<dd>The filesystem’s block mapper function.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the pages and the blocks within each page, building and
emitting large BIOs.</p>
<p>If anything unusual happens, such as:</p>
<ul class="simple">
<li>encountering a page which has buffers</li>
<li>encountering a page which has a non-hole after a hole</li>
<li>encountering a page with non-contiguous blocks</li>
</ul>
<p>then this code just gives up and calls the buffer_head-based read function.
It does handle a page which has holes at the end - that is a common case:
the end-of-file on blocksize &lt; PAGE_SIZE setups.</p>
<p>BH_Boundary explanation:</p>
<p>There is a problem.  The mpage read code assembles several pages, gets all
their disk mappings, and then submits them all.  That’s fine, but obtaining
the disk mappings may require I/O.  Reads of indirect blocks, for example.</p>
<p>So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be
submitted in the following order:</p>
<blockquote>
<div>12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16</div></blockquote>
<p>because the indirect block has to be read to get the mappings of blocks
13,14,15,16.  Obviously, this impacts performance.</p>
<p>So what we do it to allow the filesystem’s get_block() function to set
BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block
after this one will require I/O against a block which is probably close to
this one.  So you should push what I/O you have currently accumulated.</p>
<p>This all causes the disk requests to be issued in the correct order.</p>
<dl class="function">
<dt id="c.mpage_writepages">
int <code class="descname">mpage_writepages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a> *<em>&nbsp;mapping</em>, struct writeback_control *<em>&nbsp;wbc</em>, get_block_t<em>&nbsp;get_block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mpage_writepages" title="Permalink to this definition">¶</a></dt>
<dd><p>walk the list of dirty pages of the given address space &amp; writepage() all of them</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>subtract the number of written pages from <strong>*wbc-&gt;nr_to_write</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_block_t</span> <span class="pre">get_block</span></code></dt>
<dd>the filesystem’s block mapper function.
If this is NULL then use a_ops-&gt;writepage.  Otherwise, go
direct-to-BIO.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a library function, which implements the writepages()
address_space_operation.</p>
<p>If a page is already under I/O, <a class="reference internal" href="../core-api/mm-api.html#c.generic_writepages" title="generic_writepages"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_writepages()</span></code></a> skips it, even
if it’s dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as fsync().  fsync()
and msync() need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
WB_SYNC_ALL then we were called for data integrity and we must wait for
existing IO to complete.</p>
<dl class="function">
<dt id="c.generic_permission">
int <code class="descname">generic_permission</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_permission" title="Permalink to this definition">¶</a></dt>
<dd><p>check for access rights on a Posix-like filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to check access rights for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>right to check for (<code class="docutils literal notranslate"><span class="pre">MAY_READ</span></code>, <code class="docutils literal notranslate"><span class="pre">MAY_WRITE</span></code>, <code class="docutils literal notranslate"><span class="pre">MAY_EXEC</span></code>,
<code class="docutils literal notranslate"><span class="pre">MAY_NOT_BLOCK</span></code> …)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to check for read/write/execute permissions on a file.
We use “fsuid” for this, letting us set arbitrary permissions
for filesystem access without changing the “normal” uids which
are used for other things.</p>
<p>generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk
request cannot be satisfied (eg. requires blocking or too much complexity).
It would then be called again in ref-walk mode.</p>
<dl class="function">
<dt id="c.inode_permission">
int <code class="descname">inode_permission</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_permission" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for access rights to a given inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>Inode to check permission on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>Right to check for (<code class="docutils literal notranslate"><span class="pre">MAY_READ</span></code>, <code class="docutils literal notranslate"><span class="pre">MAY_WRITE</span></code>, <code class="docutils literal notranslate"><span class="pre">MAY_EXEC</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for read/write/execute permissions on an inode.  We use fs[ug]id for
this, letting us set arbitrary permissions for filesystem access without
changing the “normal” UIDs which are used for other things.</p>
<p>When checking for MAY_APPEND, MAY_WRITE must also be set in <strong>mask</strong>.</p>
<dl class="function">
<dt id="c.path_get">
void <code class="descname">path_get</code><span class="sig-paren">(</span>const struct path *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a path</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to get the reference to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a path increment the reference count to the dentry and the vfsmount.</p>
<dl class="function">
<dt id="c.path_put">
void <code class="descname">path_put</code><span class="sig-paren">(</span>const struct path *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_put" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference to a path</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to put the reference to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a path decrement the reference count to the dentry and the vfsmount.</p>
<dl class="function">
<dt id="c.vfs_path_lookup">
int <code class="descname">vfs_path_lookup</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct vfsmount *<em>&nbsp;mnt</em>, const char *<em>&nbsp;name</em>, unsigned int<em>&nbsp;flags</em>, struct path *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_path_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup a file path relative to a dentry-vfsmount pair</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>pointer to dentry of the base directory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*</span> <span class="pre">mnt</span></code></dt>
<dd>pointer to vfs mount of the base directory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pointer to file name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>lookup flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>pointer to struct path to fill</dd>
</dl>
<dl class="function">
<dt id="c.try_lookup_one_len">
struct dentry * <code class="descname">try_lookup_one_len</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;base</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_lookup_one_len" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pathname component to lookup</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>base directory to lookup from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>maximum length <strong>len</strong> should be interpreted to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look up a dentry by name in the dcache, returning NULL if it does not
currently exist.  The function does not try to create a dentry.</p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>The caller must hold base-&gt;i_mutex.</p>
<dl class="function">
<dt id="c.lookup_one_len">
struct dentry * <code class="descname">lookup_one_len</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;base</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_one_len" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pathname component to lookup</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>base directory to lookup from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>maximum length <strong>len</strong> should be interpreted to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>The caller must hold base-&gt;i_mutex.</p>
<dl class="function">
<dt id="c.lookup_one_len_unlocked">
struct dentry * <code class="descname">lookup_one_len_unlocked</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;base</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_one_len_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pathname component to lookup</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>base directory to lookup from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>maximum length <strong>len</strong> should be interpreted to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>Unlike lookup_one_len, it should be called without the parent
i_mutex held, and will take the i_mutex itself if necessary.</p>
<dl class="function">
<dt id="c.vfs_unlink">
int <code class="descname">vfs_unlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;dir</em>, struct dentry *<em>&nbsp;dentry</em>, struct inode **<em>&nbsp;delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>unlink a filesystem object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>parent directory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>victim</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**</span> <span class="pre">delegated_inode</span></code></dt>
<dd>returns victim inode, if the inode is delegated.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold dir-&gt;i_mutex.</p>
<p>If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
return a reference to the inode in delegated_inode.  The caller
should then break the delegation on that inode and retry.  Because
breaking a delegation may take a long time, the caller should drop
dir-&gt;i_mutex before doing so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.</p>
<dl class="function">
<dt id="c.vfs_link">
int <code class="descname">vfs_link</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;old_dentry</em>, struct inode *<em>&nbsp;dir</em>, struct dentry *<em>&nbsp;new_dentry</em>, struct inode **<em>&nbsp;delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">old_dentry</span></code></dt>
<dd>object to be linked</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>new parent</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">new_dentry</span></code></dt>
<dd>where to create the new link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**</span> <span class="pre">delegated_inode</span></code></dt>
<dd>returns inode needing a delegation break</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold dir-&gt;i_mutex</p>
<p>If vfs_link discovers a delegation on the to-be-linked file in need
of breaking, it will return -EWOULDBLOCK and return a reference to the
inode in delegated_inode.  The caller should then break the delegation
and retry.  Because breaking a delegation may take a long time, the
caller should drop the i_mutex before doing so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.</p>
<dl class="function">
<dt id="c.vfs_rename">
int <code class="descname">vfs_rename</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;old_dir</em>, struct dentry *<em>&nbsp;old_dentry</em>, struct inode *<em>&nbsp;new_dir</em>, struct dentry *<em>&nbsp;new_dentry</em>, struct inode **<em>&nbsp;delegated_inode</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>rename a filesystem object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">old_dir</span></code></dt>
<dd>parent of source</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">old_dentry</span></code></dt>
<dd>source</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">new_dir</span></code></dt>
<dd>parent of destination</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">new_dentry</span></code></dt>
<dd>destination</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**</span> <span class="pre">delegated_inode</span></code></dt>
<dd>returns an inode needing a delegation break</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>rename flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold multiple mutexes–see lock_rename()).</p>
<p>If vfs_rename discovers a delegation in need of breaking at either
the source or destination, it will return -EWOULDBLOCK and return a
reference to the inode in delegated_inode.  The caller should then
break the delegation and retry.  Because breaking a delegation may
take a long time, the caller should drop all locks before doing
so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.</p>
<p>The worst of all namespace operations - renaming directory. “Perverted”
doesn’t even start to describe it. Somebody in UCB had a heck of a trip…
Problems:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>we can get into loop creation.</li>
<li>race potential - two innocent renames can create a loop together.
That’s where 4.4 screws up. Current fix: serialization on
sb-&gt;s_vfs_rename_mutex. We might be more accurate, but that’s another
story.</li>
<li>we have to lock _four_ objects - parents and victim (if it exists),
and source (if it is not a directory).
And that - after we got -&gt;i_mutex on parents (until then we don’t know
whether the target exists).  Solution: try to be smart with locking
order for inodes.  We rely on the fact that tree topology may change
only under -&gt;s_vfs_rename_mutex _and_ that parent of the object we
move will be locked.  Thus we can rank directories by the tree
(ancestors first) and rank all non-directories after them.
That works since everybody except rename does “lock parent, lookup,
lock child” and rename is under -&gt;s_vfs_rename_mutex.
HOWEVER, it relies on the assumption that any object with -&gt;lookup()
has no more than 1 dentry.  If “hybrid” objects will ever appear,
we’d better make sure that there’s no link(2) for them.</li>
<li>conversion from fhandle to dentry may come in the wrong moment - when
we are removing the target. Solution: we will have to grab -&gt;i_mutex
in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
-&gt;i_mutex on parents, which works but leads to some truly excessive
locking].</li>
</ol>
</div></blockquote>
<dl class="function">
<dt id="c.vfs_readlink">
int <code class="descname">vfs_readlink</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, char __user *<em>&nbsp;buffer</em>, int<em>&nbsp;buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_readlink" title="Permalink to this definition">¶</a></dt>
<dd><p>copy symlink body into userspace buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry on which to get symbolic link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>user memory pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Does not touch atime.  That’s up to the caller if necessary</p>
<p>Does not call security hook.</p>
<dl class="function">
<dt id="c.vfs_get_link">
const char * <code class="descname">vfs_get_link</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct delayed_call *<em>&nbsp;done</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_get_link" title="Permalink to this definition">¶</a></dt>
<dd><p>get symlink body</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry on which to get symbolic link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_call</span> <span class="pre">*</span> <span class="pre">done</span></code></dt>
<dd>caller needs to free returned data with this</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls security hook and i_op-&gt;get_link() on the supplied inode.</p>
<p>It does not touch atime.  That’s up to the caller if necessary.</p>
<p>Does not work on “special” symlinks like /proc/$$/fd/N</p>
<dl class="function">
<dt id="c.sync_mapping_buffers">
int <code class="descname">sync_mapping_buffers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a> *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_mapping_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>write out &amp; wait upon a mapping’s “associated” buffers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the mapping which wants those buffers written</dd>
</dl>
<p><strong>Description</strong></p>
<p>Starts I/O against the buffers at mapping-&gt;private_list, and waits upon
that I/O.</p>
<p>Basically, this is a convenience function for fsync().
<strong>mapping</strong> is a file or directory which needs those buffers to be written for
a successful fsync().</p>
<dl class="function">
<dt id="c.mark_buffer_dirty">
void <code class="descname">mark_buffer_dirty</code><span class="sig-paren">(</span>struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mark_buffer_dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a buffer_head as needing writeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>the buffer_head to mark dirty</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mark_buffer_dirty" title="mark_buffer_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">mark_buffer_dirty()</span></code></a> will set the dirty bit against the buffer, then set
its backing page dirty, then tag the page as dirty in the page cache
and then attach the address_space’s inode to its superblock’s dirty
inode list.</p>
<p><a class="reference internal" href="#c.mark_buffer_dirty" title="mark_buffer_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">mark_buffer_dirty()</span></code></a> is atomic.  It takes bh-&gt;b_page-&gt;mapping-&gt;private_lock,
i_pages lock and mapping-&gt;host-&gt;i_lock.</p>
<dl class="function">
<dt id="c.__bread_gfp">
struct buffer_head * <code class="descname">__bread_gfp</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;block</em>, unsigned<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bread_gfp" title="Permalink to this definition">¶</a></dt>
<dd><p>reads a specified block and returns the bh</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the block_device to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt>
<dd>number of block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">size</span></code></dt>
<dd>size (in bytes) to read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd><p class="first">page allocation flag</p>
<p class="last">Reads a specified block, and returns buffer head that contains it.
The page cache can be allocated from non-movable area
not to prevent page migration if you set gfp to zero.
It returns NULL if the block was unreadable.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.block_invalidatepage">
void <code class="descname">block_invalidatepage</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;offset</em>, unsigned int<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.block_invalidatepage" title="Permalink to this definition">¶</a></dt>
<dd><p>invalidate part or all of a buffer-backed page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page which is affected</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>start of the range to invalidate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">length</span></code></dt>
<dd>length of the range to invalidate</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.block_invalidatepage" title="block_invalidatepage"><code class="xref c c-func docutils literal notranslate"><span class="pre">block_invalidatepage()</span></code></a> is called when all or part of the page has become
invalidated by a truncate operation.</p>
<p><a class="reference internal" href="#c.block_invalidatepage" title="block_invalidatepage"><code class="xref c c-func docutils literal notranslate"><span class="pre">block_invalidatepage()</span></code></a> does not have to release all buffers, but it must
ensure that no dirty buffer is left outside <strong>offset</strong> and that no I/O
is underway against any of the blocks which are outside the truncation
point.  Because the caller is about to free (and possibly reuse) those
blocks on-disk.</p>
<dl class="function">
<dt id="c.clean_bdev_aliases">
void <code class="descname">clean_bdev_aliases</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;block</em>, sector_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clean_bdev_aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>Block device to clean buffers in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt>
<dd>Start of a range of blocks to clean</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">len</span></code></dt>
<dd>Number of blocks to clean</dd>
</dl>
<p><strong>Description</strong></p>
<p>We are taking a range of blocks for data and we don’t want writeback of any
buffer-cache aliases starting from return from this function and until the
moment when something will explicitly mark the buffer dirty (hopefully that
will not happen until we will free that block ;-) We don’t even need to mark
it not-uptodate - nobody can expect anything from a newly allocated buffer
anyway. We used to use unmap_buffer() for such invalidation, but that was
wrong. We definitely don’t want to mark the alias unmapped, for example - it
would confuse anyone who might pick it with bread() afterwards…</p>
<p>Also..  Note that bforget() doesn’t lock the buffer.  So there can be
writeout I/O going on against recently-freed buffers.  We don’t wait on that
I/O in bforget() - it’s more efficient to wait on the I/O only if we really
need to.  That happens here.</p>
<dl class="function">
<dt id="c.ll_rw_block">
void <code class="descname">ll_rw_block</code><span class="sig-paren">(</span>int<em>&nbsp;op</em>, int<em>&nbsp;op_flags</em>, int<em>&nbsp;nr</em>, struct buffer_head *<em>&nbsp;bhs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ll_rw_block" title="Permalink to this definition">¶</a></dt>
<dd><p>level access to block devices (DEPRECATED)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>whether to <code class="docutils literal notranslate"><span class="pre">READ</span></code> or <code class="docutils literal notranslate"><span class="pre">WRITE</span></code></dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">op_flags</span></code></dt>
<dd>req_flag_bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>number of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_heads</span></code> in the array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bhs</span></code></dt>
<dd>array of pointers to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ll_rw_block" title="ll_rw_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">ll_rw_block()</span></code></a> takes an array of pointers to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_heads</span></code>, and
requests an I/O operation on them, either a <code class="docutils literal notranslate"><span class="pre">REQ_OP_READ</span></code> or a <code class="docutils literal notranslate"><span class="pre">REQ_OP_WRITE</span></code>.
<strong>op_flags</strong> contains flags modifying the detailed I/O behavior, most notably
<code class="docutils literal notranslate"><span class="pre">REQ_RAHEAD</span></code>.</p>
<p>This function drops any buffer that it cannot get a lock on (with the
BH_Lock state bit), any buffer that appears to be clean when doing a write
request, and any buffer that appears to be up-to-date when doing read
request.  Further it marks as clean buffers that are processed for
writing (the buffer cache won’t assume that they are actually clean
until the buffer gets unlocked).</p>
<p>ll_rw_block sets b_end_io to simple completion handler that marks
the buffer up-to-date (if appropriate), unlocks the buffer and wakes
any waiters.</p>
<p>All of the buffers must be for the same device, and must also be a
multiple of the current approved size for the device.</p>
<dl class="function">
<dt id="c.bh_uptodate_or_lock">
int <code class="descname">bh_uptodate_or_lock</code><span class="sig-paren">(</span>struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bh_uptodate_or_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the buffer is uptodate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>struct buffer_head</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the buffer is up-to-date and false,
with the buffer locked, if not.</p>
<dl class="function">
<dt id="c.bh_submit_read">
int <code class="descname">bh_submit_read</code><span class="sig-paren">(</span>struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bh_submit_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Submit a locked buffer for reading</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>struct buffer_head</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero on success and -EIO on error.</p>
<dl class="function">
<dt id="c.bio_reset">
void <code class="descname">bio_reset</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reinitialize a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to reset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>After calling <a class="reference internal" href="#c.bio_reset" title="bio_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_reset()</span></code></a>, <strong>bio</strong> will be in the same state as a freshly
allocated bio returned bio <a class="reference internal" href="#c.bio_alloc_bioset" title="bio_alloc_bioset"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_alloc_bioset()</span></code></a> - the only fields that are
preserved are the ones that are initialized by <a class="reference internal" href="#c.bio_alloc_bioset" title="bio_alloc_bioset"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_alloc_bioset()</span></code></a>. See
comment in struct bio.</div></blockquote>
<dl class="function">
<dt id="c.bio_chain">
void <code class="descname">bio_chain</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct bio *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>chain bio completions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>the target bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>the <strong>bio</strong>’s parent bio</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller won’t have a bi_end_io called when <strong>bio</strong> completes - instead,
<strong>parent</strong>’s bi_end_io won’t be called until both <strong>parent</strong> and <strong>bio</strong> have
completed; the chained bio will also be freed when it completes.</p>
<p>The caller must not set bi_private or bi_end_io in <strong>bio</strong>.</p>
<dl class="function">
<dt id="c.bio_alloc_bioset">
struct bio * <code class="descname">bio_alloc_bioset</code><span class="sig-paren">(</span>gfp_t<em>&nbsp;gfp_mask</em>, unsigned int<em>&nbsp;nr_iovecs</em>, struct bio_set *<em>&nbsp;bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_alloc_bioset" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a bio for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>the GFP_* mask given to the slab allocator</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_iovecs</span></code></dt>
<dd>number of iovecs to pre-allocate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>the bio_set to allocate from.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If <strong>bs</strong> is NULL, uses <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> to allocate the bio; else the allocation is
backed by the <strong>bs</strong>’s mempool.</p>
<p>When <strong>bs</strong> is not NULL, if <code class="docutils literal notranslate"><span class="pre">__GFP_DIRECT_RECLAIM</span></code> is set then bio_alloc will
always be able to allocate a bio. This is due to the mempool guarantees.
To make this work, callers must never allocate more than 1 bio at a time
from this pool. Callers that need to allocate more than 1 bio must always
submit the previously allocated bio for IO before attempting to allocate
a new one. Failure to do so can cause deadlocks under memory pressure.</p>
<p>Note that when running under <a class="reference internal" href="../core-api/kernel-api.html#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_make_request()</span></code></a> (i.e. any block
driver), bios are not submitted until after you return - see the code in
<a class="reference internal" href="../core-api/kernel-api.html#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_make_request()</span></code></a> that converts recursion into iteration, to prevent
stack overflows.</p>
<p>This would normally mean allocating multiple bios under
<a class="reference internal" href="../core-api/kernel-api.html#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_make_request()</span></code></a> would be susceptible to deadlocks, but we have
deadlock avoidance code that resubmits any blocked bios from a rescuer
thread.</p>
<p>However, we do not guarantee forward progress for allocations from other
mempools. Doing multiple allocations from the same mempool under
<a class="reference internal" href="../core-api/kernel-api.html#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_make_request()</span></code></a> should be avoided - instead, use bio_set’s front_pad
for per bio allocations.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to new bio on success, NULL on failure.</div></blockquote>
<dl class="function">
<dt id="c.bio_put">
void <code class="descname">bio_put</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to release reference to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Put a reference to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code>, either one you have gotten with
bio_alloc, bio_get or bio_clone_*. The last put of a bio will free it.</div></blockquote>
<dl class="function">
<dt id="c.__bio_clone_fast">
void <code class="descname">__bio_clone_fast</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct bio *<em>&nbsp;bio_src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bio_clone_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a bio that shares the original bio’s biovec</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio_src</span></code></dt>
<dd><p class="first">bio to clone</p>
<p>Clone a <code class="xref c c-type docutils literal notranslate"><span class="pre">bio</span></code>. Caller will own the returned bio, but not
the actual data it points to. Reference count of returned
bio will be one.</p>
<p class="last">Caller must ensure that <strong>bio_src</strong> is not freed before <strong>bio</strong>.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.bio_clone_fast">
struct bio * <code class="descname">bio_clone_fast</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, gfp_t<em>&nbsp;gfp_mask</em>, struct bio_set *<em>&nbsp;bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_clone_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a bio that shares the original bio’s biovec</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to clone</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd><p class="first">bio_set to allocate from</p>
<p class="last">Like __bio_clone_fast, only also allocates the returned bio</p>
</dd>
</dl>
<dl class="function">
<dt id="c.bio_add_pc_page">
int <code class="descname">bio_add_pc_page</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;len</em>, unsigned int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_add_pc_page" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to add page to passthrough bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the target queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>vec entry length</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>vec entry offset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to add a page to the bio_vec maplist. This can fail for a
number of reasons, such as the bio being full or target block device
limitations. The target block device must allow bio’s up to PAGE_SIZE,
so it is always possible to add a single page to an empty bio.</p>
<p>This should only be used by passthrough bios.</p>
<dl class="function">
<dt id="c.__bio_try_merge_page">
bool <code class="descname">__bio_try_merge_page</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;len</em>, unsigned int<em>&nbsp;off</em>, bool *<em>&nbsp;same_page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bio_try_merge_page" title="Permalink to this definition">¶</a></dt>
<dd><p>try appending data to an existing bvec.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>start page to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of the data to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">off</span></code></dt>
<dd>offset of the data relative to <strong>page</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">same_page</span></code></dt>
<dd>return if the segment has been merged inside the same page</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to add the data at <strong>page</strong> + <strong>off</strong> to the last bvec of <strong>bio</strong>.  This is a
a useful optimisation for file systems with a block size smaller than the
page size.</p>
<p>Warn if (<strong>len</strong>, <strong>off</strong>) crosses pages in case that <strong>same_page</strong> is true.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> on success or <code class="docutils literal notranslate"><span class="pre">false</span></code> on failure.</p>
<dl class="function">
<dt id="c.__bio_add_page">
void <code class="descname">__bio_add_page</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;len</em>, unsigned int<em>&nbsp;off</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bio_add_page" title="Permalink to this definition">¶</a></dt>
<dd><p>add page(s) to a bio in a new segment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>start page to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of the data to add, may cross pages</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">off</span></code></dt>
<dd>offset of the data relative to <strong>page</strong>, may cross pages</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the data at <strong>page</strong> + <strong>off</strong> to <strong>bio</strong> as a new bvec.  The caller must ensure
that <strong>bio</strong> has space for another bvec.</p>
<dl class="function">
<dt id="c.bio_add_page">
int <code class="descname">bio_add_page</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;len</em>, unsigned int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_add_page" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to add page(s) to bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>start page to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>vec entry length, may cross pages</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd><p class="first">vec entry offset relative to <strong>page</strong>, may cross pages</p>
<p class="last">Attempt to add page(s) to the bio_vec maplist. This will only fail
if either bio-&gt;bi_vcnt == bio-&gt;bi_max_vecs or it’s a cloned bio.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.bio_iov_iter_get_pages">
int <code class="descname">bio_iov_iter_get_pages</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct iov_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_iov_iter_get_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>add user or kernel pages to a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to add pages to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>iov iterator describing the region to be added</dd>
</dl>
<p><strong>Description</strong></p>
<p>This takes either an iterator pointing to user memory, or one pointing to
kernel pages (BVEC iterator). If we’re adding user pages, we pin them and
map them into the kernel. On IO completion, the caller should put those
pages. If we’re adding kernel pages, and the caller told us it’s safe to
do so, we just have to add the pages to the bio directly. We don’t grab an
extra reference to those pages (the user should already have that), and we
don’t put the page on IO completion. The caller needs to check if the bio is
flagged BIO_NO_PAGE_REF on IO completion. If it isn’t, then pages should be
released.</p>
<p>The function tries, but does not guarantee, to pin as many pages as
fit into the bio, or are requested in <a href="#id1"><span class="problematic" id="id2">*</span></a>iter, whatever is smaller. If
MM encounters an error pinning the requested pages, it stops. Error
is returned only if 0 pages could be pinned.</p>
<dl class="function">
<dt id="c.submit_bio_wait">
int <code class="descname">submit_bio_wait</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.submit_bio_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>submit a bio, and wait until it completes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code> which describes the I/O</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simple wrapper around <a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio()</span></code></a>. Returns 0 on success, or the error from
<a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_endio()</span></code></a> on failure.</p>
<p>WARNING: Unlike to how <a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio()</span></code></a> is usually used, this function does not
result in bio reference to be consumed. The caller must drop the reference
on his own.</p>
<dl class="function">
<dt id="c.bio_advance">
void <code class="descname">bio_advance</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, unsigned<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_advance" title="Permalink to this definition">¶</a></dt>
<dd><p>increment/complete a bio by some number of bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to advance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">bytes</span></code></dt>
<dd>number of bytes to complete</dd>
</dl>
<p><strong>Description</strong></p>
<p>This updates bi_sector, bi_size and bi_idx; if the number of bytes to
complete doesn’t align with a bvec boundary, then bv_len and bv_offset will
be updated on the last bvec as well.</p>
<p><strong>bio</strong> will then represent the remaining, uncompleted portion of the io.</p>
<dl class="function">
<dt id="c.bio_copy_data">
void <code class="descname">bio_copy_data</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;dst</em>, struct bio *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_copy_data" title="Permalink to this definition">¶</a></dt>
<dd><p>copy contents of data buffers from one bio to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bio</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops when it reaches the end of either <strong>src</strong> or <strong>dst</strong> - that is, copies
min(src-&gt;bi_size, dst-&gt;bi_size) bytes (or the equivalent for lists of bios).</p>
<dl class="function">
<dt id="c.bio_list_copy_data">
void <code class="descname">bio_list_copy_data</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;dst</em>, struct bio *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_list_copy_data" title="Permalink to this definition">¶</a></dt>
<dd><p>copy contents of data buffers from one chain of bios to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bio list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bio list</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops when it reaches the end of either the <strong>src</strong> list or <strong>dst</strong> list - that is,
copies min(src-&gt;bi_size, dst-&gt;bi_size) bytes (or the equivalent for lists of
bios).</p>
<dl class="function">
<dt id="c.bio_endio">
void <code class="descname">bio_endio</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_endio" title="Permalink to this definition">¶</a></dt>
<dd><p>end I/O on a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_endio()</span></code></a> will end I/O on the whole bio. <a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_endio()</span></code></a> is the preferred
way to end I/O on a bio. No one should call bi_end_io() directly on a
bio unless they own it and thus know that it has an end_io function.</p>
<p><a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_endio()</span></code></a> can be called several times on a bio that has been chained
using <a class="reference internal" href="#c.bio_chain" title="bio_chain"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_chain()</span></code></a>.  The -&gt;bi_end_io() function will only be called the
last time.  At this point the BLK_TA_COMPLETE tracing event will be
generated if BIO_TRACE_COMPLETION is set.</p>
</div></blockquote>
<dl class="function">
<dt id="c.bio_split">
struct bio * <code class="descname">bio_split</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, int<em>&nbsp;sectors</em>, gfp_t<em>&nbsp;gfp</em>, struct bio_set *<em>&nbsp;bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_split" title="Permalink to this definition">¶</a></dt>
<dd><p>split a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to split</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sectors</span></code></dt>
<dd>number of sectors to split from the front of <strong>bio</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>gfp mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>bio set to allocate from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a new bio which represents <strong>sectors</strong> from the start of
<strong>bio</strong>, and updates <strong>bio</strong> to represent the remaining sectors.</p>
<p>Unless this is a discard request the newly allocated bio will point
to <strong>bio</strong>’s bi_io_vec. It is the caller’s responsibility to ensure that
neither <strong>bio</strong> nor <strong>bs</strong> are freed before the split bio.</p>
<dl class="function">
<dt id="c.bio_trim">
void <code class="descname">bio_trim</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, int<em>&nbsp;offset</em>, int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_trim" title="Permalink to this definition">¶</a></dt>
<dd><p>trim a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to trim</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>number of sectors to trim from the front of <strong>bio</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>size we want to trim <strong>bio</strong> to, in sectors</dd>
</dl>
<dl class="function">
<dt id="c.bioset_init">
int <code class="descname">bioset_init</code><span class="sig-paren">(</span>struct bio_set *<em>&nbsp;bs</em>, unsigned int<em>&nbsp;pool_size</em>, unsigned int<em>&nbsp;front_pad</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bioset_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a bio_set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>pool to initialize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pool_size</span></code></dt>
<dd>Number of bio and bio_vecs to cache in the mempool</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">front_pad</span></code></dt>
<dd>Number of bytes to allocate in front of the returned bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>Flags to modify behavior, currently <code class="docutils literal notranslate"><span class="pre">BIOSET_NEED_BVECS</span></code>
and <code class="docutils literal notranslate"><span class="pre">BIOSET_NEED_RESCUER</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Set up a bio_set to be used with <strong>bio_alloc_bioset</strong>. Allows the caller
to ask for a number of bytes to be allocated in front of the bio.
Front pad allocation is useful for embedding the bio inside
another structure, to avoid allocating extra data to go with the bio.
Note that the bio must be embedded at the END of that structure always,
or things will break badly.
If <code class="docutils literal notranslate"><span class="pre">BIOSET_NEED_BVECS</span></code> is set in <strong>flags</strong>, a separate pool will be allocated
for allocating iovecs.  This pool is not needed e.g. for <a class="reference internal" href="#c.bio_clone_fast" title="bio_clone_fast"><code class="xref c c-func docutils literal notranslate"><span class="pre">bio_clone_fast()</span></code></a>.
If <code class="docutils literal notranslate"><span class="pre">BIOSET_NEED_RESCUER</span></code> is set, a workqueue is created which can be used to
dispatch queued requests when the mempool runs out of space.</div></blockquote>
<dl class="function">
<dt id="c.bio_disassociate_blkg">
void <code class="descname">bio_disassociate_blkg</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_disassociate_blkg" title="Permalink to this definition">¶</a></dt>
<dd><p>puts back the blkg reference if associated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>target bio</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to disassociate the blkg from <strong>bio</strong> if a blkg is associated.</p>
<dl class="function">
<dt id="c.bio_associate_blkg_from_css">
void <code class="descname">bio_associate_blkg_from_css</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct cgroup_subsys_state *<em>&nbsp;css</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_associate_blkg_from_css" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a bio with a specified css</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>target bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cgroup_subsys_state</span> <span class="pre">*</span> <span class="pre">css</span></code></dt>
<dd>target css</dd>
</dl>
<p><strong>Description</strong></p>
<p>Associate <strong>bio</strong> with the blkg found by combining the css’s blkg and the
request_queue of the <strong>bio</strong>.  This falls back to the queue’s root_blkg if
the association fails with the css.</p>
<dl class="function">
<dt id="c.bio_associate_blkg">
void <code class="descname">bio_associate_blkg</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_associate_blkg" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a bio with a blkg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>target bio</dd>
</dl>
<p><strong>Description</strong></p>
<p>Associate <strong>bio</strong> with the blkg found from the bio’s css and request_queue.
If one is not found, bio_lookup_blkg() creates the blkg.  If a blkg is
already associated, the css is reused and association redone as the
request_queue may have changed.</p>
<dl class="function">
<dt id="c.bio_clone_blkg_association">
void <code class="descname">bio_clone_blkg_association</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;dst</em>, struct bio *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_clone_blkg_association" title="Permalink to this definition">¶</a></dt>
<dd><p>clone blkg association from src to dst bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bio</dd>
</dl>
<dl class="function">
<dt id="c.seq_open">
int <code class="descname">seq_open</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, const struct seq_operations *<em>&nbsp;op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_open" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize sequential file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file we initialize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">seq_operations</span> <span class="pre">*</span> <span class="pre">op</span></code></dt>
<dd><p class="first">method table describing the sequence</p>
<p class="last"><a class="reference internal" href="#c.seq_open" title="seq_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">seq_open()</span></code></a> sets <strong>file</strong>, associating it with a sequence described
by <strong>op</strong>.  <strong>op-&gt;start()</strong> sets the iterator up and returns the first
element of sequence. <strong>op-&gt;stop()</strong> shuts it down.  <strong>op-&gt;next()</strong>
returns the next element of sequence.  <strong>op-&gt;show()</strong> prints element
into the buffer.  In case of error -&gt;start() and -&gt;next() return
ERR_PTR(error).  In the end of sequence they return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. -&gt;show()
returns 0 in case of success and negative number in case of error.
Returning SEQ_SKIP means “discard this element and move on”.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>seq_open() will allocate a struct seq_file and store its</dt>
<dd>pointer in <strong>file-&gt;private_data</strong>. This pointer should not be modified.</dd>
</dl>
<dl class="function">
<dt id="c.seq_read">
ssize_t <code class="descname">seq_read</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, char __user *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>-&gt;read() method for sequential files.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>the file to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to read to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the maximum number of bytes to read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd><p class="first">the current position in the file</p>
<p class="last">Ready-made -&gt;f_op-&gt;read()</p>
</dd>
</dl>
<dl class="function">
<dt id="c.seq_lseek">
loff_t <code class="descname">seq_lseek</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;offset</em>, int<em>&nbsp;whence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_lseek" title="Permalink to this definition">¶</a></dt>
<dd><p>-&gt;llseek() method for sequential files.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>the file in question</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt>
<dd>new position</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">whence</span></code></dt>
<dd><p class="first">0 for absolute, 1 for relative position</p>
<p class="last">Ready-made -&gt;f_op-&gt;llseek()</p>
</dd>
</dl>
<dl class="function">
<dt id="c.seq_release">
int <code class="descname">seq_release</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_release" title="Permalink to this definition">¶</a></dt>
<dd><p>free the structures associated with sequential file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd><p class="first">its inode</p>
<p class="last">Frees the structures associated with sequential file; can be used
as -&gt;f_op-&gt;release() if you don’t have private data to destroy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file in question</dd>
</dl>
<dl class="function">
<dt id="c.seq_escape">
void <code class="descname">seq_escape</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, const char *<em>&nbsp;s</em>, const char *<em>&nbsp;esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_escape" title="Permalink to this definition">¶</a></dt>
<dd><p>print string into buffer, escaping some characters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>target buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">esc</span></code></dt>
<dd><p class="first">set of characters that need escaping</p>
<p class="last">Puts string into buffer, replacing each occurrence of character from
<strong>esc</strong> with usual octal escape.
Use seq_has_overflowed() to check for errors.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.mangle_path">
char * <code class="descname">mangle_path</code><span class="sig-paren">(</span>char *<em>&nbsp;s</em>, const char *<em>&nbsp;p</em>, const char *<em>&nbsp;esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mangle_path" title="Permalink to this definition">¶</a></dt>
<dd><p>mangle and copy path to buffer beginning</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>buffer start</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>beginning of path in above buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">esc</span></code></dt>
<dd><p class="first">set of characters that need escaping</p>
<p class="last">Copy the path from <strong>p</strong> to <strong>s</strong>, replacing each occurrence of character from
<strong>esc</strong> with usual octal escape.
Returns pointer past last written character in <strong>s</strong>, or NULL in case of
failure.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.seq_path">
int <code class="descname">seq_path</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, const struct path *<em>&nbsp;path</em>, const char *<em>&nbsp;esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_path" title="Permalink to this definition">¶</a></dt>
<dd><p>seq_file interface to print a pathname</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>the seq_file handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>the struct path to print</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">esc</span></code></dt>
<dd>set of characters to escape in the output</dd>
</dl>
<p><strong>Description</strong></p>
<p>return the absolute path of ‘path’, as represented by the
dentry / mnt pair in the path parameter.</p>
<dl class="function">
<dt id="c.seq_file_path">
int <code class="descname">seq_file_path</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, struct file *<em>&nbsp;file</em>, const char *<em>&nbsp;esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_file_path" title="Permalink to this definition">¶</a></dt>
<dd><p>seq_file interface to print a pathname of a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>the seq_file handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>the struct file to print</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">esc</span></code></dt>
<dd>set of characters to escape in the output</dd>
</dl>
<p><strong>Description</strong></p>
<p>return the absolute path to the file.</p>
<dl class="function">
<dt id="c.seq_write">
int <code class="descname">seq_write</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;seq</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write arbitrary data to buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">seq</span></code></dt>
<dd>seq_file identifying the buffer to which data should be written</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, non-zero otherwise.</p>
<dl class="function">
<dt id="c.seq_pad">
void <code class="descname">seq_pad</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, char<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>write padding spaces to buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>seq_file identifying the buffer to which data should be written</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">c</span></code></dt>
<dd>the byte to append after padding if non-zero</dd>
</dl>
<dl class="function">
<dt id="c.seq_hlist_start">
struct hlist_node * <code class="descname">seq_hlist_start</code><span class="sig-paren">(</span>struct hlist_head *<em>&nbsp;head</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>the start position of the sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;start().</p>
<dl class="function">
<dt id="c.seq_hlist_start_head">
struct hlist_node * <code class="descname">seq_hlist_start_head</code><span class="sig-paren">(</span>struct hlist_head *<em>&nbsp;head</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_head" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>the start position of the sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;start(). Call this function if you want to
print a header at the top of the output.</p>
<dl class="function">
<dt id="c.seq_hlist_next">
struct hlist_node * <code class="descname">seq_hlist_next</code><span class="sig-paren">(</span>void *<em>&nbsp;v</em>, struct hlist_head *<em>&nbsp;head</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_next" title="Permalink to this definition">¶</a></dt>
<dd><p>move to the next position of the hlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>the current iterator</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;next().</p>
<dl class="function">
<dt id="c.seq_hlist_start_rcu">
struct hlist_node * <code class="descname">seq_hlist_start_rcu</code><span class="sig-paren">(</span>struct hlist_head *<em>&nbsp;head</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist protected by RCU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>the start position of the sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;start().</p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.seq_hlist_start_head_rcu">
struct hlist_node * <code class="descname">seq_hlist_start_head_rcu</code><span class="sig-paren">(</span>struct hlist_head *<em>&nbsp;head</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist protected by RCU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>the start position of the sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;start(). Call this function if you want to
print a header at the top of the output.</p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.seq_hlist_next_rcu">
struct hlist_node * <code class="descname">seq_hlist_next_rcu</code><span class="sig-paren">(</span>void *<em>&nbsp;v</em>, struct hlist_head *<em>&nbsp;head</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_next_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>move to the next position of the hlist protected by RCU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>the current iterator</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;next().</p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.seq_hlist_start_percpu">
struct hlist_node * <code class="descname">seq_hlist_start_percpu</code><span class="sig-paren">(</span>struct hlist_head __percpu *<em>&nbsp;head</em>, int *<em>&nbsp;cpu</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a percpu hlist array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to percpu array of struct hlist_heads</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">cpu</span></code></dt>
<dd>pointer to cpu “cursor”</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>start position of sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;start().</p>
<dl class="function">
<dt id="c.seq_hlist_next_percpu">
struct hlist_node * <code class="descname">seq_hlist_next_percpu</code><span class="sig-paren">(</span>void *<em>&nbsp;v</em>, struct hlist_head __percpu *<em>&nbsp;head</em>, int *<em>&nbsp;cpu</em>, loff_t *<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_next_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>move to the next position of the percpu hlist array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer to current hlist_node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to percpu array of struct hlist_heads</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">cpu</span></code></dt>
<dd>pointer to cpu “cursor”</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">pos</span></code></dt>
<dd>start position of sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;next().</p>
<dl class="function">
<dt id="c.register_filesystem">
int <code class="descname">register_filesystem</code><span class="sig-paren">(</span>struct file_system_type *<em>&nbsp;fs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_filesystem" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">fs</span></code></dt>
<dd><p class="first">the file system structure</p>
<p>Adds the file system passed to the list of file systems the kernel
is aware of for mount and other syscalls. Returns 0 on success,
or a negative errno code on an error.</p>
<p class="last">The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> that is passed is linked into the kernel
structures and must not be freed until the file system has been
unregistered.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.unregister_filesystem">
int <code class="descname">unregister_filesystem</code><span class="sig-paren">(</span>struct file_system_type *<em>&nbsp;fs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_filesystem" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a file system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">fs</span></code></dt>
<dd><p class="first">filesystem to unregister</p>
<p>Remove a file system that was previously successfully registered
with the kernel. An error is returned if the file system is not found.
Zero is returned on a success.</p>
<p class="last">Once this function has returned the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> structure
may be freed or reused.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.wbc_attach_and_unlock_inode">
void <code class="descname">wbc_attach_and_unlock_inode</code><span class="sig-paren">(</span>struct writeback_control *<em>&nbsp;wbc</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wbc_attach_and_unlock_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>associate wbc with target inode and unlock it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>writeback_control of interest</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>target inode</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>inode</strong> is locked and about to be written back under the control of <strong>wbc</strong>.
Record <strong>inode</strong>’s writeback context into <strong>wbc</strong> and unlock the i_lock.  On
writeback completion, <a class="reference internal" href="#c.wbc_detach_inode" title="wbc_detach_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">wbc_detach_inode()</span></code></a> should be called.  This is used
to track the cgroup writeback context.</p>
<dl class="function">
<dt id="c.wbc_detach_inode">
void <code class="descname">wbc_detach_inode</code><span class="sig-paren">(</span>struct writeback_control *<em>&nbsp;wbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wbc_detach_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>disassociate wbc from inode and perform foreign detection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>writeback_control of the just finished writeback</dd>
</dl>
<p><strong>Description</strong></p>
<p>To be called after a writeback attempt of an inode finishes and undoes
<a class="reference internal" href="#c.wbc_attach_and_unlock_inode" title="wbc_attach_and_unlock_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">wbc_attach_and_unlock_inode()</span></code></a>.  Can be called under any context.</p>
<p>As concurrent write sharing of an inode is expected to be very rare and
memcg only tracks page ownership on first-use basis severely confining
the usefulness of such sharing, cgroup writeback tracks ownership
per-inode.  While the support for concurrent write sharing of an inode
is deemed unnecessary, an inode being written to by different cgroups at
different points in time is a lot more common, and, more importantly,
charging only by first-use can too readily lead to grossly incorrect
behaviors (single foreign page can lead to gigabytes of writeback to be
incorrectly attributed).</p>
<p>To resolve this issue, cgroup writeback detects the majority dirtier of
an inode and transfers the ownership to it.  To avoid unnnecessary
oscillation, the detection mechanism keeps track of history and gives
out the switch verdict only if the foreign usage pattern is stable over
a certain amount of time and/or writeback attempts.</p>
<p>On each writeback attempt, <strong>wbc</strong> tries to detect the majority writer
using Boyer-Moore majority vote algorithm.  In addition to the byte
count from the majority voting, it also counts the bytes written for the
current wb and the last round’s winner wb (max of last round’s current
wb, the winner from two rounds ago, and the last round’s majority
candidate).  Keeping track of the historical winner helps the algorithm
to semi-reliably detect the most active writer even when it’s not the
absolute majority.</p>
<p>Once the winner of the round is determined, whether the winner is
foreign or not and how much IO time the round consumed is recorded in
inode-&gt;i_wb_frn_history.  If the amount of recorded foreign IO time is
over a certain threshold, the switch verdict is given.</p>
<dl class="function">
<dt id="c.wbc_account_cgroup_owner">
void <code class="descname">wbc_account_cgroup_owner</code><span class="sig-paren">(</span>struct writeback_control *<em>&nbsp;wbc</em>, struct page *<em>&nbsp;page</em>, size_t<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wbc_account_cgroup_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>account writeback to update inode cgroup ownership</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>writeback_control of the writeback in progress</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page being written out</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">bytes</span></code></dt>
<dd>number of bytes being written out</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>bytes</strong> from <strong>page</strong> are about to written out during the writeback
controlled by <strong>wbc</strong>.  Keep the book for foreign inode detection.  See
<a class="reference internal" href="#c.wbc_detach_inode" title="wbc_detach_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">wbc_detach_inode()</span></code></a>.</p>
<dl class="function">
<dt id="c.inode_congested">
int <code class="descname">inode_congested</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;cong_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_congested" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether an inode is congested</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to test for congestion (may be NULL)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cong_bits</span></code></dt>
<dd>mask of WB_[a]sync_congested bits to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tests whether <strong>inode</strong> is congested.  <strong>cong_bits</strong> is the mask of congestion
bits to test and the return value is the mask of set bits.</p>
<p>If cgroup writeback is enabled for <strong>inode</strong>, the congestion state is
determined by whether the cgwb (cgroup bdi_writeback) for the blkcg
associated with <strong>inode</strong> is congested; otherwise, the root wb’s congestion
state is used.</p>
<p><strong>inode</strong> is allowed to be NULL as this function is often called on
mapping-&gt;host which is NULL for the swapper space.</p>
<dl class="function">
<dt id="c.__mark_inode_dirty">
void <code class="descname">__mark_inode_dirty</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mark_inode_dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>internal function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to mark</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>what kind of dirty (i.e. I_DIRTY_SYNC)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark an inode as dirty. Callers should use mark_inode_dirty or
mark_inode_dirty_sync.</p>
<p>Put the inode on the super block’s dirty list.</p>
<p>CAREFUL! We mark it dirty unconditionally, but move it onto the
dirty list only if it is hashed or if it refers to a blockdev.
If it was not hashed, it will never be added to the dirty list
even if it is later hashed, as it will have been marked dirty already.</p>
<p>In short, make sure you hash any inodes _before_ you start marking
them dirty.</p>
<p>Note that for blockdevs, inode-&gt;dirtied_when represents the dirtying time of
the block-special inode (/dev/hda1) itself.  And the -&gt;dirtied_when field of
the kernel-internal blockdev inode represents the dirtying time of the
blockdev’s pages.  This is why for I_DIRTY_PAGES we always use
page-&gt;mapping-&gt;host, so the page-dirtying time is recorded in the internal
blockdev inode.</p>
<dl class="function">
<dt id="c.writeback_inodes_sb_nr">
void <code class="descname">writeback_inodes_sb_nr</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;nr</em>, enum wb_reason<em>&nbsp;reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.writeback_inodes_sb_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>writeback dirty inodes from given super_block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the number of pages to write</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt>
<dd>reason why some writeback work initiated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start writeback on some inodes on this super_block. No guarantees are made
on how many (if any) will be written, and this function does not wait
for IO completion of submitted IO.</p>
<dl class="function">
<dt id="c.writeback_inodes_sb">
void <code class="descname">writeback_inodes_sb</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, enum wb_reason<em>&nbsp;reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.writeback_inodes_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>writeback dirty inodes from given super_block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt>
<dd>reason why some writeback work was initiated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start writeback on some inodes on this super_block. No guarantees are made
on how many (if any) will be written, and this function does not wait
for IO completion of submitted IO.</p>
<dl class="function">
<dt id="c.try_to_writeback_inodes_sb">
void <code class="descname">try_to_writeback_inodes_sb</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, enum wb_reason<em>&nbsp;reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_writeback_inodes_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>try to start writeback if none underway</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt>
<dd>reason why some writeback work was initiated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoke __writeback_inodes_sb_nr if no writeback is currently underway.</p>
<dl class="function">
<dt id="c.sync_inodes_sb">
void <code class="descname">sync_inodes_sb</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_inodes_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>sync sb inode pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function writes and waits on any dirty inode belonging to this
super_block.</p>
<dl class="function">
<dt id="c.write_inode_now">
int <code class="descname">write_inode_now</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_inode_now" title="Permalink to this definition">¶</a></dt>
<dd><p>write an inode to disk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to write to disk</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sync</span></code></dt>
<dd>whether the write should be synchronous or not</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits an inode to disk immediately if it is dirty. This is
primarily needed by knfsd.</p>
<p>The caller must either have a ref on the inode or must have set I_WILL_FREE.</p>
<dl class="function">
<dt id="c.sync_inode">
int <code class="descname">sync_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct writeback_control *<em>&nbsp;wbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>write an inode and its pages to disk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode to sync</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>controls the writeback mode</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.sync_inode" title="sync_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">sync_inode()</span></code></a> will write an inode and its pages to disk.  It will also
correctly update the inode on its superblock’s dirty inode lists and will
update inode-&gt;i_state.</p>
<p>The caller must have a ref on the inode.</p>
<dl class="function">
<dt id="c.sync_inode_metadata">
int <code class="descname">sync_inode_metadata</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_inode_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>write an inode to disk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode to sync</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">wait</span></code></dt>
<dd>wait for I/O to complete.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write an inode to disk and adjust its dirty state after completion.</p>
<p><strong>Note</strong></p>
<p>only writes the actual inode, no associated data or other metadata.</p>
<dl class="function">
<dt id="c.freeze_bdev">
struct super_block * <code class="descname">freeze_bdev</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.freeze_bdev" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>lock a filesystem and force it into a consistent state</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdevice to lock</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a superblock is found on this device, we take the s_umount semaphore
on it to make sure nobody unmounts until the snapshot creation is done.
The reference counter (bd_fsfreeze_count) guarantees that only the last
unfreeze process can unfreeze the frozen filesystem actually when multiple
freeze requests arrive simultaneously. It counts up in <a class="reference internal" href="#c.freeze_bdev" title="freeze_bdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">freeze_bdev()</span></code></a> and
count down in <a class="reference internal" href="#c.thaw_bdev" title="thaw_bdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">thaw_bdev()</span></code></a>. When it becomes 0, <a class="reference internal" href="#c.thaw_bdev" title="thaw_bdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">thaw_bdev()</span></code></a> will unfreeze
actually.</p>
<dl class="function">
<dt id="c.thaw_bdev">
int <code class="descname">thaw_bdev</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.thaw_bdev" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>unlock filesystem</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdevice to unlock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>associated superblock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the filesystem and marks it writeable again after <a class="reference internal" href="#c.freeze_bdev" title="freeze_bdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">freeze_bdev()</span></code></a>.</p>
<dl class="function">
<dt id="c.bdgrab">
struct block_device * <code class="descname">bdgrab</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdgrab" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Grab a reference to an already referenced block device</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>Block device to grab a reference to.</dd>
</dl>
<dl class="function">
<dt id="c.bd_start_claiming">
struct block_device * <code class="descname">bd_start_claiming</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, void *<em>&nbsp;holder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bd_start_claiming" title="Permalink to this definition">¶</a></dt>
<dd><p>start claiming a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>block device of interest</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">holder</span></code></dt>
<dd>holder trying to claim <strong>bdev</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>bdev</strong> is about to be opened exclusively.  Check <strong>bdev</strong> can be opened
exclusively and mark that an exclusive open is in progress.  Each
successful call to this function must be matched with a call to
either <a class="reference internal" href="#c.bd_finish_claiming" title="bd_finish_claiming"><code class="xref c c-func docutils literal notranslate"><span class="pre">bd_finish_claiming()</span></code></a> or <a class="reference internal" href="#c.bd_abort_claiming" title="bd_abort_claiming"><code class="xref c c-func docutils literal notranslate"><span class="pre">bd_abort_claiming()</span></code></a> (which do not
fail).</p>
<p>This function is used to gain exclusive access to the block device
without actually causing other exclusive open attempts to fail. It
should be used when the open sequence itself requires exclusive
access but may subsequently fail.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>Pointer to the block device containing <strong>bdev</strong> on success, ERR_PTR()
value on failure.</p>
<dl class="function">
<dt id="c.bd_finish_claiming">
void <code class="descname">bd_finish_claiming</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct block_device *<em>&nbsp;whole</em>, void *<em>&nbsp;holder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bd_finish_claiming" title="Permalink to this definition">¶</a></dt>
<dd><p>finish claiming of a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>block device of interest</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">whole</span></code></dt>
<dd>whole block device (returned from <a class="reference internal" href="#c.bd_start_claiming" title="bd_start_claiming"><code class="xref c c-func docutils literal notranslate"><span class="pre">bd_start_claiming()</span></code></a>)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">holder</span></code></dt>
<dd>holder that has claimed <strong>bdev</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Finish exclusive open of a block device. Mark the device as exlusively
open by the holder and wake up all waiters for exclusive open to finish.</p>
<dl class="function">
<dt id="c.bd_abort_claiming">
void <code class="descname">bd_abort_claiming</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct block_device *<em>&nbsp;whole</em>, void *<em>&nbsp;holder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bd_abort_claiming" title="Permalink to this definition">¶</a></dt>
<dd><p>abort claiming of a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>block device of interest</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">whole</span></code></dt>
<dd>whole block device (returned from <a class="reference internal" href="#c.bd_start_claiming" title="bd_start_claiming"><code class="xref c c-func docutils literal notranslate"><span class="pre">bd_start_claiming()</span></code></a>)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">holder</span></code></dt>
<dd>holder that has claimed <strong>bdev</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Abort claiming of a block device when the exclusive open failed. This can be
also used when exclusive open is not actually desired and we just needed
to block other exclusive openers for a while.</p>
<dl class="function">
<dt id="c.bd_link_disk_holder">
int <code class="descname">bd_link_disk_holder</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bd_link_disk_holder" title="Permalink to this definition">¶</a></dt>
<dd><p>create symlinks between holding disk and slave bdev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the claimed slave bdev</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>the holding disk</dd>
</dl>
<p><strong>Description</strong></p>
<p>DON’T USE THIS UNLESS YOU’RE ALREADY USING IT.</p>
<p>This functions creates the following sysfs symlinks.</p>
<ul class="simple">
<li>from “slaves” directory of the holder <strong>disk</strong> to the claimed <strong>bdev</strong></li>
<li>from “holders” directory of the <strong>bdev</strong> to the holder <strong>disk</strong></li>
</ul>
<p>For example, if /dev/dm-0 maps to /dev/sda and disk for dm-0 is
passed to <a class="reference internal" href="#c.bd_link_disk_holder" title="bd_link_disk_holder"><code class="xref c c-func docutils literal notranslate"><span class="pre">bd_link_disk_holder()</span></code></a>, then:</p>
<blockquote>
<div>/sys/block/dm-0/slaves/sda –&gt; /sys/block/sda
/sys/block/sda/holders/dm-0 –&gt; /sys/block/dm-0</div></blockquote>
<p>The caller must have claimed <strong>bdev</strong> before calling this function and
ensure that both <strong>bdev</strong> and <strong>disk</strong> are valid during the creation and
lifetime of these symlinks.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.bd_unlink_disk_holder">
void <code class="descname">bd_unlink_disk_holder</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bd_unlink_disk_holder" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy symlinks created by <a class="reference internal" href="#c.bd_link_disk_holder" title="bd_link_disk_holder"><code class="xref c c-func docutils literal notranslate"><span class="pre">bd_link_disk_holder()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the calimed slave bdev</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>the holding disk</dd>
</dl>
<p><strong>Description</strong></p>
<p>DON’T USE THIS UNLESS YOU’RE ALREADY USING IT.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.revalidate_disk">
int <code class="descname">revalidate_disk</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.revalidate_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for lower-level driver’s revalidate_disk call-back</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>struct gendisk to be revalidated</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is a wrapper for lower-level driver’s revalidate_disk
call-backs.  It is used to do common pre and post operations needed
for all revalidate_disk operations.</p>
<dl class="function">
<dt id="c.blkdev_get">
int <code class="descname">blkdev_get</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, fmode_t<em>&nbsp;mode</em>, void *<em>&nbsp;holder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_get" title="Permalink to this definition">¶</a></dt>
<dd><p>open a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>block_device to open</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fmode_t</span> <span class="pre">mode</span></code></dt>
<dd>FMODE_* mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">holder</span></code></dt>
<dd>exclusive holder identifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open <strong>bdev</strong> with <strong>mode</strong>.  If <strong>mode</strong> includes <code class="docutils literal notranslate"><span class="pre">FMODE_EXCL</span></code>, <strong>bdev</strong> is
open with exclusive access.  Specifying <code class="docutils literal notranslate"><span class="pre">FMODE_EXCL</span></code> with <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
<strong>holder</strong> is invalid.  Exclusive opens may nest for the same <strong>holder</strong>.</p>
<p>On success, the reference count of <strong>bdev</strong> is unchanged.  On failure,
<strong>bdev</strong> is put.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.blkdev_get_by_path">
struct block_device * <code class="descname">blkdev_get_by_path</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em>, fmode_t<em>&nbsp;mode</em>, void *<em>&nbsp;holder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_get_by_path" title="Permalink to this definition">¶</a></dt>
<dd><p>open a block device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to the block device to open</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fmode_t</span> <span class="pre">mode</span></code></dt>
<dd>FMODE_* mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">holder</span></code></dt>
<dd>exclusive holder identifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open the blockdevice described by the device file at <strong>path</strong>.  <strong>mode</strong>
and <strong>holder</strong> are identical to <a class="reference internal" href="#c.blkdev_get" title="blkdev_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">blkdev_get()</span></code></a>.</p>
<p>On success, the returned block_device has reference count of one.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>Pointer to block_device on success, ERR_PTR(-errno) on failure.</p>
<dl class="function">
<dt id="c.blkdev_get_by_dev">
struct block_device * <code class="descname">blkdev_get_by_dev</code><span class="sig-paren">(</span>dev_t<em>&nbsp;dev</em>, fmode_t<em>&nbsp;mode</em>, void *<em>&nbsp;holder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_get_by_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>open a block device by device number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>device number of block device to open</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fmode_t</span> <span class="pre">mode</span></code></dt>
<dd>FMODE_* mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">holder</span></code></dt>
<dd>exclusive holder identifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open the blockdevice described by device number <strong>dev</strong>.  <strong>mode</strong> and
<strong>holder</strong> are identical to <a class="reference internal" href="#c.blkdev_get" title="blkdev_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">blkdev_get()</span></code></a>.</p>
<p>Use it ONLY if you really do not have anything better - i.e. when
you are behind a truly sucky interface and all you are given is a
device number.  _Never_ to be used for internal purposes.  If you
ever need it - reconsider your API.</p>
<p>On success, the returned block_device has reference count of one.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>Pointer to block_device on success, ERR_PTR(-errno) on failure.</p>
<dl class="function">
<dt id="c.lookup_bdev">
struct block_device * <code class="descname">lookup_bdev</code><span class="sig-paren">(</span>const char *<em>&nbsp;pathname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_bdev" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup a struct block_device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pathname</span></code></dt>
<dd>special file representing the block device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a reference to the blockdevice at <strong>pathname</strong> in the current
namespace if possible and return it.  Return ERR_PTR(error)
otherwise.</p>
<dl class="function">
<dt id="c.anon_inode_getfile">
struct file * <code class="descname">anon_inode_getfile</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, const struct file_operations *<em>&nbsp;fops</em>, void *<em>&nbsp;priv</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_inode_getfile" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new file instance by hooking it up to an anonymous inode, and a dentry that describe the “class” of the file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>[in]    name of the “class” of the new file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>[in]    file operations for the new file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>[in]    private data for the new file (will be file’s private_data)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>[in]    flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new file by hooking it on a single inode. This is useful for files
that do not need to have a full-fledged inode in order to operate correctly.
All the files created with <a class="reference internal" href="#c.anon_inode_getfile" title="anon_inode_getfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">anon_inode_getfile()</span></code></a> will share a single inode,
hence saving memory and avoiding code duplication for the file/inode/dentry
setup.  Returns the newly created file* or an error pointer.</p>
<dl class="function">
<dt id="c.anon_inode_getfd">
int <code class="descname">anon_inode_getfd</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, const struct file_operations *<em>&nbsp;fops</em>, void *<em>&nbsp;priv</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_inode_getfd" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new file instance by hooking it up to an anonymous inode, and a dentry that describe the “class” of the file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>[in]    name of the “class” of the new file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>[in]    file operations for the new file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>[in]    private data for the new file (will be file’s private_data)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>[in]    flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new file by hooking it on a single inode. This is useful for files
that do not need to have a full-fledged inode in order to operate correctly.
All the files created with <a class="reference internal" href="#c.anon_inode_getfd" title="anon_inode_getfd"><code class="xref c c-func docutils literal notranslate"><span class="pre">anon_inode_getfd()</span></code></a> will share a single inode,
hence saving memory and avoiding code duplication for the file/inode/dentry
setup.  Returns new descriptor or an error code.</p>
<dl class="function">
<dt id="c.setattr_prepare">
int <code class="descname">setattr_prepare</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct iattr *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setattr_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>check if attribute changes to a dentry are allowed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry to check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attributes to change</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if we are allowed to change the attributes contained in <strong>attr</strong>
in the given dentry.  This includes the normal unix access permission
checks, as well as checks for rlimits and others. The function also clears
SGID bit from mode if user is not allowed to set it. Also file capabilities
and IMA extended attributes are cleared if ATTR_KILL_PRIV is set.</p>
<p>Should be called as the first thing in -&gt;setattr implementations,
possibly after taking additional locks.</p>
<dl class="function">
<dt id="c.inode_newsize_ok">
int <code class="descname">inode_newsize_ok</code><span class="sig-paren">(</span>const struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_newsize_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>may this inode be truncated to a given size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode to be truncated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt>
<dd>the new size to assign to the inode</dd>
</dl>
<p><strong>Description</strong></p>
<p>inode_newsize_ok must be called with i_mutex held.</p>
<p>inode_newsize_ok will check filesystem limits and ulimits to check that the
new inode size is within limits. inode_newsize_ok will also send SIGXFSZ
when necessary. Caller must not proceed with inode size change if failure is
returned. <strong>inode</strong> must be a file (not directory), with appropriate
permissions to allow truncate (inode_newsize_ok does NOT check these
conditions).</p>
<p><strong>Return</strong></p>
<p>0 on success, -ve errno on failure</p>
<dl class="function">
<dt id="c.setattr_copy">
void <code class="descname">setattr_copy</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, const struct iattr *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setattr_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>copy simple metadata updates into the generic inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode to be updated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>the new attributes</dd>
</dl>
<p><strong>Description</strong></p>
<p>setattr_copy must be called with i_mutex held.</p>
<p>setattr_copy updates the inode’s metadata with that specified
in attr. Noticeably missing is inode size update, which is more complex
as it requires pagecache updates.</p>
<p>The inode is not marked as dirty after this operation. The rationale is
that for “simple” filesystems, the struct inode is the inode storage.
The caller is free to mark the inode dirty afterwards if needed.</p>
<dl class="function">
<dt id="c.notify_change">
int <code class="descname">notify_change</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct iattr *<em>&nbsp;attr</em>, struct inode **<em>&nbsp;delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.notify_change" title="Permalink to this definition">¶</a></dt>
<dd><p>modify attributes of a filesytem object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>object affected</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>new attributes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**</span> <span class="pre">delegated_inode</span></code></dt>
<dd>returns inode, if the inode is delegated</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold the i_mutex on the affected object.</p>
<p>If notify_change discovers a delegation in need of breaking,
it will return -EWOULDBLOCK and return a reference to the inode in
delegated_inode.  The caller should then break the delegation and
retry.  Because breaking a delegation may take a long time, the
caller should drop the i_mutex before doing so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.  Also, passing NULL is fine for callers holding
the file open for write, as there can be no conflicting delegation in
that case.</p>
<dl class="function">
<dt id="c.d_path">
char * <code class="descname">d_path</code><span class="sig-paren">(</span>const struct path *<em>&nbsp;path</em>, char *<em>&nbsp;buf</em>, int<em>&nbsp;buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_path" title="Permalink to this definition">¶</a></dt>
<dd><p>return the path of a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to report</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to return value in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>buffer length</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convert a dentry into an ASCII path name. If the entry has been deleted
the string ” (deleted)” is appended. Note that this is ambiguous.</p>
<p>Returns a pointer into the buffer or an error code if the path was
too long. Note: Callers should use the returned pointer, not the passed
in buffer, to use the name! The implementation often starts at an offset
into the buffer, and may leave 0 bytes at the start.</p>
<p>“buflen” should be positive.</p>
<dl class="function">
<dt id="c.dax_layout_busy_page">
struct page * <code class="descname">dax_layout_busy_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a> *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dax_layout_busy_page" title="Permalink to this definition">¶</a></dt>
<dd><p>find first pinned page in <strong>mapping</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space to scan for a page with ref count &gt; 1</dd>
</dl>
<p><strong>Description</strong></p>
<p>DAX requires ZONE_DEVICE mapped pages. These pages are never
‘onlined’ to the page allocator so they are considered idle when
page-&gt;count == 1. A filesystem uses this interface to determine if
any page in the mapping is busy, i.e. for DMA, or other
get_user_pages() usages.</p>
<p>It is expected that the filesystem is holding locks to block the
establishment of new mappings in this address_space. I.e. it expects
to be able to run <a class="reference internal" href="../core-api/mm-api.html#c.unmap_mapping_range" title="unmap_mapping_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">unmap_mapping_range()</span></code></a> and subsequently not race
mapping_mapped() becoming true.</p>
<dl class="function">
<dt id="c.dax_iomap_rw">
ssize_t <code class="descname">dax_iomap_rw</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;iter</em>, const struct iomap_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dax_iomap_rw" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform I/O to a DAX file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>The control block for this I/O</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>The addresses to do I/O from or to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iomap_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>iomap ops passed from the file system</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function performs read and write operations to directly mapped
persistent memory.  The callers needs to take care of read/write exclusion
and evicting any page cache pages in the region under I/O.</p>
<dl class="function">
<dt id="c.dax_iomap_fault">
vm_fault_t <code class="descname">dax_iomap_fault</code><span class="sig-paren">(</span>struct vm_fault *<em>&nbsp;vmf</em>, enum page_entry_size<em>&nbsp;pe_size</em>, pfn_t *<em>&nbsp;pfnp</em>, int *<em>&nbsp;iomap_errp</em>, const struct iomap_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dax_iomap_fault" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a page fault on a DAX file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*</span> <span class="pre">vmf</span></code></dt>
<dd>The description of the fault</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">page_entry_size</span> <span class="pre">pe_size</span></code></dt>
<dd>Size of the page to fault in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pfn_t</span> <span class="pre">*</span> <span class="pre">pfnp</span></code></dt>
<dd>PFN to insert for synchronous faults if fsync is required</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">iomap_errp</span></code></dt>
<dd>Storage for detailed error code in case of error</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iomap_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>Iomap ops passed from the file system</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a page fault occurs, filesystems may call this helper in
their fault handler for DAX files. <a class="reference internal" href="#c.dax_iomap_fault" title="dax_iomap_fault"><code class="xref c c-func docutils literal notranslate"><span class="pre">dax_iomap_fault()</span></code></a> assumes the caller
has done all the necessary locking for page fault to proceed
successfully.</p>
<dl class="function">
<dt id="c.dax_finish_sync_fault">
vm_fault_t <code class="descname">dax_finish_sync_fault</code><span class="sig-paren">(</span>struct vm_fault *<em>&nbsp;vmf</em>, enum page_entry_size<em>&nbsp;pe_size</em>, pfn_t<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dax_finish_sync_fault" title="Permalink to this definition">¶</a></dt>
<dd><p>finish synchronous page fault</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*</span> <span class="pre">vmf</span></code></dt>
<dd>The description of the fault</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">page_entry_size</span> <span class="pre">pe_size</span></code></dt>
<dd>Size of entry to be inserted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pfn_t</span> <span class="pre">pfn</span></code></dt>
<dd>PFN to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function ensures that the file range touched by the page fault is
stored persistently on the media and handles inserting of appropriate page
table entry.</p>
<dl class="function">
<dt id="c.dio_end_io">
void <code class="descname">dio_end_io</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dio_end_io" title="Permalink to this definition">¶</a></dt>
<dd><p>handle the end io action for the given bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The direct io bio thats being completed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is meant to be called by any filesystem that uses their own dio_submit_t
so that the DIO specific endio actions are dealt with after the filesystem
has done it’s completion work.</p>
<dl class="function">
<dt id="c.simple_setattr">
int <code class="descname">simple_setattr</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct iattr *<em>&nbsp;iattr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_setattr" title="Permalink to this definition">¶</a></dt>
<dd><p>setattr for simple filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iattr</span> <span class="pre">*</span> <span class="pre">iattr</span></code></dt>
<dd>iattr structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -error on failure.</p>
<p>simple_setattr is a simple -&gt;setattr implementation without a proper
implementation of size changes.</p>
<p>It can either be used for in-memory filesystems or special files
on simple regular filesystems.  Anything that needs to change on-disk
or wire state on size changes needs its own setattr method.</p>
<dl class="function">
<dt id="c.simple_write_end">
int <code class="descname">simple_write_end</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, struct <a class="reference internal" href="#c.address_space" title="address_space">address_space</a> *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;pos</em>, unsigned<em>&nbsp;len</em>, unsigned<em>&nbsp;copied</em>, struct page *<em>&nbsp;page</em>, void *<em>&nbsp;fsdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_write_end" title="Permalink to this definition">¶</a></dt>
<dd><p>.write_end helper for non-block-device FSes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>See .write_end of address_space_operations</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>“</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>“</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">len</span></code></dt>
<dd>“</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">copied</span></code></dt>
<dd>“</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>“</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">fsdata</span></code></dt>
<dd>“</dd>
</dl>
<p><strong>Description</strong></p>
<p>simple_write_end does the minimum needed for updating a page after writing is
done. It has the same API signature as the .write_end of
address_space_operations vector. So it can just be set onto .write_end for
FSes that don’t need any other processing. i_mutex is assumed to be held.
Block based filesystems should use generic_write_end().
Use <em>ONLY</em> with simple_readpage()</p>
<p><strong>NOTE</strong></p>
<p>Even though i_size might get updated by this function, mark_inode_dirty
is not called, so a filesystem that actually does store data in .write_inode
should extend on what’s done here with a call to mark_inode_dirty() in the
case that i_size has changed.</p>
<dl class="function">
<dt id="c.simple_read_from_buffer">
ssize_t <code class="descname">simple_read_from_buffer</code><span class="sig-paren">(</span>void __user *<em>&nbsp;to</em>, size_t<em>&nbsp;count</em>, loff_t *<em>&nbsp;ppos</em>, const void *<em>&nbsp;from</em>, size_t<em>&nbsp;available</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_read_from_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from the buffer to user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>the user space buffer to read to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>the maximum number of bytes to read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position in the buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>the buffer to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">available</span></code></dt>
<dd>the size of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.simple_read_from_buffer" title="simple_read_from_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_read_from_buffer()</span></code></a> function reads up to <strong>count</strong> bytes from the
buffer <strong>from</strong> at offset <strong>ppos</strong> into the user space address starting at <strong>to</strong>.</p>
<p>On success, the number of bytes read is returned and the offset <strong>ppos</strong> is
advanced by this number, or negative value is returned on error.</p>
<dl class="function">
<dt id="c.simple_write_to_buffer">
ssize_t <code class="descname">simple_write_to_buffer</code><span class="sig-paren">(</span>void *<em>&nbsp;to</em>, size_t<em>&nbsp;available</em>, loff_t *<em>&nbsp;ppos</em>, const void __user *<em>&nbsp;from</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_write_to_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from user space to the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>the buffer to write to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">available</span></code></dt>
<dd>the size of the buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position in the buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>the user space buffer to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>the maximum number of bytes to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.simple_write_to_buffer" title="simple_write_to_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_write_to_buffer()</span></code></a> function reads up to <strong>count</strong> bytes from the user
space address starting at <strong>from</strong> into the buffer <strong>to</strong> at offset <strong>ppos</strong>.</p>
<p>On success, the number of bytes written is returned and the offset <strong>ppos</strong> is
advanced by this number, or negative value is returned on error.</p>
<dl class="function">
<dt id="c.memory_read_from_buffer">
ssize_t <code class="descname">memory_read_from_buffer</code><span class="sig-paren">(</span>void *<em>&nbsp;to</em>, size_t<em>&nbsp;count</em>, loff_t *<em>&nbsp;ppos</em>, const void *<em>&nbsp;from</em>, size_t<em>&nbsp;available</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memory_read_from_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>the kernel space buffer to read to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>the maximum number of bytes to read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position in the buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>the buffer to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">available</span></code></dt>
<dd>the size of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.memory_read_from_buffer" title="memory_read_from_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">memory_read_from_buffer()</span></code></a> function reads up to <strong>count</strong> bytes from the
buffer <strong>from</strong> at offset <strong>ppos</strong> into the kernel space address starting at <strong>to</strong>.</p>
<p>On success, the number of bytes read is returned and the offset <strong>ppos</strong> is
advanced by this number, or negative value is returned on error.</p>
<dl class="function">
<dt id="c.generic_fh_to_dentry">
struct dentry * <code class="descname">generic_fh_to_dentry</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, struct fid *<em>&nbsp;fid</em>, int<em>&nbsp;fh_len</em>, int<em>&nbsp;fh_type</em>, struct inode *(<em>*get_inode</em>)(struct super_block *sb, u64 ino, u32 gen)<span class="sig-paren">)</span><a class="headerlink" href="#c.generic_fh_to_dentry" title="Permalink to this definition">¶</a></dt>
<dd><p>generic helper for the fh_to_dentry export operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>filesystem to do the file handle conversion on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fid</span> <span class="pre">*</span> <span class="pre">fid</span></code></dt>
<dd>file handle to convert</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fh_len</span></code></dt>
<dd>length of the file handle in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fh_type</span></code></dt>
<dd>type of file handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*(*)</span> <span class="pre">(struct</span> <span class="pre">super_block</span> <span class="pre">*sb,</span> <span class="pre">u64</span> <span class="pre">ino,</span> <span class="pre">u32</span> <span class="pre">gen)</span> <span class="pre">get_inode</span></code></dt>
<dd>filesystem callback to retrieve inode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decodes <strong>fid</strong> as long as it has one of the well-known
Linux filehandle types and calls <strong>get_inode</strong> on it to retrieve the
inode for the object specified in the file handle.</p>
<dl class="function">
<dt id="c.generic_fh_to_parent">
struct dentry * <code class="descname">generic_fh_to_parent</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, struct fid *<em>&nbsp;fid</em>, int<em>&nbsp;fh_len</em>, int<em>&nbsp;fh_type</em>, struct inode *(<em>*get_inode</em>)(struct super_block *sb, u64 ino, u32 gen)<span class="sig-paren">)</span><a class="headerlink" href="#c.generic_fh_to_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>generic helper for the fh_to_parent export operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>filesystem to do the file handle conversion on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fid</span> <span class="pre">*</span> <span class="pre">fid</span></code></dt>
<dd>file handle to convert</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fh_len</span></code></dt>
<dd>length of the file handle in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fh_type</span></code></dt>
<dd>type of file handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*(*)</span> <span class="pre">(struct</span> <span class="pre">super_block</span> <span class="pre">*sb,</span> <span class="pre">u64</span> <span class="pre">ino,</span> <span class="pre">u32</span> <span class="pre">gen)</span> <span class="pre">get_inode</span></code></dt>
<dd>filesystem callback to retrieve inode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decodes <strong>fid</strong> as long as it has one of the well-known
Linux filehandle types and calls <strong>get_inode</strong> on it to retrieve the
inode for the _parent_ object specified in the file handle if it
is specified in the file handle, or NULL otherwise.</p>
<dl class="function">
<dt id="c.__generic_file_fsync">
int <code class="descname">__generic_file_fsync</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;start</em>, loff_t<em>&nbsp;end</em>, int<em>&nbsp;datasync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__generic_file_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>generic fsync implementation for simple filesystems</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file to synchronize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt>
<dd>start offset in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt>
<dd>end offset in bytes (inclusive)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datasync</span></code></dt>
<dd>only synchronize essential metadata if true</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a generic implementation of the fsync method for simple
filesystems which track all non-inode metadata in the buffers list
hanging off the address_space structure.</p>
<dl class="function">
<dt id="c.generic_file_fsync">
int <code class="descname">generic_file_fsync</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;start</em>, loff_t<em>&nbsp;end</em>, int<em>&nbsp;datasync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>generic fsync implementation for simple filesystems with flush</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file to synchronize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt>
<dd>start offset in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt>
<dd>end offset in bytes (inclusive)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datasync</span></code></dt>
<dd>only synchronize essential metadata if true</dd>
</dl>
<dl class="function">
<dt id="c.generic_check_addressable">
int <code class="descname">generic_check_addressable</code><span class="sig-paren">(</span>unsigned<em>&nbsp;blocksize_bits</em>, u64<em>&nbsp;num_blocks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_check_addressable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check addressability of file system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">blocksize_bits</span></code></dt>
<dd>log of file system block size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">num_blocks</span></code></dt>
<dd>number of blocks in file system</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether a file system with <strong>num_blocks</strong> blocks (and a
block size of 2****blocksize_bits**) is addressable by the sector_t
and page cache of the system.  Return 0 if so and -EFBIG otherwise.</p>
<dl class="function">
<dt id="c.simple_nosetlease">
int <code class="descname">simple_nosetlease</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, long<em>&nbsp;arg</em>, struct file_lock **<em>&nbsp;flp</em>, void **<em>&nbsp;priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_nosetlease" title="Permalink to this definition">¶</a></dt>
<dd><p>generic helper for prohibiting leases</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>type of lease to obtain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">**</span> <span class="pre">flp</span></code></dt>
<dd>new lease supplied for insertion</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">priv</span></code></dt>
<dd>private data for lm_setup operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generic helper for filesystems that do not wish to allow leases to be set.
All arguments are ignored and it just returns -EINVAL.</p>
<dl class="function">
<dt id="c.simple_get_link">
const char * <code class="descname">simple_get_link</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct inode *<em>&nbsp;inode</em>, struct delayed_call *<em>&nbsp;done</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_get_link" title="Permalink to this definition">¶</a></dt>
<dd><p>generic helper to get the target of “fast” symlinks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>not used here</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the symlink inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_call</span> <span class="pre">*</span> <span class="pre">done</span></code></dt>
<dd>not used here</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generic helper for filesystems to use for symlink inodes where a pointer to
the symlink target is stored in -&gt;i_link.  NOTE: this isn’t normally called,
since as an optimization the path lookup code uses any non-NULL -&gt;i_link
directly, without calling -&gt;get_link().  But -&gt;get_link() still must be set,
to mark the inode_operations as being for a symlink.</p>
<p><strong>Return</strong></p>
<p>the symlink target</p>
<dl class="function">
<dt id="c.posix_acl_update_mode">
int <code class="descname">posix_acl_update_mode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, umode_t *<em>&nbsp;mode_p</em>, struct posix_acl **<em>&nbsp;acl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_acl_update_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>update mode in set_acl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>target inode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">*</span> <span class="pre">mode_p</span></code></dt>
<dd>mode (pointer) for update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">posix_acl</span> <span class="pre">**</span> <span class="pre">acl</span></code></dt>
<dd>acl pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the file mode when setting an ACL: compute the new file permission
bits based on the ACL.  In addition, if the ACL is equivalent to the new
file mode, set <strong>*acl</strong> to NULL to indicate that no ACL should be set.</p>
<p>As with chmod, clear the setgid bit if the caller is not in the owning group
or capable of CAP_FSETID (see inode_change_ok).</p>
<p>Called from set_acl inode operations.</p>
<dl class="function">
<dt id="c.generic_fillattr">
void <code class="descname">generic_fillattr</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct kstat *<em>&nbsp;stat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_fillattr" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill in the basic attributes from the inode struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>Inode to use as the source</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kstat</span> <span class="pre">*</span> <span class="pre">stat</span></code></dt>
<dd>Where to fill in the attributes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the basic attributes in the kstat structure from data that’s to be
found on the VFS inode structure.  This is the default if no getattr inode
operation is supplied.</p>
<dl class="function">
<dt id="c.vfs_getattr_nosec">
int <code class="descname">vfs_getattr_nosec</code><span class="sig-paren">(</span>const struct path *<em>&nbsp;path</em>, struct kstat *<em>&nbsp;stat</em>, u32<em>&nbsp;request_mask</em>, unsigned int<em>&nbsp;query_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_getattr_nosec" title="Permalink to this definition">¶</a></dt>
<dd><p>getattr without security checks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>file to get attributes from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kstat</span> <span class="pre">*</span> <span class="pre">stat</span></code></dt>
<dd>structure to return attributes in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">request_mask</span></code></dt>
<dd>STATX_xxx flags indicating what the caller wants</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">query_flags</span></code></dt>
<dd>Query mode (KSTAT_QUERY_FLAGS)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get attributes without calling security_inode_getattr.</p>
<p>Currently the only caller other than vfs_getattr is internal to the
filehandle lookup code, which uses only the inode number and returns no
attributes to any user.  Any other code probably wants vfs_getattr.</p>
<dl class="function">
<dt id="c.vfs_statx_fd">
int <code class="descname">vfs_statx_fd</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;fd</em>, struct kstat *<em>&nbsp;stat</em>, u32<em>&nbsp;request_mask</em>, unsigned int<em>&nbsp;query_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_statx_fd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the enhanced basic attributes by file descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>The file descriptor referring to the file of interest</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kstat</span> <span class="pre">*</span> <span class="pre">stat</span></code></dt>
<dd>The result structure to fill in.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">request_mask</span></code></dt>
<dd>STATX_xxx flags indicating what the caller wants</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">query_flags</span></code></dt>
<dd>Query mode (KSTAT_QUERY_FLAGS)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a wrapper around vfs_getattr().  The main difference is
that it uses a file descriptor to determine the file location.</p>
<p>0 will be returned on success, and a -ve error code if unsuccessful.</p>
<dl class="function">
<dt id="c.vfs_statx">
int <code class="descname">vfs_statx</code><span class="sig-paren">(</span>int<em>&nbsp;dfd</em>, const char __user *<em>&nbsp;filename</em>, int<em>&nbsp;flags</em>, struct kstat *<em>&nbsp;stat</em>, u32<em>&nbsp;request_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_statx" title="Permalink to this definition">¶</a></dt>
<dd><p>Get basic and extra attributes by filename</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dfd</span></code></dt>
<dd>A file descriptor representing the base dir for a relative filename</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">filename</span></code></dt>
<dd>The name of the file of interest</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>Flags to control the query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kstat</span> <span class="pre">*</span> <span class="pre">stat</span></code></dt>
<dd>The result structure to fill in.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">request_mask</span></code></dt>
<dd>STATX_xxx flags indicating what the caller wants</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a wrapper around vfs_getattr().  The main difference is
that it uses a filename and base directory to determine the file location.
Additionally, the use of AT_SYMLINK_NOFOLLOW in flags will prevent a symlink
at the given name from being referenced.</p>
<p>0 will be returned on success, and a -ve error code if unsuccessful.</p>
<dl class="function">
<dt id="c.vfs_fsync_range">
int <code class="descname">vfs_fsync_range</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;start</em>, loff_t<em>&nbsp;end</em>, int<em>&nbsp;datasync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_fsync_range" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to sync a range of data &amp; metadata to disk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file to sync</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt>
<dd>offset in bytes of the beginning of data range to sync</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt>
<dd>offset in bytes of the end of data range (inclusive)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datasync</span></code></dt>
<dd>perform only datasync</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write back data in range <strong>start</strong>..**end** and metadata for <strong>file</strong> to disk.  If
<strong>datasync</strong> is set only metadata needed to access modified file data is
written.</p>
<dl class="function">
<dt id="c.vfs_fsync">
int <code class="descname">vfs_fsync</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, int<em>&nbsp;datasync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a fsync or fdatasync on a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file to sync</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datasync</span></code></dt>
<dd>only perform a fdatasync operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write back data and metadata for <strong>file</strong> to disk.  If <strong>datasync</strong> is
set only metadata needed to access modified file data is written.</p>
<dl class="function">
<dt id="c.xattr_full_name">
const char * <code class="descname">xattr_full_name</code><span class="sig-paren">(</span>const struct xattr_handler *<em>&nbsp;handler</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xattr_full_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute full attribute name from suffix</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xattr_handler</span> <span class="pre">*</span> <span class="pre">handler</span></code></dt>
<dd>handler of the xattr_handler operation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name passed to the xattr_handler operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>The get and set xattr handler operations are called with the remainder of
the attribute name after skipping the handler’s prefix: for example, “foo”
is passed to the get operation of a handler with prefix “user.” to get
attribute “user.foo”.  The full name is still “there” in the name though.</p>
<p><strong>Note</strong></p>
<p>the list xattr handler operation when called from the vfs is passed a
NULL name; some file systems use this operation internally, with varying
semantics.</p>
</div>
</div>
<div class="section" id="the-proc-filesystem">
<h2>The proc filesystem<a class="headerlink" href="#the-proc-filesystem" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sysctl-interface">
<h3>sysctl interface<a class="headerlink" href="#sysctl-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.proc_dostring">
int <code class="descname">proc_dostring</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dostring" title="Permalink to this definition">¶</a></dt>
<dd><p>read a string sysctl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes a string from/to the user buffer. If the kernel
buffer provided is not large enough to hold the string, the
string is truncated. The copied string is <code class="docutils literal notranslate"><span class="pre">NULL-terminated</span></code>.
If the string is being read by the user process, it is copied
and a newline ‘n’ is added. It is truncated if the buffer is
not large enough.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec">
int <code class="descname">proc_dointvec</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_douintvec">
int <code class="descname">proc_douintvec</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_douintvec" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of unsigned integers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) unsigned integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec_minmax">
int <code class="descname">proc_dointvec_minmax</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers with min/max values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success or -EINVAL on write when the range check fails.</p>
<dl class="function">
<dt id="c.proc_douintvec_minmax">
int <code class="descname">proc_douintvec_minmax</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_douintvec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of unsigned ints with min/max values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) unsigned integer
values from/to the user buffer, treated as an ASCII string. Negative
strings are not allowed.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max). There is a final sanity
check for UINT_MAX to avoid having to support wrap around uses from
userspace.</p>
<p>Returns 0 on success or -ERANGE on write when the range check fails.</p>
<dl class="function">
<dt id="c.proc_doulongvec_minmax">
int <code class="descname">proc_doulongvec_minmax</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_doulongvec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of long integers with min/max values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_doulongvec_ms_jiffies_minmax">
int <code class="descname">proc_doulongvec_ms_jiffies_minmax</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_doulongvec_ms_jiffies_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of millisecond values with min/max values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string. The values
are treated as milliseconds, and converted to jiffies when they are stored.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec_jiffies">
int <code class="descname">proc_dointvec_jiffies</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers as seconds</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in seconds, and are converted into
jiffies.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec_userhz_jiffies">
int <code class="descname">proc_dointvec_userhz_jiffies</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_userhz_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers as 1/USER_HZ seconds</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>pointer to the file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in 1/USER_HZ seconds, and
are converted into jiffies.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec_ms_jiffies">
int <code class="descname">proc_dointvec_ms_jiffies</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_ms_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers as 1 milliseconds</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position in the file</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in 1/1000 seconds, and
are converted into jiffies.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_do_large_bitmap">
int <code class="descname">proc_do_large_bitmap</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_do_large_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>read/write from/to a large bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>The bitmap is stored at table-&gt;data and the bitmap length (in bits)
in table-&gt;maxlen.</p>
<p>We use a range comma separated format (e.g. 1,3-4,10-10) so that
large bitmaps may be represented in a compact manner. Writing into
the file will clear the bitmap then update it with the given input.</p>
<p>Returns 0 on success.</p>
</div>
<div class="section" id="proc-filesystem-interface">
<h3>proc filesystem interface<a class="headerlink" href="#proc-filesystem-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.proc_flush_pid">
void <code class="descname">proc_flush_pid</code><span class="sig-paren">(</span>struct pid *<em>&nbsp;pid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_flush_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove dcache entries for <strong>pid</strong> from the /proc dcache.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pid</span> <span class="pre">*</span> <span class="pre">pid</span></code></dt>
<dd>pid that should be flushed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks a list of inodes (that belong to any proc
filesystem) that are attached to the pid and flushes them from
the dentry cache.</p>
<p>It is safe and reasonable to cache /proc entries for a task until
that task exits.  After that they just clog up the dcache with
useless entries, possibly causing useful dcache entries to be
flushed instead.  This routine is provided to flush those useless
dcache entries when a process is reaped.</p>
<p><strong>NOTE</strong></p>
<dl class="docutils">
<dt>This routine is just an optimization so it does not guarantee</dt>
<dd>that no dcache entries will exist after a process is reaped
it just makes it very unlikely that any will persist.</dd>
</dl>
</div>
</div>
<div class="section" id="events-based-on-file-descriptors">
<h2>Events based on file descriptors<a class="headerlink" href="#events-based-on-file-descriptors" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.eventfd_signal">
__u64 <code class="descname">eventfd_signal</code><span class="sig-paren">(</span>struct eventfd_ctx *<em>&nbsp;ctx</em>, __u64<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <strong>n</strong> to the eventfd counter.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>[in] Pointer to the eventfd context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u64</span> <span class="pre">n</span></code></dt>
<dd>[in] Value of the counter to be added to the eventfd internal counter.
The value cannot be negative.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is supposed to be called by the kernel in paths that do not
allow sleeping. In this function we allow the counter to reach the ULLONG_MAX
value, and we signal this as overflow condition by returning a EPOLLERR
to poll(2).</p>
<p>Returns the amount by which the counter was incremented.  This will be less
than <strong>n</strong> if the counter has overflowed.</p>
<dl class="function">
<dt id="c.eventfd_ctx_put">
void <code class="descname">eventfd_ctx_put</code><span class="sig-paren">(</span>struct eventfd_ctx *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases a reference to the internal eventfd context.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>[in] Pointer to eventfd context.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The eventfd context reference must have been previously acquired either
with <a class="reference internal" href="#c.eventfd_ctx_fdget" title="eventfd_ctx_fdget"><code class="xref c c-func docutils literal notranslate"><span class="pre">eventfd_ctx_fdget()</span></code></a> or <a class="reference internal" href="#c.eventfd_ctx_fileget" title="eventfd_ctx_fileget"><code class="xref c c-func docutils literal notranslate"><span class="pre">eventfd_ctx_fileget()</span></code></a>.</p>
<dl class="function">
<dt id="c.eventfd_ctx_remove_wait_queue">
int <code class="descname">eventfd_ctx_remove_wait_queue</code><span class="sig-paren">(</span>struct eventfd_ctx *<em>&nbsp;ctx</em>, wait_queue_entry_t *<em>&nbsp;wait</em>, __u64 *<em>&nbsp;cnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_remove_wait_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the current counter and removes wait queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>[in] Pointer to eventfd context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_queue_entry_t</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd>[in] Wait queue to be removed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u64</span> <span class="pre">*</span> <span class="pre">cnt</span></code></dt>
<dd>[out] Pointer to the 64-bit counter value.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">0</span></code> if successful, or the following error codes:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>AGAIN</var></span></kbd></td>
<td>: The operation would have blocked.</td></tr>
</tbody>
</table>
<p>This is used to atomically remove a wait queue entry from the eventfd wait
queue head, and read/reset the counter value.</p>
<dl class="function">
<dt id="c.eventfd_fget">
struct file * <code class="descname">eventfd_fget</code><span class="sig-paren">(</span>int<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_fget" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a reference of an eventfd file descriptor.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>[in] Eventfd file descriptor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the eventfd file structure in case of success, or the
following error pointer:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>BADF</var></span></kbd></td>
<td>: Invalid <strong>fd</strong> file descriptor.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-E<var>INVAL</var></span></kbd></td>
<td>: The <strong>fd</strong> file descriptor is not an eventfd file.</td></tr>
</tbody>
</table>
<dl class="function">
<dt id="c.eventfd_ctx_fdget">
struct eventfd_ctx * <code class="descname">eventfd_ctx_fdget</code><span class="sig-paren">(</span>int<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_fdget" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquires a reference to the internal eventfd context.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>[in] Eventfd file descriptor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the internal eventfd context, otherwise the error
pointers returned by the following functions:</p>
<p>eventfd_fget</p>
<dl class="function">
<dt id="c.eventfd_ctx_fileget">
struct eventfd_ctx * <code class="descname">eventfd_ctx_fileget</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_fileget" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquires a reference to the internal eventfd context.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>[in] Eventfd file pointer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the internal eventfd context, otherwise the error
pointer:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>INVAL</var></span></kbd></td>
<td>: The <strong>fd</strong> file descriptor is not an eventfd file.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="the-filesystem-for-exporting-kernel-objects">
<h2>The Filesystem for Exporting Kernel Objects<a class="headerlink" href="#the-filesystem-for-exporting-kernel-objects" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.sysfs_create_file_ns">
int <code class="descname">sysfs_create_file_ns</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, const void *<em>&nbsp;ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_file_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>create an attribute file for an object with custom ns</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re creating for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>namespace the new file should belong to</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_add_file_to_group">
int <code class="descname">sysfs_add_file_to_group</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, const char *<em>&nbsp;group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_add_file_to_group" title="Permalink to this definition">¶</a></dt>
<dd><p>add an attribute file to a pre-existing group.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">group</span></code></dt>
<dd>group name.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_chmod_file">
int <code class="descname">sysfs_chmod_file</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, umode_t<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_chmod_file" title="Permalink to this definition">¶</a></dt>
<dd><p>update the modified mode value on an object attribute.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>file permissions.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_break_active_protection">
struct kernfs_node * <code class="descname">sysfs_break_active_protection</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_break_active_protection" title="Permalink to this definition">¶</a></dt>
<dd><p>break “active” protection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>The kernel object <strong>attr</strong> is associated with.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>The attribute to break the “active” protection for.</dd>
</dl>
<p><strong>Description</strong></p>
<p>With sysfs, just like kernfs, deletion of an attribute is postponed until
all active .show() and .store() callbacks have finished unless this function
is called. Hence this function is useful in methods that implement self
deletion.</p>
<dl class="function">
<dt id="c.sysfs_unbreak_active_protection">
void <code class="descname">sysfs_unbreak_active_protection</code><span class="sig-paren">(</span>struct kernfs_node *<em>&nbsp;kn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_unbreak_active_protection" title="Permalink to this definition">¶</a></dt>
<dd><p>restore “active” protection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kernfs_node</span> <span class="pre">*</span> <span class="pre">kn</span></code></dt>
<dd>Pointer returned by <a class="reference internal" href="#c.sysfs_break_active_protection" title="sysfs_break_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_break_active_protection()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo the effects of <a class="reference internal" href="#c.sysfs_break_active_protection" title="sysfs_break_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_break_active_protection()</span></code></a>. Since this function
calls kernfs_put() on the kernfs node that corresponds to the ‘attr’
argument passed to <a class="reference internal" href="#c.sysfs_break_active_protection" title="sysfs_break_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_break_active_protection()</span></code></a> that attribute may have
been removed between the <a class="reference internal" href="#c.sysfs_break_active_protection" title="sysfs_break_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_break_active_protection()</span></code></a> and
<a class="reference internal" href="#c.sysfs_unbreak_active_protection" title="sysfs_unbreak_active_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_unbreak_active_protection()</span></code></a> calls, it is not safe to access <strong>kn</strong> after
this function has returned.</p>
<dl class="function">
<dt id="c.sysfs_remove_file_ns">
void <code class="descname">sysfs_remove_file_ns</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, const void *<em>&nbsp;ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_file_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an object attribute with a custom ns tag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>namespace tag of the file to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hash the attribute name and namespace tag and kill the victim.</p>
<dl class="function">
<dt id="c.sysfs_remove_file_self">
bool <code class="descname">sysfs_remove_file_self</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_file_self" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an object attribute from its own method</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor</dd>
</dl>
<p><strong>Description</strong></p>
<p>See kernfs_remove_self() for details.</p>
<dl class="function">
<dt id="c.sysfs_remove_file_from_group">
void <code class="descname">sysfs_remove_file_from_group</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, const char *<em>&nbsp;group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_file_from_group" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an attribute file from a group.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">group</span></code></dt>
<dd>group name.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_create_bin_file">
int <code class="descname">sysfs_create_bin_file</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct bin_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create binary file for object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_remove_bin_file">
void <code class="descname">sysfs_remove_bin_file</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct bin_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>remove binary file for object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_file_change_owner">
int <code class="descname">sysfs_file_change_owner</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const char *<em>&nbsp;name</em>, kuid_t<em>&nbsp;kuid</em>, kgid_t<em>&nbsp;kgid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_file_change_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>change owner of a sysfs file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the file to change.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kuid_t</span> <span class="pre">kuid</span></code></dt>
<dd>new owner’s kuid</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kgid_t</span> <span class="pre">kgid</span></code></dt>
<dd>new owner’s kgid</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the sysfs entry <strong>name</strong> under <strong>kobj</strong> and changes the
ownership to <strong>kuid</strong>/<strong>kgid</strong>.</p>
<p>Returns 0 on success or error code on failure.</p>
<dl class="function">
<dt id="c.sysfs_change_owner">
int <code class="descname">sysfs_change_owner</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, kuid_t<em>&nbsp;kuid</em>, kgid_t<em>&nbsp;kgid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_change_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>change owner of the given object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kuid_t</span> <span class="pre">kuid</span></code></dt>
<dd>new owner’s kuid</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kgid_t</span> <span class="pre">kgid</span></code></dt>
<dd>new owner’s kgid</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change the owner of the default directory, files, groups, and attributes of
<strong>kobj</strong> to <strong>kuid</strong>/<strong>kgid</strong>. Note that sysfs_change_owner mirrors how the sysfs
entries for a kobject are added by driver core. In summary,
<a class="reference internal" href="#c.sysfs_change_owner" title="sysfs_change_owner"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_change_owner()</span></code></a> takes care of the default directory entry for <strong>kobj</strong>,
the default attributes associated with the ktype of <strong>kobj</strong> and the default
attributes associated with the ktype of <strong>kobj</strong>.
Additional properties not added by driver core have to be changed by the
driver or subsystem which created them. This is similar to how
driver/subsystem specific entries are removed.</p>
<p>Returns 0 on success or error code on failure.</p>
<dl class="function">
<dt id="c.sysfs_create_link">
int <code class="descname">sysfs_create_link</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct kobject *<em>&nbsp;target</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create symlink between two objects.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object whose directory we’re creating the link in.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">target</span></code></dt>
<dd>object we’re pointing to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the symlink.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_create_link_nowarn">
int <code class="descname">sysfs_create_link_nowarn</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct kobject *<em>&nbsp;target</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_link_nowarn" title="Permalink to this definition">¶</a></dt>
<dd><p>create symlink between two objects.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object whose directory we’re creating the link in.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">target</span></code></dt>
<dd>object we’re pointing to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd><p class="first">name of the symlink.</p>
<p class="last">This function does the same as <a class="reference internal" href="#c.sysfs_create_link" title="sysfs_create_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs_create_link()</span></code></a>, but it
doesn’t warn if the link already exists.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_remove_link">
void <code class="descname">sysfs_remove_link</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_link" title="Permalink to this definition">¶</a></dt>
<dd><p>remove symlink in object’s directory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the symlink to remove.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_rename_link_ns">
int <code class="descname">sysfs_rename_link_ns</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct kobject *<em>&nbsp;targ</em>, const char *<em>&nbsp;old</em>, const char *<em>&nbsp;new</em>, const void *<em>&nbsp;new_ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_rename_link_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>rename symlink in object’s directory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">targ</span></code></dt>
<dd>object we’re pointing to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>previous name of the symlink.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new name of the symlink.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">new_ns</span></code></dt>
<dd><p class="first">new namespace of the symlink.</p>
<p class="last">A helper function for the common rename symlink idiom.</p>
</dd>
</dl>
</div>
<div class="section" id="the-debugfs-filesystem">
<h2>The debugfs filesystem<a class="headerlink" href="#the-debugfs-filesystem" title="Permalink to this headline">¶</a></h2>
<div class="section" id="debugfs-interface">
<h3>debugfs interface<a class="headerlink" href="#debugfs-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.debugfs_lookup">
struct dentry * <code class="descname">debugfs_lookup</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>look up an existing debugfs file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to look up.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry of the file.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return a pointer to a dentry if it succeeds.  If the file
doesn’t exist or an error occurs, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> will be returned.  The returned
dentry must be passed to dput() when it is no longer needed.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_create_file">
struct dentry * <code class="descname">debugfs_create_file</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the open() call.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>a pointer to a struct file_operations that should be used for
this file.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the basic “create a file” function for debugfs.  It allows for a
wide range of flexibility in creating a file, or a directory (if you want
to create a directory, the <a class="reference internal" href="#c.debugfs_create_dir" title="debugfs_create_dir"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_dir()</span></code></a> function is
recommended to be used instead.)</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_create_file_unsafe">
struct dentry * <code class="descname">debugfs_create_file_unsafe</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_file_unsafe" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the open() call.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>a pointer to a struct file_operations that should be used for
this file.</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.debugfs_create_file_unsafe" title="debugfs_create_file_unsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_file_unsafe()</span></code></a> is completely analogous to
<a class="reference internal" href="#c.debugfs_create_file" title="debugfs_create_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_file()</span></code></a>, the only difference being that the fops
handed it will not get protected against file removals by the
debugfs core.</p>
<p>It is your responsibility to protect your struct file_operation
methods against file removals by means of <a class="reference internal" href="#c.debugfs_file_get" title="debugfs_file_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_get()</span></code></a>
and <a class="reference internal" href="#c.debugfs_file_put" title="debugfs_file_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_put()</span></code></a>. -&gt;open() is still protected by
debugfs though.</p>
<p>Any struct file_operations defined by means of
DEFINE_DEBUGFS_ATTRIBUTE() is protected against file removals and
thus, may be used here.</p>
<dl class="function">
<dt id="c.debugfs_create_file_size">
void <code class="descname">debugfs_create_file_size</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, const struct file_operations *<em>&nbsp;fops</em>, loff_t<em>&nbsp;file_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_file_size" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the open() call.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>a pointer to a struct file_operations that should be used for
this file.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">file_size</span></code></dt>
<dd>initial file size</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the basic “create a file” function for debugfs.  It allows for a
wide range of flexibility in creating a file, or a directory (if you want
to create a directory, the <a class="reference internal" href="#c.debugfs_create_dir" title="debugfs_create_dir"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_dir()</span></code></a> function is
recommended to be used instead.)</p>
<dl class="function">
<dt id="c.debugfs_create_dir">
struct dentry * <code class="descname">debugfs_create_dir</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>create a directory in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the directory to
create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
directory will be created in the root of the debugfs filesystem.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a directory in debugfs with the given name.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_create_automount">
struct dentry * <code class="descname">debugfs_create_automount</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em>, debugfs_automount_t<em>&nbsp;f</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_automount" title="Permalink to this definition">¶</a></dt>
<dd><p>create automount point in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_automount_t</span> <span class="pre">f</span></code></dt>
<dd>function to be called when pathname resolution steps on that one.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque argument to pass to f().</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>f</strong> should return what -&gt;d_automount() would.</p>
<dl class="function">
<dt id="c.debugfs_create_symlink">
struct dentry * <code class="descname">debugfs_create_symlink</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em>, const char *<em>&nbsp;target</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>create a symbolic link in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the symbolic link to
create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this symbolic link.  This
should be a directory dentry if set.  If this parameter is NULL,
then the symbolic link will be created in the root of the debugfs
filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">target</span></code></dt>
<dd>a pointer to a string containing the path to the target of the
symbolic link.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a symbolic link with the given name in debugfs that
links to the given target path.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the symbolic
link is to be removed (no automatic cleanup happens if your module is
unloaded, you are responsible here.)  If an error occurs, ERR_PTR(-ERROR)
will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_remove">
void <code class="descname">debugfs_remove</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>recursively removes a directory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>a pointer to a the dentry of the directory to be removed.  If this
parameter is NULL or an error value, nothing will be done.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function recursively removes a directory tree in debugfs that
was previously created with a call to another debugfs function
(like <a class="reference internal" href="#c.debugfs_create_file" title="debugfs_create_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_create_file()</span></code></a> or variants thereof.)</p>
<p>This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.</p>
<dl class="function">
<dt id="c.debugfs_rename">
struct dentry * <code class="descname">debugfs_rename</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;old_dir</em>, struct dentry *<em>&nbsp;old_dentry</em>, struct dentry *<em>&nbsp;new_dir</em>, const char *<em>&nbsp;new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>rename a file/directory in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">old_dir</span></code></dt>
<dd>a pointer to the parent dentry for the renamed object. This
should be a directory dentry.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">old_dentry</span></code></dt>
<dd>dentry of an object to be renamed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">new_dir</span></code></dt>
<dd>a pointer to the parent dentry where the object should be
moved. This should be a directory dentry.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">new_name</span></code></dt>
<dd>a pointer to a string containing the target name.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function renames a file/directory in debugfs.  The target must not
exist for rename to succeed.</p>
<p>This function will return a pointer to old_dentry (which is updated to
reflect renaming) if it succeeds. If an error occurs, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal notranslate"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_initialized">
bool <code class="descname">debugfs_initialized</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells whether debugfs has been registered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_file_get">
int <code class="descname">debugfs_file_get</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_file_get" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of file data access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>the dentry object whose data is being accessed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Up to a matching call to <a class="reference internal" href="#c.debugfs_file_put" title="debugfs_file_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_put()</span></code></a>, any successive call
into the file removing functions <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> and
debugfs_remove_recursive() will block. Since associated private
file data may only get freed after a successful return of any of
the removal functions, you may safely access it after a successful
call to <a class="reference internal" href="#c.debugfs_file_get" title="debugfs_file_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_get()</span></code></a> without worrying about lifetime issues.</p>
<p>If -<code class="docutils literal notranslate"><span class="pre">EIO</span></code> is returned, the file has already been removed and thus,
it is not safe to access any of its data. If, on the other hand,
it is allowed to access the file data, zero is returned.</p>
<dl class="function">
<dt id="c.debugfs_file_put">
void <code class="descname">debugfs_file_put</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_file_put" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the end of file data access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>the dentry object formerly passed to
<a class="reference internal" href="#c.debugfs_file_get" title="debugfs_file_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_get()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow any ongoing concurrent call into <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> or
debugfs_remove_recursive() blocked by a former call to
<a class="reference internal" href="#c.debugfs_file_get" title="debugfs_file_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_file_get()</span></code></a> to proceed and return to its caller.</p>
<dl class="function">
<dt id="c.debugfs_create_u8">
void <code class="descname">debugfs_create_u8</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u8 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u8" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 8-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<dl class="function">
<dt id="c.debugfs_create_u16">
void <code class="descname">debugfs_create_u16</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u16 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u16" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 16-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<dl class="function">
<dt id="c.debugfs_create_u32">
void <code class="descname">debugfs_create_u32</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u32 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u32" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 32-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<dl class="function">
<dt id="c.debugfs_create_u64">
void <code class="descname">debugfs_create_u64</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u64 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 64-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<dl class="function">
<dt id="c.debugfs_create_ulong">
struct dentry * <code class="descname">debugfs_create_ulong</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, unsigned long *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_ulong" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned long value.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value ERR_PTR(-ENODEV) will
be returned.</p>
<dl class="function">
<dt id="c.debugfs_create_x8">
void <code class="descname">debugfs_create_x8</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u8 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x8" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 8-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_x16">
void <code class="descname">debugfs_create_x16</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u16 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x16" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 16-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_x32">
void <code class="descname">debugfs_create_x32</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u32 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x32" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 32-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_x64">
void <code class="descname">debugfs_create_x64</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u64 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x64" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 64-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_size_t">
void <code class="descname">debugfs_create_size_t</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, size_t *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an size_t value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_atomic_t">
void <code class="descname">debugfs_create_atomic_t</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, atomic_t *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_atomic_t" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an atomic_t value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_bool">
struct dentry * <code class="descname">debugfs_create_bool</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, bool *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_bool" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write a boolean value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value ERR_PTR(-ENODEV) will
be returned.</p>
<dl class="function">
<dt id="c.debugfs_create_blob">
struct dentry * <code class="descname">debugfs_create_blob</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, struct debugfs_blob_wrapper *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read a binary blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">debugfs_blob_wrapper</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>a pointer to a struct debugfs_blob_wrapper which contains a pointer
to the blob data and the size of the data.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that exports
<strong>blob-&gt;data</strong> as a binary blob. If the <strong>mode</strong> variable is so set it can be
read from. Writing is not supported.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value ERR_PTR(-ENODEV) will
be returned.</p>
<dl class="function">
<dt id="c.debugfs_create_u32_array">
void <code class="descname">debugfs_create_u32_array</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u32 *<em>&nbsp;array</em>, u32<em>&nbsp;elements</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u32_array" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read u32 array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>u32 array that provides data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">elements</span></code></dt>
<dd>total number of elements in the array.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that exports
<strong>array</strong> as data. If the <strong>mode</strong> variable is so set it can be read from.
Writing is not supported. Seek within the file is also not supported.
Once array is created its size can not be changed.</p>
<dl class="function">
<dt id="c.debugfs_print_regs32">
void <code class="descname">debugfs_print_regs32</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;s</em>, const struct debugfs_reg32 *<em>&nbsp;regs</em>, int<em>&nbsp;nregs</em>, void __iomem *<em>&nbsp;base</em>, char *<em>&nbsp;prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_print_regs32" title="Permalink to this definition">¶</a></dt>
<dd><p>use seq_print to describe a set of registers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the seq_file structure being used to generate output</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">debugfs_reg32</span> <span class="pre">*</span> <span class="pre">regs</span></code></dt>
<dd>an array if struct debugfs_reg32 structures</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nregs</span></code></dt>
<dd>the length of the above array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>the base address to be used in reading the registers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">prefix</span></code></dt>
<dd>a string to be prefixed to every output line</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function outputs a text block describing the current values of
some 32-bit hardware registers. It is meant to be used within debugfs
files based on seq_file that need to show registers, intermixed with other
information. The prefix argument may be used to specify a leading string,
because some peripherals have several blocks of identical registers,
for example configuration of dma channels</p>
<dl class="function">
<dt id="c.debugfs_create_regset32">
void <code class="descname">debugfs_create_regset32</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, struct debugfs_regset32 *<em>&nbsp;regset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_regset32" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that returns register values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">debugfs_regset32</span> <span class="pre">*</span> <span class="pre">regset</span></code></dt>
<dd>a pointer to a struct debugfs_regset32, which contains a pointer
to an array of register definitions, the array size and the base
address where the register bank is to be found.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that reports
the names and values of a set of 32-bit registers. If the <strong>mode</strong> variable
is so set it can be read from. Writing is not supported.</p>
<dl class="function">
<dt id="c.debugfs_create_devm_seqfile">
struct dentry * <code class="descname">debugfs_create_devm_seqfile</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em>, int (<em>*read_fn</em>)(struct seq_file *s, void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_devm_seqfile" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is bound to device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device related to this debugfs file.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the debugfs file.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">seq_file</span> <span class="pre">*s,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">read_fn</span></code></dt>
<dd>function pointer called to print the seq_file content.</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>