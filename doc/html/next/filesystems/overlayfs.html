

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Overlay Filesystem &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Overlay Filesystem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/overlayfs.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>Written by: Neil Brown
Please see MAINTAINERS file for where to send questions.</p>
<div class="section" id="overlay-filesystem">
<h1>Overlay Filesystem<a class="headerlink" href="#overlay-filesystem" title="Permalink to this headline">¶</a></h1>
<p>This document describes a prototype for a new approach to providing
overlay-filesystem functionality in Linux (sometimes referred to as
union-filesystems).  An overlay-filesystem tries to present a
filesystem which is the result over overlaying one filesystem on top
of the other.</p>
<div class="section" id="overlay-objects">
<h2>Overlay objects<a class="headerlink" href="#overlay-objects" title="Permalink to this headline">¶</a></h2>
<p>The overlay filesystem approach is ‘hybrid’, because the objects that
appear in the filesystem do not always appear to belong to that filesystem.
In many cases, an object accessed in the union will be indistinguishable
from accessing the corresponding object from the original filesystem.
This is most obvious from the ‘st_dev’ field returned by stat(2).</p>
<p>While directories will report an st_dev from the overlay-filesystem,
non-directory objects may report an st_dev from the lower filesystem or
upper filesystem that is providing the object.  Similarly st_ino will
only be unique when combined with st_dev, and both of these can change
over the lifetime of a non-directory object.  Many applications and
tools ignore these values and will not be affected.</p>
<p>In the special case of all overlay layers on the same underlying
filesystem, all objects will report an st_dev from the overlay
filesystem and st_ino from the underlying filesystem.  This will
make the overlay mount more compliant with filesystem scanners and
overlay objects will be distinguishable from the corresponding
objects in the original filesystem.</p>
<p>On 64bit systems, even if all overlay layers are not on the same
underlying filesystem, the same compliant behavior could be achieved
with the “xino” feature.  The “xino” feature composes a unique object
identifier from the real object st_ino and an underlying fsid index.</p>
<p>If all underlying filesystems support NFS file handles and export file
handles with 32bit inode number encoding (e.g. ext4), overlay filesystem
will use the high inode number bits for fsid.  Even when the underlying
filesystem uses 64bit inode numbers, users can still enable the “xino”
feature with the “-o xino=on” overlay mount option.  That is useful for the
case of underlying filesystems like xfs and tmpfs, which use 64bit inode
numbers, but are very unlikely to use the high inode number bits.  In case
the underlying inode number does overflow into the high xino bits, overlay
filesystem will fall back to the non xino behavior for that inode.</p>
<p>The following table summarizes what can be expected in different overlay
configurations.</p>
<div class="section" id="inode-properties">
<h3>Inode properties<a class="headerlink" href="#inode-properties" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="7%" />
<col width="9%" />
<col width="7%" />
<col width="9%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Configuration</th>
<th class="head" colspan="2">Persistent
st_ino</th>
<th class="head" colspan="2">Uniform
st_dev</th>
<th class="head" colspan="2">st_ino == d_ino</th>
<th class="head" colspan="2">d_ino == i_ino
[*]</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="2">&#160;</td>
<td rowspan="2">dir</td>
<td rowspan="2">!dir</td>
<td rowspan="2">dir</td>
<td rowspan="2">!dir</td>
<td rowspan="2">dir</td>
<td rowspan="2">!dir</td>
<td rowspan="2">dir</td>
<td rowspan="2">!dir</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td>All layers
on same fs</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td>Layers not
on same fs,
xino=off</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr class="row-even"><td>xino=on/auto</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td>xino=on/auto,
ino overflow</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p>[*] nfsd v3 readdirplus verifies d_ino == i_ino. i_ino is exposed via several
/proc files, such as /proc/locks and /proc/self/fdinfo/&lt;fd&gt; of an inotify
file descriptor.</p>
</div>
</div>
<div class="section" id="upper-and-lower">
<h2>Upper and Lower<a class="headerlink" href="#upper-and-lower" title="Permalink to this headline">¶</a></h2>
<p>An overlay filesystem combines two filesystems - an ‘upper’ filesystem
and a ‘lower’ filesystem.  When a name exists in both filesystems, the
object in the ‘upper’ filesystem is visible while the object in the
‘lower’ filesystem is either hidden or, in the case of directories,
merged with the ‘upper’ object.</p>
<p>It would be more correct to refer to an upper and lower ‘directory
tree’ rather than ‘filesystem’ as it is quite possible for both
directory trees to be in the same filesystem and there is no
requirement that the root of a filesystem be given for either upper or
lower.</p>
<p>The lower filesystem can be any filesystem supported by Linux and does
not need to be writable.  The lower filesystem can even be another
overlayfs.  The upper filesystem will normally be writable and if it
is it must support the creation of trusted.* extended attributes, and
must provide valid d_type in readdir responses, so NFS is not suitable.</p>
<p>A read-only overlay of two read-only filesystems may use any
filesystem type.</p>
</div>
<div class="section" id="directories">
<h2>Directories<a class="headerlink" href="#directories" title="Permalink to this headline">¶</a></h2>
<p>Overlaying mainly involves directories.  If a given name appears in both
upper and lower filesystems and refers to a non-directory in either,
then the lower object is hidden - the name refers only to the upper
object.</p>
<p>Where both upper and lower objects are directories, a merged directory
is formed.</p>
<p>At mount time, the two directories given as mount options “lowerdir” and
“upperdir” are combined into a merged directory:</p>
<blockquote>
<div>mount -t overlay overlay -olowerdir=/lower,upperdir=/upper,workdir=/work /merged</div></blockquote>
<p>The “workdir” needs to be an empty directory on the same filesystem
as upperdir.</p>
<p>Then whenever a lookup is requested in such a merged directory, the
lookup is performed in each actual directory and the combined result
is cached in the dentry belonging to the overlay filesystem.  If both
actual lookups find directories, both are stored and a merged
directory is created, otherwise only one is stored: the upper if it
exists, else the lower.</p>
<p>Only the lists of names from directories are merged.  Other content
such as metadata and extended attributes are reported for the upper
directory only.  These attributes of the lower directory are hidden.</p>
</div>
<div class="section" id="whiteouts-and-opaque-directories">
<h2>whiteouts and opaque directories<a class="headerlink" href="#whiteouts-and-opaque-directories" title="Permalink to this headline">¶</a></h2>
<p>In order to support rm and rmdir without changing the lower
filesystem, an overlay filesystem needs to record in the upper filesystem
that files have been removed.  This is done using whiteouts and opaque
directories (non-directories are always opaque).</p>
<p>A whiteout is created as a character device with 0/0 device number.
When a whiteout is found in the upper level of a merged directory, any
matching name in the lower level is ignored, and the whiteout itself
is also hidden.</p>
<p>A directory is made opaque by setting the xattr “trusted.overlay.opaque”
to “y”.  Where the upper filesystem contains an opaque directory, any
directory in the lower filesystem with the same name is ignored.</p>
</div>
<div class="section" id="readdir">
<h2>readdir<a class="headerlink" href="#readdir" title="Permalink to this headline">¶</a></h2>
<p>When a ‘readdir’ request is made on a merged directory, the upper and
lower directories are each read and the name lists merged in the
obvious way (upper is read first, then lower - entries that already
exist are not re-added).  This merged name list is cached in the
‘struct file’ and so remains as long as the file is kept open.  If the
directory is opened and read by two processes at the same time, they
will each have separate caches.  A seekdir to the start of the
directory (offset 0) followed by a readdir will cause the cache to be
discarded and rebuilt.</p>
<p>This means that changes to the merged directory do not appear while a
directory is being read.  This is unlikely to be noticed by many
programs.</p>
<p>seek offsets are assigned sequentially when the directories are read.
Thus if</p>
<blockquote>
<div><ul class="simple">
<li>read part of a directory</li>
<li>remember an offset, and close the directory</li>
<li>re-open the directory some time later</li>
<li>seek to the remembered offset</li>
</ul>
</div></blockquote>
<p>there may be little correlation between the old and new locations in
the list of filenames, particularly if anything has changed in the
directory.</p>
<p>Readdir on directories that are not merged is simply handled by the
underlying directory (upper or lower).</p>
</div>
<div class="section" id="renaming-directories">
<h2>renaming directories<a class="headerlink" href="#renaming-directories" title="Permalink to this headline">¶</a></h2>
<p>When renaming a directory that is on the lower layer or merged (i.e. the
directory was not created on the upper layer to start with) overlayfs can
handle it in two different ways:</p>
<ol class="arabic simple">
<li>return EXDEV error: this error is returned by rename(2) when trying to
move a file or directory across filesystem boundaries.  Hence
applications are usually prepared to hande this error (mv(1) for example
recursively copies the directory tree).  This is the default behavior.</li>
<li>If the “redirect_dir” feature is enabled, then the directory will be
copied up (but not the contents).  Then the “trusted.overlay.redirect”
extended attribute is set to the path of the original location from the
root of the overlay.  Finally the directory is moved to the new
location.</li>
</ol>
<p>There are several ways to tune the “redirect_dir” feature.</p>
<p>Kernel config options:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>OVERLAY_FS_REDIRECT_DIR:</dt>
<dd>If this is enabled, then redirect_dir is turned on by  default.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW:</dt>
<dd>If this is enabled, then redirects are always followed by default. Enabling
this results in a less secure configuration.  Enable this option only when
worried about backward compatibility with kernels that have the redirect_dir
feature and follow redirects even if turned off.</dd>
</dl>
</li>
</ul>
<p>Module options (can also be changed through /sys/module/overlay/parameters/):</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>“redirect_dir=BOOL”:</dt>
<dd>See OVERLAY_FS_REDIRECT_DIR kernel config option above.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>“redirect_always_follow=BOOL”:</dt>
<dd>See OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW kernel config option above.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>“redirect_max=NUM”:</dt>
<dd>The maximum number of bytes in an absolute redirect (default is 256).</dd>
</dl>
</li>
</ul>
<p>Mount options:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>“redirect_dir=on”:</dt>
<dd>Redirects are enabled.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>“redirect_dir=follow”:</dt>
<dd>Redirects are not created, but followed.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>“redirect_dir=off”:</dt>
<dd>Redirects are not created and only followed if “redirect_always_follow”
feature is enabled in the kernel/module config.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>“redirect_dir=nofollow”:</dt>
<dd>Redirects are not created and not followed (equivalent to “redirect_dir=off”
if “redirect_always_follow” feature is not enabled).</dd>
</dl>
</li>
</ul>
<p>When the NFS export feature is enabled, every copied up directory is
indexed by the file handle of the lower inode and a file handle of the
upper directory is stored in a “trusted.overlay.upper” extended attribute
on the index entry.  On lookup of a merged directory, if the upper
directory does not match the file handle stores in the index, that is an
indication that multiple upper directories may be redirected to the same
lower directory.  In that case, lookup returns an error and warns about
a possible inconsistency.</p>
<p>Because lower layer redirects cannot be verified with the index, enabling
NFS export support on an overlay filesystem with no upper layer requires
turning off redirect follow (e.g. “redirect_dir=nofollow”).</p>
</div>
<div class="section" id="non-directories">
<h2>Non-directories<a class="headerlink" href="#non-directories" title="Permalink to this headline">¶</a></h2>
<p>Objects that are not directories (files, symlinks, device-special
files etc.) are presented either from the upper or lower filesystem as
appropriate.  When a file in the lower filesystem is accessed in a way
the requires write-access, such as opening for write access, changing
some metadata etc., the file is first copied from the lower filesystem
to the upper filesystem (copy_up).  Note that creating a hard-link
also requires copy_up, though of course creation of a symlink does
not.</p>
<p>The copy_up may turn out to be unnecessary, for example if the file is
opened for read-write but the data is not modified.</p>
<p>The copy_up process first makes sure that the containing directory
exists in the upper filesystem - creating it and any parents as
necessary.  It then creates the object with the same metadata (owner,
mode, mtime, symlink-target etc.) and then if the object is a file, the
data is copied from the lower to the upper filesystem.  Finally any
extended attributes are copied up.</p>
<p>Once the copy_up is complete, the overlay filesystem simply
provides direct access to the newly created file in the upper
filesystem - future operations on the file are barely noticed by the
overlay filesystem (though an operation on the name of the file such as
rename or unlink will of course be noticed and handled).</p>
</div>
<div class="section" id="permission-model">
<h2>Permission model<a class="headerlink" href="#permission-model" title="Permalink to this headline">¶</a></h2>
<p>Permission checking in the overlay filesystem follows these principles:</p>
<blockquote>
<div><ol class="arabic simple">
<li>permission check SHOULD return the same result before and after copy up</li>
<li>task creating the overlay mount MUST NOT gain additional privileges</li>
</ol>
<p>3) non-mounting task MAY gain additional privileges through the overlay,
compared to direct access on underlying lower or upper filesystems</p>
</div></blockquote>
<p>This is achieved by performing two permission checks on each access</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>check if current task is allowed access based on local DAC (owner,
group, mode and posix acl), as well as MAC checks</li>
<li>check if mounting task would be allowed real operation on lower or
upper layer based on underlying filesystem permissions, again including
MAC checks</li>
</ol>
</div></blockquote>
<p>Check (a) ensures consistency (1) since owner, group, mode and posix acls
are copied up.  On the other hand it can result in server enforced
permissions (used by NFS, for example) being ignored (3).</p>
<p>Check (b) ensures that no task gains permissions to underlying layers that
the mounting task does not have (2).  This also means that it is possible
to create setups where the consistency rule (1) does not hold; normally,
however, the mounting task will have sufficient privileges to perform all
operations.</p>
<p>Another way to demonstrate this model is drawing parallels between</p>
<blockquote>
<div>mount -t overlay overlay -olowerdir=/lower,upperdir=/upper,… /merged</div></blockquote>
<p>and</p>
<blockquote>
<div>cp -a /lower /upper
mount –bind /upper /merged</div></blockquote>
<p>The resulting access permissions should be the same.  The difference is in
the time of copy (on-demand vs. up-front).</p>
</div>
<div class="section" id="multiple-lower-layers">
<h2>Multiple lower layers<a class="headerlink" href="#multiple-lower-layers" title="Permalink to this headline">¶</a></h2>
<p>Multiple lower layers can now be given using the the colon (“:”) as a
separator character between the directory names.  For example:</p>
<blockquote>
<div>mount -t overlay overlay -olowerdir=/lower1:/lower2:/lower3 /merged</div></blockquote>
<p>As the example shows, “upperdir=” and “workdir=” may be omitted.  In
that case the overlay will be read-only.</p>
<p>The specified lower directories will be stacked beginning from the
rightmost one and going left.  In the above example lower1 will be the
top, lower2 the middle and lower3 the bottom layer.</p>
</div>
<div class="section" id="metadata-only-copy-up">
<h2>Metadata only copy up<a class="headerlink" href="#metadata-only-copy-up" title="Permalink to this headline">¶</a></h2>
<p>When metadata only copy up feature is enabled, overlayfs will only copy
up metadata (as opposed to whole file), when a metadata specific operation
like chown/chmod is performed. Full file will be copied up later when
file is opened for WRITE operation.</p>
<p>In other words, this is delayed data copy up operation and data is copied
up when there is a need to actually modify data.</p>
<p>There are multiple ways to enable/disable this feature. A config option
CONFIG_OVERLAY_FS_METACOPY can be set/unset to enable/disable this feature
by default. Or one can enable/disable it at module load time with module
parameter metacopy=on/off. Lastly, there is also a per mount option
metacopy=on/off to enable/disable this feature per mount.</p>
<p>Do not use metacopy=on with untrusted upper/lower directories. Otherwise
it is possible that an attacker can create a handcrafted file with
appropriate REDIRECT and METACOPY xattrs, and gain access to file on lower
pointed by REDIRECT. This should not be possible on local system as setting
“trusted.” xattrs will require CAP_SYS_ADMIN. But it should be possible
for untrusted layers like from a pen drive.</p>
<p>Note: redirect_dir={off|nofollow|follow[*]} and nfs_export=on mount options
conflict with metacopy=on, and will result in an error.</p>
<p>[*] redirect_dir=follow only conflicts with metacopy=on if upperdir=… is
given.</p>
</div>
<div class="section" id="sharing-and-copying-layers">
<h2>Sharing and copying layers<a class="headerlink" href="#sharing-and-copying-layers" title="Permalink to this headline">¶</a></h2>
<p>Lower layers may be shared among several overlay mounts and that is indeed
a very common practice.  An overlay mount may use the same lower layer
path as another overlay mount and it may use a lower layer path that is
beneath or above the path of another overlay lower layer path.</p>
<p>Using an upper layer path and/or a workdir path that are already used by
another overlay mount is not allowed and may fail with EBUSY.  Using
partially overlapping paths is not allowed and may fail with EBUSY.
If files are accessed from two overlayfs mounts which share or overlap the
upper layer and/or workdir path the behavior of the overlay is undefined,
though it will not result in a crash or deadlock.</p>
<p>Mounting an overlay using an upper layer path, where the upper layer path
was previously used by another mounted overlay in combination with a
different lower layer path, is allowed, unless the “inodes index” feature
or “metadata only copy up” feature is enabled.</p>
<p>With the “inodes index” feature, on the first time mount, an NFS file
handle of the lower layer root directory, along with the UUID of the lower
filesystem, are encoded and stored in the “trusted.overlay.origin” extended
attribute on the upper layer root directory.  On subsequent mount attempts,
the lower root directory file handle and lower filesystem UUID are compared
to the stored origin in upper root directory.  On failure to verify the
lower root origin, mount will fail with ESTALE.  An overlayfs mount with
“inodes index” enabled will fail with EOPNOTSUPP if the lower filesystem
does not support NFS export, lower filesystem does not have a valid UUID or
if the upper filesystem does not support extended attributes.</p>
<p>For “metadata only copy up” feature there is no verification mechanism at
mount time. So if same upper is mounted with different set of lower, mount
probably will succeed but expect the unexpected later on. So don’t do it.</p>
<p>It is quite a common practice to copy overlay layers to a different
directory tree on the same or different underlying filesystem, and even
to a different machine.  With the “inodes index” feature, trying to mount
the copied layers will fail the verification of the lower root file handle.</p>
</div>
<div class="section" id="non-standard-behavior">
<h2>Non-standard behavior<a class="headerlink" href="#non-standard-behavior" title="Permalink to this headline">¶</a></h2>
<p>Current version of overlayfs can act as a mostly POSIX compliant
filesystem.</p>
<p>This is the list of cases that overlayfs doesn’t currently handle:</p>
<p>a) POSIX mandates updating st_atime for reads.  This is currently not
done in the case when the file resides on a lower layer.</p>
<p>b) If a file residing on a lower layer is opened for read-only and then
memory mapped with MAP_SHARED, then subsequent changes to the file are not
reflected in the memory mapping.</p>
<p>The following options allow overlayfs to act more like a standards
compliant filesystem:</p>
<ol class="arabic simple">
<li>“redirect_dir”</li>
</ol>
<p>Enabled with the mount option or module option: “redirect_dir=on” or with
the kernel config option CONFIG_OVERLAY_FS_REDIRECT_DIR=y.</p>
<p>If this feature is disabled, then rename(2) on a lower or merged directory
will fail with EXDEV (“Invalid cross-device link”).</p>
<ol class="arabic simple" start="2">
<li>“inode index”</li>
</ol>
<p>Enabled with the mount option or module option “index=on” or with the
kernel config option CONFIG_OVERLAY_FS_INDEX=y.</p>
<p>If this feature is disabled and a file with multiple hard links is copied
up, then this will “break” the link.  Changes will not be propagated to
other names referring to the same inode.</p>
<ol class="arabic simple" start="3">
<li>“xino”</li>
</ol>
<p>Enabled with the mount option “xino=auto” or “xino=on”, with the module
option “xino_auto=on” or with the kernel config option
CONFIG_OVERLAY_FS_XINO_AUTO=y.  Also implicitly enabled by using the same
underlying filesystem for all layers making up the overlay.</p>
<p>If this feature is disabled or the underlying filesystem doesn’t have
enough free bits in the inode number, then overlayfs will not be able to
guarantee that the values of st_ino and st_dev returned by stat(2) and the
value of d_ino returned by readdir(3) will act like on a normal filesystem.
E.g. the value of st_dev may be different for two objects in the same
overlay filesystem and the value of st_ino for directory objects may not be
persistent and could change even while the overlay filesystem is mounted, as
summarized in the <a class="reference internal" href="#inode-properties">Inode properties</a> table above.</p>
</div>
<div class="section" id="changes-to-underlying-filesystems">
<h2>Changes to underlying filesystems<a class="headerlink" href="#changes-to-underlying-filesystems" title="Permalink to this headline">¶</a></h2>
<p>Offline changes, when the overlay is not mounted, are allowed to either
the upper or the lower trees.</p>
<p>Changes to the underlying filesystems while part of a mounted overlay
filesystem are not allowed.  If the underlying filesystem is changed,
the behavior of the overlay is undefined, though it will not result in
a crash or deadlock.</p>
<p>When the overlay NFS export feature is enabled, overlay filesystems
behavior on offline changes of the underlying lower layer is different
than the behavior when NFS export is disabled.</p>
<p>On every copy_up, an NFS file handle of the lower inode, along with the
UUID of the lower filesystem, are encoded and stored in an extended
attribute “trusted.overlay.origin” on the upper inode.</p>
<p>When the NFS export feature is enabled, a lookup of a merged directory,
that found a lower directory at the lookup path or at the path pointed
to by the “trusted.overlay.redirect” extended attribute, will verify
that the found lower directory file handle and lower filesystem UUID
match the origin file handle that was stored at copy_up time.  If a
found lower directory does not match the stored origin, that directory
will not be merged with the upper directory.</p>
</div>
<div class="section" id="nfs-export">
<h2>NFS export<a class="headerlink" href="#nfs-export" title="Permalink to this headline">¶</a></h2>
<p>When the underlying filesystems supports NFS export and the “nfs_export”
feature is enabled, an overlay filesystem may be exported to NFS.</p>
<p>With the “nfs_export” feature, on copy_up of any lower object, an index
entry is created under the index directory.  The index entry name is the
hexadecimal representation of the copy up origin file handle.  For a
non-directory object, the index entry is a hard link to the upper inode.
For a directory object, the index entry has an extended attribute
“trusted.overlay.upper” with an encoded file handle of the upper
directory inode.</p>
<p>When encoding a file handle from an overlay filesystem object, the
following rules apply:</p>
<ol class="arabic simple">
<li>For a non-upper object, encode a lower file handle from lower inode</li>
<li>For an indexed object, encode a lower file handle from copy_up origin</li>
<li>For a pure-upper object and for an existing non-indexed upper object,
encode an upper file handle from upper inode</li>
</ol>
<dl class="docutils">
<dt>The encoded overlay file handle includes:</dt>
<dd><ul class="first last simple">
<li>Header including path type information (e.g. lower/upper)</li>
<li>UUID of the underlying filesystem</li>
<li>Underlying filesystem encoding of underlying inode</li>
</ul>
</dd>
</dl>
<p>This encoding format is identical to the encoding format file handles that
are stored in extended attribute “trusted.overlay.origin”.</p>
<p>When decoding an overlay file handle, the following steps are followed:</p>
<ol class="arabic simple">
<li>Find underlying layer by UUID and path type information.</li>
<li>Decode the underlying filesystem file handle to underlying dentry.</li>
<li>For a lower file handle, lookup the handle in index directory by name.</li>
<li>If a whiteout is found in index, return ESTALE. This represents an
overlay object that was deleted after its file handle was encoded.</li>
<li>For a non-directory, instantiate a disconnected overlay dentry from the
decoded underlying dentry, the path type and index inode, if found.</li>
<li>For a directory, use the connected underlying decoded dentry, path type
and index, to lookup a connected overlay dentry.</li>
</ol>
<p>Decoding a non-directory file handle may return a disconnected dentry.
copy_up of that disconnected dentry will create an upper index entry with
no upper alias.</p>
<p>When overlay filesystem has multiple lower layers, a middle layer
directory may have a “redirect” to lower directory.  Because middle layer
“redirects” are not indexed, a lower file handle that was encoded from the
“redirect” origin directory, cannot be used to find the middle or upper
layer directory.  Similarly, a lower file handle that was encoded from a
descendant of the “redirect” origin directory, cannot be used to
reconstruct a connected overlay path.  To mitigate the cases of
directories that cannot be decoded from a lower file handle, these
directories are copied up on encode and encoded as an upper file handle.
On an overlay filesystem with no upper layer this mitigation cannot be
used NFS export in this setup requires turning off redirect follow (e.g.
“redirect_dir=nofollow”).</p>
<p>The overlay filesystem does not support non-directory connectable file
handles, so exporting with the ‘subtree_check’ exportfs configuration will
cause failures to lookup files over NFS.</p>
<p>When the NFS export feature is enabled, all directory index entries are
verified on mount time to check that upper file handles are not stale.
This verification may cause significant overhead in some cases.</p>
<p>Note: the mount options index=off,nfs_export=on are conflicting for a
read-write mount and will result in an error.</p>
</div>
<div class="section" id="testsuite">
<h2>Testsuite<a class="headerlink" href="#testsuite" title="Permalink to this headline">¶</a></h2>
<p>There’s a testsuite originally developed by David Howells and currently
maintained by Amir Goldstein at:</p>
<blockquote>
<div><a class="reference external" href="https://github.com/amir73il/unionmount-testsuite.git">https://github.com/amir73il/unionmount-testsuite.git</a></div></blockquote>
<p>Run as root:</p>
<blockquote>
<div># cd unionmount-testsuite
# ./run –ov –verify</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>