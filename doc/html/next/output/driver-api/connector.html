

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel Connector &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Kernel Connector</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/connector.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-connector">
<h1>Kernel Connector<a class="headerlink" href="#kernel-connector" title="Permalink to this headline">¶</a></h1>
<p>Kernel connector - new netlink based userspace &lt;-&gt; kernel space easy
to use communication module.</p>
<p>The Connector driver makes it easy to connect various agents using a
netlink based network.  One must register a callback and an identifier.
When the driver receives a special netlink message with the appropriate
identifier, the appropriate callback will be called.</p>
<p>From the userspace point of view it’s quite straightforward:</p>
<blockquote>
<div><ul class="simple">
<li>socket();</li>
<li>bind();</li>
<li>send();</li>
<li>recv();</li>
</ul>
</div></blockquote>
<p>But if kernelspace wants to use the full power of such connections, the
driver writer must create special sockets, must know about struct sk_buff
handling, etc…  The Connector driver allows any kernelspace agents to use
netlink based networking for inter-process communication in a significantly
easier way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int cn_add_callback(struct cb_id *id, char *name, void (*callback) (struct cn_msg *, struct netlink_skb_parms *));
void cn_netlink_send_multi(struct cn_msg *msg, u16 len, u32 portid, u32 __group, int gfp_mask);
void cn_netlink_send(struct cn_msg *msg, u32 portid, u32 __group, int gfp_mask);

struct cb_id
{
      __u32                   idx;
      __u32                   val;
};
</pre></div>
</div>
<p>idx and val are unique identifiers which must be registered in the
connector.h header for in-kernel usage.  <cite>void (*callback) (void *)</cite> is a
callback function which will be called when a message with above idx.val
is received by the connector core.  The argument for that function must
be dereferenced to <cite>struct cn_msg *</cite>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cn_msg
{
      struct cb_id            id;

      __u32                   seq;
      __u32                   ack;

      __u32                   len;    /* Length of the following data */
      __u8                    data[0];
};
</pre></div>
</div>
<div class="section" id="connector-interfaces">
<h2>Connector interfaces<a class="headerlink" href="#connector-interfaces" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="function">
<dt id="c.cn_add_callback">
int <code class="descname">cn_add_callback</code><span class="sig-paren">(</span>struct cb_id *<em>&nbsp;id</em>, const char *<em>&nbsp;name</em>, void (*callback) (struct cn_msg<em>&nbsp;*</em>, struct netlink_skb_parms<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cn_add_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers new callback with connector core.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cb_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>unique connector’s user identifier.
It must be registered in connector.h for legal
in-kernel users.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>connector’s callback symbolic name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">cn_msg</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">netlink_skb_parms</span> <span class="pre">*)</span> <span class="pre">callback</span></code></dt>
<dd>connector’s callback.
parameters are <code class="docutils literal notranslate"><span class="pre">cn_msg</span></code> and the sender’s credentials</dd>
</dl>
<dl class="function">
<dt id="c.cn_del_callback">
void <code class="descname">cn_del_callback</code><span class="sig-paren">(</span>struct cb_id *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cn_del_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters new callback with connector core.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cb_id</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>unique connector’s user identifier.</dd>
</dl>
<dl class="function">
<dt id="c.cn_netlink_send_mult">
int <code class="descname">cn_netlink_send_mult</code><span class="sig-paren">(</span>struct cn_msg *<em>&nbsp;msg</em>, u16<em>&nbsp;len</em>, u32<em>&nbsp;portid</em>, u32<em>&nbsp;group</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cn_netlink_send_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends message to the specified groups.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cn_msg</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>message header(with attached data).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">len</span></code></dt>
<dd>Number of <strong>msg</strong> to be sent.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">portid</span></code></dt>
<dd>destination port.
If non-zero the message will be sent to the given port,
which should be set to the original sender.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">group</span></code></dt>
<dd>destination group.
If <strong>portid</strong> and <strong>group</strong> is zero, then appropriate group will
be searched through all registered connector users, and
message will be delivered to the group which was created
for user with the same ID as in <strong>msg</strong>.
If <strong>group</strong> is not zero, then message will be delivered
to the specified group.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP mask.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It can be safely called from softirq context, but may silently
fail under strong memory pressure.</p>
<p>If there are no listeners for given group <code class="docutils literal notranslate"><span class="pre">-ESRCH</span></code> can be returned.</p>
<dl class="function">
<dt id="c.cn_netlink_send">
int <code class="descname">cn_netlink_send</code><span class="sig-paren">(</span>struct cn_msg *<em>&nbsp;msg</em>, u32<em>&nbsp;portid</em>, u32<em>&nbsp;group</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cn_netlink_send" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends message to the specified groups.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cn_msg</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>message header(with attached data).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">portid</span></code></dt>
<dd>destination port.
If non-zero the message will be sent to the given port,
which should be set to the original sender.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">group</span></code></dt>
<dd>destination group.
If <strong>portid</strong> and <strong>group</strong> is zero, then appropriate group will
be searched through all registered connector users, and
message will be delivered to the group which was created
for user with the same ID as in <strong>msg</strong>.
If <strong>group</strong> is not zero, then message will be delivered
to the specified group.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP mask.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It can be safely called from softirq context, but may silently
fail under strong memory pressure.</p>
<p>If there are no listeners for given group <code class="docutils literal notranslate"><span class="pre">-ESRCH</span></code> can be returned.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>When registering new callback user, connector core assigns
netlink group to the user which is equal to its id.idx.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="protocol-description">
<h2>Protocol description<a class="headerlink" href="#protocol-description" title="Permalink to this headline">¶</a></h2>
<p>The current framework offers a transport layer with fixed headers.  The
recommended protocol which uses such a header is as following:</p>
<p>msg-&gt;seq and msg-&gt;ack are used to determine message genealogy.  When
someone sends a message, they use a locally unique sequence and random
acknowledge number.  The sequence number may be copied into
nlmsghdr-&gt;nlmsg_seq too.</p>
<p>The sequence number is incremented with each message sent.</p>
<p>If you expect a reply to the message, then the sequence number in the
received message MUST be the same as in the original message, and the
acknowledge number MUST be the same + 1.</p>
<p>If we receive a message and its sequence number is not equal to one we
are expecting, then it is a new message.  If we receive a message and
its sequence number is the same as one we are expecting, but its
acknowledge is not equal to the sequence number in the original
message + 1, then it is a new message.</p>
<p>Obviously, the protocol header contains the above id.</p>
<p>The connector allows event notification in the following form: kernel
driver or userspace process can ask connector to notify it when
selected ids will be turned on or off (registered or unregistered its
callback).  It is done by sending a special command to the connector
driver (it also registers itself with id={-1, -1}).</p>
<p>As example of this usage can be found in the cn_test.c module which
uses the connector to request notification and to send messages.</p>
</div>
<div class="section" id="reliability">
<h2>Reliability<a class="headerlink" href="#reliability" title="Permalink to this headline">¶</a></h2>
<p>Netlink itself is not a reliable protocol.  That means that messages can
be lost due to memory pressure or process’ receiving queue overflowed,
so caller is warned that it must be prepared.  That is why the struct
cn_msg [main connector’s message header] contains u32 seq and u32 ack
fields.</p>
</div>
<div class="section" id="userspace-usage">
<h2>Userspace usage<a class="headerlink" href="#userspace-usage" title="Permalink to this headline">¶</a></h2>
<p>2.6.14 has a new netlink socket implementation, which by default does not
allow people to send data to netlink groups other than 1.
So, if you wish to use a netlink socket (for example using connector)
with a different group number, the userspace application must subscribe to
that group first.  It can be achieved by the following pseudocode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);

l_local.nl_family = AF_NETLINK;
l_local.nl_groups = 12345;
l_local.nl_pid = 0;

if (bind(s, (struct sockaddr *)&amp;l_local, sizeof(struct sockaddr_nl)) == -1) {
      perror(&quot;bind&quot;);
      close(s);
      return -1;
}

{
      int on = l_local.nl_groups;
      setsockopt(s, 270, 1, &amp;on, sizeof(on));
}
</pre></div>
</div>
<p>Where 270 above is SOL_NETLINK, and 1 is a NETLINK_ADD_MEMBERSHIP socket
option.  To drop a multicast subscription, one should call the above socket
option with the NETLINK_DROP_MEMBERSHIP parameter which is defined as 0.</p>
<p>2.6.14 netlink code only allows to select a group which is less or equal to
the maximum group number, which is used at netlink_kernel_create() time.
In case of connector it is CN_NETLINK_USERS + 0xf, so if you want to use
group number 12345, you must increment CN_NETLINK_USERS to that number.
Additional 0xf numbers are allocated to be used by non-in-kernel users.</p>
<p>Due to this limitation, group 0xffffffff does not work now, so one can
not use add/remove connector’s group notifications, but as far as I know,
only cn_test.c test module used it.</p>
<p>Some work in netlink area is still being done, so things can be changed in
2.6.15 timeframe, if it will happen, documentation will be updated for that
kernel.</p>
</div>
<div class="section" id="code-samples">
<h2>Code samples<a class="headerlink" href="#code-samples" title="Permalink to this headline">¶</a></h2>
<p>Sample code for a connector test module and user space can be found
in samples/connector/. To build this code, enable CONFIG_CONNECTOR
and CONFIG_SAMPLES.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>