

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>FUSE &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>FUSE</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/fuse.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fuse">
<h1>FUSE<a class="headerlink" href="#fuse" title="Permalink to this headline">¶</a></h1>
<div class="section" id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Userspace filesystem:</dt>
<dd>A filesystem in which data and metadata are provided by an ordinary
userspace process.  The filesystem can be accessed normally through
the kernel interface.</dd>
<dt>Filesystem daemon:</dt>
<dd>The process(es) providing the data and metadata of the filesystem.</dd>
<dt>Non-privileged mount (or user mount):</dt>
<dd>A userspace filesystem mounted by a non-privileged (non-root) user.
The filesystem daemon is running with the privileges of the mounting
user.  NOTE: this is not the same as mounts allowed with the “user”
option in /etc/fstab, which is not discussed here.</dd>
<dt>Filesystem connection:</dt>
<dd>A connection between the filesystem daemon and the kernel.  The
connection exists until either the daemon dies, or the filesystem is
umounted.  Note that detaching (or lazy umounting) the filesystem
does <em>not</em> break the connection, in this case it will exist until
the last reference to the filesystem is released.</dd>
<dt>Mount owner:</dt>
<dd>The user who does the mounting.</dd>
<dt>User:</dt>
<dd>The user who is performing filesystem operations.</dd>
</dl>
</div>
<div class="section" id="what-is-fuse">
<h2>What is FUSE?<a class="headerlink" href="#what-is-fuse" title="Permalink to this headline">¶</a></h2>
<p>FUSE is a userspace filesystem framework.  It consists of a kernel
module (fuse.ko), a userspace library (libfuse.*) and a mount utility
(fusermount).</p>
<p>One of the most important features of FUSE is allowing secure,
non-privileged mounts.  This opens up new possibilities for the use of
filesystems.  A good example is sshfs: a secure network filesystem
using the sftp protocol.</p>
<p>The userspace library and utilities are available from the
<a class="reference external" href="http://fuse.sourceforge.net/">FUSE homepage:</a></p>
</div>
<div class="section" id="filesystem-type">
<h2>Filesystem type<a class="headerlink" href="#filesystem-type" title="Permalink to this headline">¶</a></h2>
<p>The filesystem type given to mount(2) can be one of the following:</p>
<blockquote>
<div><dl class="docutils">
<dt>fuse</dt>
<dd>This is the usual way to mount a FUSE filesystem.  The first
argument of the mount system call may contain an arbitrary string,
which is not interpreted by the kernel.</dd>
<dt>fuseblk</dt>
<dd>The filesystem is block device based.  The first argument of the
mount system call is interpreted as the name of the device.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="mount-options">
<h2>Mount options<a class="headerlink" href="#mount-options" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>fd=N</dt>
<dd>The file descriptor to use for communication between the userspace
filesystem and the kernel.  The file descriptor must have been
obtained by opening the FUSE device (‘/dev/fuse’).</dd>
<dt>rootmode=M</dt>
<dd>The file mode of the filesystem’s root in octal representation.</dd>
<dt>user_id=N</dt>
<dd>The numeric user id of the mount owner.</dd>
<dt>group_id=N</dt>
<dd>The numeric group id of the mount owner.</dd>
<dt>default_permissions</dt>
<dd>By default FUSE doesn’t check file access permissions, the
filesystem is free to implement its access policy or leave it to
the underlying file access mechanism (e.g. in case of network
filesystems).  This option enables permission checking, restricting
access based on file mode.  It is usually useful together with the
‘allow_other’ mount option.</dd>
<dt>allow_other</dt>
<dd>This option overrides the security measure restricting file access
to the user mounting the filesystem.  This option is by default only
allowed to root, but this restriction can be removed with a
(userspace) configuration option.</dd>
<dt>max_read=N</dt>
<dd>With this option the maximum size of read operations can be set.
The default is infinite.  Note that the size of read requests is
limited anyway to 32 pages (which is 128kbyte on i386).</dd>
<dt>blksize=N</dt>
<dd>Set the block size for the filesystem.  The default is 512.  This
option is only valid for ‘fuseblk’ type mounts.</dd>
</dl>
</div>
<div class="section" id="control-filesystem">
<h2>Control filesystem<a class="headerlink" href="#control-filesystem" title="Permalink to this headline">¶</a></h2>
<p>There’s a control filesystem for FUSE, which can be mounted by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t fusectl none /sys/fs/fuse/connections
</pre></div>
</div>
<p>Mounting it under the ‘/sys/fs/fuse/connections’ directory makes it
backwards compatible with earlier versions.</p>
<p>Under the fuse control filesystem each connection has a directory
named by a unique number.</p>
<p>For each connection the following files exist within this directory:</p>
<blockquote>
<div><dl class="docutils">
<dt>waiting</dt>
<dd>The number of requests which are waiting to be transferred to
userspace or being processed by the filesystem daemon.  If there is
no filesystem activity and ‘waiting’ is non-zero, then the
filesystem is hung or deadlocked.</dd>
<dt>abort</dt>
<dd>Writing anything into this file will abort the filesystem
connection.  This means that all waiting requests will be aborted an
error returned for all aborted and new requests.</dd>
</dl>
</div></blockquote>
<p>Only the owner of the mount may read or write these files.</p>
<div class="section" id="interrupting-filesystem-operations">
<h3>Interrupting filesystem operations<a class="headerlink" href="#interrupting-filesystem-operations" title="Permalink to this headline">¶</a></h3>
<p>If a process issuing a FUSE filesystem request is interrupted, the
following will happen:</p>
<blockquote>
<div><ul class="simple">
<li>If the request is not yet sent to userspace AND the signal is
fatal (SIGKILL or unhandled fatal signal), then the request is
dequeued and returns immediately.</li>
<li>If the request is not yet sent to userspace AND the signal is not
fatal, then an interrupted flag is set for the request.  When
the request has been successfully transferred to userspace and
this flag is set, an INTERRUPT request is queued.</li>
<li>If the request is already sent to userspace, then an INTERRUPT
request is queued.</li>
</ul>
</div></blockquote>
<p>INTERRUPT requests take precedence over other requests, so the
userspace filesystem will receive queued INTERRUPTs before any others.</p>
<p>The userspace filesystem may ignore the INTERRUPT requests entirely,
or may honor them by sending a reply to the <em>original</em> request, with
the error set to EINTR.</p>
<p>It is also possible that there’s a race between processing the
original request and its INTERRUPT request.  There are two possibilities:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The INTERRUPT request is processed before the original request is
processed</li>
<li>The INTERRUPT request is processed after the original request has
been answered</li>
</ol>
</div></blockquote>
<p>If the filesystem cannot find the original request, it should wait for
some timeout and/or a number of new requests to arrive, after which it
should reply to the INTERRUPT request with an EAGAIN error.  In case
1) the INTERRUPT request will be requeued.  In case 2) the INTERRUPT
reply will be ignored.</p>
</div>
</div>
<div class="section" id="aborting-a-filesystem-connection">
<h2>Aborting a filesystem connection<a class="headerlink" href="#aborting-a-filesystem-connection" title="Permalink to this headline">¶</a></h2>
<p>It is possible to get into certain situations where the filesystem is
not responding.  Reasons for this may be:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>Broken userspace filesystem implementation</li>
<li>Network connection down</li>
<li>Accidental deadlock</li>
<li>Malicious deadlock</li>
</ol>
</div></blockquote>
<p>(For more on c) and d) see later sections)</p>
<p>In either of these cases it may be useful to abort the connection to
the filesystem.  There are several ways to do this:</p>
<blockquote>
<div><ul class="simple">
<li>Kill the filesystem daemon.  Works in case of a) and b)</li>
<li>Kill the filesystem daemon and all users of the filesystem.  Works
in all cases except some malicious deadlocks</li>
<li>Use forced umount (umount -f).  Works in all cases but only if
filesystem is still attached (it hasn’t been lazy unmounted)</li>
<li>Abort filesystem through the FUSE control filesystem.  Most
powerful method, always works.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-do-non-privileged-mounts-work">
<h2>How do non-privileged mounts work?<a class="headerlink" href="#how-do-non-privileged-mounts-work" title="Permalink to this headline">¶</a></h2>
<p>Since the mount() system call is a privileged operation, a helper
program (fusermount) is needed, which is installed setuid root.</p>
<p>The implication of providing non-privileged mounts is that the mount
owner must not be able to use this capability to compromise the
system.  Obvious requirements arising from this are:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li>mount owner should not be able to get elevated privileges with the
help of the mounted filesystem</li>
<li>mount owner should not get illegitimate access to information from
other users’ and the super user’s processes</li>
<li>mount owner should not be able to induce undesired behavior in
other users’ or the super user’s processes</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="how-are-requirements-fulfilled">
<h2>How are requirements fulfilled?<a class="headerlink" href="#how-are-requirements-fulfilled" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ol class="upperalpha">
<li><p class="first">The mount owner could gain elevated privileges by either:</p>
<ol class="arabic simple">
<li>creating a filesystem containing a device file, then opening this device</li>
<li>creating a filesystem containing a suid or sgid application, then executing this application</li>
</ol>
<p>The solution is not to allow opening device files and ignore
setuid and setgid bits when executing programs.  To ensure this
fusermount always adds “nosuid” and “nodev” to the mount options
for non-privileged mounts.</p>
</li>
<li><p class="first">If another user is accessing files or directories in the
filesystem, the filesystem daemon serving requests can record the
exact sequence and timing of operations performed.  This
information is otherwise inaccessible to the mount owner, so this
counts as an information leak.</p>
<p>The solution to this problem will be presented in point 2) of C).</p>
</li>
<li><p class="first">There are several ways in which the mount owner can induce
undesired behavior in other users’ processes, such as:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">mounting a filesystem over a file or directory which the mount
owner could otherwise not be able to modify (or could only
make limited modifications).</p>
<p>This is solved in fusermount, by checking the access
permissions on the mountpoint and only allowing the mount if
the mount owner can do unlimited modification (has write
access to the mountpoint, and mountpoint is not a “sticky”
directory)</p>
</li>
<li><p class="first">Even if 1) is solved the mount owner can change the behavior
of other users’ processes.</p>
<blockquote>
<div><ol class="lowerroman simple">
<li>It can slow down or indefinitely delay the execution of a
filesystem operation creating a DoS against the user or the
whole system.  For example a suid application locking a
system file, and then accessing a file on the mount owner’s
filesystem could be stopped, and thus causing the system
file to be locked forever.</li>
<li>It can present files or directories of unlimited length, or
directory structures of unlimited depth, possibly causing a
system process to eat up diskspace, memory or other
resources, again causing <em>DoS</em>.</li>
</ol>
</div></blockquote>
<p>The solution to this as well as B) is not to allow processes
to access the filesystem, which could otherwise not be
monitored or manipulated by the mount owner.  Since if the
mount owner can ptrace a process, it can do all of the above
without using a FUSE mount, the same criteria as used in
ptrace can be used to check if a process is allowed to access
the filesystem or not.</p>
<p>Note that the <em>ptrace</em> check is not strictly necessary to
prevent B/2/i, it is enough to check if mount owner has enough
privilege to send signal to the process accessing the
filesystem, since <em>SIGSTOP</em> can be used to get a similar effect.</p>
</li>
</ol>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="i-think-these-limitations-are-unacceptable">
<h2>I think these limitations are unacceptable?<a class="headerlink" href="#i-think-these-limitations-are-unacceptable" title="Permalink to this headline">¶</a></h2>
<p>If a sysadmin trusts the users enough, or can ensure through other
measures, that system processes will never enter non-privileged
mounts, it can relax the last limitation with a ‘user_allow_other’
config option.  If this config option is set, the mounting user can
add the ‘allow_other’ mount option which disables the check for other
users’ processes.</p>
</div>
<div class="section" id="kernel-userspace-interface">
<h2>Kernel - userspace interface<a class="headerlink" href="#kernel-userspace-interface" title="Permalink to this headline">¶</a></h2>
<p>The following diagram shows how a filesystem operation (in this
example unlink) is performed in FUSE.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>|  &quot;rm /mnt/fuse/file&quot;               |  FUSE filesystem daemon
|                                    |
|                                    |  &gt;sys_read()
|                                    |    &gt;fuse_dev_read()
|                                    |      &gt;request_wait()
|                                    |        [sleep on fc-&gt;waitq]
|                                    |
|  &gt;sys_unlink()                     |
|    &gt;fuse_unlink()                  |
|      [get request from             |
|       fc-&gt;unused_list]             |
|      &gt;request_send()               |
|        [queue req on fc-&gt;pending]  |
|        [wake up fc-&gt;waitq]         |        [woken up]
|        &gt;request_wait_answer()      |
|          [sleep on req-&gt;waitq]     |
|                                    |      &lt;request_wait()
|                                    |      [remove req from fc-&gt;pending]
|                                    |      [copy req to read buffer]
|                                    |      [add req to fc-&gt;processing]
|                                    |    &lt;fuse_dev_read()
|                                    |  &lt;sys_read()
|                                    |
|                                    |  [perform unlink]
|                                    |
|                                    |  &gt;sys_write()
|                                    |    &gt;fuse_dev_write()
|                                    |      [look up req in fc-&gt;processing]
|                                    |      [remove from fc-&gt;processing]
|                                    |      [copy write buffer to req]
|          [woken up]                |      [wake up req-&gt;waitq]
|                                    |    &lt;fuse_dev_write()
|                                    |  &lt;sys_write()
|        &lt;request_wait_answer()      |
|      &lt;request_send()               |
|      [add request to               |
|       fc-&gt;unused_list]             |
|    &lt;fuse_unlink()                  |
|  &lt;sys_unlink()                     |
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Everything in the description above is greatly simplified</p>
</div>
<p>There are a couple of ways in which to deadlock a FUSE filesystem.
Since we are talking about unprivileged userspace programs,
something must be done about these.</p>
<p><strong>Scenario 1 -  Simple deadlock</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>|  &quot;rm /mnt/fuse/file&quot;               |  FUSE filesystem daemon
|                                    |
|  &gt;sys_unlink(&quot;/mnt/fuse/file&quot;)     |
|    [acquire inode semaphore        |
|     for &quot;file&quot;]                    |
|    &gt;fuse_unlink()                  |
|      [sleep on req-&gt;waitq]         |
|                                    |  &lt;sys_read()
|                                    |  &gt;sys_unlink(&quot;/mnt/fuse/file&quot;)
|                                    |    [acquire inode semaphore
|                                    |     for &quot;file&quot;]
|                                    |    *DEADLOCK*
</pre></div>
</div>
<p>The solution for this is to allow the filesystem to be aborted.</p>
<p><strong>Scenario 2 - Tricky deadlock</strong></p>
<p>This one needs a carefully crafted filesystem.  It’s a variation on
the above, only the call back to the filesystem is not explicit,
but is caused by a pagefault.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>|  Kamikaze filesystem thread 1      |  Kamikaze filesystem thread 2
|                                    |
|  [fd = open(&quot;/mnt/fuse/file&quot;)]     |  [request served normally]
|  [mmap fd to &#39;addr&#39;]               |
|  [close fd]                        |  [FLUSH triggers &#39;magic&#39; flag]
|  [read a byte from addr]           |
|    &gt;do_page_fault()                |
|      [find or create page]         |
|      [lock page]                   |
|      &gt;fuse_readpage()              |
|         [queue READ request]       |
|         [sleep on req-&gt;waitq]      |
|                                    |  [read request to buffer]
|                                    |  [create reply header before addr]
|                                    |  &gt;sys_write(addr - headerlength)
|                                    |    &gt;fuse_dev_write()
|                                    |      [look up req in fc-&gt;processing]
|                                    |      [remove from fc-&gt;processing]
|                                    |      [copy write buffer to req]
|                                    |        &gt;do_page_fault()
|                                    |           [find or create page]
|                                    |           [lock page]
|                                    |           * DEADLOCK *
</pre></div>
</div>
<p>The solution is basically the same as above.</p>
<p>An additional problem is that while the write buffer is being copied
to the request, the request must not be interrupted/aborted.  This is
because the destination address of the copy may not be valid after the
request has returned.</p>
<p>This is solved with doing the copy atomically, and allowing abort
while the page(s) belonging to the write buffer are faulted with
get_user_pages().  The ‘req-&gt;locked’ flag indicates when the copy is
taking place, and abort is delayed until this flag is unset.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>