

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Memory Hotplug &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.12.0-rc3-mm1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Memory Hotplug</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/admin-guide/mm/memory-hotplug.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memory-hotplug">
<span id="admin-guide-memory-hotplug"></span><h1>Memory Hotplug<a class="headerlink" href="#memory-hotplug" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Created</dt>
<dd class="field-odd"><p>Jul 28 2007</p>
</dd>
<dt class="field-even">Updated</dt>
<dd class="field-even"><p>Add some details about locking internals:             Aug 20 2018</p>
</dd>
</dl>
<p>This document is about memory hotplug including how-to-use and current status.
Because Memory Hotplug is still under development, contents of this text will
be changed often.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#purpose-of-memory-hotplug" id="id2">Purpose of memory hotplug</a></p></li>
<li><p><a class="reference internal" href="#phases-of-memory-hotplug" id="id3">Phases of memory hotplug</a></p></li>
<li><p><a class="reference internal" href="#unit-of-memory-online-offline-operation" id="id4">Unit of Memory online/offline operation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#kernel-configuration" id="id5">Kernel Configuration</a></p></li>
<li><p><a class="reference internal" href="#sysfs-files-for-memory-hotplug" id="id6">sysfs files for memory hotplug</a></p></li>
<li><p><a class="reference internal" href="#physical-memory-hot-add-phase" id="id7">Physical memory hot-add phase</a></p>
<ul>
<li><p><a class="reference internal" href="#hardware-firmware-support" id="id8">Hardware(Firmware) Support</a></p></li>
<li><p><a class="reference internal" href="#notify-memory-hot-add-event-by-hand" id="id9">Notify memory hot-add event by hand</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#logical-memory-hot-add-phase" id="id10">Logical Memory hot-add phase</a></p>
<ul>
<li><p><a class="reference internal" href="#state-of-memory" id="id11">State of memory</a></p></li>
<li><p><a class="reference internal" href="#how-to-online-memory" id="id12">How to online memory</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#logical-memory-remove" id="id13">Logical memory remove</a></p>
<ul>
<li><p><a class="reference internal" href="#memory-offline-and-zone-movable" id="id14">Memory offline and ZONE_MOVABLE</a></p></li>
<li><p><a class="reference internal" href="#how-to-offline-memory" id="id15">How to offline memory</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#physical-memory-remove" id="id16">Physical memory remove</a></p></li>
<li><p><a class="reference internal" href="#locking-internals" id="id17">Locking Internals</a></p></li>
<li><p><a class="reference internal" href="#future-work" id="id18">Future Work</a></p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>x86_64’s has special implementation for memory hotplug.
This text does not describe it.</p></li>
<li><p>This text assumes that sysfs is mounted at <code class="docutils literal notranslate"><span class="pre">/sys</span></code>.</p></li>
</ol>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="purpose-of-memory-hotplug">
<h3><a class="toc-backref" href="#id2">Purpose of memory hotplug</a><a class="headerlink" href="#purpose-of-memory-hotplug" title="Permalink to this headline">¶</a></h3>
<p>Memory Hotplug allows users to increase/decrease the amount of memory.
Generally, there are two purposes.</p>
<ol class="upperalpha simple">
<li><p>For changing the amount of memory.
This is to allow a feature like capacity on demand.</p></li>
<li><p>For installing/removing DIMMs or NUMA-nodes physically.
This is to exchange DIMMs/NUMA-nodes, reduce power consumption, etc.</p></li>
</ol>
<p>(A) is required by highly virtualized environments and (B) is required by
hardware which supports memory power management.</p>
<p>Linux memory hotplug is designed for both purpose.</p>
</div>
<div class="section" id="phases-of-memory-hotplug">
<h3><a class="toc-backref" href="#id3">Phases of memory hotplug</a><a class="headerlink" href="#phases-of-memory-hotplug" title="Permalink to this headline">¶</a></h3>
<p>There are 2 phases in Memory Hotplug:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Physical Memory Hotplug phase</p></li>
<li><p>Logical Memory Hotplug phase.</p></li>
</ol>
</div></blockquote>
<p>The First phase is to communicate hardware/firmware and make/erase
environment for hotplugged memory. Basically, this phase is necessary
for the purpose (B), but this is good phase for communication between
highly virtualized environments too.</p>
<p>When memory is hotplugged, the kernel recognizes new memory, makes new memory
management tables, and makes sysfs files for new memory’s operation.</p>
<p>If firmware supports notification of connection of new memory to OS,
this phase is triggered automatically. ACPI can notify this event. If not,
“probe” operation by system administration is used instead.
(see <a class="reference internal" href="#memory-hotplug-physical-mem"><span class="std std-ref">Physical memory hot-add phase</span></a>).</p>
<p>Logical Memory Hotplug phase is to change memory state into
available/unavailable for users. Amount of memory from user’s view is
changed by this phase. The kernel makes all memory in it as free pages
when a memory range is available.</p>
<p>In this document, this phase is described as online/offline.</p>
<p>Logical Memory Hotplug phase is triggered by write of sysfs file by system
administrator. For the hot-add case, it must be executed after Physical Hotplug
phase by hand.
(However, if you writes udev’s hotplug scripts for memory hotplug, these
phases can be execute in seamless way.)</p>
</div>
<div class="section" id="unit-of-memory-online-offline-operation">
<h3><a class="toc-backref" href="#id4">Unit of Memory online/offline operation</a><a class="headerlink" href="#unit-of-memory-online-offline-operation" title="Permalink to this headline">¶</a></h3>
<p>Memory hotplug uses SPARSEMEM memory model which allows memory to be divided
into chunks of the same size. These chunks are called “sections”. The size of
a memory section is architecture dependent. For example, power uses 16MiB, ia64
uses 1GiB.</p>
<p>Memory sections are combined into chunks referred to as “memory blocks”. The
size of a memory block is architecture dependent and represents the logical
unit upon which memory online/offline operations are to be performed. The
default size of a memory block is the same as memory section size unless an
architecture specifies otherwise. (see <a class="reference internal" href="#memory-hotplug-sysfs-files"><span class="std std-ref">sysfs files for memory hotplug</span></a>.)</p>
<p>To determine the size (in bytes) of a memory block please read this file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/memory/block_size_bytes
</pre></div>
</div>
</div>
</div>
<div class="section" id="kernel-configuration">
<h2><a class="toc-backref" href="#id5">Kernel Configuration</a><a class="headerlink" href="#kernel-configuration" title="Permalink to this headline">¶</a></h2>
<p>To use memory hotplug feature, kernel must be compiled with following
config options.</p>
<ul>
<li><dl class="simple">
<dt>For all memory hotplug:</dt><dd><ul class="simple">
<li><p>Memory model -&gt; Sparse Memory  (<code class="docutils literal notranslate"><span class="pre">CONFIG_SPARSEMEM</span></code>)</p></li>
<li><p>Allow for memory hot-add       (<code class="docutils literal notranslate"><span class="pre">CONFIG_MEMORY_HOTPLUG</span></code>)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>To enable memory removal, the following are also necessary:</dt><dd><ul class="simple">
<li><p>Allow for memory hot remove    (<code class="docutils literal notranslate"><span class="pre">CONFIG_MEMORY_HOTREMOVE</span></code>)</p></li>
<li><p>Page Migration                 (<code class="docutils literal notranslate"><span class="pre">CONFIG_MIGRATION</span></code>)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>For ACPI memory hotplug, the following are also necessary:</dt><dd><ul class="simple">
<li><p>Memory hotplug (under ACPI Support menu) (<code class="docutils literal notranslate"><span class="pre">CONFIG_ACPI_HOTPLUG_MEMORY</span></code>)</p></li>
<li><p>This option can be kernel module.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>As a related configuration, if your box has a feature of NUMA-node hotplug
via ACPI, then this option is necessary too.</p>
<blockquote>
<div><ul class="simple">
<li><p>ACPI0004,PNP0A05 and PNP0A06 Container Driver (under ACPI Support menu)
(<code class="docutils literal notranslate"><span class="pre">CONFIG_ACPI_CONTAINER</span></code>).</p></li>
</ul>
<blockquote>
<div><p>This option can be kernel module too.</p>
</div></blockquote>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="sysfs-files-for-memory-hotplug">
<span id="memory-hotplug-sysfs-files"></span><h2><a class="toc-backref" href="#id6">sysfs files for memory hotplug</a><a class="headerlink" href="#sysfs-files-for-memory-hotplug" title="Permalink to this headline">¶</a></h2>
<p>All memory blocks have their device information in sysfs.  Each memory block
is described under <code class="docutils literal notranslate"><span class="pre">/sys/devices/system/memory</span></code> as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/memory/memoryXXX
</pre></div>
</div>
<p>where XXX is the memory block id.</p>
<p>For the memory block covered by the sysfs directory.  It is expected that all
memory sections in this range are present and no memory holes exist in the
range. Currently there is no way to determine if there is a memory hole, but
the existence of one should not affect the hotplug capabilities of the memory
block.</p>
<p>For example, assume 1GiB memory block size. A device for a memory starting at
0x100000000 is <code class="docutils literal notranslate"><span class="pre">/sys/device/system/memory/memory4</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(0x100000000 / 1Gib = 4)
</pre></div>
</div>
<p>This device covers address range [0x100000000 … 0x140000000)</p>
<p>Under each memory block, you can see 5 files:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/devices/system/memory/memoryXXX/phys_index</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/devices/system/memory/memoryXXX/phys_device</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/devices/system/memory/memoryXXX/state</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/devices/system/memory/memoryXXX/removable</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/devices/system/memory/memoryXXX/valid_zones</span></code></p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 76%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">phys_index</span></code></p></td>
<td><p>read-only and contains memory block id, same as XXX.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">state</span></code></p></td>
<td><p>read-write</p>
<ul class="simple">
<li><p>at read:  contains online/offline state of memory.</p></li>
<li><p>at write: user can specify “online_kernel”,</p></li>
</ul>
<p>“online_movable”, “online”, “offline” command
which will be performed on all sections in the block.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">phys_device</span></code></p></td>
<td><p>read-only: legacy interface only ever used on s390x to
expose the covered storage increment.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">removable</span></code></p></td>
<td><p>read-only: legacy interface that indicated whether a memory
block was likely to be offlineable or not.  Newer kernel
versions return “1” if and only if the kernel supports
memory offlining.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">valid_zones</span></code></p></td>
<td><p>read-only: designed to show by which zone memory provided by
a memory block is managed, and to show by which zone memory
provided by an offline memory block could be managed when
onlining.</p>
<p>The first column shows it`s default zone.</p>
<p>“memory6/valid_zones: Normal Movable” shows this memoryblock
can be onlined to ZONE_NORMAL by default and to ZONE_MOVABLE
by online_movable.</p>
<p>“memory7/valid_zones: Movable Normal” shows this memoryblock
can be onlined to ZONE_MOVABLE by default and to ZONE_NORMAL
by online_kernel.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These directories/files appear after physical memory hotplug phase.</p>
</div>
<p>If CONFIG_NUMA is enabled the memoryXXX/ directories can also be accessed
via symbolic links located in the <code class="docutils literal notranslate"><span class="pre">/sys/devices/system/node/node*</span></code> directories.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/node/node0/memory9 -&gt; ../../memory/memory9
</pre></div>
</div>
<p>A backlink will also be created:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/memory/memory9/node0 -&gt; ../../node/node0
</pre></div>
</div>
</div>
<div class="section" id="physical-memory-hot-add-phase">
<span id="memory-hotplug-physical-mem"></span><h2><a class="toc-backref" href="#id7">Physical memory hot-add phase</a><a class="headerlink" href="#physical-memory-hot-add-phase" title="Permalink to this headline">¶</a></h2>
<div class="section" id="hardware-firmware-support">
<h3><a class="toc-backref" href="#id8">Hardware(Firmware) Support</a><a class="headerlink" href="#hardware-firmware-support" title="Permalink to this headline">¶</a></h3>
<p>On x86_64/ia64 platform, memory hotplug by ACPI is supported.</p>
<p>In general, the firmware (ACPI) which supports memory hotplug defines
memory class object of _HID “PNP0C80”. When a notify is asserted to PNP0C80,
Linux’s ACPI handler does hot-add memory to the system and calls a hotplug udev
script. This will be done automatically.</p>
<p>But scripts for memory hotplug are not contained in generic udev package(now).
You may have to write it by yourself or online/offline memory by hand.
Please see <a class="reference internal" href="#memory-hotplug-how-to-online-memory"><span class="std std-ref">How to online memory</span></a> and
<a class="reference internal" href="#memory-hotplug-how-to-offline-memory"><span class="std std-ref">How to offline memory</span></a>.</p>
<p>If firmware supports NUMA-node hotplug, and defines an object _HID “ACPI0004”,
“PNP0A05”, or “PNP0A06”, notification is asserted to it, and ACPI handler
calls hotplug code for all of objects which are defined in it.
If memory device is found, memory hotplug code will be called.</p>
</div>
<div class="section" id="notify-memory-hot-add-event-by-hand">
<h3><a class="toc-backref" href="#id9">Notify memory hot-add event by hand</a><a class="headerlink" href="#notify-memory-hot-add-event-by-hand" title="Permalink to this headline">¶</a></h3>
<p>On some architectures, the firmware may not notify the kernel of a memory
hotplug event.  Therefore, the memory “probe” interface is supported to
explicitly notify the kernel.  This interface depends on
CONFIG_ARCH_MEMORY_PROBE and can be configured on powerpc, sh, and x86
if hotplug is supported, although for x86 this should be handled by ACPI
notification.</p>
<p>Probe interface is located at:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/memory/probe
</pre></div>
</div>
<p>You can tell the physical address of new memory to the kernel by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo start_address_of_new_memory &gt; /sys/devices/system/memory/probe
</pre></div>
</div>
<p>Then, [start_address_of_new_memory, start_address_of_new_memory +
memory_block_size] memory range is hot-added. In this case, hotplug script is
not called (in current implementation). You’ll have to online memory by
yourself.  Please see <a class="reference internal" href="#memory-hotplug-how-to-online-memory"><span class="std std-ref">How to online memory</span></a>.</p>
</div>
</div>
<div class="section" id="logical-memory-hot-add-phase">
<h2><a class="toc-backref" href="#id10">Logical Memory hot-add phase</a><a class="headerlink" href="#logical-memory-hot-add-phase" title="Permalink to this headline">¶</a></h2>
<div class="section" id="state-of-memory">
<h3><a class="toc-backref" href="#id11">State of memory</a><a class="headerlink" href="#state-of-memory" title="Permalink to this headline">¶</a></h3>
<p>To see (online/offline) state of a memory block, read ‘state’ file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% cat /sys/device/system/memory/memoryXXX/state
</pre></div>
</div>
<ul class="simple">
<li><p>If the memory block is online, you’ll read “online”.</p></li>
<li><p>If the memory block is offline, you’ll read “offline”.</p></li>
</ul>
</div>
<div class="section" id="how-to-online-memory">
<span id="memory-hotplug-how-to-online-memory"></span><h3><a class="toc-backref" href="#id12">How to online memory</a><a class="headerlink" href="#how-to-online-memory" title="Permalink to this headline">¶</a></h3>
<p>When the memory is hot-added, the kernel decides whether or not to “online”
it according to the policy which can be read from “auto_online_blocks” file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% cat /sys/devices/system/memory/auto_online_blocks
</pre></div>
</div>
<p>The default depends on the CONFIG_MEMORY_HOTPLUG_DEFAULT_ONLINE kernel config
option. If it is disabled the default is “offline” which means the newly added
memory is not in a ready-to-use state and you have to “online” the newly added
memory blocks manually. Automatic onlining can be requested by writing “online”
to “auto_online_blocks” file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo online &gt; /sys/devices/system/memory/auto_online_blocks
</pre></div>
</div>
<p>This sets a global policy and impacts all memory blocks that will subsequently
be hotplugged. Currently offline blocks keep their state. It is possible, under
certain circumstances, that some memory blocks will be added but will fail to
online. User space tools can check their “state” files
(<code class="docutils literal notranslate"><span class="pre">/sys/devices/system/memory/memoryXXX/state</span></code>) and try to online them manually.</p>
<p>If the automatic onlining wasn’t requested, failed, or some memory block was
offlined it is possible to change the individual block’s state by writing to the
“state” file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo online &gt; /sys/devices/system/memory/memoryXXX/state
</pre></div>
</div>
<p>This onlining will not change the ZONE type of the target memory block,
If the memory block doesn’t belong to any zone an appropriate kernel zone
(usually ZONE_NORMAL) will be used unless movable_node kernel command line
option is specified when ZONE_MOVABLE will be used.</p>
<p>You can explicitly request to associate it with ZONE_MOVABLE by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo online_movable &gt; /sys/devices/system/memory/memoryXXX/state
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>current limit: this memory block must be adjacent to ZONE_MOVABLE</p>
</div>
<p>Or you can explicitly request a kernel zone (usually ZONE_NORMAL) by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo online_kernel &gt; /sys/devices/system/memory/memoryXXX/state
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>current limit: this memory block must be adjacent to ZONE_NORMAL</p>
</div>
<p>An explicit zone onlining can fail (e.g. when the range is already within
and existing and incompatible zone already).</p>
<p>After this, memory block XXX’s state will be ‘online’ and the amount of
available memory will be increased.</p>
<p>This may be changed in future.</p>
</div>
</div>
<div class="section" id="logical-memory-remove">
<h2><a class="toc-backref" href="#id13">Logical memory remove</a><a class="headerlink" href="#logical-memory-remove" title="Permalink to this headline">¶</a></h2>
<div class="section" id="memory-offline-and-zone-movable">
<h3><a class="toc-backref" href="#id14">Memory offline and ZONE_MOVABLE</a><a class="headerlink" href="#memory-offline-and-zone-movable" title="Permalink to this headline">¶</a></h3>
<p>Memory offlining is more complicated than memory online. Because memory offline
has to make the whole memory block be unused, memory offline can fail if
the memory block includes memory which cannot be freed.</p>
<p>In general, memory offline can use 2 techniques.</p>
<ol class="arabic simple">
<li><p>reclaim and free all memory in the memory block.</p></li>
<li><p>migrate all pages in the memory block.</p></li>
</ol>
<p>In the current implementation, Linux’s memory offline uses method (2), freeing
all  pages in the memory block by page migration. But not all pages are
migratable. Under current Linux, migratable pages are anonymous pages and
page caches. For offlining a memory block by migration, the kernel has to
guarantee that the memory block contains only migratable pages.</p>
<p>Now, a boot option for making a memory block which consists of migratable pages
is supported. By specifying “kernelcore=” or “movablecore=” boot option, you can
create ZONE_MOVABLE…a zone which is just used for movable pages.
(See also <a class="reference internal" href="../kernel-parameters.html"><span class="doc">The kernel’s command-line parameters</span></a>)</p>
<p>Assume the system has “TOTAL” amount of memory at boot time, this boot option
creates ZONE_MOVABLE as following.</p>
<ol class="arabic simple">
<li><p>When kernelcore=YYYY boot option is used,
Size of memory not for movable pages (not for offline) is YYYY.
Size of memory for movable pages (for offline) is TOTAL-YYYY.</p></li>
<li><p>When movablecore=ZZZZ boot option is used,
Size of memory not for movable pages (not for offline) is TOTAL - ZZZZ.
Size of memory for movable pages (for offline) is ZZZZ.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unfortunately, there is no information to show which memory block belongs
to ZONE_MOVABLE. This is TBD.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Techniques that rely on long-term pinnings of memory (especially, RDMA and
vfio) are fundamentally problematic with ZONE_MOVABLE and, therefore, memory
hot remove. Pinned pages cannot reside on ZONE_MOVABLE, to guarantee that
memory can still get hot removed - be aware that pinning can fail even if
there is plenty of free memory in ZONE_MOVABLE. In addition, using
ZONE_MOVABLE might make page pinning more expensive, because pages have to be
migrated off that zone first.</p>
</div>
</div>
<div class="section" id="how-to-offline-memory">
<span id="memory-hotplug-how-to-offline-memory"></span><h3><a class="toc-backref" href="#id15">How to offline memory</a><a class="headerlink" href="#how-to-offline-memory" title="Permalink to this headline">¶</a></h3>
<p>You can offline a memory block by using the same sysfs interface that was used
in memory onlining:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% echo offline &gt; /sys/devices/system/memory/memoryXXX/state
</pre></div>
</div>
<p>If offline succeeds, the state of the memory block is changed to be “offline”.
If it fails, some error core (like -EBUSY) will be returned by the kernel.
Even if a memory block does not belong to ZONE_MOVABLE, you can try to offline
it.  If it doesn’t contain ‘unmovable’ memory, you’ll get success.</p>
<p>A memory block under ZONE_MOVABLE is considered to be able to be offlined
easily.  But under some busy state, it may return -EBUSY. Even if a memory
block cannot be offlined due to -EBUSY, you can retry offlining it and may be
able to offline it (or not). (For example, a page is referred to by some kernel
internal call and released soon.)</p>
<dl class="simple">
<dt>Consideration:</dt><dd><p>Memory hotplug’s design direction is to make the possibility of memory
offlining higher and to guarantee unplugging memory under any situation. But
it needs more work. Returning -EBUSY under some situation may be good because
the user can decide to retry more or not by himself. Currently, memory
offlining code does some amount of retry with 120 seconds timeout.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="physical-memory-remove">
<h2><a class="toc-backref" href="#id16">Physical memory remove</a><a class="headerlink" href="#physical-memory-remove" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Need more implementation yet….</dt><dd><ul class="simple">
<li><p>Notification completion of remove works by OS to firmware.</p></li>
<li><p>Guard from remove if not yet.</p></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="locking-internals">
<h2><a class="toc-backref" href="#id17">Locking Internals</a><a class="headerlink" href="#locking-internals" title="Permalink to this headline">¶</a></h2>
<p>When adding/removing memory that uses memory block devices (i.e. ordinary RAM),
the device_hotplug_lock should be held to:</p>
<ul class="simple">
<li><p>synchronize against online/offline requests (e.g. via sysfs). This way, memory
block devices can only be accessed (.online/.state attributes) by user
space once memory has been fully added. And when removing memory, we
know nobody is in critical sections.</p></li>
<li><p>synchronize against CPU hotplug and similar (e.g. relevant for ACPI and PPC)</p></li>
</ul>
<p>Especially, there is a possible lock inversion that is avoided using
device_hotplug_lock when adding memory and user space tries to online that
memory faster than expected:</p>
<ul class="simple">
<li><p>device_online() will first take the device_lock(), followed by
mem_hotplug_lock</p></li>
<li><p>add_memory_resource() will first take the mem_hotplug_lock, followed by
the device_lock() (while creating the devices, during bus_add_device()).</p></li>
</ul>
<p>As the device is visible to user space before taking the device_lock(), this
can result in a lock inversion.</p>
<p>onlining/offlining of memory should be done via device_online()/
device_offline() - to make sure it is properly synchronized to actions
via sysfs. Holding device_hotplug_lock is advised (to e.g. protect online_type)</p>
<p>When adding/removing/onlining/offlining memory or adding/removing
heterogeneous/device memory, we should always hold the mem_hotplug_lock in
write mode to serialise memory hotplug (e.g. access to global/zone
variables).</p>
<p>In addition, mem_hotplug_lock (in contrast to device_hotplug_lock) in read
mode allows for a quite efficient get_online_mems/put_online_mems
implementation, so code accessing memory can protect from that memory
vanishing.</p>
</div>
<div class="section" id="future-work">
<h2><a class="toc-backref" href="#id18">Future Work</a><a class="headerlink" href="#future-work" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p>allowing memory hot-add to ZONE_MOVABLE. maybe we need some switch like
sysctl or new control file.</p></li>
<li><p>showing memory block and physical device relationship.</p></li>
<li><p>test and make it better memory offlining.</p></li>
<li><p>support HugeTLB page migration and offlining.</p></li>
<li><p>memmap removing at memory offline.</p></li>
<li><p>physical remove memory.</p></li>
</ul>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>