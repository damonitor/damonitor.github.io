

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Heterogeneous Memory Management (HMM) &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.13.0-rc1-mm1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Heterogeneous Memory Management (HMM)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/vm/hmm.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="heterogeneous-memory-management-hmm">
<span id="hmm"></span><h1>Heterogeneous Memory Management (HMM)<a class="headerlink" href="#heterogeneous-memory-management-hmm" title="Permalink to this headline">¶</a></h1>
<p>Provide infrastructure and helpers to integrate non-conventional memory (device
memory like GPU on board memory) into regular kernel path, with the cornerstone
of this being specialized struct page for such memory (see sections 5 to 7 of
this document).</p>
<p>HMM also provides optional helpers for SVM (Share Virtual Memory), i.e.,
allowing a device to transparently access program addresses coherently with
the CPU meaning that any valid pointer on the CPU is also a valid pointer
for the device. This is becoming mandatory to simplify the use of advanced
heterogeneous computing where GPU, DSP, or FPGA are used to perform various
computations on behalf of a process.</p>
<p>This document is divided as follows: in the first section I expose the problems
related to using device specific memory allocators. In the second section, I
expose the hardware limitations that are inherent to many platforms. The third
section gives an overview of the HMM design. The fourth section explains how
CPU page-table mirroring works and the purpose of HMM in this context. The
fifth section deals with how device memory is represented inside the kernel.
Finally, the last section presents a new migration helper that allows
leveraging the device DMA engine.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#problems-of-using-a-device-specific-memory-allocator" id="id1">Problems of using a device specific memory allocator</a></p></li>
<li><p><a class="reference internal" href="#i-o-bus-device-memory-characteristics" id="id2">I/O bus, device memory characteristics</a></p></li>
<li><p><a class="reference internal" href="#shared-address-space-and-migration" id="id3">Shared address space and migration</a></p></li>
<li><p><a class="reference internal" href="#address-space-mirroring-implementation-and-api" id="id4">Address space mirroring implementation and API</a></p></li>
<li><p><a class="reference internal" href="#leverage-default-flags-and-pfn-flags-mask" id="id5">Leverage default_flags and pfn_flags_mask</a></p></li>
<li><p><a class="reference internal" href="#represent-and-manage-device-memory-from-core-kernel-point-of-view" id="id6">Represent and manage device memory from core kernel point of view</a></p></li>
<li><p><a class="reference internal" href="#migration-to-and-from-device-memory" id="id7">Migration to and from device memory</a></p></li>
<li><p><a class="reference internal" href="#memory-cgroup-memcg-and-rss-accounting" id="id8">Memory cgroup (memcg) and rss accounting</a></p></li>
</ul>
</div>
<div class="section" id="problems-of-using-a-device-specific-memory-allocator">
<h2><a class="toc-backref" href="#id1">Problems of using a device specific memory allocator</a><a class="headerlink" href="#problems-of-using-a-device-specific-memory-allocator" title="Permalink to this headline">¶</a></h2>
<p>Devices with a large amount of on board memory (several gigabytes) like GPUs
have historically managed their memory through dedicated driver specific APIs.
This creates a disconnect between memory allocated and managed by a device
driver and regular application memory (private anonymous, shared memory, or
regular file backed memory). From here on I will refer to this aspect as split
address space. I use shared address space to refer to the opposite situation:
i.e., one in which any application memory region can be used by a device
transparently.</p>
<p>Split address space happens because devices can only access memory allocated
through a device specific API. This implies that all memory objects in a program
are not equal from the device point of view which complicates large programs
that rely on a wide set of libraries.</p>
<p>Concretely, this means that code that wants to leverage devices like GPUs needs
to copy objects between generically allocated memory (malloc, mmap private, mmap
share) and memory allocated through the device driver API (this still ends up
with an mmap but of the device file).</p>
<p>For flat data sets (array, grid, image, …) this isn’t too hard to achieve but
for complex data sets (list, tree, …) it’s hard to get right. Duplicating a
complex data set needs to re-map all the pointer relations between each of its
elements. This is error prone and programs get harder to debug because of the
duplicate data set and addresses.</p>
<p>Split address space also means that libraries cannot transparently use data
they are getting from the core program or another library and thus each library
might have to duplicate its input data set using the device specific memory
allocator. Large projects suffer from this and waste resources because of the
various memory copies.</p>
<p>Duplicating each library API to accept as input or output memory allocated by
each device specific allocator is not a viable option. It would lead to a
combinatorial explosion in the library entry points.</p>
<p>Finally, with the advance of high level language constructs (in C++ but in
other languages too) it is now possible for the compiler to leverage GPUs and
other devices without programmer knowledge. Some compiler identified patterns
are only do-able with a shared address space. It is also more reasonable to use
a shared address space for all other patterns.</p>
</div>
<div class="section" id="i-o-bus-device-memory-characteristics">
<h2><a class="toc-backref" href="#id2">I/O bus, device memory characteristics</a><a class="headerlink" href="#i-o-bus-device-memory-characteristics" title="Permalink to this headline">¶</a></h2>
<p>I/O buses cripple shared address spaces due to a few limitations. Most I/O
buses only allow basic memory access from device to main memory; even cache
coherency is often optional. Access to device memory from a CPU is even more
limited. More often than not, it is not cache coherent.</p>
<p>If we only consider the PCIE bus, then a device can access main memory (often
through an IOMMU) and be cache coherent with the CPUs. However, it only allows
a limited set of atomic operations from the device on main memory. This is worse
in the other direction: the CPU can only access a limited range of the device
memory and cannot perform atomic operations on it. Thus device memory cannot
be considered the same as regular memory from the kernel point of view.</p>
<p>Another crippling factor is the limited bandwidth (~32GBytes/s with PCIE 4.0
and 16 lanes). This is 33 times less than the fastest GPU memory (1 TBytes/s).
The final limitation is latency. Access to main memory from the device has an
order of magnitude higher latency than when the device accesses its own memory.</p>
<p>Some platforms are developing new I/O buses or additions/modifications to PCIE
to address some of these limitations (OpenCAPI, CCIX). They mainly allow
two-way cache coherency between CPU and device and allow all atomic operations the
architecture supports. Sadly, not all platforms are following this trend and
some major architectures are left without hardware solutions to these problems.</p>
<p>So for shared address space to make sense, not only must we allow devices to
access any memory but we must also permit any memory to be migrated to device
memory while the device is using it (blocking CPU access while it happens).</p>
</div>
<div class="section" id="shared-address-space-and-migration">
<h2><a class="toc-backref" href="#id3">Shared address space and migration</a><a class="headerlink" href="#shared-address-space-and-migration" title="Permalink to this headline">¶</a></h2>
<p>HMM intends to provide two main features. The first one is to share the address
space by duplicating the CPU page table in the device page table so the same
address points to the same physical memory for any valid main memory address in
the process address space.</p>
<p>To achieve this, HMM offers a set of helpers to populate the device page table
while keeping track of CPU page table updates. Device page table updates are
not as easy as CPU page table updates. To update the device page table, you must
allocate a buffer (or use a pool of pre-allocated buffers) and write GPU
specific commands in it to perform the update (unmap, cache invalidations, and
flush, …). This cannot be done through common code for all devices. Hence
why HMM provides helpers to factor out everything that can be while leaving the
hardware specific details to the device driver.</p>
<p>The second mechanism HMM provides is a new kind of ZONE_DEVICE memory that
allows allocating a struct page for each page of device memory. Those pages
are special because the CPU cannot map them. However, they allow migrating
main memory to device memory using existing migration mechanisms and everything
looks like a page that is swapped out to disk from the CPU point of view. Using a
struct page gives the easiest and cleanest integration with existing mm
mechanisms. Here again, HMM only provides helpers, first to hotplug new ZONE_DEVICE
memory for the device memory and second to perform migration. Policy decisions
of what and when to migrate is left to the device driver.</p>
<p>Note that any CPU access to a device page triggers a page fault and a migration
back to main memory. For example, when a page backing a given CPU address A is
migrated from a main memory page to a device page, then any CPU access to
address A triggers a page fault and initiates a migration back to main memory.</p>
<p>With these two features, HMM not only allows a device to mirror process address
space and keeps both CPU and device page tables synchronized, but also
leverages device memory by migrating the part of the data set that is actively being
used by the device.</p>
</div>
<div class="section" id="address-space-mirroring-implementation-and-api">
<h2><a class="toc-backref" href="#id4">Address space mirroring implementation and API</a><a class="headerlink" href="#address-space-mirroring-implementation-and-api" title="Permalink to this headline">¶</a></h2>
<p>Address space mirroring’s main objective is to allow duplication of a range of
CPU page table into a device page table; HMM helps keep both synchronized. A
device driver that wants to mirror a process address space must start with the
registration of a mmu_interval_notifier:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int mmu_interval_notifier_insert(struct mmu_interval_notifier *interval_sub,
                                 struct mm_struct *mm, unsigned long start,
                                 unsigned long length,
                                 const struct mmu_interval_notifier_ops *ops);
</pre></div>
</div>
<p>During the ops-&gt;invalidate() callback the device driver must perform the
update action to the range (mark range read only, or fully unmap, etc.). The
device must complete the update before the driver callback returns.</p>
<p>When the device driver wants to populate a range of virtual addresses, it can
use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int hmm_range_fault(struct hmm_range *range);
</pre></div>
</div>
<p>It will trigger a page fault on missing or read-only entries if write access is
requested (see below). Page faults use the generic mm page fault code path just
like a CPU page fault.</p>
<p>Both functions copy CPU page table entries into their pfns array argument. Each
entry in that array corresponds to an address in the virtual range. HMM
provides a set of flags to help the driver identify special CPU page table
entries.</p>
<p>Locking within the sync_cpu_device_pagetables() callback is the most important
aspect the driver must respect in order to keep things properly synchronized.
The usage pattern is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int driver_populate_range(...)
{
     struct hmm_range range;
     ...

     range.notifier = &amp;interval_sub;
     range.start = ...;
     range.end = ...;
     range.hmm_pfns = ...;

     if (!mmget_not_zero(interval_sub-&gt;notifier.mm))
         return -EFAULT;

again:
     range.notifier_seq = mmu_interval_read_begin(&amp;interval_sub);
     mmap_read_lock(mm);
     ret = hmm_range_fault(&amp;range);
     if (ret) {
         mmap_read_unlock(mm);
         if (ret == -EBUSY)
                goto again;
         return ret;
     }
     mmap_read_unlock(mm);

     take_lock(driver-&gt;update);
     if (mmu_interval_read_retry(&amp;ni, range.notifier_seq) {
         release_lock(driver-&gt;update);
         goto again;
     }

     /* Use pfns array content to update device page table,
      * under the update lock */

     release_lock(driver-&gt;update);
     return 0;
}
</pre></div>
</div>
<p>The driver-&gt;update lock is the same lock that the driver takes inside its
invalidate() callback. That lock must be held before calling
mmu_interval_read_retry() to avoid any race with a concurrent CPU page table
update.</p>
</div>
<div class="section" id="leverage-default-flags-and-pfn-flags-mask">
<h2><a class="toc-backref" href="#id5">Leverage default_flags and pfn_flags_mask</a><a class="headerlink" href="#leverage-default-flags-and-pfn-flags-mask" title="Permalink to this headline">¶</a></h2>
<p>The hmm_range struct has 2 fields, default_flags and pfn_flags_mask, that specify
fault or snapshot policy for the whole range instead of having to set them
for each entry in the pfns array.</p>
<p>For instance if the device driver wants pages for a range with at least read
permission, it sets:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>range-&gt;default_flags = HMM_PFN_REQ_FAULT;
range-&gt;pfn_flags_mask = 0;
</pre></div>
</div>
<p>and calls hmm_range_fault() as described above. This will fill fault all pages
in the range with at least read permission.</p>
<p>Now let’s say the driver wants to do the same except for one page in the range for
which it wants to have write permission. Now driver set:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>range-&gt;default_flags = HMM_PFN_REQ_FAULT;
range-&gt;pfn_flags_mask = HMM_PFN_REQ_WRITE;
range-&gt;pfns[index_of_write] = HMM_PFN_REQ_WRITE;
</pre></div>
</div>
<p>With this, HMM will fault in all pages with at least read (i.e., valid) and for the
address == range-&gt;start + (index_of_write &lt;&lt; PAGE_SHIFT) it will fault with
write permission i.e., if the CPU pte does not have write permission set then HMM
will call handle_mm_fault().</p>
<p>After hmm_range_fault completes the flag bits are set to the current state of
the page tables, ie HMM_PFN_VALID | HMM_PFN_WRITE will be set if the page is
writable.</p>
</div>
<div class="section" id="represent-and-manage-device-memory-from-core-kernel-point-of-view">
<h2><a class="toc-backref" href="#id6">Represent and manage device memory from core kernel point of view</a><a class="headerlink" href="#represent-and-manage-device-memory-from-core-kernel-point-of-view" title="Permalink to this headline">¶</a></h2>
<p>Several different designs were tried to support device memory. The first one
used a device specific data structure to keep information about migrated memory
and HMM hooked itself in various places of mm code to handle any access to
addresses that were backed by device memory. It turns out that this ended up
replicating most of the fields of struct page and also needed many kernel code
paths to be updated to understand this new kind of memory.</p>
<p>Most kernel code paths never try to access the memory behind a page
but only care about struct page contents. Because of this, HMM switched to
directly using struct page for device memory which left most kernel code paths
unaware of the difference. We only need to make sure that no one ever tries to
map those pages from the CPU side.</p>
</div>
<div class="section" id="migration-to-and-from-device-memory">
<h2><a class="toc-backref" href="#id7">Migration to and from device memory</a><a class="headerlink" href="#migration-to-and-from-device-memory" title="Permalink to this headline">¶</a></h2>
<p>Because the CPU cannot access device memory directly, the device driver must
use hardware DMA or device specific load/store instructions to migrate data.
The migrate_vma_setup(), migrate_vma_pages(), and migrate_vma_finalize()
functions are designed to make drivers easier to write and to centralize common
code across drivers.</p>
<p>Before migrating pages to device private memory, special device private
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> need to be created. These will be used as special “swap”
page table entries so that a CPU process will fault if it tries to access
a page that has been migrated to device private memory.</p>
<p>These can be allocated and freed with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct resource *res;
struct dev_pagemap pagemap;

res = request_free_mem_region(&amp;iomem_resource, /* number of bytes */,
                              &quot;name of driver resource&quot;);
pagemap.type = MEMORY_DEVICE_PRIVATE;
pagemap.range.start = res-&gt;start;
pagemap.range.end = res-&gt;end;
pagemap.nr_range = 1;
pagemap.ops = &amp;device_devmem_ops;
memremap_pages(&amp;pagemap, numa_node_id());

memunmap_pages(&amp;pagemap);
release_mem_region(pagemap.range.start, range_len(&amp;pagemap.range));
</pre></div>
</div>
<p>There are also <a class="reference internal" href="../core-api/kernel-api.html#c.devm_request_free_mem_region" title="devm_request_free_mem_region"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_request_free_mem_region()</span></code></a>, devm_memremap_pages(),
devm_memunmap_pages(), and devm_release_mem_region() when the resources can
be tied to a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code>.</p>
<p>The overall migration steps are similar to migrating NUMA pages within system
memory (see <a class="reference internal" href="page_migration.html#page-migration"><span class="std std-ref">Page migration</span></a>) but the steps are split
between device driver specific code and shared common code:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">mmap_read_lock()</span></code></p>
<p>The device driver has to pass a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> to
migrate_vma_setup() so the mmap_read_lock() or mmap_write_lock() needs to
be held for the duration of the migration.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">migrate_vma_setup(struct</span> <span class="pre">migrate_vma</span> <span class="pre">*args)</span></code></p>
<p>The device driver initializes the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">migrate_vma</span></code> fields and passes
the pointer to migrate_vma_setup(). The <code class="docutils literal notranslate"><span class="pre">args-&gt;flags</span></code> field is used to
filter which source pages should be migrated. For example, setting
<code class="docutils literal notranslate"><span class="pre">MIGRATE_VMA_SELECT_SYSTEM</span></code> will only migrate system memory and
<code class="docutils literal notranslate"><span class="pre">MIGRATE_VMA_SELECT_DEVICE_PRIVATE</span></code> will only migrate pages residing in
device private memory. If the latter flag is set, the <code class="docutils literal notranslate"><span class="pre">args-&gt;pgmap_owner</span></code>
field is used to identify device private pages owned by the driver. This
avoids trying to migrate device private pages residing in other devices.
Currently only anonymous private VMA ranges can be migrated to or from
system memory and device private memory.</p>
<p>One of the first steps migrate_vma_setup() does is to invalidate other
device’s MMUs with the <code class="docutils literal notranslate"><span class="pre">mmu_notifier_invalidate_range_start(()</span></code> and
<code class="docutils literal notranslate"><span class="pre">mmu_notifier_invalidate_range_end()</span></code> calls around the page table
walks to fill in the <code class="docutils literal notranslate"><span class="pre">args-&gt;src</span></code> array with PFNs to be migrated.
The <code class="docutils literal notranslate"><span class="pre">invalidate_range_start()</span></code> callback is passed a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mmu_notifier_range</span></code> with the <code class="docutils literal notranslate"><span class="pre">event</span></code> field set to
<code class="docutils literal notranslate"><span class="pre">MMU_NOTIFY_MIGRATE</span></code> and the <code class="docutils literal notranslate"><span class="pre">migrate_pgmap_owner</span></code> field set to
the <code class="docutils literal notranslate"><span class="pre">args-&gt;pgmap_owner</span></code> field passed to migrate_vma_setup(). This is
allows the device driver to skip the invalidation callback and only
invalidate device private MMU mappings that are actually migrating.
This is explained more in the next section.</p>
<p>While walking the page tables, a <code class="docutils literal notranslate"><span class="pre">pte_none()</span></code> or <code class="docutils literal notranslate"><span class="pre">is_zero_pfn()</span></code>
entry results in a valid “zero” PFN stored in the <code class="docutils literal notranslate"><span class="pre">args-&gt;src</span></code> array.
This lets the driver allocate device private memory and clear it instead
of copying a page of zeros. Valid PTE entries to system memory or
device private struct pages will be locked with <code class="docutils literal notranslate"><span class="pre">lock_page()</span></code>, isolated
from the LRU (if system memory since device private pages are not on
the LRU), unmapped from the process, and a special migration PTE is
inserted in place of the original PTE.
migrate_vma_setup() also clears the <code class="docutils literal notranslate"><span class="pre">args-&gt;dst</span></code> array.</p>
</li>
<li><p>The device driver allocates destination pages and copies source pages to
destination pages.</p>
<p>The driver checks each <code class="docutils literal notranslate"><span class="pre">src</span></code> entry to see if the <code class="docutils literal notranslate"><span class="pre">MIGRATE_PFN_MIGRATE</span></code>
bit is set and skips entries that are not migrating. The device driver
can also choose to skip migrating a page by not filling in the <code class="docutils literal notranslate"><span class="pre">dst</span></code>
array for that page.</p>
<p>The driver then allocates either a device private struct page or a
system memory page, locks the page with <code class="docutils literal notranslate"><span class="pre">lock_page()</span></code>, and fills in the
<code class="docutils literal notranslate"><span class="pre">dst</span></code> array entry with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst[i] = migrate_pfn(page_to_pfn(dpage)) | MIGRATE_PFN_LOCKED;
</pre></div>
</div>
<p>Now that the driver knows that this page is being migrated, it can
invalidate device private MMU mappings and copy device private memory
to system memory or another device private page. The core Linux kernel
handles CPU page table invalidations so the device driver only has to
invalidate its own MMU mappings.</p>
<p>The driver can use <code class="docutils literal notranslate"><span class="pre">migrate_pfn_to_page(src[i])</span></code> to get the
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> of the source and either copy the source page to the
destination or clear the destination device private memory if the pointer
is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> meaning the source page was not populated in system memory.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">migrate_vma_pages()</span></code></p>
<p>This step is where the migration is actually “committed”.</p>
<p>If the source page was a <code class="docutils literal notranslate"><span class="pre">pte_none()</span></code> or <code class="docutils literal notranslate"><span class="pre">is_zero_pfn()</span></code> page, this
is where the newly allocated page is inserted into the CPU’s page table.
This can fail if a CPU thread faults on the same page. However, the page
table is locked and only one of the new pages will be inserted.
The device driver will see that the <code class="docutils literal notranslate"><span class="pre">MIGRATE_PFN_MIGRATE</span></code> bit is cleared
if it loses the race.</p>
<p>If the source page was locked, isolated, etc. the source <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code>
information is now copied to destination <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> finalizing the
migration on the CPU side.</p>
</li>
<li><p>Device driver updates device MMU page tables for pages still migrating,
rolling back pages not migrating.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">src</span></code> entry still has <code class="docutils literal notranslate"><span class="pre">MIGRATE_PFN_MIGRATE</span></code> bit set, the device
driver can update the device MMU and set the write enable bit if the
<code class="docutils literal notranslate"><span class="pre">MIGRATE_PFN_WRITE</span></code> bit is set.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">migrate_vma_finalize()</span></code></p>
<p>This step replaces the special migration page table entry with the new
page’s page table entry and releases the reference to the source and
destination <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mmap_read_unlock()</span></code></p>
<p>The lock can now be released.</p>
</li>
</ol>
</div>
<div class="section" id="memory-cgroup-memcg-and-rss-accounting">
<h2><a class="toc-backref" href="#id8">Memory cgroup (memcg) and rss accounting</a><a class="headerlink" href="#memory-cgroup-memcg-and-rss-accounting" title="Permalink to this headline">¶</a></h2>
<p>For now, device memory is accounted as any regular page in rss counters (either
anonymous if device page is used for anonymous, file if device page is used for
file backed page, or shmem if device page is used for shared memory). This is a
deliberate choice to keep existing applications, that might start using device
memory without knowing about it, running unimpacted.</p>
<p>A drawback is that the OOM killer might kill an application using a lot of
device memory and not a lot of regular system memory and thus not freeing much
system memory. We want to gather more real world experience on how applications
and system react under memory pressure in the presence of device memory before
deciding to account device memory differently.</p>
<p>Same decision was made for memory cgroup. Device memory pages are accounted
against same memory cgroup a regular page would be accounted to. This does
simplify migration to and from device memory. This also means that migration
back from device memory to regular memory cannot fail because it would
go above memory cgroup limit. We might revisit this choice latter on once we
get more experience in how device memory is used and its impact on memory
resource control.</p>
<p>Note that device memory can never be pinned by a device driver nor through GUP
and thus such memory is always free upon process exit. Or when last reference
is dropped in case of shared memory or file backed memory.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright The kernel development community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>