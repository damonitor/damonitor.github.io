

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>splice and pipes &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>splice and pipes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/splice.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="splice-and-pipes">
<h1>splice and pipes<a class="headerlink" href="#splice-and-pipes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="splice-api">
<h2>splice API<a class="headerlink" href="#splice-api" title="Permalink to this headline">¶</a></h2>
<p>splice is a method for moving blocks of data around inside the kernel,
without continually transferring them between the kernel and user space.</p>
<dl class="function">
<dt id="c.splice_to_pipe">
ssize_t <code class="descname">splice_to_pipe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_pipe_desc *<em>&nbsp;spd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_to_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>fill passed data into a pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to fill</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_pipe_desc</span> <span class="pre">*</span> <span class="pre">spd</span></code></dt>
<dd>data to fill</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><strong>spd</strong> contains a map of pages and len/offset tuples, along with
the struct pipe_buf_operations associated with these pages. This
function will link that data to the pipe.</div></blockquote>
<dl class="function">
<dt id="c.generic_file_splice_read">
ssize_t <code class="descname">generic_file_splice_read</code><span class="sig-paren">(</span>struct file *<em>&nbsp;in</em>, loff_t *<em>&nbsp;ppos</em>, struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_splice_read" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from file to a pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>file to splice from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>position in <strong>in</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to splice</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Will read pages from given file and fill them into a pipe. Can be
used as long as it has more or less sane -&gt;read_iter().</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe_feed">
int <code class="descname">splice_from_pipe_feed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_desc *<em>&nbsp;sd</em>, splice_actor *<em>&nbsp;actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>feed available data from a pipe to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information to <strong>actor</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_actor</span> <span class="pre">*</span> <span class="pre">actor</span></code></dt>
<dd>handler that splices the data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function loops over the pipe and calls <strong>actor</strong> to do the
actual moving of a single struct pipe_buffer to the desired
destination.  It returns when there’s no more buffers left in
the pipe or if the requested number of bytes (<strong>sd-&gt;total_len</strong>)
have been copied.  It returns a positive number (one) if the
pipe needs to be filled with more data, zero if the required
number of bytes have been copied and -errno on error.</p>
<p>This, together with splice_from_pipe_{begin,end,next}, may be
used to implement the functionality of <a class="reference internal" href="#c.__splice_from_pipe" title="__splice_from_pipe"><code class="xref c c-func docutils literal notranslate"><span class="pre">__splice_from_pipe()</span></code></a> when
locking is required around copying the pipe buffers to the
destination.</p>
</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe_next">
int <code class="descname">splice_from_pipe_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_desc *<em>&nbsp;sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_next" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for some data to splice from</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information about the splice operation</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function will wait for some data and return a positive
value (one) if pipe buffers are available.  It will return zero
or -errno if no more data needs to be spliced.</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe_begin">
void <code class="descname">splice_from_pipe_begin</code><span class="sig-paren">(</span>struct splice_desc *<em>&nbsp;sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>start splicing from pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information about the splice operation</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function should be called before a loop containing
<a class="reference internal" href="#c.splice_from_pipe_next" title="splice_from_pipe_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">splice_from_pipe_next()</span></code></a> and <a class="reference internal" href="#c.splice_from_pipe_feed" title="splice_from_pipe_feed"><code class="xref c c-func docutils literal notranslate"><span class="pre">splice_from_pipe_feed()</span></code></a> to
initialize the necessary fields of <strong>sd</strong>.</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe_end">
void <code class="descname">splice_from_pipe_end</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_desc *<em>&nbsp;sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_end" title="Permalink to this definition">¶</a></dt>
<dd><p>finish splicing from pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information about the splice operation</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function will wake up pipe writers if necessary.  It should
be called after a loop containing <a class="reference internal" href="#c.splice_from_pipe_next" title="splice_from_pipe_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">splice_from_pipe_next()</span></code></a> and
<a class="reference internal" href="#c.splice_from_pipe_feed" title="splice_from_pipe_feed"><code class="xref c c-func docutils literal notranslate"><span class="pre">splice_from_pipe_feed()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.__splice_from_pipe">
ssize_t <code class="descname">__splice_from_pipe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_desc *<em>&nbsp;sd</em>, splice_actor *<em>&nbsp;actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__splice_from_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to given actor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information to <strong>actor</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_actor</span> <span class="pre">*</span> <span class="pre">actor</span></code></dt>
<dd>handler that splices the data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function does little more than loop over the pipe and call
<strong>actor</strong> to do the actual moving of a single struct pipe_buffer to
the desired destination. See pipe_to_file, pipe_to_sendpage, or
pipe_to_user.</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe">
ssize_t <code class="descname">splice_from_pipe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct file *<em>&nbsp;out</em>, loff_t *<em>&nbsp;ppos</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em>, splice_actor *<em>&nbsp;actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>file to splice to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>position in <strong>out</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>how many bytes to splice</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_actor</span> <span class="pre">*</span> <span class="pre">actor</span></code></dt>
<dd>handler that splices the data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>See __splice_from_pipe. This function locks the pipe inode,
otherwise it’s identical to <a class="reference internal" href="#c.__splice_from_pipe" title="__splice_from_pipe"><code class="xref c c-func docutils literal notranslate"><span class="pre">__splice_from_pipe()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.iter_file_splice_write">
ssize_t <code class="descname">iter_file_splice_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct file *<em>&nbsp;out</em>, loff_t *<em>&nbsp;ppos</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iter_file_splice_write" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe info</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>file to write to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>position in <strong>out</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to splice</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Will either move or copy pages (determined by <strong>flags</strong> options) from
the given pipe inode to the given file.
This one is -&gt;write_iter-based.</div></blockquote>
<dl class="function">
<dt id="c.generic_splice_sendpage">
ssize_t <code class="descname">generic_splice_sendpage</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct file *<em>&nbsp;out</em>, loff_t *<em>&nbsp;ppos</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_splice_sendpage" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>socket to write to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>position in <strong>out</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to splice</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Will send <strong>len</strong> bytes from the pipe to a network socket. No data copying
is involved.</div></blockquote>
<dl class="function">
<dt id="c.splice_direct_to_actor">
ssize_t <code class="descname">splice_direct_to_actor</code><span class="sig-paren">(</span>struct file *<em>&nbsp;in</em>, struct splice_desc *<em>&nbsp;sd</em>, splice_direct_actor *<em>&nbsp;actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_direct_to_actor" title="Permalink to this definition">¶</a></dt>
<dd><p>splices data directly between two non-pipes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>file to splice from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>actor information on where to splice to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">splice_direct_actor</span> <span class="pre">*</span> <span class="pre">actor</span></code></dt>
<dd>handles the data splicing</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is a special case helper to splice directly between two
points, without requiring an explicit pipe. Internally an allocated
pipe is cached in the process, and reused during the lifetime of
that process.</div></blockquote>
<dl class="function">
<dt id="c.do_splice_direct">
long <code class="descname">do_splice_direct</code><span class="sig-paren">(</span>struct file *<em>&nbsp;in</em>, loff_t *<em>&nbsp;ppos</em>, struct file *<em>&nbsp;out</em>, loff_t *<em>&nbsp;opos</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_splice_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>splices data directly between two files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>file to splice from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>input file offset</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>file to splice to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">opos</span></code></dt>
<dd>output file offset</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to splice</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For use by do_sendfile(). splice can easily emulate sendfile, but
doing it in the application would incur an extra system call
(splice in + splice out, as compared to just sendfile()). So this helper
can splice directly through a process-private pipe.</div></blockquote>
</div>
<div class="section" id="pipes-api">
<h2>pipes API<a class="headerlink" href="#pipes-api" title="Permalink to this headline">¶</a></h2>
<p>Pipe interfaces are all for in-kernel (builtin image) use. They are not
exported for use by modules.</p>
<dl class="type">
<dt id="c.pipe_buffer">
struct <code class="descname">pipe_buffer</code><a class="headerlink" href="#c.pipe_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>a linux kernel pipe buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pipe_buffer {
  struct page *page;
  unsigned int offset, len;
  const struct pipe_buf_operations *ops;
  unsigned int flags;
  unsigned long private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">page</span></code></dt>
<dd>the page containing the data for the pipe buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt>
<dd>offset of data inside the <strong>page</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt>
<dd>length of data inside the <strong>page</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt>
<dd>operations associated with this buffer. See <strong>pipe_buf_operations</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>pipe buffer flags. See above.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt>
<dd>private data owned by the ops.</dd>
</dl>
<dl class="type">
<dt id="c.pipe_inode_info">
struct <code class="descname">pipe_inode_info</code><a class="headerlink" href="#c.pipe_inode_info" title="Permalink to this definition">¶</a></dt>
<dd><p>a linux kernel pipe</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pipe_inode_info {
  struct mutex mutex;
  wait_queue_head_t rd_wait, wr_wait;
  unsigned int head;
  unsigned int tail;
  unsigned int max_usage;
  unsigned int ring_size;
  unsigned int readers;
  unsigned int writers;
  unsigned int files;
  unsigned int r_counter;
  unsigned int w_counter;
  struct page *tmp_page;
  struct fasync_struct *fasync_readers;
  struct fasync_struct *fasync_writers;
  struct pipe_buffer *bufs;
  struct user_struct *user;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt>
<dd>mutex protecting the whole thing</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rd_wait</span></code></dt>
<dd>reader wait point in case of empty pipe</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wr_wait</span></code></dt>
<dd>writer wait point in case of full pipe</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt>
<dd>The point of buffer production</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tail</span></code></dt>
<dd>The point of buffer consumption</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_usage</span></code></dt>
<dd>The maximum number of slots that may be used in the ring</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ring_size</span></code></dt>
<dd>total number of buffers (should be a power of 2)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">readers</span></code></dt>
<dd>number of current readers of this pipe</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writers</span></code></dt>
<dd>number of current writers of this pipe</dd>
<dt><code class="docutils literal notranslate"><span class="pre">files</span></code></dt>
<dd>number of struct file referring this pipe (protected by -&gt;i_lock)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">r_counter</span></code></dt>
<dd>reader counter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w_counter</span></code></dt>
<dd>writer counter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tmp_page</span></code></dt>
<dd>cached released page</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fasync_readers</span></code></dt>
<dd>reader side fasync</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fasync_writers</span></code></dt>
<dd>writer side fasync</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bufs</span></code></dt>
<dd>the circular array of pipe buffers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">user</span></code></dt>
<dd>the user who created this pipe</dd>
</dl>
<dl class="function">
<dt id="c.pipe_empty">
bool <code class="descname">pipe_empty</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;head</em>, unsigned int<em>&nbsp;tail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the pipe is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">head</span></code></dt>
<dd>The pipe ring head pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tail</span></code></dt>
<dd>The pipe ring tail pointer</dd>
</dl>
<dl class="function">
<dt id="c.pipe_occupancy">
unsigned int <code class="descname">pipe_occupancy</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;head</em>, unsigned int<em>&nbsp;tail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_occupancy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of slots used in the pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">head</span></code></dt>
<dd>The pipe ring head pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tail</span></code></dt>
<dd>The pipe ring tail pointer</dd>
</dl>
<dl class="function">
<dt id="c.pipe_full">
bool <code class="descname">pipe_full</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;head</em>, unsigned int<em>&nbsp;tail</em>, unsigned int<em>&nbsp;limit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the pipe is full</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">head</span></code></dt>
<dd>The pipe ring head pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tail</span></code></dt>
<dd>The pipe ring tail pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">limit</span></code></dt>
<dd>The maximum amount of slots available.</dd>
</dl>
<dl class="function">
<dt id="c.pipe_space_for_user">
unsigned int <code class="descname">pipe_space_for_user</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;head</em>, unsigned int<em>&nbsp;tail</em>, struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_space_for_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of slots available to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">head</span></code></dt>
<dd>The pipe ring head pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tail</span></code></dt>
<dd>The pipe ring tail pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>The pipe info structure</dd>
</dl>
<dl class="function">
<dt id="c.pipe_buf_get">
bool <code class="descname">pipe_buf_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a pipe_buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to get a reference to</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the reference was successfully obtained.</p>
<dl class="function">
<dt id="c.pipe_buf_release">
void <code class="descname">pipe_buf_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_release" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference to a pipe_buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to put a reference to</dd>
</dl>
<dl class="function">
<dt id="c.pipe_buf_confirm">
int <code class="descname">pipe_buf_confirm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_confirm" title="Permalink to this definition">¶</a></dt>
<dd><p>verify contents of the pipe buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to confirm</dd>
</dl>
<dl class="function">
<dt id="c.pipe_buf_steal">
int <code class="descname">pipe_buf_steal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_steal" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to take ownership of a pipe_buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to attempt to steal</dd>
</dl>
<dl class="function">
<dt id="c.generic_pipe_buf_steal">
int <code class="descname">generic_pipe_buf_steal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_steal" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to take ownership of a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">pipe_buffer</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to attempt to steal</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function attempts to steal the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> attached to
<strong>buf</strong>. If successful, this function returns 0 and returns with
the page locked. The caller may then reuse the page for whatever
he wishes; the typical use is insertion into a different file
page cache.</div></blockquote>
<dl class="function">
<dt id="c.generic_pipe_buf_get">
bool <code class="descname">generic_pipe_buf_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to get a reference to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function grabs an extra reference to <strong>buf</strong>. It’s used in
in the tee() system call, when we duplicate the buffers in one
pipe into another.</div></blockquote>
<dl class="function">
<dt id="c.generic_pipe_buf_confirm">
int <code class="descname">generic_pipe_buf_confirm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;info</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_confirm" title="Permalink to this definition">¶</a></dt>
<dd><p>verify contents of the pipe buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to confirm</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function does nothing, because the generic pipe code uses
pages that are always good when inserted into the pipe.</div></blockquote>
<dl class="function">
<dt id="c.generic_pipe_buf_release">
void <code class="descname">generic_pipe_buf_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_release" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference to a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to put a reference to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function releases a reference to <strong>buf</strong>.</div></blockquote>
<dl class="function">
<dt id="c.pipe_buf_mark_unmergeable">
void <code class="descname">pipe_buf_mark_unmergeable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_mark_unmergeable" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a> as unmergeable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to mark</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function ensures that no future writes will be merged into the
given <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a>. This is necessary when multiple pipe buffers
share the same backing page.</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>