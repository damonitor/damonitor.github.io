

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Lock types and their rules &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Lock types and their rules</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/locking/locktypes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="lock-types-and-their-rules">
<span id="kernel-hacking-locktypes"></span><h1>Lock types and their rules<a class="headerlink" href="#lock-types-and-their-rules" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The kernel provides a variety of locking primitives which can be divided
into two categories:</p>
<blockquote>
<div><ul class="simple">
<li>Sleeping locks</li>
<li>Spinning locks</li>
</ul>
</div></blockquote>
<p>This document conceptually describes these lock types and provides rules
for their nesting, including the rules for use under PREEMPT_RT.</p>
</div>
<div class="section" id="lock-categories">
<h2>Lock categories<a class="headerlink" href="#lock-categories" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sleeping-locks">
<h3>Sleeping locks<a class="headerlink" href="#sleeping-locks" title="Permalink to this headline">¶</a></h3>
<p>Sleeping locks can only be acquired in preemptible task context.</p>
<p>Although implementations allow try_lock() from other contexts, it is
necessary to carefully evaluate the safety of unlock() as well as of
try_lock().  Furthermore, it is also necessary to evaluate the debugging
versions of these primitives.  In short, don’t acquire sleeping locks from
other contexts unless there is no other option.</p>
<p>Sleeping lock types:</p>
<blockquote>
<div><ul class="simple">
<li>mutex</li>
<li>rt_mutex</li>
<li>semaphore</li>
<li>rw_semaphore</li>
<li>ww_mutex</li>
<li>percpu_rw_semaphore</li>
</ul>
</div></blockquote>
<p>On PREEMPT_RT kernels, these lock types are converted to sleeping locks:</p>
<blockquote>
<div><ul class="simple">
<li>spinlock_t</li>
<li>rwlock_t</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="spinning-locks">
<h3>Spinning locks<a class="headerlink" href="#spinning-locks" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>raw_spinlock_t</li>
<li>bit spinlocks</li>
</ul>
</div></blockquote>
<p>On non-PREEMPT_RT kernels, these lock types are also spinning locks:</p>
<blockquote>
<div><ul class="simple">
<li>spinlock_t</li>
<li>rwlock_t</li>
</ul>
</div></blockquote>
<p>Spinning locks implicitly disable preemption and the lock / unlock functions
can have suffixes which apply further protections:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>_bh()</td>
<td>Disable / enable bottom halves (soft interrupts)</td>
</tr>
<tr class="row-even"><td>_irq()</td>
<td>Disable / enable interrupts</td>
</tr>
<tr class="row-odd"><td>_irqsave/restore()</td>
<td>Save and disable / restore interrupt disabled state</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="owner-semantics">
<h2>Owner semantics<a class="headerlink" href="#owner-semantics" title="Permalink to this headline">¶</a></h2>
<p>The aforementioned lock types except semaphores have strict owner
semantics:</p>
<blockquote>
<div>The context (task) that acquired the lock must release it.</div></blockquote>
<p>rw_semaphores have a special interface which allows non-owner release for
readers.</p>
</div>
<div class="section" id="rtmutex">
<h2>rtmutex<a class="headerlink" href="#rtmutex" title="Permalink to this headline">¶</a></h2>
<p>RT-mutexes are mutexes with support for priority inheritance (PI).</p>
<p>PI has limitations on non-PREEMPT_RT kernels due to preemption and
interrupt disabled sections.</p>
<p>PI clearly cannot preempt preemption-disabled or interrupt-disabled
regions of code, even on PREEMPT_RT kernels.  Instead, PREEMPT_RT kernels
execute most such regions of code in preemptible task context, especially
interrupt handlers and soft interrupts.  This conversion allows spinlock_t
and rwlock_t to be implemented via RT-mutexes.</p>
</div>
<div class="section" id="semaphore">
<h2>semaphore<a class="headerlink" href="#semaphore" title="Permalink to this headline">¶</a></h2>
<p>semaphore is a counting semaphore implementation.</p>
<p>Semaphores are often used for both serialization and waiting, but new use
cases should instead use separate serialization and wait mechanisms, such
as mutexes and completions.</p>
<div class="section" id="semaphores-and-preempt-rt">
<h3>semaphores and PREEMPT_RT<a class="headerlink" href="#semaphores-and-preempt-rt" title="Permalink to this headline">¶</a></h3>
<p>PREEMPT_RT does not change the semaphore implementation because counting
semaphores have no concept of owners, thus preventing PREEMPT_RT from
providing priority inheritance for semaphores.  After all, an unknown
owner cannot be boosted. As a consequence, blocking on semaphores can
result in priority inversion.</p>
</div>
</div>
<div class="section" id="rw-semaphore">
<h2>rw_semaphore<a class="headerlink" href="#rw-semaphore" title="Permalink to this headline">¶</a></h2>
<p>rw_semaphore is a multiple readers and single writer lock mechanism.</p>
<p>On non-PREEMPT_RT kernels the implementation is fair, thus preventing
writer starvation.</p>
<p>rw_semaphore complies by default with the strict owner semantics, but there
exist special-purpose interfaces that allow non-owner release for readers.
These interfaces work independent of the kernel configuration.</p>
<div class="section" id="rw-semaphore-and-preempt-rt">
<h3>rw_semaphore and PREEMPT_RT<a class="headerlink" href="#rw-semaphore-and-preempt-rt" title="Permalink to this headline">¶</a></h3>
<p>PREEMPT_RT kernels map rw_semaphore to a separate rt_mutex-based
implementation, thus changing the fairness:</p>
<blockquote>
<div>Because an rw_semaphore writer cannot grant its priority to multiple
readers, a preempted low-priority reader will continue holding its lock,
thus starving even high-priority writers.  In contrast, because readers
can grant their priority to a writer, a preempted low-priority writer will
have its priority boosted until it releases the lock, thus preventing that
writer from starving readers.</div></blockquote>
</div>
</div>
<div class="section" id="raw-spinlock-t-and-spinlock-t">
<h2>raw_spinlock_t and spinlock_t<a class="headerlink" href="#raw-spinlock-t-and-spinlock-t" title="Permalink to this headline">¶</a></h2>
<div class="section" id="raw-spinlock-t">
<h3>raw_spinlock_t<a class="headerlink" href="#raw-spinlock-t" title="Permalink to this headline">¶</a></h3>
<p>raw_spinlock_t is a strict spinning lock implementation regardless of the
kernel configuration including PREEMPT_RT enabled kernels.</p>
<p>raw_spinlock_t is a strict spinning lock implementation in all kernels,
including PREEMPT_RT kernels.  Use raw_spinlock_t only in real critical
core code, low-level interrupt handling and places where disabling
preemption or interrupts is required, for example, to safely access
hardware state.  raw_spinlock_t can sometimes also be used when the
critical section is tiny, thus avoiding RT-mutex overhead.</p>
</div>
<div class="section" id="spinlock-t">
<h3>spinlock_t<a class="headerlink" href="#spinlock-t" title="Permalink to this headline">¶</a></h3>
<p>The semantics of spinlock_t change with the state of PREEMPT_RT.</p>
<p>On a non-PREEMPT_RT kernel spinlock_t is mapped to raw_spinlock_t and has
exactly the same semantics.</p>
</div>
<div class="section" id="spinlock-t-and-preempt-rt">
<h3>spinlock_t and PREEMPT_RT<a class="headerlink" href="#spinlock-t-and-preempt-rt" title="Permalink to this headline">¶</a></h3>
<p>On a PREEMPT_RT kernel spinlock_t is mapped to a separate implementation
based on rt_mutex which changes the semantics:</p>
<blockquote>
<div><ul>
<li><p class="first">Preemption is not disabled.</p>
</li>
<li><p class="first">The hard interrupt related suffixes for spin_lock / spin_unlock
operations (_irq, _irqsave / _irqrestore) do not affect the CPU’s
interrupt disabled state.</p>
</li>
<li><p class="first">The soft interrupt related suffix (_bh()) still disables softirq
handlers.</p>
<p>Non-PREEMPT_RT kernels disable preemption to get this effect.</p>
<p>PREEMPT_RT kernels use a per-CPU lock for serialization which keeps
preemption disabled. The lock disables softirq handlers and also
prevents reentrancy due to task preemption.</p>
</li>
</ul>
</div></blockquote>
<p>PREEMPT_RT kernels preserve all other spinlock_t semantics:</p>
<blockquote>
<div><ul>
<li><p class="first">Tasks holding a spinlock_t do not migrate.  Non-PREEMPT_RT kernels
avoid migration by disabling preemption.  PREEMPT_RT kernels instead
disable migration, which ensures that pointers to per-CPU variables
remain valid even if the task is preempted.</p>
</li>
<li><p class="first">Task state is preserved across spinlock acquisition, ensuring that the
task-state rules apply to all kernel configurations.  Non-PREEMPT_RT
kernels leave task state untouched.  However, PREEMPT_RT must change
task state if the task blocks during acquisition.  Therefore, it saves
the current task state before blocking and the corresponding lock wakeup
restores it, as shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>task-&gt;state = TASK_INTERRUPTIBLE
 lock()
   block()
     task-&gt;saved_state = task-&gt;state
     task-&gt;state = TASK_UNINTERRUPTIBLE
     schedule()
                                    lock wakeup
                                      task-&gt;state = task-&gt;saved_state
</pre></div>
</div>
<p>Other types of wakeups would normally unconditionally set the task state
to RUNNING, but that does not work here because the task must remain
blocked until the lock becomes available.  Therefore, when a non-lock
wakeup attempts to awaken a task blocked waiting for a spinlock, it
instead sets the saved state to RUNNING.  Then, when the lock
acquisition completes, the lock wakeup sets the task state to the saved
state, in this case setting it to RUNNING:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>task-&gt;state = TASK_INTERRUPTIBLE
 lock()
   block()
     task-&gt;saved_state = task-&gt;state
     task-&gt;state = TASK_UNINTERRUPTIBLE
     schedule()
                                    non lock wakeup
                                      task-&gt;saved_state = TASK_RUNNING

                                    lock wakeup
                                      task-&gt;state = task-&gt;saved_state
</pre></div>
</div>
<p>This ensures that the real wakeup cannot be lost.</p>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="rwlock-t">
<h2>rwlock_t<a class="headerlink" href="#rwlock-t" title="Permalink to this headline">¶</a></h2>
<p>rwlock_t is a multiple readers and single writer lock mechanism.</p>
<p>Non-PREEMPT_RT kernels implement rwlock_t as a spinning lock and the
suffix rules of spinlock_t apply accordingly. The implementation is fair,
thus preventing writer starvation.</p>
<div class="section" id="rwlock-t-and-preempt-rt">
<h3>rwlock_t and PREEMPT_RT<a class="headerlink" href="#rwlock-t-and-preempt-rt" title="Permalink to this headline">¶</a></h3>
<p>PREEMPT_RT kernels map rwlock_t to a separate rt_mutex-based
implementation, thus changing semantics:</p>
<blockquote>
<div><ul class="simple">
<li>All the spinlock_t changes also apply to rwlock_t.</li>
<li>Because an rwlock_t writer cannot grant its priority to multiple
readers, a preempted low-priority reader will continue holding its lock,
thus starving even high-priority writers.  In contrast, because readers
can grant their priority to a writer, a preempted low-priority writer
will have its priority boosted until it releases the lock, thus
preventing that writer from starving readers.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="preempt-rt-caveats">
<h2>PREEMPT_RT caveats<a class="headerlink" href="#preempt-rt-caveats" title="Permalink to this headline">¶</a></h2>
<div class="section" id="spinlock-t-and-rwlock-t">
<h3>spinlock_t and rwlock_t<a class="headerlink" href="#spinlock-t-and-rwlock-t" title="Permalink to this headline">¶</a></h3>
<p>These changes in spinlock_t and rwlock_t semantics on PREEMPT_RT kernels
have a few implications.  For example, on a non-PREEMPT_RT kernel the
following code sequence works as expected:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>local_irq_disable();
spin_lock(&amp;lock);
</pre></div>
</div>
<p>and is fully equivalent to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>spin_lock_irq(&amp;lock);
</pre></div>
</div>
<p>Same applies to rwlock_t and the _irqsave() suffix variants.</p>
<p>On PREEMPT_RT kernel this code sequence breaks because RT-mutex requires a
fully preemptible context.  Instead, use spin_lock_irq() or
spin_lock_irqsave() and their unlock counterparts.  In cases where the
interrupt disabling and locking must remain separate, PREEMPT_RT offers a
local_lock mechanism.  Acquiring the local_lock pins the task to a CPU,
allowing things like per-CPU interrupt disabled locks to be acquired.
However, this approach should be used only where absolutely necessary.</p>
</div>
<div class="section" id="id1">
<h3>raw_spinlock_t<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Acquiring a raw_spinlock_t disables preemption and possibly also
interrupts, so the critical section must avoid acquiring a regular
spinlock_t or rwlock_t, for example, the critical section must avoid
allocating memory.  Thus, on a non-PREEMPT_RT kernel the following code
works perfectly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>raw_spin_lock(&amp;lock);
p = kmalloc(sizeof(*p), GFP_ATOMIC);
</pre></div>
</div>
<p>But this code fails on PREEMPT_RT kernels because the memory allocator is
fully preemptible and therefore cannot be invoked from truly atomic
contexts.  However, it is perfectly fine to invoke the memory allocator
while holding normal non-raw spinlocks because they do not disable
preemption on PREEMPT_RT kernels:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>spin_lock(&amp;lock);
p = kmalloc(sizeof(*p), GFP_ATOMIC);
</pre></div>
</div>
</div>
<div class="section" id="bit-spinlocks">
<h3>bit spinlocks<a class="headerlink" href="#bit-spinlocks" title="Permalink to this headline">¶</a></h3>
<p>PREEMPT_RT cannot substitute bit spinlocks because a single bit is too
small to accommodate an RT-mutex.  Therefore, the semantics of bit
spinlocks are preserved on PREEMPT_RT kernels, so that the raw_spinlock_t
caveats also apply to bit spinlocks.</p>
<p>Some bit spinlocks are replaced with regular spinlock_t for PREEMPT_RT
using conditional (#ifdef’ed) code changes at the usage site.  In contrast,
usage-site changes are not needed for the spinlock_t substitution.
Instead, conditionals in header files and the core locking implemementation
enable the compiler to do the substitution transparently.</p>
</div>
</div>
<div class="section" id="lock-type-nesting-rules">
<h2>Lock type nesting rules<a class="headerlink" href="#lock-type-nesting-rules" title="Permalink to this headline">¶</a></h2>
<p>The most basic rules are:</p>
<blockquote>
<div><ul class="simple">
<li>Lock types of the same lock category (sleeping, spinning) can nest
arbitrarily as long as they respect the general lock ordering rules to
prevent deadlocks.</li>
<li>Sleeping lock types cannot nest inside spinning lock types.</li>
<li>Spinning lock types can nest inside sleeping lock types.</li>
</ul>
</div></blockquote>
<p>These constraints apply both in PREEMPT_RT and otherwise.</p>
<p>The fact that PREEMPT_RT changes the lock category of spinlock_t and
rwlock_t from spinning to sleeping means that they cannot be acquired while
holding a raw spinlock.  This results in the following nesting ordering:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Sleeping locks</li>
<li>spinlock_t and rwlock_t</li>
<li>raw_spinlock_t and bit spinlocks</li>
</ol>
</div></blockquote>
<p>Lockdep will complain if these constraints are violated, both in
PREEMPT_RT and otherwise.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>