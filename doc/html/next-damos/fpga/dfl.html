

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>FPGA Device Feature List (DFL) Framework Overview &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>FPGA Device Feature List (DFL) Framework Overview</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/fpga/dfl.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fpga-device-feature-list-dfl-framework-overview">
<h1>FPGA Device Feature List (DFL) Framework Overview<a class="headerlink" href="#fpga-device-feature-list-dfl-framework-overview" title="Permalink to this headline">¶</a></h1>
<p>Authors:</p>
<ul class="simple">
<li>Enno Luebbers &lt;<a class="reference external" href="mailto:enno&#46;luebbers&#37;&#52;&#48;intel&#46;com">enno<span>&#46;</span>luebbers<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</li>
<li>Xiao Guangrong &lt;<a class="reference external" href="mailto:guangrong&#46;xiao&#37;&#52;&#48;linux&#46;intel&#46;com">guangrong<span>&#46;</span>xiao<span>&#64;</span>linux<span>&#46;</span>intel<span>&#46;</span>com</a>&gt;</li>
<li>Wu Hao &lt;<a class="reference external" href="mailto:hao&#46;wu&#37;&#52;&#48;intel&#46;com">hao<span>&#46;</span>wu<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</li>
</ul>
<p>The Device Feature List (DFL) FPGA framework (and drivers according to this
this framework) hides the very details of low layer hardwares and provides
unified interfaces to userspace. Applications could use these interfaces to
configure, enumerate, open and access FPGA accelerators on platforms which
implement the DFL in the device memory. Besides this, the DFL framework
enables system level management functions such as FPGA reconfiguration.</p>
<div class="section" id="device-feature-list-dfl-overview">
<h2>Device Feature List (DFL) Overview<a class="headerlink" href="#device-feature-list-dfl-overview" title="Permalink to this headline">¶</a></h2>
<p>Device Feature List (DFL) defines a linked list of feature headers within the
device MMIO space to provide an extensible way of adding features. Software can
walk through these predefined data structures to enumerate FPGA features:
FPGA Interface Unit (FIU), Accelerated Function Unit (AFU) and Private Features,
as illustrated below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   Header            Header            Header            Header
+----------+  +--&gt;+----------+  +--&gt;+----------+  +--&gt;+----------+
|   Type   |  |   |  Type    |  |   |  Type    |  |   |  Type    |
|   FIU    |  |   | Private  |  |   | Private  |  |   | Private  |
+----------+  |   | Feature  |  |   | Feature  |  |   | Feature  |
| Next_DFH |--+   +----------+  |   +----------+  |   +----------+
+----------+      | Next_DFH |--+   | Next_DFH |--+   | Next_DFH |--&gt; NULL
|    ID    |      +----------+      +----------+      +----------+
+----------+      |    ID    |      |    ID    |      |    ID    |
| Next_AFU |--+   +----------+      +----------+      +----------+
+----------+  |   | Feature  |      | Feature  |      | Feature  |
|  Header  |  |   | Register |      | Register |      | Register |
| Register |  |   |   Set    |      |   Set    |      |   Set    |
|   Set    |  |   +----------+      +----------+      +----------+
+----------+  |      Header
              +--&gt;+----------+
                  |   Type   |
                  |   AFU    |
                  +----------+
                  | Next_DFH |--&gt; NULL
                  +----------+
                  |   GUID   |
                  +----------+
                  |  Header  |
                  | Register |
                  |   Set    |
                  +----------+
</pre></div>
</div>
<p>FPGA Interface Unit (FIU) represents a standalone functional unit for the
interface to FPGA, e.g. the FPGA Management Engine (FME) and Port (more
descriptions on FME and Port in later sections).</p>
<p>Accelerated Function Unit (AFU) represents a FPGA programmable region and
always connects to a FIU (e.g. a Port) as its child as illustrated above.</p>
<p>Private Features represent sub features of the FIU and AFU. They could be
various function blocks with different IDs, but all private features which
belong to the same FIU or AFU, must be linked to one list via the Next Device
Feature Header (Next_DFH) pointer.</p>
<p>Each FIU, AFU and Private Feature could implement its own functional registers.
The functional register set for FIU and AFU, is named as Header Register Set,
e.g. FME Header Register Set, and the one for Private Feature, is named as
Feature Register Set, e.g. FME Partial Reconfiguration Feature Register Set.</p>
<p>This Device Feature List provides a way of linking features together, it’s
convenient for software to locate each feature by walking through this list,
and can be implemented in register regions of any FPGA device.</p>
</div>
<div class="section" id="fiu-fme-fpga-management-engine">
<h2>FIU - FME (FPGA Management Engine)<a class="headerlink" href="#fiu-fme-fpga-management-engine" title="Permalink to this headline">¶</a></h2>
<p>The FPGA Management Engine performs reconfiguration and other infrastructure
functions. Each FPGA device only has one FME.</p>
<p>User-space applications can acquire exclusive access to the FME using open(),
and release it using close().</p>
<p>The following functions are exposed through ioctls:</p>
<ul class="simple">
<li>Get driver API version (DFL_FPGA_GET_API_VERSION)</li>
<li>Check for extensions (DFL_FPGA_CHECK_EXTENSION)</li>
<li>Program bitstream (DFL_FPGA_FME_PORT_PR)</li>
<li>Assign port to PF (DFL_FPGA_FME_PORT_ASSIGN)</li>
<li>Release port from PF (DFL_FPGA_FME_PORT_RELEASE)</li>
</ul>
<p>More functions are exposed through sysfs
(/sys/class/fpga_region/regionX/dfl-fme.n/):</p>
<blockquote>
<div><dl class="docutils">
<dt>Read bitstream ID (bitstream_id)</dt>
<dd>bitstream_id indicates version of the static FPGA region.</dd>
<dt>Read bitstream metadata (bitstream_metadata)</dt>
<dd>bitstream_metadata includes detailed information of static FPGA region,
e.g. synthesis date and seed.</dd>
<dt>Read number of ports (ports_num)</dt>
<dd>one FPGA device may have more than one port, this sysfs interface indicates
how many ports the FPGA device has.</dd>
<dt>Global error reporting management (errors/)</dt>
<dd>error reporting sysfs interfaces allow user to read errors detected by the
hardware, and clear the logged errors.</dd>
<dt>Power management (dfl_fme_power hwmon)</dt>
<dd>power management hwmon sysfs interfaces allow user to read power management
information (power consumption, thresholds, threshold status, limits, etc.)
and configure power thresholds for different throttling levels.</dd>
<dt>Thermal management (dfl_fme_thermal hwmon)</dt>
<dd>thermal management hwmon sysfs interfaces allow user to read thermal
management information (current temperature, thresholds, threshold status,
etc.).</dd>
<dt>Performance reporting</dt>
<dd>performance counters are exposed through perf PMU APIs. Standard perf tool
can be used to monitor all available perf events. Please see performance
counter section below for more detailed information.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="fiu-port">
<h2>FIU - PORT<a class="headerlink" href="#fiu-port" title="Permalink to this headline">¶</a></h2>
<p>A port represents the interface between the static FPGA fabric and a partially
reconfigurable region containing an AFU. It controls the communication from SW
to the accelerator and exposes features such as reset and debug. Each FPGA
device may have more than one port, but always one AFU per port.</p>
</div>
<div class="section" id="afu">
<h2>AFU<a class="headerlink" href="#afu" title="Permalink to this headline">¶</a></h2>
<p>An AFU is attached to a port FIU and exposes a fixed length MMIO region to be
used for accelerator-specific control registers.</p>
<p>User-space applications can acquire exclusive access to an AFU attached to a
port by using open() on the port device node and release it using close().</p>
<p>The following functions are exposed through ioctls:</p>
<ul class="simple">
<li>Get driver API version (DFL_FPGA_GET_API_VERSION)</li>
<li>Check for extensions (DFL_FPGA_CHECK_EXTENSION)</li>
<li>Get port info (DFL_FPGA_PORT_GET_INFO)</li>
<li>Get MMIO region info (DFL_FPGA_PORT_GET_REGION_INFO)</li>
<li>Map DMA buffer (DFL_FPGA_PORT_DMA_MAP)</li>
<li>Unmap DMA buffer (DFL_FPGA_PORT_DMA_UNMAP)</li>
<li>Reset AFU (DFL_FPGA_PORT_RESET)</li>
</ul>
<dl class="docutils">
<dt>DFL_FPGA_PORT_RESET:</dt>
<dd>reset the FPGA Port and its AFU. Userspace can do Port
reset at any time, e.g. during DMA or Partial Reconfiguration. But it should
never cause any system level issue, only functional failure (e.g. DMA or PR
operation failure) and be recoverable from the failure.</dd>
</dl>
<p>User-space applications can also mmap() accelerator MMIO regions.</p>
<p>More functions are exposed through sysfs:
(/sys/class/fpga_region/&lt;regionX&gt;/&lt;dfl-port.m&gt;/):</p>
<blockquote>
<div><dl class="docutils">
<dt>Read Accelerator GUID (afu_id)</dt>
<dd>afu_id indicates which PR bitstream is programmed to this AFU.</dd>
<dt>Error reporting (errors/)</dt>
<dd>error reporting sysfs interfaces allow user to read port/afu errors
detected by the hardware, and clear the logged errors.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="dfl-framework-overview">
<h2>DFL Framework Overview<a class="headerlink" href="#dfl-framework-overview" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>       +----------+    +--------+ +--------+ +--------+
       |   FME    |    |  AFU   | |  AFU   | |  AFU   |
       |  Module  |    | Module | | Module | | Module |
       +----------+    +--------+ +--------+ +--------+
               +-----------------------+
               | FPGA Container Device |    Device Feature List
               |  (FPGA Base Region)   |         Framework
               +-----------------------+
------------------------------------------------------------------
             +----------------------------+
             |   FPGA DFL Device Module   |
             | (e.g. PCIE/Platform Device)|
             +----------------------------+
               +------------------------+
               |  FPGA Hardware Device  |
               +------------------------+
</pre></div>
</div>
<p>DFL framework in kernel provides common interfaces to create container device
(FPGA base region), discover feature devices and their private features from the
given Device Feature Lists and create platform devices for feature devices
(e.g. FME, Port and AFU) with related resources under the container device. It
also abstracts operations for the private features and exposes common ops to
feature device drivers.</p>
<p>The FPGA DFL Device could be different hardwares, e.g. PCIe device, platform
device and etc. Its driver module is always loaded first once the device is
created by the system. This driver plays an infrastructural role in the
driver architecture. It locates the DFLs in the device memory, handles them
and related resources to common interfaces from DFL framework for enumeration.
(Please refer to drivers/fpga/dfl.c for detailed enumeration APIs).</p>
<p>The FPGA Management Engine (FME) driver is a platform driver which is loaded
automatically after FME platform device creation from the DFL device module. It
provides the key features for FPGA management, including:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>Expose static FPGA region information, e.g. version and metadata.
Users can read related information via sysfs interfaces exposed
by FME driver.</li>
<li>Partial Reconfiguration. The FME driver creates FPGA manager, FPGA
bridges and FPGA regions during PR sub feature initialization. Once
it receives a DFL_FPGA_FME_PORT_PR ioctl from user, it invokes the
common interface function from FPGA Region to complete the partial
reconfiguration of the PR bitstream to the given port.</li>
</ol>
</div></blockquote>
<p>Similar to the FME driver, the FPGA Accelerated Function Unit (AFU) driver is
probed once the AFU platform device is created. The main function of this module
is to provide an interface for userspace applications to access the individual
accelerators, including basic reset control on port, AFU MMIO region export, dma
buffer mapping service functions.</p>
<p>After feature platform devices creation, matched platform drivers will be loaded
automatically to handle different functionalities. Please refer to next sections
for detailed information on functional units which have been already implemented
under this DFL framework.</p>
</div>
<div class="section" id="partial-reconfiguration">
<h2>Partial Reconfiguration<a class="headerlink" href="#partial-reconfiguration" title="Permalink to this headline">¶</a></h2>
<p>As mentioned above, accelerators can be reconfigured through partial
reconfiguration of a PR bitstream file. The PR bitstream file must have been
generated for the exact static FPGA region and targeted reconfigurable region
(port) of the FPGA, otherwise, the reconfiguration operation will fail and
possibly cause system instability. This compatibility can be checked by
comparing the compatibility ID noted in the header of PR bitstream file against
the compat_id exposed by the target FPGA region. This check is usually done by
userspace before calling the reconfiguration IOCTL.</p>
</div>
<div class="section" id="fpga-virtualization-pcie-sriov">
<h2>FPGA virtualization - PCIe SRIOV<a class="headerlink" href="#fpga-virtualization-pcie-sriov" title="Permalink to this headline">¶</a></h2>
<p>This section describes the virtualization support on DFL based FPGA device to
enable accessing an accelerator from applications running in a virtual machine
(VM). This section only describes the PCIe based FPGA device with SRIOV support.</p>
<p>Features supported by the particular FPGA device are exposed through Device
Feature Lists, as illustrated below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  +-------------------------------+  +-------------+
  |              PF               |  |     VF      |
  +-------------------------------+  +-------------+
      ^            ^         ^              ^
      |            |         |              |
+-----|------------|---------|--------------|-------+
|     |            |         |              |       |
|  +-----+     +-------+ +-------+      +-------+   |
|  | FME |     | Port0 | | Port1 |      | Port2 |   |
|  +-----+     +-------+ +-------+      +-------+   |
|                  ^         ^              ^       |
|                  |         |              |       |
|              +-------+ +------+       +-------+   |
|              |  AFU  | |  AFU |       |  AFU  |   |
|              +-------+ +------+       +-------+   |
|                                                   |
|            DFL based FPGA PCIe Device             |
+---------------------------------------------------+
</pre></div>
</div>
<p>FME is always accessed through the physical function (PF).</p>
<p>Ports (and related AFUs) are accessed via PF by default, but could be exposed
through virtual function (VF) devices via PCIe SRIOV. Each VF only contains
1 Port and 1 AFU for isolation. Users could assign individual VFs (accelerators)
created via PCIe SRIOV interface, to virtual machines.</p>
<p>The driver organization in virtualization case is illustrated below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> +-------++------++------+             |
 | FME   || FME  || FME  |             |
 | FPGA  || FPGA || FPGA |             |
 |Manager||Bridge||Region|             |
 +-------++------++------+             |
 +-----------------------+  +--------+ |             +--------+
 |          FME          |  |  AFU   | |             |  AFU   |
 |         Module        |  | Module | |             | Module |
 +-----------------------+  +--------+ |             +--------+
       +-----------------------+       |       +-----------------------+
       | FPGA Container Device |       |       | FPGA Container Device |
       |  (FPGA Base Region)   |       |       |  (FPGA Base Region)   |
       +-----------------------+       |       +-----------------------+
         +------------------+          |         +------------------+
         | FPGA PCIE Module |          | Virtual | FPGA PCIE Module |
         +------------------+   Host   | Machine +------------------+
-------------------------------------- | ------------------------------
          +---------------+            |          +---------------+
          | PCI PF Device |            |          | PCI VF Device |
          +---------------+            |          +---------------+
</pre></div>
</div>
<p>FPGA PCIe device driver is always loaded first once a FPGA PCIe PF or VF device
is detected. It:</p>
<ul class="simple">
<li>Finishes enumeration on both FPGA PCIe PF and VF device using common
interfaces from DFL framework.</li>
<li>Supports SRIOV.</li>
</ul>
<p>The FME device driver plays a management role in this driver architecture, it
provides ioctls to release Port from PF and assign Port to PF. After release
a port from PF, then it’s safe to expose this port through a VF via PCIe SRIOV
sysfs interface.</p>
<p>To enable accessing an accelerator from applications running in a VM, the
respective AFU’s port needs to be assigned to a VF using the following steps:</p>
<ol class="arabic">
<li><p class="first">The PF owns all AFU ports by default. Any port that needs to be
reassigned to a VF must first be released through the
DFL_FPGA_FME_PORT_RELEASE ioctl on the FME device.</p>
</li>
<li><p class="first">Once N ports are released from PF, then user can use command below
to enable SRIOV and VFs. Each VF owns only one Port with AFU.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo N &gt; $PCI_DEVICE_PATH/sriov_numvfs
</pre></div>
</div>
</li>
<li><p class="first">Pass through the VFs to VMs</p>
</li>
<li><p class="first">The AFU under VF is accessible from applications in VM (using the
same driver inside the VF).</p>
</li>
</ol>
<p>Note that an FME can’t be assigned to a VF, thus PR and other management
functions are only available via the PF.</p>
</div>
<div class="section" id="device-enumeration">
<h2>Device enumeration<a class="headerlink" href="#device-enumeration" title="Permalink to this headline">¶</a></h2>
<p>This section introduces how applications enumerate the fpga device from
the sysfs hierarchy under /sys/class/fpga_region.</p>
<p>In the example below, two DFL based FPGA devices are installed in the host. Each
fpga device has one FME and two ports (AFUs).</p>
<p>FPGA regions are created under /sys/class/fpga_region/:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/class/fpga_region/region0
/sys/class/fpga_region/region1
/sys/class/fpga_region/region2
...
</pre></div>
</div>
<p>Application needs to search each regionX folder, if feature device is found,
(e.g. “dfl-port.n” or “dfl-fme.m” is found), then it’s the base
fpga region which represents the FPGA device.</p>
<p>Each base region has one FME and two ports (AFUs) as child devices:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/class/fpga_region/region0/dfl-fme.0
/sys/class/fpga_region/region0/dfl-port.0
/sys/class/fpga_region/region0/dfl-port.1
...

/sys/class/fpga_region/region3/dfl-fme.1
/sys/class/fpga_region/region3/dfl-port.2
/sys/class/fpga_region/region3/dfl-port.3
...
</pre></div>
</div>
<p>In general, the FME/AFU sysfs interfaces are named as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/class/fpga_region/&lt;regionX&gt;/&lt;dfl-fme.n&gt;/
/sys/class/fpga_region/&lt;regionX&gt;/&lt;dfl-port.m&gt;/
</pre></div>
</div>
<p>with ‘n’ consecutively numbering all FMEs and ‘m’ consecutively numbering all
ports.</p>
<p>The device nodes used for ioctl() or mmap() can be referenced through:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/class/fpga_region/&lt;regionX&gt;/&lt;dfl-fme.n&gt;/dev
/sys/class/fpga_region/&lt;regionX&gt;/&lt;dfl-port.n&gt;/dev
</pre></div>
</div>
</div>
<div class="section" id="performance-counters">
<h2>Performance Counters<a class="headerlink" href="#performance-counters" title="Permalink to this headline">¶</a></h2>
<p>Performance reporting is one private feature implemented in FME. It could
supports several independent, system-wide, device counter sets in hardware to
monitor and count for performance events, including “basic”, “cache”, “fabric”,
“vtd” and “vtd_sip” counters. Users could use standard perf tool to monitor
FPGA cache hit/miss rate, transaction number, interface clock counter of AFU
and other FPGA performance events.</p>
<p>Different FPGA devices may have different counter sets, depending on hardware
implementation. E.g., some discrete FPGA cards don’t have any cache. User could
use “perf list” to check which perf events are supported by target hardware.</p>
<p>In order to allow user to use standard perf API to access these performance
counters, driver creates a perf PMU, and related sysfs interfaces in
/sys/bus/event_source/devices/dfl_fme* to describe available perf events and
configuration options.</p>
<p>The “format” directory describes the format of the config field of struct
perf_event_attr. There are 3 bitfields for config: “evtype” defines which type
the perf event belongs to; “event” is the identity of the event within its
category; “portid” is introduced to decide counters set to monitor on FPGA
overall data or a specific port.</p>
<p>The “events” directory describes the configuration templates for all available
events which can be used with perf tool directly. For example, fab_mmio_read
has the configuration “event=0x06,evtype=0x02,portid=0xff”, which shows this
event belongs to fabric type (0x02), the local event id is 0x06 and it is for
overall monitoring (portid=0xff).</p>
<p>Example usage of perf:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$# perf list |grep dfl_fme

dfl_fme0/fab_mmio_read/                              [Kernel PMU event]
&lt;...&gt;
dfl_fme0/fab_port_mmio_read,portid=?/                [Kernel PMU event]
&lt;...&gt;

$# perf stat -a -e dfl_fme0/fab_mmio_read/ &lt;command&gt;
or
$# perf stat -a -e dfl_fme0/event=0x06,evtype=0x02,portid=0xff/ &lt;command&gt;
or
$# perf stat -a -e dfl_fme0/config=0xff2006/ &lt;command&gt;
</pre></div>
</div>
<p>Another example, fab_port_mmio_read monitors mmio read of a specific port. So
its configuration template is “event=0x06,evtype=0x01,portid=?”. The portid
should be explicitly set.</p>
<p>Its usage of perf:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$# perf stat -a -e dfl_fme0/fab_port_mmio_read,portid=0x0/ &lt;command&gt;
or
$# perf stat -a -e dfl_fme0/event=0x06,evtype=0x02,portid=0x0/ &lt;command&gt;
or
$# perf stat -a -e dfl_fme0/config=0x2006/ &lt;command&gt;
</pre></div>
</div>
<p>Please note for fabric counters, overall perf events (fab_*) and port perf
events (fab_port_*) actually share one set of counters in hardware, so it can’t
monitor both at the same time. If this set of counters is configured to monitor
overall data, then per port perf data is not supported. See below example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$# perf stat -e dfl_fme0/fab_mmio_read/,dfl_fme0/fab_port_mmio_write,\
                                                  portid=0/ sleep 1

Performance counter stats for &#39;system wide&#39;:

               3      dfl_fme0/fab_mmio_read/
 &lt;not supported&gt;      dfl_fme0/fab_port_mmio_write,portid=0x0/

     1.001750904 seconds time elapsed
</pre></div>
</div>
<p>The driver also provides a “cpumask” sysfs attribute, which contains only one
CPU id used to access these perf events. Counting on multiple CPU is not allowed
since they are system-wide counters on FPGA device.</p>
<p>The current driver does not support sampling. So “perf record” is unsupported.</p>
</div>
<div class="section" id="add-new-fius-support">
<h2>Add new FIUs support<a class="headerlink" href="#add-new-fius-support" title="Permalink to this headline">¶</a></h2>
<p>It’s possible that developers made some new function blocks (FIUs) under this
DFL framework, then new platform device driver needs to be developed for the
new feature dev (FIU) following the same way as existing feature dev drivers
(e.g. FME and Port/AFU platform device driver). Besides that, it requires
modification on DFL framework enumeration code too, for new FIU type detection
and related platform devices creation.</p>
</div>
<div class="section" id="add-new-private-features-support">
<h2>Add new private features support<a class="headerlink" href="#add-new-private-features-support" title="Permalink to this headline">¶</a></h2>
<p>In some cases, we may need to add some new private features to existing FIUs
(e.g. FME or Port). Developers don’t need to touch enumeration code in DFL
framework, as each private feature will be parsed automatically and related
mmio resources can be found under FIU platform device created by DFL framework.
Developer only needs to provide a sub feature driver with matched feature id.
FME Partial Reconfiguration Sub Feature driver (see drivers/fpga/dfl-fme-pr.c)
could be a reference.</p>
</div>
<div class="section" id="open-discussion">
<h2>Open discussion<a class="headerlink" href="#open-discussion" title="Permalink to this headline">¶</a></h2>
<p>FME driver exports one ioctl (DFL_FPGA_FME_PORT_PR) for partial reconfiguration
to user now. In the future, if unified user interfaces for reconfiguration are
added, FME driver should switch to them from ioctl interface.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>