

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>request_firmware API &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>request_firmware API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/firmware/request_firmware.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="request-firmware-api">
<h1>request_firmware API<a class="headerlink" href="#request-firmware-api" title="Permalink to this headline">¶</a></h1>
<p>You would typically load firmware and then load it into your device somehow.
The typical firmware work flow is reflected below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if(request_firmware(&amp;fw_entry, $FIRMWARE, device) == 0)
       copy_fw_to_device(fw_entry-&gt;data, fw_entry-&gt;size);
release_firmware(fw_entry);
</pre></div>
</div>
<div class="section" id="synchronous-firmware-requests">
<h2>Synchronous firmware requests<a class="headerlink" href="#synchronous-firmware-requests" title="Permalink to this headline">¶</a></h2>
<p>Synchronous firmware requests will wait until the firmware is found or until
an error is returned.</p>
<div class="section" id="request-firmware">
<h3>request_firmware<a class="headerlink" href="#request-firmware" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_firmware">
int <code class="descname">request_firmware</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware" title="Permalink to this definition">¶</a></dt>
<dd><p>send firmware request and wait for it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>firmware_p</strong> will be used to return a firmware image by the name
of <strong>name</strong> for device <strong>device</strong>.</p>
<p>Should be called from user context where sleeping is allowed.</p>
<p><strong>name</strong> will be used as $FIRMWARE in the uevent environment and
should be distinctive enough not to be confused with any other
firmware image for this or any other device.</p>
<p>Caller must hold the reference count of <strong>device</strong>.</p>
<p>The function can be called safely inside device’s suspend and
resume callback.</p>
</div></blockquote>
</div>
<div class="section" id="firmware-request-nowarn">
<h3>firmware_request_nowarn<a class="headerlink" href="#firmware-request-nowarn" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.firmware_request_nowarn">
int <code class="descname">firmware_request_nowarn</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_nowarn" title="Permalink to this definition">¶</a></dt>
<dd><p>request for an optional fw module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar in behaviour to <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a>, except
it doesn’t produce warning messages when the file is not found.
The sysfs fallback mechanism is enabled if direct filesystem lookup fails,
however, however failures to find the firmware file with it are still
suppressed. It is therefore up to the driver to check for the return value
of this call and to decide when to inform the users of errors.</p>
</div>
<div class="section" id="firmware-request-platform">
<h3>firmware_request_platform<a class="headerlink" href="#firmware-request-platform" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.firmware_request_platform">
int <code class="descname">firmware_request_platform</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_platform" title="Permalink to this definition">¶</a></dt>
<dd><p>request firmware with platform-fw fallback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar in behaviour to request_firmware, except that if
direct filesystem lookup fails, it will fallback to looking for a copy of the
requested firmware embedded in the platform’s main (e.g. UEFI) firmware.</p>
</div>
<div class="section" id="request-firmware-direct">
<h3>request_firmware_direct<a class="headerlink" href="#request-firmware-direct" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_firmware_direct">
int <code class="descname">request_firmware_direct</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>load firmware directly without usermode helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a>, but this doesn’t
fall back to usermode helper even if the firmware couldn’t be loaded
directly from fs.  Hence it’s useful for loading optional firmwares, which
aren’t always present, without extra long timeouts of udev.</p>
</div>
<div class="section" id="request-firmware-into-buf">
<h3>request_firmware_into_buf<a class="headerlink" href="#request-firmware-into-buf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_firmware_into_buf">
int <code class="descname">request_firmware_into_buf</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em>, void *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_into_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>load firmware into a previously allocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded and DMA region allocated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>address of buffer to load firmware into</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a>, but it doesn’t
allocate a buffer to hold the firmware data. Instead, the firmware
is loaded directly into the buffer pointed to by <strong>buf</strong> and the <strong>firmware_p</strong>
data member is pointed at <strong>buf</strong>.</p>
<p>This function doesn’t cache firmware either.</p>
</div>
</div>
<div class="section" id="asynchronous-firmware-requests">
<h2>Asynchronous firmware requests<a class="headerlink" href="#asynchronous-firmware-requests" title="Permalink to this headline">¶</a></h2>
<p>Asynchronous firmware requests allow driver code to not have to wait
until the firmware or an error is returned. Function callbacks are
provided so that when the firmware or an error is found the driver is
informed through the callback. <a class="reference internal" href="#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> cannot be called
in atomic contexts.</p>
<div class="section" id="request-firmware-nowait">
<h3>request_firmware_nowait<a class="headerlink" href="#request-firmware-nowait" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_firmware_nowait">
int <code class="descname">request_firmware_nowait</code><span class="sig-paren">(</span>struct module *<em>&nbsp;module</em>, bool<em>&nbsp;uevent</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em>, gfp_t<em>&nbsp;gfp</em>, void *<em>&nbsp;context</em>, void (<em>*cont</em>)(const struct firmware *fw, void *context)<span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous version of request_firmware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>module requesting the firmware</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">uevent</span></code></dt>
<dd>sends uevent to copy the firmware image if this flag
is non-zero else the firmware copy must be done manually.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">context</span></code></dt>
<dd>will be passed over to <strong>cont</strong>, and
<strong>fw</strong> may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if firmware request fails.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">*fw,</span> <span class="pre">void</span> <span class="pre">*context)</span> <span class="pre">cont</span></code></dt>
<dd>function will be called asynchronously when the firmware
request is over.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Caller must hold the reference count of <strong>device</strong>.</p>
<dl class="docutils">
<dt>Asynchronous variant of request_firmware() for user contexts:</dt>
<dd><ul class="first last simple">
<li>sleep for as small periods as possible since it may
increase kernel boot time of built-in device drivers
requesting firmware in their -&gt;probe() methods, if
<strong>gfp</strong> is GFP_KERNEL.</li>
<li>can’t sleep at all if <strong>gfp</strong> is GFP_ATOMIC.</li>
</ul>
</dd>
</dl>
</div></blockquote>
</div>
</div>
<div class="section" id="special-optimizations-on-reboot">
<h2>Special optimizations on reboot<a class="headerlink" href="#special-optimizations-on-reboot" title="Permalink to this headline">¶</a></h2>
<p>Some devices have an optimization in place to enable the firmware to be
retained during system reboot. When such optimizations are used the driver
author must ensure the firmware is still available on resume from suspend,
this can be done with <a class="reference internal" href="#c.firmware_request_cache" title="firmware_request_cache"><code class="xref c c-func docutils literal notranslate"><span class="pre">firmware_request_cache()</span></code></a> instead of requesting for the
firmware to be loaded.</p>
<div class="section" id="firmware-request-cache">
<h3>firmware_request_cache()<a class="headerlink" href="#firmware-request-cache" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.firmware_request_cache">
int <code class="descname">firmware_request_cache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>cache firmware for suspend so resume can use it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware should be cached for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
</dl>
<p><strong>Description</strong></p>
<p>There are some devices with an optimization that enables the device to not
require loading firmware on system reboot. This optimization may still
require the firmware present on resume from suspend. This routine can be
used to ensure the firmware is present on resume from suspend in these
situations. This helper is not compatible with drivers which use
<a class="reference internal" href="#c.request_firmware_into_buf" title="request_firmware_into_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_into_buf()</span></code></a> or <a class="reference internal" href="#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> with no uevent set.</p>
</div>
</div>
<div class="section" id="request-firmware-api-expected-driver-use">
<h2>request firmware API expected driver use<a class="headerlink" href="#request-firmware-api-expected-driver-use" title="Permalink to this headline">¶</a></h2>
<p>Once an API call returns you process the firmware and then release the
firmware. For example if you used <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a> and it returns,
the driver has the firmware image accessible in fw_entry-&gt;{data,size}.
If something went wrong <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a> returns non-zero and fw_entry
is set to NULL. Once your driver is done with processing the firmware it
can call call release_firmware(fw_entry) to release the firmware image
and any related resource.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>