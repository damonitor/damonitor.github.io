

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>InfiniBand and Remote DMA (RDMA) Interfaces &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.7.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>InfiniBand and Remote DMA (RDMA) Interfaces</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/infiniband.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="infiniband-and-remote-dma-rdma-interfaces">
<h1>InfiniBand and Remote DMA (RDMA) Interfaces<a class="headerlink" href="#infiniband-and-remote-dma-rdma-interfaces" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction-and-overview">
<h2>Introduction and Overview<a class="headerlink" href="#introduction-and-overview" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
</div>
<div class="section" id="infiniband-core-interfaces">
<h2>InfiniBand core interfaces<a class="headerlink" href="#infiniband-core-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.iwpm_get_nlmsg_request">
struct iwpm_nlmsg_request * <code class="descname">iwpm_get_nlmsg_request</code><span class="sig-paren">(</span>__u32<em>&nbsp;nlmsg_seq</em>, u8<em>&nbsp;nl_client</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_get_nlmsg_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initialize netlink message request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">__u32</span> <span class="pre">nlmsg_seq</span></code></dt>
<dd>Sequence number of the netlink message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">nl_client</span></code></dt>
<dd>The index of the netlink client</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Indicates how the memory for the request should be allocated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the newly allocated netlink request object if successful,
otherwise returns NULL</p>
<dl class="function">
<dt id="c.iwpm_free_nlmsg_request">
void <code class="descname">iwpm_free_nlmsg_request</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_free_nlmsg_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocate netlink message request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt>
<dd>Holds reference of netlink message request</dd>
</dl>
<dl class="function">
<dt id="c.iwpm_find_nlmsg_request">
struct iwpm_nlmsg_request * <code class="descname">iwpm_find_nlmsg_request</code><span class="sig-paren">(</span>__u32<em>&nbsp;echo_seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_find_nlmsg_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Find netlink message request in the request list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">__u32</span> <span class="pre">echo_seq</span></code></dt>
<dd>Sequence number of the netlink request to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the found netlink message request,
if not found, returns NULL</p>
<dl class="function">
<dt id="c.iwpm_wait_complete_req">
int <code class="descname">iwpm_wait_complete_req</code><span class="sig-paren">(</span>struct iwpm_nlmsg_request *<em>&nbsp;nlmsg_request</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_wait_complete_req" title="Permalink to this definition">¶</a></dt>
<dd><p>Block while servicing the netlink request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iwpm_nlmsg_request</span> <span class="pre">*</span> <span class="pre">nlmsg_request</span></code></dt>
<dd>Netlink message request to service</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wakes up, after the request is completed or expired
Returns 0 if the request is complete without error</p>
<dl class="function">
<dt id="c.iwpm_get_nlmsg_seq">
int <code class="descname">iwpm_get_nlmsg_seq</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_get_nlmsg_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the sequence number for a netlink message to send to the port mapper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the sequence number for the netlink message.</p>
<dl class="function">
<dt id="c.iwpm_add_remote_info">
void <code class="descname">iwpm_add_remote_info</code><span class="sig-paren">(</span>struct iwpm_remote_info *<em>&nbsp;reminfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_add_remote_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Add remote address info of the connecting peer to the remote info hash table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iwpm_remote_info</span> <span class="pre">*</span> <span class="pre">reminfo</span></code></dt>
<dd>The remote info to be added</dd>
</dl>
<dl class="function">
<dt id="c.iwpm_valid_client">
int <code class="descname">iwpm_valid_client</code><span class="sig-paren">(</span>u8<em>&nbsp;nl_client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_valid_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the port mapper client is valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">nl_client</span></code></dt>
<dd>The index of the netlink client</dd>
</dl>
<p><strong>Description</strong></p>
<p>Valid clients need to call iwpm_init() before using
the port mapper</p>
<dl class="function">
<dt id="c.iwpm_set_valid">
void <code class="descname">iwpm_set_valid</code><span class="sig-paren">(</span>u8<em>&nbsp;nl_client</em>, int<em>&nbsp;valid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_set_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the port mapper client to valid or not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">nl_client</span></code></dt>
<dd>The index of the netlink client</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">valid</span></code></dt>
<dd>1 if valid or 0 if invalid</dd>
</dl>
<dl class="function">
<dt id="c.iwpm_check_registration">
u32 <code class="descname">iwpm_check_registration</code><span class="sig-paren">(</span>u8<em>&nbsp;nl_client</em>, u32<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_check_registration" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the client registration matches the given one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">nl_client</span></code></dt>
<dd>The index of the netlink client</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">reg</span></code></dt>
<dd>The given registration type to compare with</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call iwpm_register_pid() to register a client
Returns true if the client registration matches reg,
otherwise returns false</p>
<dl class="function">
<dt id="c.iwpm_set_registration">
void <code class="descname">iwpm_set_registration</code><span class="sig-paren">(</span>u8<em>&nbsp;nl_client</em>, u32<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_set_registration" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the client registration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">nl_client</span></code></dt>
<dd>The index of the netlink client</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">reg</span></code></dt>
<dd>Registration type to set</dd>
</dl>
<dl class="function">
<dt id="c.iwpm_get_registration">
u32 <code class="descname">iwpm_get_registration</code><span class="sig-paren">(</span>u8<em>&nbsp;nl_client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_get_registration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">nl_client</span></code></dt>
<dd>The index of the netlink client</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the client registration type</p>
<dl class="function">
<dt id="c.iwpm_send_mapinfo">
int <code class="descname">iwpm_send_mapinfo</code><span class="sig-paren">(</span>u8<em>&nbsp;nl_client</em>, int<em>&nbsp;iwpm_pid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_send_mapinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Send local and mapped IPv4/IPv6 address info of a client to the user space port mapper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">nl_client</span></code></dt>
<dd>The index of the netlink client</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">iwpm_pid</span></code></dt>
<dd>The pid of the user space port mapper</dd>
</dl>
<p><strong>Description</strong></p>
<p>If successful, returns the number of sent mapping info records</p>
<dl class="function">
<dt id="c.iwpm_mapinfo_available">
int <code class="descname">iwpm_mapinfo_available</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_mapinfo_available" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any mapping info records is available in the hash table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 1 if mapping information is available, otherwise returns 0</p>
<dl class="function">
<dt id="c.iwpm_compare_sockaddr">
int <code class="descname">iwpm_compare_sockaddr</code><span class="sig-paren">(</span>struct sockaddr_storage *<em>&nbsp;a_sockaddr</em>, struct sockaddr_storage *<em>&nbsp;b_sockaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_compare_sockaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two sockaddr storage structs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_storage</span> <span class="pre">*</span> <span class="pre">a_sockaddr</span></code></dt>
<dd>first sockaddr to compare</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_storage</span> <span class="pre">*</span> <span class="pre">b_sockaddr</span></code></dt>
<dd>second sockaddr to compare</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if they are holding the same ip/tcp address info,
otherwise returns 1</p>
<dl class="function">
<dt id="c.iwpm_validate_nlmsg_attr">
int <code class="descname">iwpm_validate_nlmsg_attr</code><span class="sig-paren">(</span>struct nlattr *<em>&nbsp;nltb</em>, int<em>&nbsp;nla_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_validate_nlmsg_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for NULL netlink attributes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*</span> <span class="pre">nltb</span></code></dt>
<dd>Holds address of each netlink message attributes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nla_count</span></code></dt>
<dd>Number of netlink message attributes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns error if any of the nla_count attributes is NULL</p>
<dl class="function">
<dt id="c.iwpm_create_nlmsg">
struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">iwpm_create_nlmsg</code><span class="sig-paren">(</span>u32<em>&nbsp;nl_op</em>, struct nlmsghdr **<em>&nbsp;nlh</em>, int<em>&nbsp;nl_client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_create_nlmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate skb and form a netlink message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">nl_op</span></code></dt>
<dd>Netlink message opcode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlmsghdr</span> <span class="pre">**</span> <span class="pre">nlh</span></code></dt>
<dd>Holds address of the netlink message header in skb</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nl_client</span></code></dt>
<dd>The index of the netlink client</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the newly allcated skb, or NULL if the tailroom of the skb
is insufficient to store the message header and payload</p>
<dl class="function">
<dt id="c.iwpm_parse_nlmsg">
int <code class="descname">iwpm_parse_nlmsg</code><span class="sig-paren">(</span>struct netlink_callback *<em>&nbsp;cb</em>, int<em>&nbsp;policy_max</em>, const struct nla_policy *<em>&nbsp;nlmsg_policy</em>, struct nlattr *<em>&nbsp;nltb</em>, const char *<em>&nbsp;msg_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_parse_nlmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate and parse the received netlink message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_callback</span> <span class="pre">*</span> <span class="pre">cb</span></code></dt>
<dd>Netlink callback structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">policy_max</span></code></dt>
<dd>Maximum attribute type to be expected</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nla_policy</span> <span class="pre">*</span> <span class="pre">nlmsg_policy</span></code></dt>
<dd>Validation policy</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*</span> <span class="pre">nltb</span></code></dt>
<dd>Array to store policy_max parsed elements</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg_type</span></code></dt>
<dd>Type of netlink message</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code</p>
<dl class="function">
<dt id="c.iwpm_print_sockaddr">
void <code class="descname">iwpm_print_sockaddr</code><span class="sig-paren">(</span>struct sockaddr_storage *<em>&nbsp;sockaddr</em>, char *<em>&nbsp;msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_print_sockaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Print IPv4/IPv6 address and TCP port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_storage</span> <span class="pre">*</span> <span class="pre">sockaddr</span></code></dt>
<dd>Socket address to print</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>Message to print</dd>
</dl>
<dl class="function">
<dt id="c.iwpm_send_hello">
int <code class="descname">iwpm_send_hello</code><span class="sig-paren">(</span>u8<em>&nbsp;nl_client</em>, int<em>&nbsp;iwpm_pid</em>, u16<em>&nbsp;abi_version</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iwpm_send_hello" title="Permalink to this definition">¶</a></dt>
<dd><p>Send hello response to iwpmd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">nl_client</span></code></dt>
<dd>The index of the netlink client</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">iwpm_pid</span></code></dt>
<dd>The pid of the user space port mapper</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">abi_version</span></code></dt>
<dd>The kernel’s abi_version</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code</p>
<dl class="function">
<dt id="c.ib_process_cq_direct">
int <code class="descname">ib_process_cq_direct</code><span class="sig-paren">(</span>struct ib_cq *<em>&nbsp;cq</em>, int<em>&nbsp;budget</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_process_cq_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>process a CQ in caller context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_cq</span> <span class="pre">*</span> <span class="pre">cq</span></code></dt>
<dd>CQ to process</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">budget</span></code></dt>
<dd>number of CQEs to poll for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to process all outstanding CQ entries.
It does not offload CQ processing to a different context and does
not ask for completion interrupts from the HCA.
Using direct processing on CQ with non IB_POLL_DIRECT type may trigger
concurrent processing.</p>
<p><strong>Note</strong></p>
<p>do not pass -1 as <code class="docutils literal notranslate"><span class="pre">budget</span></code> unless it is guaranteed that the number
of completions that will be processed is small.</p>
<dl class="function">
<dt id="c.__ib_alloc_cq_user">
struct ib_cq * <code class="descname">__ib_alloc_cq_user</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;dev</em>, void *<em>&nbsp;private</em>, int<em>&nbsp;nr_cqe</em>, int<em>&nbsp;comp_vector</em>, enum ib_poll_context<em>&nbsp;poll_ctx</em>, const char *<em>&nbsp;caller</em>, struct ib_udata *<em>&nbsp;udata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__ib_alloc_cq_user" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a completion queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to allocate the CQ for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private</span></code></dt>
<dd>driver private data, accessible from cq-&gt;cq_context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_cqe</span></code></dt>
<dd>number of CQEs to allocate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">comp_vector</span></code></dt>
<dd>HCA completion vectors for this CQ</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ib_poll_context</span> <span class="pre">poll_ctx</span></code></dt>
<dd>context to poll the CQ from.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">caller</span></code></dt>
<dd>module owner name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_udata</span> <span class="pre">*</span> <span class="pre">udata</span></code></dt>
<dd>Valid user data or NULL for kernel object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the proper interface to allocate a CQ for in-kernel users. A
CQ allocated with this interface will automatically be polled from the
specified context. The ULP must use wr-&gt;wr_cqe instead of wr-&gt;wr_id
to use this CQ abstraction.</p>
<dl class="function">
<dt id="c.__ib_alloc_cq_any">
struct ib_cq * <code class="descname">__ib_alloc_cq_any</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;dev</em>, void *<em>&nbsp;private</em>, int<em>&nbsp;nr_cqe</em>, enum ib_poll_context<em>&nbsp;poll_ctx</em>, const char *<em>&nbsp;caller</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__ib_alloc_cq_any" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a completion queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to allocate the CQ for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private</span></code></dt>
<dd>driver private data, accessible from cq-&gt;cq_context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_cqe</span></code></dt>
<dd>number of CQEs to allocate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ib_poll_context</span> <span class="pre">poll_ctx</span></code></dt>
<dd>context to poll the CQ from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">caller</span></code></dt>
<dd>module owner name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to spread ULP Completion Queues over each device’s interrupt
vectors. A simple best-effort mechanism is used.</p>
<dl class="function">
<dt id="c.ib_free_cq_user">
void <code class="descname">ib_free_cq_user</code><span class="sig-paren">(</span>struct ib_cq *<em>&nbsp;cq</em>, struct ib_udata *<em>&nbsp;udata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_free_cq_user" title="Permalink to this definition">¶</a></dt>
<dd><p>free a completion queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_cq</span> <span class="pre">*</span> <span class="pre">cq</span></code></dt>
<dd>completion queue to free.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_udata</span> <span class="pre">*</span> <span class="pre">udata</span></code></dt>
<dd>User data or NULL for kernel object</dd>
</dl>
<dl class="function">
<dt id="c.ib_cm_listen">
int <code class="descname">ib_cm_listen</code><span class="sig-paren">(</span>struct ib_cm_id *<em>&nbsp;cm_id</em>, __be64<em>&nbsp;service_id</em>, __be64<em>&nbsp;service_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_cm_listen" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiates listening on the specified service ID for connection and service ID resolution requests.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_cm_id</span> <span class="pre">*</span> <span class="pre">cm_id</span></code></dt>
<dd>Connection identifier associated with the listen request.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be64</span> <span class="pre">service_id</span></code></dt>
<dd>Service identifier matched against incoming connection
and service ID resolution requests.  The service ID should be specified
network-byte order.  If set to IB_CM_ASSIGN_SERVICE_ID, the CM will
assign a service ID to the caller.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be64</span> <span class="pre">service_mask</span></code></dt>
<dd>Mask applied to service ID used to listen across a
range of service IDs.  If set to 0, the service ID is matched
exactly.  This parameter is ignored if <code class="docutils literal notranslate"><span class="pre">service_id</span></code> is set to
IB_CM_ASSIGN_SERVICE_ID.</dd>
</dl>
<dl class="function">
<dt id="c.ib_cm_insert_listen">
struct ib_cm_id * <code class="descname">ib_cm_insert_listen</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, ib_cm_handler<em>&nbsp;cm_handler</em>, __be64<em>&nbsp;service_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_cm_insert_listen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>Device associated with the cm_id.  All related communication will
be associated with the specified device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_cm_handler</span> <span class="pre">cm_handler</span></code></dt>
<dd>Callback invoked to notify the user of CM events.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be64</span> <span class="pre">service_id</span></code></dt>
<dd>Service identifier matched against incoming connection
and service ID resolution requests.  The service ID should be specified
network-byte order.  If set to IB_CM_ASSIGN_SERVICE_ID, the CM will
assign a service ID to the caller.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If there’s an existing ID listening on that same device and service ID,
return it.</p>
<p>Callers should call ib_destroy_cm_id when done with the listener ID.</p>
<dl class="function">
<dt id="c.rdma_rw_ctx_init">
int <code class="descname">rdma_rw_ctx_init</code><span class="sig-paren">(</span>struct rdma_rw_ctx *<em>&nbsp;ctx</em>, struct ib_qp *<em>&nbsp;qp</em>, u8<em>&nbsp;port_num</em>, struct scatterlist *<em>&nbsp;sg</em>, u32<em>&nbsp;sg_cnt</em>, u32<em>&nbsp;sg_offset</em>, u64<em>&nbsp;remote_addr</em>, u32<em>&nbsp;rkey</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_rw_ctx_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a RDMA READ/WRITE context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_rw_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>context to initialize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>port num to which the connection is bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>scatterlist to READ/WRITE from/to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">sg_cnt</span></code></dt>
<dd>number of entries in <strong>sg</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">sg_offset</span></code></dt>
<dd>current byte offset into <strong>sg</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">remote_addr</span></code></dt>
<dd>remote address to read/write (relative to <strong>rkey</strong>)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">rkey</span></code></dt>
<dd>remote key to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">DMA_TO_DEVICE</span></code> for RDMA WRITE, <code class="docutils literal notranslate"><span class="pre">DMA_FROM_DEVICE</span></code> for RDMA READ</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of WQEs that will be needed on the workqueue if
successful, or a negative error code.</p>
<dl class="function">
<dt id="c.rdma_rw_ctx_signature_init">
int <code class="descname">rdma_rw_ctx_signature_init</code><span class="sig-paren">(</span>struct rdma_rw_ctx *<em>&nbsp;ctx</em>, struct ib_qp *<em>&nbsp;qp</em>, u8<em>&nbsp;port_num</em>, struct scatterlist *<em>&nbsp;sg</em>, u32<em>&nbsp;sg_cnt</em>, struct scatterlist *<em>&nbsp;prot_sg</em>, u32<em>&nbsp;prot_sg_cnt</em>, struct ib_sig_attrs *<em>&nbsp;sig_attrs</em>, u64<em>&nbsp;remote_addr</em>, u32<em>&nbsp;rkey</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_rw_ctx_signature_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a RW context with signature offload</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_rw_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>context to initialize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>port num to which the connection is bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>scatterlist to READ/WRITE from/to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">sg_cnt</span></code></dt>
<dd>number of entries in <strong>sg</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">prot_sg</span></code></dt>
<dd>scatterlist to READ/WRITE protection information from/to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">prot_sg_cnt</span></code></dt>
<dd>number of entries in <strong>prot_sg</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_sig_attrs</span> <span class="pre">*</span> <span class="pre">sig_attrs</span></code></dt>
<dd>signature offloading algorithms</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">remote_addr</span></code></dt>
<dd>remote address to read/write (relative to <strong>rkey</strong>)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">rkey</span></code></dt>
<dd>remote key to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">DMA_TO_DEVICE</span></code> for RDMA WRITE, <code class="docutils literal notranslate"><span class="pre">DMA_FROM_DEVICE</span></code> for RDMA READ</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of WQEs that will be needed on the workqueue if
successful, or a negative error code.</p>
<dl class="function">
<dt id="c.rdma_rw_ctx_wrs">
struct ib_send_wr * <code class="descname">rdma_rw_ctx_wrs</code><span class="sig-paren">(</span>struct rdma_rw_ctx *<em>&nbsp;ctx</em>, struct ib_qp *<em>&nbsp;qp</em>, u8<em>&nbsp;port_num</em>, struct ib_cqe *<em>&nbsp;cqe</em>, struct ib_send_wr *<em>&nbsp;chain_wr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_rw_ctx_wrs" title="Permalink to this definition">¶</a></dt>
<dd><p>return chain of WRs for a RDMA READ or WRITE operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_rw_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>context to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>port num to which the connection is bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_cqe</span> <span class="pre">*</span> <span class="pre">cqe</span></code></dt>
<dd>completion queue entry for the last WR</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_send_wr</span> <span class="pre">*</span> <span class="pre">chain_wr</span></code></dt>
<dd>WR to append to the posted chain</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the WR chain for the set of RDMA READ/WRITE operations described by
<strong>ctx</strong>, as well as any memory registration operations needed.  If <strong>chain_wr</strong>
is non-NULL the WR it points to will be appended to the chain of WRs posted.
If <strong>chain_wr</strong> is not set <strong>cqe</strong> must be set so that the caller gets a
completion notification.</p>
<dl class="function">
<dt id="c.rdma_rw_ctx_post">
int <code class="descname">rdma_rw_ctx_post</code><span class="sig-paren">(</span>struct rdma_rw_ctx *<em>&nbsp;ctx</em>, struct ib_qp *<em>&nbsp;qp</em>, u8<em>&nbsp;port_num</em>, struct ib_cqe *<em>&nbsp;cqe</em>, struct ib_send_wr *<em>&nbsp;chain_wr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_rw_ctx_post" title="Permalink to this definition">¶</a></dt>
<dd><p>post a RDMA READ or RDMA WRITE operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_rw_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>context to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>port num to which the connection is bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_cqe</span> <span class="pre">*</span> <span class="pre">cqe</span></code></dt>
<dd>completion queue entry for the last WR</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_send_wr</span> <span class="pre">*</span> <span class="pre">chain_wr</span></code></dt>
<dd>WR to append to the posted chain</dd>
</dl>
<p><strong>Description</strong></p>
<p>Post the set of RDMA READ/WRITE operations described by <strong>ctx</strong>, as well as
any memory registration operations needed.  If <strong>chain_wr</strong> is non-NULL the
WR it points to will be appended to the chain of WRs posted.  If <strong>chain_wr</strong>
is not set <strong>cqe</strong> must be set so that the caller gets a completion
notification.</p>
<dl class="function">
<dt id="c.rdma_rw_ctx_destroy">
void <code class="descname">rdma_rw_ctx_destroy</code><span class="sig-paren">(</span>struct rdma_rw_ctx *<em>&nbsp;ctx</em>, struct ib_qp *<em>&nbsp;qp</em>, u8<em>&nbsp;port_num</em>, struct scatterlist *<em>&nbsp;sg</em>, u32<em>&nbsp;sg_cnt</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_rw_ctx_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>release all resources allocated by rdma_rw_ctx_init</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_rw_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>context to release</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>port num to which the connection is bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>scatterlist that was used for the READ/WRITE</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">sg_cnt</span></code></dt>
<dd>number of entries in <strong>sg</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">DMA_TO_DEVICE</span></code> for RDMA WRITE, <code class="docutils literal notranslate"><span class="pre">DMA_FROM_DEVICE</span></code> for RDMA READ</dd>
</dl>
<dl class="function">
<dt id="c.rdma_rw_ctx_destroy_signature">
void <code class="descname">rdma_rw_ctx_destroy_signature</code><span class="sig-paren">(</span>struct rdma_rw_ctx *<em>&nbsp;ctx</em>, struct ib_qp *<em>&nbsp;qp</em>, u8<em>&nbsp;port_num</em>, struct scatterlist *<em>&nbsp;sg</em>, u32<em>&nbsp;sg_cnt</em>, struct scatterlist *<em>&nbsp;prot_sg</em>, u32<em>&nbsp;prot_sg_cnt</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_rw_ctx_destroy_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>release all resources allocated by rdma_rw_ctx_signature_init</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_rw_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>context to release</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to operate on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>port num to which the connection is bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>scatterlist that was used for the READ/WRITE</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">sg_cnt</span></code></dt>
<dd>number of entries in <strong>sg</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">prot_sg</span></code></dt>
<dd>scatterlist that was used for the READ/WRITE of the PI</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">prot_sg_cnt</span></code></dt>
<dd>number of entries in <strong>prot_sg</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">DMA_TO_DEVICE</span></code> for RDMA WRITE, <code class="docutils literal notranslate"><span class="pre">DMA_FROM_DEVICE</span></code> for RDMA READ</dd>
</dl>
<dl class="function">
<dt id="c.rdma_rw_mr_factor">
unsigned int <code class="descname">rdma_rw_mr_factor</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, u8<em>&nbsp;port_num</em>, unsigned int<em>&nbsp;maxpages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_rw_mr_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>return number of MRs required for a payload</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device handling the connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>port num to which the connection is bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">maxpages</span></code></dt>
<dd>maximum payload pages per rdma_rw_ctx</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of MRs the device requires to move <strong>maxpayload</strong>
bytes. The returned value is used during transport creation to
compute max_rdma_ctxts and the size of the transport’s Send and
Send Completion Queues.</p>
<dl class="function">
<dt id="c.rdma_dev_access_netns">
bool <code class="descname">rdma_dev_access_netns</code><span class="sig-paren">(</span>const struct ib_device *<em>&nbsp;dev</em>, const struct net *<em>&nbsp;net</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_dev_access_netns" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether an rdma device can be accessed from a specified net namespace or not.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Pointer to rdma device which needs to be checked</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>Pointer to net namesapce for which access to be checked</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the rdma device is in shared mode, it ignores the net namespace.
When the rdma device is exclusive to a net namespace, rdma device net
namespace is checked against the specified one.</p>
<dl class="function">
<dt id="c.ib_device_put">
void <code class="descname">ib_device_put</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_device_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Release IB device reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device whose reference to be released</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_device_put" title="ib_device_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_device_put()</span></code></a> releases reference to the IB device to allow it to be
unregistered and eventually free.</p>
<dl class="function">
<dt id="c.ib_device_get_by_name">
struct ib_device * <code class="descname">ib_device_get_by_name</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, enum rdma_driver_id<em>&nbsp;driver_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_device_get_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an IB device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>The name to look for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rdma_driver_id</span> <span class="pre">driver_id</span></code></dt>
<dd>The driver ID that must match (RDMA_DRIVER_UNKNOWN matches all)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find and hold an ib_device by its name. The caller must call
<a class="reference internal" href="#c.ib_device_put" title="ib_device_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_device_put()</span></code></a> on the returned pointer.</p>
<dl class="function">
<dt id="c._ib_alloc_device">
struct ib_device * <code class="descname">_ib_alloc_device</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c._ib_alloc_device" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an IB device struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of structure to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Low-level drivers should use ib_alloc_device() to allocate <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">ib_device</span></code>.  <strong>size</strong> is the size of the structure to be allocated,
including any private data used by the low-level driver.
<a class="reference internal" href="#c.ib_dealloc_device" title="ib_dealloc_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_dealloc_device()</span></code></a> must be used to free structures allocated with
ib_alloc_device().</p>
<dl class="function">
<dt id="c.ib_dealloc_device">
void <code class="descname">ib_dealloc_device</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_dealloc_device" title="Permalink to this definition">¶</a></dt>
<dd><p>free an IB device struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>structure to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free a structure allocated with ib_alloc_device().</p>
<dl class="function">
<dt id="c.ib_register_device">
int <code class="descname">ib_register_device</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Register an IB device with IB core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>Device to register</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>unique string device name. This may include a ‘%’ which will
cause a unique index to be added to the passed device name.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Low-level drivers use <a class="reference internal" href="#c.ib_register_device" title="ib_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_register_device()</span></code></a> to register their
devices with the IB core.  All registered clients will receive a
callback for each device that is added. <strong>device</strong> must be allocated
with ib_alloc_device().</p>
<p>If the driver uses ops.dealloc_driver and calls any <a class="reference internal" href="#c.ib_unregister_device" title="ib_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_unregister_device()</span></code></a>
asynchronously then the device pointer may become freed as soon as this
function returns.</p>
<dl class="function">
<dt id="c.ib_unregister_device">
void <code class="descname">ib_unregister_device</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;ib_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister an IB device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">ib_dev</span></code></dt>
<dd>The device to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister an IB device.  All clients will receive a remove callback.</p>
<p>Callers should call this routine only once, and protect against races with
registration. Typically it should only be called as part of a remove
callback in an implementation of driver core’s struct device_driver and
related.</p>
<p>If ops.dealloc_driver is used then ib_dev will be freed upon return from
this function.</p>
<dl class="function">
<dt id="c.ib_unregister_device_and_put">
void <code class="descname">ib_unregister_device_and_put</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;ib_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_unregister_device_and_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a device while holding a ‘get’</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">ib_dev</span></code></dt>
<dd>The device to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.ib_unregister_device" title="ib_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_unregister_device()</span></code></a>, except it includes an internal
<a class="reference internal" href="#c.ib_device_put" title="ib_device_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_device_put()</span></code></a> that should match a ‘get’ obtained by the caller.</p>
<p>It is safe to call this routine concurrently from multiple threads while
holding the ‘get’. When the function returns the device is fully
unregistered.</p>
<p>Drivers using this flow MUST use the driver_unregister callback to clean up
their resources associated with the device and dealloc it.</p>
<dl class="function">
<dt id="c.ib_unregister_driver">
void <code class="descname">ib_unregister_driver</code><span class="sig-paren">(</span>enum rdma_driver_id<em>&nbsp;driver_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister all IB devices for a driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rdma_driver_id</span> <span class="pre">driver_id</span></code></dt>
<dd>The driver to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implements a fence for device unregistration. It only returns once all
devices associated with the driver_id have fully completed their
unregistration and returned from ib_unregister_device*().</p>
<p>If device’s are not yet unregistered it goes ahead and starts unregistering
them.</p>
<p>This does not block creation of new devices with the given driver_id, that
is the responsibility of the caller.</p>
<dl class="function">
<dt id="c.ib_unregister_device_queued">
void <code class="descname">ib_unregister_device_queued</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;ib_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_unregister_device_queued" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a device using a work queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">ib_dev</span></code></dt>
<dd>The device to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This schedules an asynchronous unregistration using a WQ for the device. A
driver should use this to avoid holding locks while doing unregistration,
such as holding the RTNL lock.</p>
<p>Drivers using this API must use ib_unregister_driver before module unload
to ensure that all scheduled unregistrations have completed.</p>
<dl class="function">
<dt id="c.ib_register_client">
int <code class="descname">ib_register_client</code><span class="sig-paren">(</span>struct ib_client *<em>&nbsp;client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_register_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Register an IB client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Client to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Upper level users of the IB drivers can use <a class="reference internal" href="#c.ib_register_client" title="ib_register_client"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_register_client()</span></code></a> to
register callbacks for IB device addition and removal.  When an IB
device is added, each registered client’s add method will be called
(in the order the clients were registered), and when a device is
removed, each client’s remove method will be called (in the reverse
order that clients were registered).  In addition, when
<a class="reference internal" href="#c.ib_register_client" title="ib_register_client"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_register_client()</span></code></a> is called, the client will receive an add
callback for all devices already registered.</p>
<dl class="function">
<dt id="c.ib_unregister_client">
void <code class="descname">ib_unregister_client</code><span class="sig-paren">(</span>struct ib_client *<em>&nbsp;client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_unregister_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister an IB client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Client to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Upper level users use <a class="reference internal" href="#c.ib_unregister_client" title="ib_unregister_client"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_unregister_client()</span></code></a> to remove their client
registration.  When <a class="reference internal" href="#c.ib_unregister_client" title="ib_unregister_client"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_unregister_client()</span></code></a> is called, the client
will receive a remove callback for each IB device still registered.</p>
<p>This is a full fence, once it returns no client callbacks will be called,
or are running in another thread.</p>
<dl class="function">
<dt id="c.ib_set_client_data">
void <code class="descname">ib_set_client_data</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, struct ib_client *<em>&nbsp;client</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_set_client_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set IB client context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>Device to set context for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Client to set context for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Context to set</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_set_client_data" title="ib_set_client_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_set_client_data()</span></code></a> sets client context data that can be retrieved with
ib_get_client_data(). This can only be called while the client is
registered to the device, once the ib_client remove() callback returns this
cannot be called.</p>
<dl class="function">
<dt id="c.ib_register_event_handler">
void <code class="descname">ib_register_event_handler</code><span class="sig-paren">(</span>struct ib_event_handler *<em>&nbsp;event_handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_register_event_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Register an IB event handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_event_handler</span> <span class="pre">*</span> <span class="pre">event_handler</span></code></dt>
<dd>Handler to register</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_register_event_handler" title="ib_register_event_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_register_event_handler()</span></code></a> registers an event handler that will be
called back when asynchronous IB events occur (as defined in
chapter 11 of the InfiniBand Architecture Specification). This
callback occurs in workqueue context.</p>
<dl class="function">
<dt id="c.ib_unregister_event_handler">
void <code class="descname">ib_unregister_event_handler</code><span class="sig-paren">(</span>struct ib_event_handler *<em>&nbsp;event_handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_unregister_event_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister an event handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_event_handler</span> <span class="pre">*</span> <span class="pre">event_handler</span></code></dt>
<dd>Handler to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister an event handler registered with
<a class="reference internal" href="#c.ib_register_event_handler" title="ib_register_event_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_register_event_handler()</span></code></a>.</p>
<dl class="function">
<dt id="c.ib_query_port">
int <code class="descname">ib_query_port</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, u8<em>&nbsp;port_num</em>, struct ib_port_attr *<em>&nbsp;port_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_query_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Query IB port attributes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>Device to query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>Port number to query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_port_attr</span> <span class="pre">*</span> <span class="pre">port_attr</span></code></dt>
<dd>Port attributes</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_query_port" title="ib_query_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_query_port()</span></code></a> returns the attributes of a port through the
<strong>port_attr</strong> pointer.</p>
<dl class="function">
<dt id="c.ib_device_set_netdev">
int <code class="descname">ib_device_set_netdev</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;ib_dev</em>, struct <a class="reference internal" href="../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em>&nbsp;ndev</em>, unsigned int<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_device_set_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate the ib_dev with an underlying net_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">ib_dev</span></code></dt>
<dd>Device to modify</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">ndev</span></code></dt>
<dd>net_device to affiliate, may be NULL</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">port</span></code></dt>
<dd>IB port the net_device is connected to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should use this to link the ib_device to a netdev so the netdev
shows up in interfaces like ib_enum_roce_netdev. Only one netdev may be
affiliated with any port.</p>
<p>The caller must ensure that the given ndev is not unregistered or
unregistering, and that either the ib_device is unregistered or
<a class="reference internal" href="#c.ib_device_set_netdev" title="ib_device_set_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_device_set_netdev()</span></code></a> is called with NULL when the ndev sends a
NETDEV_UNREGISTER event.</p>
<dl class="function">
<dt id="c.ib_device_get_by_netdev">
struct ib_device * <code class="descname">ib_device_get_by_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.net_device" title="net_device">net_device</a> *<em>&nbsp;ndev</em>, enum rdma_driver_id<em>&nbsp;driver_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_device_get_by_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an IB device associated with a netdev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">ndev</span></code></dt>
<dd>netdev to locate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rdma_driver_id</span> <span class="pre">driver_id</span></code></dt>
<dd>The driver ID that must match (RDMA_DRIVER_UNKNOWN matches all)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find and hold an ib_device that is associated with a netdev via
<a class="reference internal" href="#c.ib_device_set_netdev" title="ib_device_set_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_device_set_netdev()</span></code></a>. The caller must call <a class="reference internal" href="#c.ib_device_put" title="ib_device_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_device_put()</span></code></a> on the
returned pointer.</p>
<dl class="function">
<dt id="c.ib_query_pkey">
int <code class="descname">ib_query_pkey</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, u8<em>&nbsp;port_num</em>, u16<em>&nbsp;index</em>, u16 *<em>&nbsp;pkey</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_query_pkey" title="Permalink to this definition">¶</a></dt>
<dd><p>Get P_Key table entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>Device to query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>Port number to query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">index</span></code></dt>
<dd>P_Key table index to query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">pkey</span></code></dt>
<dd>Returned P_Key</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_query_pkey" title="ib_query_pkey"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_query_pkey()</span></code></a> fetches the specified P_Key table entry.</p>
<dl class="function">
<dt id="c.ib_modify_device">
int <code class="descname">ib_modify_device</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, int<em>&nbsp;device_modify_mask</em>, struct ib_device_modify *<em>&nbsp;device_modify</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_modify_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Change IB device attributes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>Device to modify</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device_modify_mask</span></code></dt>
<dd>Mask of attributes to change</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device_modify</span> <span class="pre">*</span> <span class="pre">device_modify</span></code></dt>
<dd>New attribute values</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_modify_device" title="ib_modify_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_modify_device()</span></code></a> changes a device’s attributes as specified by
the <strong>device_modify_mask</strong> and <strong>device_modify</strong> structure.</p>
<dl class="function">
<dt id="c.ib_modify_port">
int <code class="descname">ib_modify_port</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, u8<em>&nbsp;port_num</em>, int<em>&nbsp;port_modify_mask</em>, struct ib_port_modify *<em>&nbsp;port_modify</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_modify_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies the attributes for the specified port.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>The device to modify.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>The number of the port to modify.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">port_modify_mask</span></code></dt>
<dd>Mask used to specify which attributes of the port
to change.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_port_modify</span> <span class="pre">*</span> <span class="pre">port_modify</span></code></dt>
<dd>New attribute values for the port.</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_modify_port" title="ib_modify_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_modify_port()</span></code></a> changes a port’s attributes as specified by the
<strong>port_modify_mask</strong> and <strong>port_modify</strong> structure.</p>
<dl class="function">
<dt id="c.ib_find_gid">
int <code class="descname">ib_find_gid</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, union ib_gid *<em>&nbsp;gid</em>, u8 *<em>&nbsp;port_num</em>, u16 *<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_find_gid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the port number and GID table index where a specified GID value occurs. Its searches only for IB link layer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>The device to query.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">ib_gid</span> <span class="pre">*</span> <span class="pre">gid</span></code></dt>
<dd>The GID value to search for.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">port_num</span></code></dt>
<dd>The port number of the device where the GID value was found.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">index</span></code></dt>
<dd>The index into the GID table where the GID was found.  This
parameter may be NULL.</dd>
</dl>
<dl class="function">
<dt id="c.ib_find_pkey">
int <code class="descname">ib_find_pkey</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, u8<em>&nbsp;port_num</em>, u16<em>&nbsp;pkey</em>, u16 *<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_find_pkey" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the PKey table index where a specified PKey value occurs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>The device to query.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>The port number of the device to search for the PKey.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">pkey</span></code></dt>
<dd>The PKey value to search for.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">index</span></code></dt>
<dd>The index into the PKey table where the PKey was found.</dd>
</dl>
<dl class="function">
<dt id="c.ib_get_net_dev_by_params">
struct <a class="reference internal" href="../networking/kapi.html#c.net_device" title="net_device">net_device</a> * <code class="descname">ib_get_net_dev_by_params</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;dev</em>, u8<em>&nbsp;port</em>, u16<em>&nbsp;pkey</em>, const union ib_gid *<em>&nbsp;gid</em>, const struct sockaddr *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_get_net_dev_by_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the appropriate net_dev for a received CM request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>An RDMA device on which the request has been received.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port</span></code></dt>
<dd>Port number on the RDMA device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">pkey</span></code></dt>
<dd>The Pkey the request came on.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">union</span> <span class="pre">ib_gid</span> <span class="pre">*</span> <span class="pre">gid</span></code></dt>
<dd>A GID that the net_dev uses to communicate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Contains the IP address that the request specified as its
destination.</dd>
</dl>
<dl class="function">
<dt id="c.__ib_alloc_pd">
struct ib_pd * <code class="descname">__ib_alloc_pd</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, unsigned int<em>&nbsp;flags</em>, const char *<em>&nbsp;caller</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__ib_alloc_pd" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates an unused protection domain.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>The device on which to allocate the protection domain.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>protection domain flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">caller</span></code></dt>
<dd>caller’s build-time module name</dd>
</dl>
<p><strong>Description</strong></p>
<p>A protection domain object provides an association between QPs, shared
receive queues, address handles, memory regions, and memory windows.</p>
<p>Every PD has a local_dma_lkey which can be used as the lkey value for local
memory operations.</p>
<dl class="function">
<dt id="c.ib_dealloc_pd_user">
void <code class="descname">ib_dealloc_pd_user</code><span class="sig-paren">(</span>struct ib_pd *<em>&nbsp;pd</em>, struct ib_udata *<em>&nbsp;udata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_dealloc_pd_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocates a protection domain.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_pd</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>The protection domain to deallocate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_udata</span> <span class="pre">*</span> <span class="pre">udata</span></code></dt>
<dd>Valid user data or NULL for kernel object</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is an error to call this function while any resources in the pd still
exist.  The caller is responsible to synchronously destroy them and
guarantee no new allocations will happen.</p>
<dl class="function">
<dt id="c.rdma_copy_ah_attr">
void <code class="descname">rdma_copy_ah_attr</code><span class="sig-paren">(</span>struct rdma_ah_attr *<em>&nbsp;dest</em>, const struct rdma_ah_attr *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_copy_ah_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy rdma ah attribute from source to destination.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Pointer to destination ah_attr. Contents of the destination
pointer is assumed to be invalid and attribute are overwritten.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Pointer to source ah_attr.</dd>
</dl>
<dl class="function">
<dt id="c.rdma_replace_ah_attr">
void <code class="descname">rdma_replace_ah_attr</code><span class="sig-paren">(</span>struct rdma_ah_attr *<em>&nbsp;old</em>, const struct rdma_ah_attr *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_replace_ah_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace valid ah_attr with new new one.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>Pointer to existing ah_attr which needs to be replaced.
old is assumed to be valid or zero’d</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>Pointer to the new ah_attr.</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.rdma_replace_ah_attr" title="rdma_replace_ah_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">rdma_replace_ah_attr()</span></code></a> first releases any reference in the old ah_attr if
old the ah_attr is valid; after that it copies the new attribute and holds
the reference to the replaced ah_attr.</p>
<dl class="function">
<dt id="c.rdma_move_ah_attr">
void <code class="descname">rdma_move_ah_attr</code><span class="sig-paren">(</span>struct rdma_ah_attr *<em>&nbsp;dest</em>, struct rdma_ah_attr *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_move_ah_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Move ah_attr pointed by source to destination.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Pointer to destination ah_attr to copy to.
dest is assumed to be valid or zero’d</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Pointer to the new ah_attr.</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.rdma_move_ah_attr" title="rdma_move_ah_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">rdma_move_ah_attr()</span></code></a> first releases any reference in the destination ah_attr
if it is valid. This also transfers ownership of internal references from
src to dest, making src invalid in the process. No new reference of the src
ah_attr is taken.</p>
<dl class="function">
<dt id="c.rdma_create_ah">
struct ib_ah * <code class="descname">rdma_create_ah</code><span class="sig-paren">(</span>struct ib_pd *<em>&nbsp;pd</em>, struct rdma_ah_attr *<em>&nbsp;ah_attr</em>, u32<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_create_ah" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an address handle for the given address vector.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_pd</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>The protection domain associated with the address handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">ah_attr</span></code></dt>
<dd>The attributes of the address vector.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>Create address handle flags (see enum rdma_create_ah_flags).</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns 0 on success and returns appropriate error code on error.
The address handle is used to reference a local or global destination
in all UD QP post sends.</p>
<dl class="function">
<dt id="c.rdma_create_user_ah">
struct ib_ah * <code class="descname">rdma_create_user_ah</code><span class="sig-paren">(</span>struct ib_pd *<em>&nbsp;pd</em>, struct rdma_ah_attr *<em>&nbsp;ah_attr</em>, struct ib_udata *<em>&nbsp;udata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_create_user_ah" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an address handle for the given address vector. It resolves destination mac address for ah attribute of RoCE type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_pd</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>The protection domain associated with the address handle.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">ah_attr</span></code></dt>
<dd>The attributes of the address vector.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_udata</span> <span class="pre">*</span> <span class="pre">udata</span></code></dt>
<dd>pointer to user’s input output buffer information need by
provider driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns 0 on success and returns appropriate error code on error.
The address handle is used to reference a local or global destination
in all UD QP post sends.</p>
<dl class="function">
<dt id="c.rdma_move_grh_sgid_attr">
void <code class="descname">rdma_move_grh_sgid_attr</code><span class="sig-paren">(</span>struct rdma_ah_attr *<em>&nbsp;attr</em>, union ib_gid *<em>&nbsp;dgid</em>, u32<em>&nbsp;flow_label</em>, u8<em>&nbsp;hop_limit</em>, u8<em>&nbsp;traffic_class</em>, const struct ib_gid_attr *<em>&nbsp;sgid_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_move_grh_sgid_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the sgid attribute of GRH, taking ownership of the reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>Pointer to AH attribute structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">ib_gid</span> <span class="pre">*</span> <span class="pre">dgid</span></code></dt>
<dd>Destination GID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flow_label</span></code></dt>
<dd>Flow label</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">hop_limit</span></code></dt>
<dd>Hop limit</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">traffic_class</span></code></dt>
<dd>traffic class</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ib_gid_attr</span> <span class="pre">*</span> <span class="pre">sgid_attr</span></code></dt>
<dd>Pointer to SGID attribute</dd>
</dl>
<p><strong>Description</strong></p>
<p>This takes ownership of the sgid_attr reference. The caller must ensure
<a class="reference internal" href="#c.rdma_destroy_ah_attr" title="rdma_destroy_ah_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">rdma_destroy_ah_attr()</span></code></a> is called before destroying the rdma_ah_attr after
calling this function.</p>
<dl class="function">
<dt id="c.rdma_destroy_ah_attr">
void <code class="descname">rdma_destroy_ah_attr</code><span class="sig-paren">(</span>struct rdma_ah_attr *<em>&nbsp;ah_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdma_destroy_ah_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Release reference to SGID attribute of ah attribute.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">ah_attr</span></code></dt>
<dd>Pointer to ah attribute</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release reference to the SGID attribute of the ah attribute if it is
non NULL. It is safe to call this multiple times, and safe to call it on
a zero initialized ah_attr.</p>
<dl class="function">
<dt id="c.ib_create_qp">
struct ib_qp * <code class="descname">ib_create_qp</code><span class="sig-paren">(</span>struct ib_pd *<em>&nbsp;pd</em>, struct ib_qp_init_attr *<em>&nbsp;qp_init_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_create_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a kernel QP associated with the specified protection domain.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_pd</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>The protection domain associated with the QP.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp_init_attr</span> <span class="pre">*</span> <span class="pre">qp_init_attr</span></code></dt>
<dd>A list of initial attributes required to create the
QP.  If QP creation succeeds, then the attributes are updated to
the actual capabilities of the created QP.</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>for user qp use ib_create_qp_user with valid udata!</p>
<dl class="function">
<dt id="c.ib_modify_qp_with_udata">
int <code class="descname">ib_modify_qp_with_udata</code><span class="sig-paren">(</span>struct ib_qp *<em>&nbsp;ib_qp</em>, struct ib_qp_attr *<em>&nbsp;attr</em>, int<em>&nbsp;attr_mask</em>, struct ib_udata *<em>&nbsp;udata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_modify_qp_with_udata" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies the attributes for the specified QP.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">ib_qp</span></code></dt>
<dd>The QP to modify.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp_attr</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>On input, specifies the QP attributes to modify.  On output,
the current values of selected QP attributes are returned.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">attr_mask</span></code></dt>
<dd>A bit-mask used to specify which attributes of the QP
are being modified.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_udata</span> <span class="pre">*</span> <span class="pre">udata</span></code></dt>
<dd>pointer to user’s input output buffer information
are being modified.
It returns 0 on success and returns appropriate error code on error.</dd>
</dl>
<dl class="function">
<dt id="c.ib_alloc_mr_user">
struct ib_mr * <code class="descname">ib_alloc_mr_user</code><span class="sig-paren">(</span>struct ib_pd *<em>&nbsp;pd</em>, enum ib_mr_type<em>&nbsp;mr_type</em>, u32<em>&nbsp;max_num_sg</em>, struct ib_udata *<em>&nbsp;udata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_alloc_mr_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates a memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_pd</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>protection domain associated with the region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ib_mr_type</span> <span class="pre">mr_type</span></code></dt>
<dd>memory region type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">max_num_sg</span></code></dt>
<dd>maximum sg entries available for registration.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_udata</span> <span class="pre">*</span> <span class="pre">udata</span></code></dt>
<dd>user data or null for kernel objects</dd>
</dl>
<p><strong>Notes</strong></p>
<p>Memory registeration page/sg lists must not exceed max_num_sg.
For mr_type IB_MR_TYPE_MEM_REG, the total length cannot exceed
max_num_sg * used_page_size.</p>
<dl class="function">
<dt id="c.ib_alloc_mr_integrity">
struct ib_mr * <code class="descname">ib_alloc_mr_integrity</code><span class="sig-paren">(</span>struct ib_pd *<em>&nbsp;pd</em>, u32<em>&nbsp;max_num_data_sg</em>, u32<em>&nbsp;max_num_meta_sg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_alloc_mr_integrity" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates an integrity memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_pd</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>protection domain associated with the region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">max_num_data_sg</span></code></dt>
<dd>maximum data sg entries available for registration</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">max_num_meta_sg</span></code></dt>
<dd>maximum metadata sg entries available for
registration</dd>
</dl>
<p><strong>Notes</strong></p>
<p>Memory registration page/sg lists must not exceed max_num_sg,
also the integrity page/sg lists must not exceed max_num_meta_sg.</p>
<dl class="function">
<dt id="c.ib_create_wq">
struct ib_wq * <code class="descname">ib_create_wq</code><span class="sig-paren">(</span>struct ib_pd *<em>&nbsp;pd</em>, struct ib_wq_init_attr *<em>&nbsp;wq_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_create_wq" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a WQ associated with the specified protection domain.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_pd</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>The protection domain associated with the WQ.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_wq_init_attr</span> <span class="pre">*</span> <span class="pre">wq_attr</span></code></dt>
<dd>A list of initial attributes required to create the
WQ. If WQ creation succeeds, then the attributes are updated to
the actual capabilities of the created WQ.</dd>
</dl>
<p><strong>Description</strong></p>
<p>wq_attr-&gt;max_wr and wq_attr-&gt;max_sge determine
the requested size of the WQ, and set to the actual values allocated
on return.
If <a class="reference internal" href="#c.ib_create_wq" title="ib_create_wq"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_create_wq()</span></code></a> succeeds, then max_wr and max_sge will always be
at least as large as the requested values.</p>
<dl class="function">
<dt id="c.ib_destroy_wq">
int <code class="descname">ib_destroy_wq</code><span class="sig-paren">(</span>struct ib_wq *<em>&nbsp;wq</em>, struct ib_udata *<em>&nbsp;udata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_destroy_wq" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroys the specified user WQ.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_wq</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>The WQ to destroy.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_udata</span> <span class="pre">*</span> <span class="pre">udata</span></code></dt>
<dd>Valid user data</dd>
</dl>
<dl class="function">
<dt id="c.ib_modify_wq">
int <code class="descname">ib_modify_wq</code><span class="sig-paren">(</span>struct ib_wq *<em>&nbsp;wq</em>, struct ib_wq_attr *<em>&nbsp;wq_attr</em>, u32<em>&nbsp;wq_attr_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_modify_wq" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies the specified WQ.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_wq</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>The WQ to modify.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_wq_attr</span> <span class="pre">*</span> <span class="pre">wq_attr</span></code></dt>
<dd>On input, specifies the WQ attributes to modify.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">wq_attr_mask</span></code></dt>
<dd>A bit-mask used to specify which attributes of the WQ
are being modified.
On output, the current values of selected WQ attributes are returned.</dd>
</dl>
<dl class="function">
<dt id="c.ib_map_mr_sg_pi">
int <code class="descname">ib_map_mr_sg_pi</code><span class="sig-paren">(</span>struct ib_mr *<em>&nbsp;mr</em>, struct scatterlist *<em>&nbsp;data_sg</em>, int<em>&nbsp;data_sg_nents</em>, unsigned int *<em>&nbsp;data_sg_offset</em>, struct scatterlist *<em>&nbsp;meta_sg</em>, int<em>&nbsp;meta_sg_nents</em>, unsigned int *<em>&nbsp;meta_sg_offset</em>, unsigned int<em>&nbsp;page_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_map_mr_sg_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the dma mapped SG lists for PI (protection information) and set an appropriate memory region for registration.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mr</span> <span class="pre">*</span> <span class="pre">mr</span></code></dt>
<dd>memory region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">data_sg</span></code></dt>
<dd>dma mapped scatterlist for data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">data_sg_nents</span></code></dt>
<dd>number of entries in data_sg</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">data_sg_offset</span></code></dt>
<dd>offset in bytes into data_sg</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">meta_sg</span></code></dt>
<dd>dma mapped scatterlist for metadata</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">meta_sg_nents</span></code></dt>
<dd>number of entries in meta_sg</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">meta_sg_offset</span></code></dt>
<dd>offset in bytes into meta_sg</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">page_size</span></code></dt>
<dd>page vector desired page size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Constraints:
- The MR must be allocated with type IB_MR_TYPE_INTEGRITY.</p>
<p><strong>Return</strong></p>
<p>0 on success.</p>
<p>After this completes successfully, the  memory region
is ready for registration.</p>
<dl class="function">
<dt id="c.ib_map_mr_sg">
int <code class="descname">ib_map_mr_sg</code><span class="sig-paren">(</span>struct ib_mr *<em>&nbsp;mr</em>, struct scatterlist *<em>&nbsp;sg</em>, int<em>&nbsp;sg_nents</em>, unsigned int *<em>&nbsp;sg_offset</em>, unsigned int<em>&nbsp;page_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_map_mr_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the largest prefix of a dma mapped SG list and set it the memory region.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mr</span> <span class="pre">*</span> <span class="pre">mr</span></code></dt>
<dd>memory region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>dma mapped scatterlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sg_nents</span></code></dt>
<dd>number of entries in sg</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">sg_offset</span></code></dt>
<dd>offset in bytes into sg</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">page_size</span></code></dt>
<dd>page vector desired page size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Constraints:
- The first sg element is allowed to have an offset.
- Each sg element must either be aligned to page_size or virtually</p>
<blockquote>
<div>contiguous to the previous element. In case an sg element has a
non-contiguous offset, the mapping prefix will not include it.</div></blockquote>
<ul class="simple">
<li>The last sg element is allowed to have length less than page_size.</li>
<li>If sg_nents total byte length exceeds the mr max_num_sge * page_size
then only max_num_sg entries will be mapped.</li>
<li>If the MR was allocated with type IB_MR_TYPE_SG_GAPS, none of these
constraints holds and the page_size argument is ignored.</li>
</ul>
<p>Returns the number of sg elements that were mapped to the memory region.</p>
<p>After this completes successfully, the  memory region
is ready for registration.</p>
<dl class="function">
<dt id="c.ib_sg_to_pages">
int <code class="descname">ib_sg_to_pages</code><span class="sig-paren">(</span>struct ib_mr *<em>&nbsp;mr</em>, struct scatterlist *<em>&nbsp;sgl</em>, int<em>&nbsp;sg_nents</em>, unsigned int *<em>&nbsp;sg_offset_p</em>, int (<em>*set_page</em>)(struct ib_mr *, u64)<span class="sig-paren">)</span><a class="headerlink" href="#c.ib_sg_to_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the largest prefix of a sg list to a page vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mr</span> <span class="pre">*</span> <span class="pre">mr</span></code></dt>
<dd>memory region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sgl</span></code></dt>
<dd>dma mapped scatterlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sg_nents</span></code></dt>
<dd>number of entries in sg</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">sg_offset_p</span></code></dt>
<dd><p class="first">IN:  start offset in bytes into sg
OUT: offset in bytes for element n of the sg of the first</p>
<blockquote class="last">
<div>byte that has not been processed where n is the return
value of this function.</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">ib_mr</span> <span class="pre">*,</span> <span class="pre">u64)</span> <span class="pre">set_page</span></code></dt>
<dd>driver page assignment function pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Core service helper for drivers to convert the largest
prefix of given sg list to a page vector. The sg list
prefix converted is the prefix that meet the requirements
of ib_map_mr_sg.</p>
<p>Returns the number of sg elements that were assigned to
a page vector.</p>
<dl class="function">
<dt id="c.ib_drain_sq">
void <code class="descname">ib_drain_sq</code><span class="sig-paren">(</span>struct ib_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_drain_sq" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until all SQ CQEs have been consumed by the application.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to drain</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the device has a provider-specific drain function, then
call that.  Otherwise call the generic drain function
__ib_drain_sq().</p>
<p>The caller must:</p>
<p>ensure there is room in the CQ and SQ for the drain work request and
completion.</p>
<p>allocate the CQ using ib_alloc_cq().</p>
<p>ensure that there are no other contexts that are posting WRs concurrently.
Otherwise the drain is not guaranteed.</p>
<dl class="function">
<dt id="c.ib_drain_rq">
void <code class="descname">ib_drain_rq</code><span class="sig-paren">(</span>struct ib_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_drain_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until all RQ CQEs have been consumed by the application.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to drain</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the device has a provider-specific drain function, then
call that.  Otherwise call the generic drain function
__ib_drain_rq().</p>
<p>The caller must:</p>
<p>ensure there is room in the CQ and RQ for the drain work request and
completion.</p>
<p>allocate the CQ using ib_alloc_cq().</p>
<p>ensure that there are no other contexts that are posting WRs concurrently.
Otherwise the drain is not guaranteed.</p>
<dl class="function">
<dt id="c.ib_drain_qp">
void <code class="descname">ib_drain_qp</code><span class="sig-paren">(</span>struct ib_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_drain_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until all CQEs have been consumed by the application on both the RQ and SQ.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to drain</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must:</p>
<p>ensure there is room in the CQ(s), SQ, and RQ for drain work requests
and completions.</p>
<p>allocate the CQs using ib_alloc_cq().</p>
<p>ensure that there are no other contexts that are posting WRs concurrently.
Otherwise the drain is not guaranteed.</p>
<dl class="function">
<dt id="c.ib_pack">
void <code class="descname">ib_pack</code><span class="sig-paren">(</span>const struct ib_field *<em>&nbsp;desc</em>, int<em>&nbsp;desc_len</em>, void *<em>&nbsp;structure</em>, void *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack a structure into a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ib_field</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Array of structure field descriptions</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc_len</span></code></dt>
<dd>Number of entries in <strong>desc</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">structure</span></code></dt>
<dd>Structure to pack from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Buffer to pack into</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_pack" title="ib_pack"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_pack()</span></code></a> packs a list of structure fields into a buffer,
controlled by the array of fields in <strong>desc</strong>.</p>
<dl class="function">
<dt id="c.ib_unpack">
void <code class="descname">ib_unpack</code><span class="sig-paren">(</span>const struct ib_field *<em>&nbsp;desc</em>, int<em>&nbsp;desc_len</em>, void *<em>&nbsp;buf</em>, void *<em>&nbsp;structure</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_unpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack a buffer into a structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ib_field</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Array of structure field descriptions</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc_len</span></code></dt>
<dd>Number of entries in <strong>desc</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Buffer to unpack from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">structure</span></code></dt>
<dd>Structure to unpack into</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_pack" title="ib_pack"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_pack()</span></code></a> unpacks a list of structure fields from a buffer,
controlled by the array of fields in <strong>desc</strong>.</p>
<dl class="function">
<dt id="c.ib_sa_cancel_query">
void <code class="descname">ib_sa_cancel_query</code><span class="sig-paren">(</span>int<em>&nbsp;id</em>, struct ib_sa_query *<em>&nbsp;query</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_sa_cancel_query" title="Permalink to this definition">¶</a></dt>
<dd><p>try to cancel an SA query</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ID of query to cancel</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_sa_query</span> <span class="pre">*</span> <span class="pre">query</span></code></dt>
<dd>query pointer to cancel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to cancel an SA query.  If the id and query don’t match up or
the query has already completed, nothing is done.  Otherwise the
query is canceled and will complete with a status of -EINTR.</p>
<dl class="function">
<dt id="c.ib_init_ah_attr_from_path">
int <code class="descname">ib_init_ah_attr_from_path</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, u8<em>&nbsp;port_num</em>, struct sa_path_rec *<em>&nbsp;rec</em>, struct rdma_ah_attr *<em>&nbsp;ah_attr</em>, const struct ib_gid_attr *<em>&nbsp;gid_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_init_ah_attr_from_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize address handle attributes based on an SA path record.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>Device associated ah attributes initialization.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>Port on the specified device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sa_path_rec</span> <span class="pre">*</span> <span class="pre">rec</span></code></dt>
<dd>path record entry to use for ah attributes initialization.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">ah_attr</span></code></dt>
<dd>address handle attributes to initialization from path record.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ib_gid_attr</span> <span class="pre">*</span> <span class="pre">gid_attr</span></code></dt>
<dd>SGID attribute to consider during initialization.</dd>
</dl>
<p><strong>Description</strong></p>
<p>When <a class="reference internal" href="#c.ib_init_ah_attr_from_path" title="ib_init_ah_attr_from_path"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_init_ah_attr_from_path()</span></code></a> returns success,
(a) for IB link layer it optionally contains a reference to SGID attribute
when GRH is present for IB link layer.
(b) for RoCE link layer it contains a reference to SGID attribute.
User must invoke <a class="reference internal" href="#c.rdma_destroy_ah_attr" title="rdma_destroy_ah_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">rdma_destroy_ah_attr()</span></code></a> to release reference to SGID
attributes which are initialized using <a class="reference internal" href="#c.ib_init_ah_attr_from_path" title="ib_init_ah_attr_from_path"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_init_ah_attr_from_path()</span></code></a>.</p>
<dl class="function">
<dt id="c.ib_sa_path_rec_get">
int <code class="descname">ib_sa_path_rec_get</code><span class="sig-paren">(</span>struct ib_sa_client *<em>&nbsp;client</em>, struct ib_device *<em>&nbsp;device</em>, u8<em>&nbsp;port_num</em>, struct sa_path_rec *<em>&nbsp;rec</em>, ib_sa_comp_mask<em>&nbsp;comp_mask</em>, unsigned long<em>&nbsp;timeout_ms</em>, gfp_t<em>&nbsp;gfp_mask</em>, void (<em>*callback</em>)(int status, struct sa_path_rec *resp, void *context), void *<em>&nbsp;context</em>, struct ib_sa_query **<em>&nbsp;sa_query</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_sa_path_rec_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a Path get query</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_sa_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>SA client</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device to send query on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>port number to send query on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sa_path_rec</span> <span class="pre">*</span> <span class="pre">rec</span></code></dt>
<dd>Path Record to send in query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_sa_comp_mask</span> <span class="pre">comp_mask</span></code></dt>
<dd>component mask to send in query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout_ms</span></code></dt>
<dd>time to wait for response</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP mask to use for internal allocations</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(int</span> <span class="pre">status,</span> <span class="pre">struct</span> <span class="pre">sa_path_rec</span> <span class="pre">*resp,</span> <span class="pre">void</span> <span class="pre">*context)</span> <span class="pre">callback</span></code></dt>
<dd>function called when query completes, times out or is
canceled</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">context</span></code></dt>
<dd>opaque user context passed to callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_sa_query</span> <span class="pre">**</span> <span class="pre">sa_query</span></code></dt>
<dd>query context, used to cancel query</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a Path Record Get query to the SA to look up a path.  The
callback function will be called when the query completes (or
fails); status is 0 for a successful response, -EINTR if the query
is canceled, -ETIMEDOUT is the query timed out, or -EIO if an error
occurred sending the query.  The resp parameter of the callback is
only valid if status is 0.</p>
<p>If the return value of <a class="reference internal" href="#c.ib_sa_path_rec_get" title="ib_sa_path_rec_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_sa_path_rec_get()</span></code></a> is negative, it is an
error code.  Otherwise it is a query ID that can be used to cancel
the query.</p>
<dl class="function">
<dt id="c.ib_sa_service_rec_query">
int <code class="descname">ib_sa_service_rec_query</code><span class="sig-paren">(</span>struct ib_sa_client *<em>&nbsp;client</em>, struct ib_device *<em>&nbsp;device</em>, u8<em>&nbsp;port_num</em>, u8<em>&nbsp;method</em>, struct ib_sa_service_rec *<em>&nbsp;rec</em>, ib_sa_comp_mask<em>&nbsp;comp_mask</em>, unsigned long<em>&nbsp;timeout_ms</em>, gfp_t<em>&nbsp;gfp_mask</em>, void (<em>*callback</em>)(int status, struct ib_sa_service_rec *resp, void *context), void *<em>&nbsp;context</em>, struct ib_sa_query **<em>&nbsp;sa_query</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_sa_service_rec_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Start Service Record operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_sa_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>SA client</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device to send request on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>port number to send request on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">method</span></code></dt>
<dd>SA method - should be get, set, or delete</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_sa_service_rec</span> <span class="pre">*</span> <span class="pre">rec</span></code></dt>
<dd>Service Record to send in request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_sa_comp_mask</span> <span class="pre">comp_mask</span></code></dt>
<dd>component mask to send in request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout_ms</span></code></dt>
<dd>time to wait for response</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP mask to use for internal allocations</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(int</span> <span class="pre">status,</span> <span class="pre">struct</span> <span class="pre">ib_sa_service_rec</span> <span class="pre">*resp,</span> <span class="pre">void</span> <span class="pre">*context)</span> <span class="pre">callback</span></code></dt>
<dd>function called when request completes, times out or is
canceled</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">context</span></code></dt>
<dd>opaque user context passed to callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_sa_query</span> <span class="pre">**</span> <span class="pre">sa_query</span></code></dt>
<dd>request context, used to cancel request</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a Service Record set/get/delete to the SA to register,
unregister or query a service record.
The callback function will be called when the request completes (or
fails); status is 0 for a successful response, -EINTR if the query
is canceled, -ETIMEDOUT is the query timed out, or -EIO if an error
occurred sending the query.  The resp parameter of the callback is
only valid if status is 0.</p>
<p>If the return value of <a class="reference internal" href="#c.ib_sa_service_rec_query" title="ib_sa_service_rec_query"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_sa_service_rec_query()</span></code></a> is negative, it is an
error code.  Otherwise it is a request ID that can be used to cancel
the query.</p>
<dl class="function">
<dt id="c.ib_ud_header_init">
int <code class="descname">ib_ud_header_init</code><span class="sig-paren">(</span>int<em>&nbsp;payload_bytes</em>, int<em>&nbsp;lrh_present</em>, int<em>&nbsp;eth_present</em>, int<em>&nbsp;vlan_present</em>, int<em>&nbsp;grh_present</em>, int<em>&nbsp;ip_version</em>, int<em>&nbsp;udp_present</em>, int<em>&nbsp;immediate_present</em>, struct ib_ud_header *<em>&nbsp;header</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_ud_header_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize UD header structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">payload_bytes</span></code></dt>
<dd>Length of packet payload</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">lrh_present</span></code></dt>
<dd>specify if LRH is present</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">eth_present</span></code></dt>
<dd>specify if Eth header is present</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vlan_present</span></code></dt>
<dd>packet is tagged vlan</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">grh_present</span></code></dt>
<dd>GRH flag (if non-zero, GRH will be included)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ip_version</span></code></dt>
<dd>if non-zero, IP header, V4 or V6, will be included</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">udp_present</span></code></dt>
<dd>if non-zero, UDP header will be included</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">immediate_present</span></code></dt>
<dd>specify if immediate data is present</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_ud_header</span> <span class="pre">*</span> <span class="pre">header</span></code></dt>
<dd>Structure to initialize</dd>
</dl>
<dl class="function">
<dt id="c.ib_ud_header_pack">
int <code class="descname">ib_ud_header_pack</code><span class="sig-paren">(</span>struct ib_ud_header *<em>&nbsp;header</em>, void *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_ud_header_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack UD header struct into wire format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_ud_header</span> <span class="pre">*</span> <span class="pre">header</span></code></dt>
<dd>UD header struct</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Buffer to pack into</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_ud_header_pack" title="ib_ud_header_pack"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_ud_header_pack()</span></code></a> packs the UD header structure <strong>header</strong> into wire
format in the buffer <strong>buf</strong>.</p>
<dl class="function">
<dt id="c.ib_ud_header_unpack">
int <code class="descname">ib_ud_header_unpack</code><span class="sig-paren">(</span>void *<em>&nbsp;buf</em>, struct ib_ud_header *<em>&nbsp;header</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_ud_header_unpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack UD header struct from wire format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Buffer to pack into</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_ud_header</span> <span class="pre">*</span> <span class="pre">header</span></code></dt>
<dd>UD header struct</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ib_ud_header_pack" title="ib_ud_header_pack"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_ud_header_pack()</span></code></a> unpacks the UD header structure <strong>header</strong> from wire
format in the buffer <strong>buf</strong>.</p>
<dl class="function">
<dt id="c.ib_create_fmr_pool">
struct ib_fmr_pool * <code class="descname">ib_create_fmr_pool</code><span class="sig-paren">(</span>struct ib_pd *<em>&nbsp;pd</em>, struct ib_fmr_pool_param *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_create_fmr_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an FMR pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_pd</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>Protection domain for FMRs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_fmr_pool_param</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>FMR pool parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a pool of FMRs.  Return value is pointer to new pool or
error code if creation failed.</p>
<dl class="function">
<dt id="c.ib_destroy_fmr_pool">
void <code class="descname">ib_destroy_fmr_pool</code><span class="sig-paren">(</span>struct ib_fmr_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_destroy_fmr_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Free FMR pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_fmr_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>FMR pool to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy an FMR pool and free all associated resources.</p>
<dl class="function">
<dt id="c.ib_flush_fmr_pool">
int <code class="descname">ib_flush_fmr_pool</code><span class="sig-paren">(</span>struct ib_fmr_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_flush_fmr_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate all unmapped FMRs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_fmr_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>FMR pool to flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensure that all unmapped FMRs are fully invalidated.</p>
<dl class="function">
<dt id="c.ib_fmr_pool_map_phys">
struct ib_pool_fmr * <code class="descname">ib_fmr_pool_map_phys</code><span class="sig-paren">(</span>struct ib_fmr_pool *<em>&nbsp;pool_handle</em>, u64 *<em>&nbsp;page_list</em>, int<em>&nbsp;list_len</em>, u64<em>&nbsp;io_virtual_address</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_fmr_pool_map_phys" title="Permalink to this definition">¶</a></dt>
<dd><p>Map an FMR from an FMR pool.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_fmr_pool</span> <span class="pre">*</span> <span class="pre">pool_handle</span></code></dt>
<dd>FMR pool to allocate FMR from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">page_list</span></code></dt>
<dd>List of pages to map</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">list_len</span></code></dt>
<dd>Number of pages in <strong>page_list</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">io_virtual_address</span></code></dt>
<dd>I/O virtual address for new FMR</dd>
</dl>
<dl class="function">
<dt id="c.ib_fmr_pool_unmap">
void <code class="descname">ib_fmr_pool_unmap</code><span class="sig-paren">(</span>struct ib_pool_fmr *<em>&nbsp;fmr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_fmr_pool_unmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap FMR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_pool_fmr</span> <span class="pre">*</span> <span class="pre">fmr</span></code></dt>
<dd>FMR to unmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap an FMR.  The FMR mapping may remain valid until the FMR is
reused (or until <a class="reference internal" href="#c.ib_flush_fmr_pool" title="ib_flush_fmr_pool"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_flush_fmr_pool()</span></code></a> is called).</p>
<dl class="function">
<dt id="c.ib_umem_find_best_pgsz">
unsigned long <code class="descname">ib_umem_find_best_pgsz</code><span class="sig-paren">(</span>struct ib_umem *<em>&nbsp;umem</em>, unsigned long<em>&nbsp;pgsz_bitmap</em>, unsigned long<em>&nbsp;virt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_umem_find_best_pgsz" title="Permalink to this definition">¶</a></dt>
<dd><p>Find best HW page size to use for this MR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_umem</span> <span class="pre">*</span> <span class="pre">umem</span></code></dt>
<dd>umem struct</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgsz_bitmap</span></code></dt>
<dd>bitmap of HW supported page sizes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">virt</span></code></dt>
<dd>IOVA</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper is intended for HW that support multiple page
sizes but can do only a single page size in an MR.</p>
<p>Returns 0 if the umem requires page sizes not supported by
the driver to be mapped. Drivers always supporting PAGE_SIZE
or smaller will never see a 0 result.</p>
<dl class="function">
<dt id="c.ib_umem_get">
struct ib_umem * <code class="descname">ib_umem_get</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, unsigned long<em>&nbsp;addr</em>, size_t<em>&nbsp;size</em>, int<em>&nbsp;access</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_umem_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin and DMA map userspace memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>IB device to connect UMEM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>userspace virtual address to start at</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>length of region to pin</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">access</span></code></dt>
<dd>IB_ACCESS_xxx flags for memory being pinned</dd>
</dl>
<dl class="function">
<dt id="c.ib_umem_release">
void <code class="descname">ib_umem_release</code><span class="sig-paren">(</span>struct ib_umem *<em>&nbsp;umem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_umem_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release memory pinned with ib_umem_get</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_umem</span> <span class="pre">*</span> <span class="pre">umem</span></code></dt>
<dd>umem struct to release</dd>
</dl>
<dl class="function">
<dt id="c.ib_umem_odp_alloc_implicit">
struct ib_umem_odp * <code class="descname">ib_umem_odp_alloc_implicit</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, int<em>&nbsp;access</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_umem_odp_alloc_implicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a parent implicit ODP umem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>IB device to create UMEM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">access</span></code></dt>
<dd>ib_reg_mr access flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implicit ODP umems do not have a VA range and do not have any page lists.
They exist only to hold the per_mm reference to help the driver create
children umems.</p>
<dl class="function">
<dt id="c.ib_umem_odp_alloc_child">
struct ib_umem_odp * <code class="descname">ib_umem_odp_alloc_child</code><span class="sig-paren">(</span>struct ib_umem_odp *<em>&nbsp;root</em>, unsigned long<em>&nbsp;addr</em>, size_t<em>&nbsp;size</em>, const struct mmu_interval_notifier_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_umem_odp_alloc_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a child ODP umem under an implicit parent ODP umem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_umem_odp</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>The parent umem enclosing the child. This must be allocated using
ib_alloc_implicit_odp_umem()</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>The starting userspace VA</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The length of the userspace VA</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mmu_interval_notifier_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<dl class="function">
<dt id="c.ib_umem_odp_get">
struct ib_umem_odp * <code class="descname">ib_umem_odp_get</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, unsigned long<em>&nbsp;addr</em>, size_t<em>&nbsp;size</em>, int<em>&nbsp;access</em>, const struct mmu_interval_notifier_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_umem_odp_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a umem_odp for a userspace va</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>IB device struct to get UMEM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>userspace virtual address to start at</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>length of region to pin</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">access</span></code></dt>
<dd>IB_ACCESS_xxx flags for memory being pinned</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mmu_interval_notifier_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>The driver should use when the access flags indicate ODP memory. It avoids
pinning, instead, stores the mm for future page fault handling in
conjunction with MMU notifiers.</p>
<dl class="function">
<dt id="c.ib_umem_odp_map_dma_pages">
int <code class="descname">ib_umem_odp_map_dma_pages</code><span class="sig-paren">(</span>struct ib_umem_odp *<em>&nbsp;umem_odp</em>, u64<em>&nbsp;user_virt</em>, u64<em>&nbsp;bcnt</em>, u64<em>&nbsp;access_mask</em>, unsigned long<em>&nbsp;current_seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ib_umem_odp_map_dma_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin and DMA map userspace memory in an ODP MR.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_umem_odp</span> <span class="pre">*</span> <span class="pre">umem_odp</span></code></dt>
<dd>the umem to map and pin</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">user_virt</span></code></dt>
<dd>the address from which we need to map.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">bcnt</span></code></dt>
<dd>the minimal number of bytes to pin and map. The mapping might be
bigger due to alignment, and may also be smaller in case of an error
pinning or mapping a page. The actual pages mapped is returned in
the return value.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">access_mask</span></code></dt>
<dd>bit mask of the requested access permissions for the given
range.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">current_seq</span></code></dt>
<dd>the MMU notifiers sequance value for synchronization with
invalidations. the sequance number is read from
umem_odp-&gt;notifiers_seq before calling this function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pins the range of pages passed in the argument, and maps them to
DMA addresses. The DMA addresses of the mapped pages is updated in
umem_odp-&gt;dma_list.</p>
<p>Returns the number of pages mapped in success, negative error code
for failure.
An -EAGAIN error code is returned when a concurrent mmu notifier prevents
the function from completing its task.
An -ENOENT error code indicates that userspace process is being terminated
and mm was already destroyed.</p>
</div>
<div class="section" id="rdma-verbs-transport-library">
<h2>RDMA Verbs transport library<a class="headerlink" href="#rdma-verbs-transport-library" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.rvt_fast_reg_mr">
int <code class="descname">rvt_fast_reg_mr</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em>, struct ib_mr *<em>&nbsp;ibmr</em>, u32<em>&nbsp;key</em>, int<em>&nbsp;access</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_fast_reg_mr" title="Permalink to this definition">¶</a></dt>
<dd><p>fast register physical MR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>the queue pair where the work request comes from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mr</span> <span class="pre">*</span> <span class="pre">ibmr</span></code></dt>
<dd>the memory region to be registered</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">key</span></code></dt>
<dd>updated key for this memory region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">access</span></code></dt>
<dd>access flags for this memory region</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.rvt_invalidate_rkey">
int <code class="descname">rvt_invalidate_rkey</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em>, u32<em>&nbsp;rkey</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_invalidate_rkey" title="Permalink to this definition">¶</a></dt>
<dd><p>invalidate an MR rkey</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair associated with the invalidate op</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">rkey</span></code></dt>
<dd>rkey to invalidate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.rvt_lkey_ok">
int <code class="descname">rvt_lkey_ok</code><span class="sig-paren">(</span>struct rvt_lkey_table *<em>&nbsp;rkt</em>, struct rvt_pd *<em>&nbsp;pd</em>, struct rvt_sge *<em>&nbsp;isge</em>, struct rvt_sge *<em>&nbsp;last_sge</em>, struct ib_sge *<em>&nbsp;sge</em>, int<em>&nbsp;acc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_lkey_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>check IB SGE for validity and initialize</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_lkey_table</span> <span class="pre">*</span> <span class="pre">rkt</span></code></dt>
<dd>table containing lkey to check SGE against</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_pd</span> <span class="pre">*</span> <span class="pre">pd</span></code></dt>
<dd>protection domain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_sge</span> <span class="pre">*</span> <span class="pre">isge</span></code></dt>
<dd>outgoing internal SGE</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_sge</span> <span class="pre">*</span> <span class="pre">last_sge</span></code></dt>
<dd>last outgoing SGE written</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_sge</span> <span class="pre">*</span> <span class="pre">sge</span></code></dt>
<dd>SGE to check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">acc</span></code></dt>
<dd>access flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the IB SGE for validity and initialize our internal version
of it.</p>
<p>Increments the reference count when a new sge is stored.</p>
<p><strong>Return</strong></p>
<p>0 if compressed, 1 if added , otherwise returns -errno.</p>
<dl class="function">
<dt id="c.rvt_rkey_ok">
int <code class="descname">rvt_rkey_ok</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em>, struct rvt_sge *<em>&nbsp;sge</em>, u32<em>&nbsp;len</em>, u64<em>&nbsp;vaddr</em>, u32<em>&nbsp;rkey</em>, int<em>&nbsp;acc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_rkey_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>check the IB virtual address, length, and RKEY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>qp for validation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_sge</span> <span class="pre">*</span> <span class="pre">sge</span></code></dt>
<dd>SGE state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">len</span></code></dt>
<dd>length of data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">vaddr</span></code></dt>
<dd>virtual address to place data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">rkey</span></code></dt>
<dd>rkey to check</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">acc</span></code></dt>
<dd>access flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if successful, otherwise 0.</p>
<p>increments the reference count upon success</p>
<dl class="function">
<dt id="c.rvt_compute_aeth">
__be32 <code class="descname">rvt_compute_aeth</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_compute_aeth" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the AETH (syndrome + MSN)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>the queue pair to compute the AETH for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the AETH.</p>
<dl class="function">
<dt id="c.rvt_get_credit">
void <code class="descname">rvt_get_credit</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em>, u32<em>&nbsp;aeth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_get_credit" title="Permalink to this definition">¶</a></dt>
<dd><p>flush the send work queue of a QP</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>the qp who’s send work queue to flush</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">aeth</span></code></dt>
<dd>the Acknowledge Extended Transport Header</dd>
</dl>
<p><strong>Description</strong></p>
<p>The QP s_lock should be held.</p>
<dl class="function">
<dt id="c.rvt_restart_sge">
u32 <code class="descname">rvt_restart_sge</code><span class="sig-paren">(</span>struct rvt_sge_state *<em>&nbsp;ss</em>, struct rvt_swqe *<em>&nbsp;wqe</em>, u32<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_restart_sge" title="Permalink to this definition">¶</a></dt>
<dd><p>rewind the sge state for a wqe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_sge_state</span> <span class="pre">*</span> <span class="pre">ss</span></code></dt>
<dd>the sge state pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_swqe</span> <span class="pre">*</span> <span class="pre">wqe</span></code></dt>
<dd>the wqe to rewind</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">len</span></code></dt>
<dd>the data length from the start of the wqe in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the remaining data length.</p>
<dl class="function">
<dt id="c.rvt_check_ah">
int <code class="descname">rvt_check_ah</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;ibdev</em>, struct rdma_ah_attr *<em>&nbsp;ah_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_check_ah" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the attributes of AH</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">ibdev</span></code></dt>
<dd>the ib device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_ah_attr</span> <span class="pre">*</span> <span class="pre">ah_attr</span></code></dt>
<dd>the attributes of the AH</dd>
</dl>
<p><strong>Description</strong></p>
<p>If driver supports a more detailed check_ah function call back to it
otherwise just check the basics.</p>
<p><strong>Return</strong></p>
<p>0 on success</p>
<dl class="function">
<dt id="c.rvt_alloc_device">
struct rvt_dev_info * <code class="descname">rvt_alloc_device</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, int<em>&nbsp;nports</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_alloc_device" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate rdi</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how big of a structure to allocate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nports</span></code></dt>
<dd>number of ports to allocate array slots for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use IB core device alloc to allocate space for the rdi which is assumed to be
inside of the ib_device. Any extra space that drivers require should be
included in size.</p>
<p>We also allocate a port array based on the number of ports.</p>
<p><strong>Return</strong></p>
<p>pointer to allocated rdi</p>
<dl class="function">
<dt id="c.rvt_dealloc_device">
void <code class="descname">rvt_dealloc_device</code><span class="sig-paren">(</span>struct rvt_dev_info *<em>&nbsp;rdi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_dealloc_device" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate rdi</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_dev_info</span> <span class="pre">*</span> <span class="pre">rdi</span></code></dt>
<dd>structure to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free a structure allocated with <a class="reference internal" href="#c.rvt_alloc_device" title="rvt_alloc_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">rvt_alloc_device()</span></code></a></p>
<dl class="function">
<dt id="c.rvt_register_device">
int <code class="descname">rvt_register_device</code><span class="sig-paren">(</span>struct rvt_dev_info *<em>&nbsp;rdi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register a driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_dev_info</span> <span class="pre">*</span> <span class="pre">rdi</span></code></dt>
<dd>main dev structure for all of rdmavt operations</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is up to drivers to allocate the rdi and fill in the appropriate
information.</p>
<p><strong>Return</strong></p>
<p>0 on success otherwise an errno.</p>
<dl class="function">
<dt id="c.rvt_unregister_device">
void <code class="descname">rvt_unregister_device</code><span class="sig-paren">(</span>struct rvt_dev_info *<em>&nbsp;rdi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_dev_info</span> <span class="pre">*</span> <span class="pre">rdi</span></code></dt>
<dd>rvt dev struct</dd>
</dl>
<dl class="function">
<dt id="c.rvt_init_port">
int <code class="descname">rvt_init_port</code><span class="sig-paren">(</span>struct rvt_dev_info *<em>&nbsp;rdi</em>, struct rvt_ibport *<em>&nbsp;port</em>, int<em>&nbsp;port_index</em>, u16 *<em>&nbsp;pkey_table</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_init_port" title="Permalink to this definition">¶</a></dt>
<dd><p>init internal data for driver port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_dev_info</span> <span class="pre">*</span> <span class="pre">rdi</span></code></dt>
<dd>rvt_dev_info struct</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_ibport</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>rvt port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">port_index</span></code></dt>
<dd>0 based index of ports, different from IB core port num</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">pkey_table</span></code></dt>
<dd>pkey_table for <strong>port</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Keep track of a list of ports. No need to have a detach port.
They persist until the driver goes away.</p>
<p><strong>Return</strong></p>
<p>always 0</p>
<dl class="function">
<dt id="c.rvt_cq_enter">
bool <code class="descname">rvt_cq_enter</code><span class="sig-paren">(</span>struct rvt_cq *<em>&nbsp;cq</em>, struct ib_wc *<em>&nbsp;entry</em>, bool<em>&nbsp;solicited</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_cq_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry to the completion queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_cq</span> <span class="pre">*</span> <span class="pre">cq</span></code></dt>
<dd>completion queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_wc</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>work completion entry to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">solicited</span></code></dt>
<dd>true if <strong>entry</strong> is solicited</dd>
</dl>
<p><strong>Description</strong></p>
<p>This may be called with qp-&gt;s_lock held.</p>
<p><strong>Return</strong></p>
<p>return true on success, else return
false if cq is full.</p>
<dl class="function">
<dt id="c.rvt_error_qp">
int <code class="descname">rvt_error_qp</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em>, enum ib_wc_status<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_error_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>put a QP into the error state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>the QP to put into the error state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ib_wc_status</span> <span class="pre">err</span></code></dt>
<dd>the receive completion error to signal if a RWQE is active</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flushes both send and receive work queues.</p>
<p><strong>Return</strong></p>
<p>true if last WQE event should be generated.
The QP r_lock and s_lock should be held and interrupts disabled.
If we are already in error state, just return.</p>
<dl class="function">
<dt id="c.rvt_get_rwqe">
int <code class="descname">rvt_get_rwqe</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em>, bool<em>&nbsp;wr_id_only</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_get_rwqe" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the next RWQE into the QP’s RWQE</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>the QP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wr_id_only</span></code></dt>
<dd>update qp-&gt;r_wr_id only, not qp-&gt;r_sge</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return -1 if there is a local error, 0 if no RWQE is available,
otherwise return 1.</p>
<p>Can be called from interrupt level.</p>
<dl class="function">
<dt id="c.rvt_comm_est">
void <code class="descname">rvt_comm_est</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_comm_est" title="Permalink to this definition">¶</a></dt>
<dd><p>handle trap with QP established</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>the QP</dd>
</dl>
<dl class="function">
<dt id="c.rvt_add_rnr_timer">
void <code class="descname">rvt_add_rnr_timer</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em>, u32<em>&nbsp;aeth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_add_rnr_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>add/start an rnr timer on the QP</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>the QP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">aeth</span></code></dt>
<dd>aeth of RNR timeout, simulated aeth for loopback</dd>
</dl>
<dl class="function">
<dt id="c.rvt_stop_rc_timers">
void <code class="descname">rvt_stop_rc_timers</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_stop_rc_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>stop all timers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>the QP
stop any pending timers</dd>
</dl>
<dl class="function">
<dt id="c.rvt_del_timers_sync">
void <code class="descname">rvt_del_timers_sync</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_del_timers_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for any timeout routines to exit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>the QP</dd>
</dl>
<dl class="function">
<dt id="c.rvt_qp_iter_init">
struct <a class="reference internal" href="#c.rvt_qp_iter" title="rvt_qp_iter">rvt_qp_iter</a> * <code class="descname">rvt_qp_iter_init</code><span class="sig-paren">(</span>struct rvt_dev_info *<em>&nbsp;rdi</em>, u64<em>&nbsp;v</em>, void (<em>*cb</em>)(struct rvt_qp *qp, u64 v)<span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_qp_iter_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initial for QP iteration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_dev_info</span> <span class="pre">*</span> <span class="pre">rdi</span></code></dt>
<dd>rvt devinfo</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">v</span></code></dt>
<dd>u64 value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">rvt_qp</span> <span class="pre">*qp,</span> <span class="pre">u64</span> <span class="pre">v)</span> <span class="pre">cb</span></code></dt>
<dd>user-defined callback</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns an iterator suitable for iterating QPs
in the system.</p>
<p>The <strong>cb</strong> is a user-defined callback and <strong>v</strong> is a 64-bit
value passed to and relevant for processing in the
<strong>cb</strong>.  An example use case would be to alter QP processing
based on criteria not part of the rvt_qp.</p>
<p>Use cases that require memory allocation to succeed
must preallocate appropriately.</p>
<p><strong>Return</strong></p>
<p>a pointer to an rvt_qp_iter or NULL</p>
<dl class="function">
<dt id="c.rvt_qp_iter_next">
int <code class="descname">rvt_qp_iter_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rvt_qp_iter" title="rvt_qp_iter">rvt_qp_iter</a> *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_qp_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>return the next QP in iter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>the iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fine grained QP iterator suitable for use
with debugfs seq_file mechanisms.</p>
<p>Updates iter-&gt;qp with the current QP when the return
value is 0.</p>
<p><strong>Return</strong></p>
<p>0 - iter-&gt;qp is valid 1 - no more QPs</p>
<dl class="function">
<dt id="c.rvt_qp_iter">
void <code class="descname">rvt_qp_iter</code><span class="sig-paren">(</span>struct rvt_dev_info *<em>&nbsp;rdi</em>, u64<em>&nbsp;v</em>, void (<em>*cb</em>)(struct rvt_qp *qp, u64 v)<span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_qp_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate all QPs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_dev_info</span> <span class="pre">*</span> <span class="pre">rdi</span></code></dt>
<dd>rvt devinfo</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">v</span></code></dt>
<dd>a 64-bit value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">rvt_qp</span> <span class="pre">*qp,</span> <span class="pre">u64</span> <span class="pre">v)</span> <span class="pre">cb</span></code></dt>
<dd>a callback</dd>
</dl>
<p><strong>Description</strong></p>
<p>This provides a way for iterating all QPs.</p>
<p>The <strong>cb</strong> is a user-defined callback and <strong>v</strong> is a 64-bit
value passed to and relevant for processing in the
cb.  An example use case would be to alter QP processing
based on criteria not part of the rvt_qp.</p>
<p>The code has an internal iterator to simplify
non seq_file use cases.</p>
<dl class="function">
<dt id="c.rvt_copy_sge">
void <code class="descname">rvt_copy_sge</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;qp</em>, struct rvt_sge_state *<em>&nbsp;ss</em>, void *<em>&nbsp;data</em>, u32<em>&nbsp;length</em>, bool<em>&nbsp;release</em>, bool<em>&nbsp;copy_last</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_copy_sge" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data to SGE memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>associated QP</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_sge_state</span> <span class="pre">*</span> <span class="pre">ss</span></code></dt>
<dd>the SGE state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>the data to copy</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">length</span></code></dt>
<dd>the length of the data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">release</span></code></dt>
<dd>boolean to release MR</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">copy_last</span></code></dt>
<dd>do a separate copy of the last 8 bytes</dd>
</dl>
<dl class="function">
<dt id="c.rvt_ruc_loopback">
void <code class="descname">rvt_ruc_loopback</code><span class="sig-paren">(</span>struct rvt_qp *<em>&nbsp;sqp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_ruc_loopback" title="Permalink to this definition">¶</a></dt>
<dd><p>handle UC and RC loopback requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_qp</span> <span class="pre">*</span> <span class="pre">sqp</span></code></dt>
<dd>the sending QP</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called from rvt_do_send() to forward a WQE addressed to the same HFI
Note that although we are single threaded due to the send engine, we still
have to protect against post_send().  We don’t have to worry about
receive interrupts since this is a connected protocol and all packets
will pass through here.</p>
<dl class="function">
<dt id="c.rvt_mcast_find">
struct rvt_mcast * <code class="descname">rvt_mcast_find</code><span class="sig-paren">(</span>struct rvt_ibport *<em>&nbsp;ibp</em>, union ib_gid *<em>&nbsp;mgid</em>, u16<em>&nbsp;lid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rvt_mcast_find" title="Permalink to this definition">¶</a></dt>
<dd><p>search the global table for the given multicast GID/LID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rvt_ibport</span> <span class="pre">*</span> <span class="pre">ibp</span></code></dt>
<dd>the IB port structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">ib_gid</span> <span class="pre">*</span> <span class="pre">mgid</span></code></dt>
<dd>the multicast GID to search for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">lid</span></code></dt>
<dd>the multicast LID portion of the multicast address (host order)</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>It is valid to have 1 MLID with multiple MGIDs.  It is not valid
to have 1 MGID with multiple MLIDs.</p>
<p><strong>Description</strong></p>
<p>The caller is responsible for decrementing the reference count if found.</p>
<p><strong>Return</strong></p>
<p>NULL if not found.</p>
</div>
<div class="section" id="upper-layer-protocols">
<h2>Upper Layer Protocols<a class="headerlink" href="#upper-layer-protocols" title="Permalink to this headline">¶</a></h2>
<div class="section" id="iscsi-extensions-for-rdma-iser">
<h3>iSCSI Extensions for RDMA (iSER)<a class="headerlink" href="#iscsi-extensions-for-rdma-iser" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.iser_data_buf">
struct <code class="descname">iser_data_buf</code><a class="headerlink" href="#c.iser_data_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>iSER data buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_data_buf {
  struct scatterlist *sg;
  int size;
  unsigned long      data_len;
  int dma_nents;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sg</span></code></dt>
<dd>pointer to the sg list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd>num entries of this sg</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_len</span></code></dt>
<dd>total beffer byte len</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_nents</span></code></dt>
<dd>returned by dma_map_sg</dd>
</dl>
<dl class="type">
<dt id="c.iser_mem_reg">
struct <code class="descname">iser_mem_reg</code><a class="headerlink" href="#c.iser_mem_reg" title="Permalink to this definition">¶</a></dt>
<dd><p>iSER memory registration info</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_mem_reg {
  struct ib_sge    sge;
  u32 rkey;
  void *mem_h;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sge</span></code></dt>
<dd>memory region sg element</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rkey</span></code></dt>
<dd>memory region remote key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_h</span></code></dt>
<dd>pointer to registration context (FMR/Fastreg)</dd>
</dl>
<dl class="type">
<dt id="c.iser_tx_desc">
struct <code class="descname">iser_tx_desc</code><a class="headerlink" href="#c.iser_tx_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>iSER TX descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_tx_desc {
  struct iser_ctrl             iser_header;
  struct iscsi_hdr             iscsi_header;
  enum iser_desc_type        type;
  u64 dma_addr;
  struct ib_sge                tx_sg[2];
  int num_sge;
  struct ib_cqe                cqe;
  bool mapped;
  struct ib_reg_wr             reg_wr;
  struct ib_send_wr            send_wr;
  struct ib_send_wr            inv_wr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">iser_header</span></code></dt>
<dd>iser header</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iscsi_header</span></code></dt>
<dd>iscsi header</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt>
<dd>command/control/dataout</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr</span></code></dt>
<dd>header buffer dma_address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_sg</span></code></dt>
<dd>sg[0] points to iser/iscsi headers
sg[1] optionally points to either of immediate data
unsolicited data-out or control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_sge</span></code></dt>
<dd>number sges used on this TX task</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cqe</span></code></dt>
<dd>completion handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mapped</span></code></dt>
<dd>Is the task header mapped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_wr</span></code></dt>
<dd>registration WR</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_wr</span></code></dt>
<dd>send WR</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inv_wr</span></code></dt>
<dd>invalidate WR</dd>
</dl>
<dl class="type">
<dt id="c.iser_rx_desc">
struct <code class="descname">iser_rx_desc</code><a class="headerlink" href="#c.iser_rx_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>iSER RX descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_rx_desc {
  struct iser_ctrl             iser_header;
  struct iscsi_hdr             iscsi_header;
  char data[ISER_RECV_DATA_SEG_LEN];
  u64 dma_addr;
  struct ib_sge                rx_sg;
  struct ib_cqe                cqe;
  char pad[ISER_RX_PAD_SIZE];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">iser_header</span></code></dt>
<dd>iser header</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iscsi_header</span></code></dt>
<dd>iscsi header</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt>
<dd>received data segment</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr</span></code></dt>
<dd>receive buffer dma address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_sg</span></code></dt>
<dd>ib_sge of receive buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cqe</span></code></dt>
<dd>completion handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt>
<dd>for sense data TODO: Modify to maximum sense length supported</dd>
</dl>
<dl class="type">
<dt id="c.iser_login_desc">
struct <code class="descname">iser_login_desc</code><a class="headerlink" href="#c.iser_login_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>iSER login descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_login_desc {
  void *req;
  void *rsp;
  u64 req_dma;
  u64 rsp_dma;
  struct ib_sge                sge;
  struct ib_cqe                cqe;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">req</span></code></dt>
<dd>pointer to login request buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsp</span></code></dt>
<dd>pointer to login response buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_dma</span></code></dt>
<dd>DMA address of login request buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsp_dma</span></code></dt>
<dd>DMA address of login response buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sge</span></code></dt>
<dd>IB sge for login post recv</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cqe</span></code></dt>
<dd>completion handler</dd>
</dl>
<dl class="type">
<dt id="c.iser_comp">
struct <code class="descname">iser_comp</code><a class="headerlink" href="#c.iser_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>iSER completion context</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_comp {
  struct ib_cq            *cq;
  int active_qps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">cq</span></code></dt>
<dd>completion queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_qps</span></code></dt>
<dd>Number of active QPs attached
to completion context</dd>
</dl>
<dl class="type">
<dt id="c.iser_reg_ops">
struct <code class="descname">iser_reg_ops</code><a class="headerlink" href="#c.iser_reg_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory registration operations per-device registration schemes</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_reg_ops {
  int (*alloc_reg_res)(struct ib_conn *ib_conn,unsigned cmds_max, unsigned int size);
  void (*free_reg_res)(struct ib_conn *ib_conn);
  int (*reg_mem)(struct iscsi_iser_task *iser_task,struct iser_data_buf *mem,struct iser_reg_resources *rsc, struct iser_mem_reg *reg);
  void (*unreg_mem)(struct iscsi_iser_task *iser_task, enum iser_data_dir cmd_dir);
  struct iser_fr_desc * (*reg_desc_get)(struct ib_conn *ib_conn);
  void (*reg_desc_put)(struct ib_conn *ib_conn, struct iser_fr_desc *desc);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">alloc_reg_res</span></code></dt>
<dd>Allocate registration resources</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_reg_res</span></code></dt>
<dd>Free registration resources</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_mem</span></code></dt>
<dd>Register memory buffers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unreg_mem</span></code></dt>
<dd>Un-register memory buffers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_desc_get</span></code></dt>
<dd>Get a registration descriptor for pool</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_desc_put</span></code></dt>
<dd>Get a registration descriptor to pool</dd>
</dl>
<dl class="type">
<dt id="c.iser_device">
struct <code class="descname">iser_device</code><a class="headerlink" href="#c.iser_device" title="Permalink to this definition">¶</a></dt>
<dd><p>iSER device handle</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_device {
  struct ib_device             *ib_device;
  struct ib_pd                 *pd;
  struct ib_event_handler      event_handler;
  struct list_head             ig_list;
  int refcount;
  int comps_used;
  struct iser_comp             *comps;
  const struct iser_reg_ops    *reg_ops;
  bool remote_inv_sup;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ib_device</span></code></dt>
<dd>RDMA device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pd</span></code></dt>
<dd>Protection Domain for this device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event_handler</span></code></dt>
<dd>IB events handle routine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ig_list</span></code></dt>
<dd>entry in devices list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt>
<dd>Reference counter, dominated by open iser connections</dd>
<dt><code class="docutils literal notranslate"><span class="pre">comps_used</span></code></dt>
<dd>Number of completion contexts used, Min between online
cpus and device max completion vectors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">comps</span></code></dt>
<dd>Dinamically allocated array of completion handlers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_ops</span></code></dt>
<dd>Registration ops</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remote_inv_sup</span></code></dt>
<dd>Remote invalidate is supported on this device</dd>
</dl>
<dl class="type">
<dt id="c.iser_reg_resources">
struct <code class="descname">iser_reg_resources</code><a class="headerlink" href="#c.iser_reg_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast registration resources</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_reg_resources {
  union {
    struct ib_mr             *mr;
    struct ib_fmr_pool       *fmr_pool;
  };
  struct ib_mr                     *sig_mr;
  struct iser_page_vec             *page_vec;
  u8 mr_valid:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mr</span></code></dt>
<dd>memory region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fmr_pool</span></code></dt>
<dd>pool of fmrs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sig_mr</span></code></dt>
<dd>signature memory region</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_vec</span></code></dt>
<dd>fast reg page list used by fmr pool</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mr_valid</span></code></dt>
<dd>is mr valid indicator</dd>
</dl>
<dl class="type">
<dt id="c.iser_fr_desc">
struct <code class="descname">iser_fr_desc</code><a class="headerlink" href="#c.iser_fr_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast registration descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_fr_desc {
  struct list_head                  list;
  struct iser_reg_resources         rsc;
  bool sig_protected;
  struct list_head                  all_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>entry in connection fastreg pool</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsc</span></code></dt>
<dd>data buffer registration resources</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sig_protected</span></code></dt>
<dd>is region protected indicator</dd>
</dl>
<dl class="type">
<dt id="c.iser_fr_pool">
struct <code class="descname">iser_fr_pool</code><a class="headerlink" href="#c.iser_fr_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>connection fast registration pool</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_fr_pool {
  struct list_head        list;
  spinlock_t lock;
  int size;
  struct list_head        all_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>list of fastreg descriptors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>protects fmr/fastreg pool</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd>size of the pool</dd>
</dl>
<dl class="type">
<dt id="c.ib_conn">
struct <code class="descname">ib_conn</code><a class="headerlink" href="#c.ib_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>Infiniband related objects</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ib_conn {
  struct rdma_cm_id           *cma_id;
  struct ib_qp                *qp;
  int post_recv_buf_count;
  u8 sig_count;
  struct ib_recv_wr            rx_wr[ISER_MIN_POSTED_RX];
  struct iser_device          *device;
  struct iser_comp            *comp;
  struct iser_fr_pool          fr_pool;
  bool pi_support;
  struct ib_cqe                reg_cqe;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">cma_id</span></code></dt>
<dd>rdma_cm connection maneger handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qp</span></code></dt>
<dd>Connection Queue-pair</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_recv_buf_count</span></code></dt>
<dd>post receive counter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sig_count</span></code></dt>
<dd>send work request signal count</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_wr</span></code></dt>
<dd>receive work request for batch posts</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device</span></code></dt>
<dd>reference to iser device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">comp</span></code></dt>
<dd>iser completion context</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fr_pool</span></code></dt>
<dd>connection fast registration poool</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pi_support</span></code></dt>
<dd>Indicate device T10-PI support</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_cqe</span></code></dt>
<dd>completion handler</dd>
</dl>
<dl class="type">
<dt id="c.iser_conn">
struct <code class="descname">iser_conn</code><a class="headerlink" href="#c.iser_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>iSER connection context</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_conn {
  struct ib_conn               ib_conn;
  struct iscsi_conn            *iscsi_conn;
  struct iscsi_endpoint        *ep;
  enum iser_conn_state         state;
  unsigned qp_max_recv_dtos;
  unsigned qp_max_recv_dtos_mask;
  unsigned min_posted_rx;
  u16 max_cmds;
  char name[ISER_OBJECT_NAME_SIZE];
  struct work_struct           release_work;
  struct mutex                 state_mutex;
  struct completion            stop_completion;
  struct completion            ib_completion;
  struct completion            up_completion;
  struct list_head             conn_list;
  struct iser_login_desc       login_desc;
  unsigned int                 rx_desc_head;
  struct iser_rx_desc          *rx_descs;
  u32 num_rx_descs;
  unsigned short               scsi_sg_tablesize;
  unsigned short               pages_per_mr;
  bool snd_w_inv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ib_conn</span></code></dt>
<dd>connection RDMA resources</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iscsi_conn</span></code></dt>
<dd>link to matching iscsi connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep</span></code></dt>
<dd>transport handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt>
<dd>connection logical state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qp_max_recv_dtos</span></code></dt>
<dd>maximum number of data outs, corresponds
to max number of post recvs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qp_max_recv_dtos_mask</span></code></dt>
<dd>(qp_max_recv_dtos - 1)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_posted_rx</span></code></dt>
<dd>(qp_max_recv_dtos &gt;&gt; 2)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_cmds</span></code></dt>
<dd>maximum cmds allowed for this connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>connection peer portal</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release_work</span></code></dt>
<dd>deffered work for release job</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_mutex</span></code></dt>
<dd>protects iser onnection state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_completion</span></code></dt>
<dd>conn_stop completion</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_completion</span></code></dt>
<dd>RDMA cleanup completion</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_completion</span></code></dt>
<dd>connection establishment completed
(state is ISER_CONN_UP)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn_list</span></code></dt>
<dd>entry in ig conn list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">login_desc</span></code></dt>
<dd>login descriptor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_desc_head</span></code></dt>
<dd>head of rx_descs cyclic buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_descs</span></code></dt>
<dd>rx buffers array (cyclic buffer)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_rx_descs</span></code></dt>
<dd>number of rx descriptors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scsi_sg_tablesize</span></code></dt>
<dd>scsi host sg_tablesize</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages_per_mr</span></code></dt>
<dd>maximum pages available for registration</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_w_inv</span></code></dt>
<dd>connection uses remote invalidation</dd>
</dl>
<dl class="type">
<dt id="c.iscsi_iser_task">
struct <code class="descname">iscsi_iser_task</code><a class="headerlink" href="#c.iscsi_iser_task" title="Permalink to this definition">¶</a></dt>
<dd><p>iser task context</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iscsi_iser_task {
  struct iser_tx_desc          desc;
  struct iser_conn             *iser_conn;
  enum iser_task_status        status;
  struct scsi_cmnd             *sc;
  int command_sent;
  int dir[ISER_DIRS_NUM];
  struct iser_mem_reg          rdma_reg[ISER_DIRS_NUM];
  struct iser_data_buf         data[ISER_DIRS_NUM];
  struct iser_data_buf         prot[ISER_DIRS_NUM];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt>
<dd>TX descriptor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iser_conn</span></code></dt>
<dd>link to iser connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt>
<dd>current task status</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sc</span></code></dt>
<dd>link to scsi command</dd>
<dt><code class="docutils literal notranslate"><span class="pre">command_sent</span></code></dt>
<dd>indicate if command was sent</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dir</span></code></dt>
<dd>iser data direction</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rdma_reg</span></code></dt>
<dd>task rdma registration desc</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt>
<dd>iser data buffer desc</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prot</span></code></dt>
<dd>iser protection buffer desc</dd>
</dl>
<dl class="type">
<dt id="c.iser_global">
struct <code class="descname">iser_global</code><a class="headerlink" href="#c.iser_global" title="Permalink to this definition">¶</a></dt>
<dd><p>iSER global context</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iser_global {
  struct mutex      device_list_mutex;
  struct list_head  device_list;
  struct mutex      connlist_mutex;
  struct list_head  connlist;
  struct kmem_cache *desc_cache;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">device_list_mutex</span></code></dt>
<dd>protects device_list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_list</span></code></dt>
<dd>iser devices global list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connlist_mutex</span></code></dt>
<dd>protects connlist</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connlist</span></code></dt>
<dd>iser connections global list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">desc_cache</span></code></dt>
<dd>kmem cache for tx dataout</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_pdu_alloc">
int <code class="descname">iscsi_iser_pdu_alloc</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em>, uint8_t<em>&nbsp;opcode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_pdu_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an iscsi-iser PDU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>iscsi task</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">opcode</span></code></dt>
<dd>iscsi command opcode</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Netes: This routine can’t fail, just assign iscsi task</dt>
<dd>hdr and max hdr size.</dd>
</dl>
<dl class="function">
<dt id="c.iser_initialize_task_headers">
int <code class="descname">iser_initialize_task_headers</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em>, struct <a class="reference internal" href="#c.iser_tx_desc" title="iser_tx_desc">iser_tx_desc</a> *<em>&nbsp;tx_desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_initialize_task_headers" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize task headers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>iscsi task</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iser_tx_desc</span> <span class="pre">*</span> <span class="pre">tx_desc</span></code></dt>
<dd>iser tx descriptor</dd>
</dl>
<p><strong>Notes</strong></p>
<p>This routine may race with iser teardown flow for scsi
error handling TMFs. So for TMF we should acquire the
state mutex to avoid dereferencing the IB device which
may have already been terminated.</p>
<dl class="function">
<dt id="c.iscsi_iser_task_init">
int <code class="descname">iscsi_iser_task_init</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_task_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize iscsi-iser task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>iscsi task</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the task for the scsi command or mgmt command.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Returns zero on success or -ENOMEM when failing</dt>
<dd>to init task headers (dma mapping error).</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_mtask_xmit">
int <code class="descname">iscsi_iser_mtask_xmit</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em>, struct iscsi_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_mtask_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>xmit management (immediate) task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task management task</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div>The function can return -EAGAIN in which case caller must
call it again later, or recover. ‘0’ return code means successful
xmit.</div></blockquote>
<dl class="function">
<dt id="c.iscsi_iser_task_xmit">
int <code class="descname">iscsi_iser_task_xmit</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_task_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>xmit iscsi-iser task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>iscsi task</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero on success or escalates $error on failure.</p>
<dl class="function">
<dt id="c.iscsi_iser_cleanup_task">
void <code class="descname">iscsi_iser_cleanup_task</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_cleanup_task" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup an iscsi-iser task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>iscsi task</dd>
</dl>
<p><strong>Notes</strong></p>
<dl class="docutils">
<dt>In case the RDMA device is already NULL (might have</dt>
<dd>been removed in DEVICE_REMOVAL CM event it will bail-out
without doing dma unmapping.</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_check_protection">
u8 <code class="descname">iscsi_iser_check_protection</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em>, sector_t *<em>&nbsp;sector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_check_protection" title="Permalink to this definition">¶</a></dt>
<dd><p>check protection information status of task.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>iscsi task</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">*</span> <span class="pre">sector</span></code></dt>
<dd>error sector if exsists (output)</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>zero if no data-integrity errors have occured</dt>
<dd><p class="first">0x1: data-integrity error occured in the guard-block
0x2: data-integrity error occured in the reference tag
0x3: data-integrity error occured in the application tag</p>
<p class="last">In addition the error sector is marked.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_conn_create">
struct iscsi_cls_conn * <code class="descname">iscsi_iser_conn_create</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em>&nbsp;cls_session</em>, uint32_t<em>&nbsp;conn_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_conn_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new iscsi-iser connection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">cls_session</span></code></dt>
<dd>iscsi class connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">conn_idx</span></code></dt>
<dd>connection index within the session (for MCS)</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>iscsi_cls_conn when iscsi_conn_setup succeeds or NULL</dt>
<dd>otherwise.</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_conn_bind">
int <code class="descname">iscsi_iser_conn_bind</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em>&nbsp;cls_session</em>, struct iscsi_cls_conn *<em>&nbsp;cls_conn</em>, uint64_t<em>&nbsp;transport_eph</em>, int<em>&nbsp;is_leading</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_conn_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>bind iscsi and iser connection structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">cls_session</span></code></dt>
<dd>iscsi class session</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*</span> <span class="pre">cls_conn</span></code></dt>
<dd>iscsi class connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">transport_eph</span></code></dt>
<dd>transport end-point handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">is_leading</span></code></dt>
<dd>indicate if this is the session leading connection (MCS)</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>zero on success, $error if iscsi_conn_bind fails and</dt>
<dd>-EINVAL in case end-point doesn’t exsits anymore or iser connection
state is not UP (teardown already started).</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_conn_start">
int <code class="descname">iscsi_iser_conn_start</code><span class="sig-paren">(</span>struct iscsi_cls_conn *<em>&nbsp;cls_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_conn_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start iscsi-iser connection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*</span> <span class="pre">cls_conn</span></code></dt>
<dd>iscsi class connection</dd>
</dl>
<p><strong>Notes</strong></p>
<dl class="docutils">
<dt>Here iser intialize (or re-initialize) stop_completion as</dt>
<dd>from this point iscsi must call conn_stop in session/connection
teardown so iser transport must wait for it.</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_conn_stop">
void <code class="descname">iscsi_iser_conn_stop</code><span class="sig-paren">(</span>struct iscsi_cls_conn *<em>&nbsp;cls_conn</em>, int<em>&nbsp;flag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_conn_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stop iscsi-iser connection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*</span> <span class="pre">cls_conn</span></code></dt>
<dd>iscsi class connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flag</span></code></dt>
<dd>indicate if recover or terminate (passed as is)</dd>
</dl>
<p><strong>Notes</strong></p>
<dl class="docutils">
<dt>Calling iscsi_conn_stop might theoretically race with</dt>
<dd>DEVICE_REMOVAL event and dereference a previously freed RDMA device
handle, so we call it under iser the state lock to protect against
this kind of race.</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_session_destroy">
void <code class="descname">iscsi_iser_session_destroy</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em>&nbsp;cls_session</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_session_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy iscsi-iser session</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">cls_session</span></code></dt>
<dd>iscsi class session</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes and free iscsi host.</p>
<dl class="function">
<dt id="c.iscsi_iser_session_create">
struct iscsi_cls_session * <code class="descname">iscsi_iser_session_create</code><span class="sig-paren">(</span>struct iscsi_endpoint *<em>&nbsp;ep</em>, uint16_t<em>&nbsp;cmds_max</em>, uint16_t<em>&nbsp;qdepth</em>, uint32_t<em>&nbsp;initial_cmdsn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_session_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an iscsi-iser session</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_endpoint</span> <span class="pre">*</span> <span class="pre">ep</span></code></dt>
<dd>iscsi end-point handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">cmds_max</span></code></dt>
<dd>maximum commands in this session</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">qdepth</span></code></dt>
<dd>session command queue depth</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">initial_cmdsn</span></code></dt>
<dd>initiator command sequnce number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and adds a scsi host, expose DIF supprot if
exists, and sets up an iscsi session.</p>
<dl class="function">
<dt id="c.iscsi_iser_ep_connect">
struct iscsi_endpoint * <code class="descname">iscsi_iser_ep_connect</code><span class="sig-paren">(</span>struct Scsi_Host *<em>&nbsp;shost</em>, struct sockaddr *<em>&nbsp;dst_addr</em>, int<em>&nbsp;non_blocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_ep_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate iSER connection establishment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>scsi_host</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">dst_addr</span></code></dt>
<dd>destination address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">non_blocking</span></code></dt>
<dd>indicate if routine can block</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an iscsi endpoint, an iser_conn structure and bind them.
After that start RDMA connection establishment via rdma_cm. We
don’t allocate iser_conn embedded in iscsi_endpoint since in teardown
the endpoint will be destroyed at ep_disconnect while iser_conn will
cleanup its resources asynchronuously.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>iscsi_endpoint created by iscsi layer or ERR_PTR(error)</dt>
<dd>if fails.</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_ep_poll">
int <code class="descname">iscsi_iser_ep_poll</code><span class="sig-paren">(</span>struct iscsi_endpoint *<em>&nbsp;ep</em>, int<em>&nbsp;timeout_ms</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_ep_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>poll for iser connection establishment to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_endpoint</span> <span class="pre">*</span> <span class="pre">ep</span></code></dt>
<dd>iscsi endpoint (created at ep_connect)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout_ms</span></code></dt>
<dd>polling timeout allowed in ms.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine boils down to waiting for up_completion signaling
that cma_id got CONNECTED event.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>1 if succeeded in connection establishment, 0 if timeout expired</dt>
<dd>(libiscsi will retry will kick in) or -1 if interrupted by signal
or more likely iser connection state transitioned to TEMINATING or
DOWN during the wait period.</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_iser_ep_disconnect">
void <code class="descname">iscsi_iser_ep_disconnect</code><span class="sig-paren">(</span>struct iscsi_endpoint *<em>&nbsp;ep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_iser_ep_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate connection teardown process</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_endpoint</span> <span class="pre">*</span> <span class="pre">ep</span></code></dt>
<dd>iscsi endpoint handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is not blocked by iser and RDMA termination process
completion as we queue a deffered work for iser/RDMA destruction
and cleanup or actually call it immediately in case we didn’t pass
iscsi conn bind/start stage, thus it is safe.</p>
<dl class="function">
<dt id="c.iser_send_command">
int <code class="descname">iser_send_command</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em>, struct iscsi_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_send_command" title="Permalink to this definition">¶</a></dt>
<dd><p>send command PDU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>link to matching iscsi connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>SCSI command task</dd>
</dl>
<dl class="function">
<dt id="c.iser_send_data_out">
int <code class="descname">iser_send_data_out</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em>, struct iscsi_task *<em>&nbsp;task</em>, struct iscsi_data *<em>&nbsp;hdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_send_data_out" title="Permalink to this definition">¶</a></dt>
<dd><p>send data out PDU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>link to matching iscsi connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>SCSI command task</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_data</span> <span class="pre">*</span> <span class="pre">hdr</span></code></dt>
<dd>pointer to the LLD’s iSCSI message header</dd>
</dl>
<dl class="function">
<dt id="c.iser_alloc_fmr_pool">
int <code class="descname">iser_alloc_fmr_pool</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ib_conn" title="ib_conn">ib_conn</a> *<em>&nbsp;ib_conn</em>, unsigned<em>&nbsp;cmds_max</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_alloc_fmr_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates FMR pool and page_vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_conn</span> <span class="pre">*</span> <span class="pre">ib_conn</span></code></dt>
<dd>connection RDMA resources</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">cmds_max</span></code></dt>
<dd>max number of SCSI commands for this connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>max number of pages per map request</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or errno code on failure</p>
<dl class="function">
<dt id="c.iser_free_fmr_pool">
void <code class="descname">iser_free_fmr_pool</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ib_conn" title="ib_conn">ib_conn</a> *<em>&nbsp;ib_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_free_fmr_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>releases the FMR pool and page vec</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_conn</span> <span class="pre">*</span> <span class="pre">ib_conn</span></code></dt>
<dd>connection RDMA resources</dd>
</dl>
<dl class="function">
<dt id="c.iser_alloc_fastreg_pool">
int <code class="descname">iser_alloc_fastreg_pool</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ib_conn" title="ib_conn">ib_conn</a> *<em>&nbsp;ib_conn</em>, unsigned<em>&nbsp;cmds_max</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_alloc_fastreg_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates pool of fast_reg descriptors for fast registration work requests.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_conn</span> <span class="pre">*</span> <span class="pre">ib_conn</span></code></dt>
<dd>connection RDMA resources</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">cmds_max</span></code></dt>
<dd>max number of SCSI commands for this connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>max number of pages per map request</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or errno code on failure</p>
<dl class="function">
<dt id="c.iser_free_fastreg_pool">
void <code class="descname">iser_free_fastreg_pool</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ib_conn" title="ib_conn">ib_conn</a> *<em>&nbsp;ib_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_free_fastreg_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>releases the pool of fast_reg descriptors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_conn</span> <span class="pre">*</span> <span class="pre">ib_conn</span></code></dt>
<dd>connection RDMA resources</dd>
</dl>
<dl class="function">
<dt id="c.iser_free_ib_conn_res">
void <code class="descname">iser_free_ib_conn_res</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.iser_conn" title="iser_conn">iser_conn</a> *<em>&nbsp;iser_conn</em>, bool<em>&nbsp;destroy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_free_ib_conn_res" title="Permalink to this definition">¶</a></dt>
<dd><p>release IB related resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iser_conn</span> <span class="pre">*</span> <span class="pre">iser_conn</span></code></dt>
<dd>iser connection struct</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">destroy</span></code></dt>
<dd>indicator if we need to try to release the
iser device and memory regoins pool (only iscsi
shutdown and DEVICE_REMOVAL will use this).</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called with the iser state mutex held
so the cm_id removal is out of here. It is Safe to
be invoked multiple times.</p>
<dl class="function">
<dt id="c.iser_conn_release">
void <code class="descname">iser_conn_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.iser_conn" title="iser_conn">iser_conn</a> *<em>&nbsp;iser_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_conn_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees all conn objects and deallocs conn descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iser_conn</span> <span class="pre">*</span> <span class="pre">iser_conn</span></code></dt>
<dd>iSER connection context</dd>
</dl>
<dl class="function">
<dt id="c.iser_conn_terminate">
int <code class="descname">iser_conn_terminate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.iser_conn" title="iser_conn">iser_conn</a> *<em>&nbsp;iser_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_conn_terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>triggers start of the disconnect procedures and waits for them to be done</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iser_conn</span> <span class="pre">*</span> <span class="pre">iser_conn</span></code></dt>
<dd>iSER connection context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called with state mutex held</p>
<dl class="function">
<dt id="c.iser_post_send">
int <code class="descname">iser_post_send</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ib_conn" title="ib_conn">ib_conn</a> *<em>&nbsp;ib_conn</em>, struct <a class="reference internal" href="#c.iser_tx_desc" title="iser_tx_desc">iser_tx_desc</a> *<em>&nbsp;tx_desc</em>, bool<em>&nbsp;signal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iser_post_send" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate a Send DTO operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_conn</span> <span class="pre">*</span> <span class="pre">ib_conn</span></code></dt>
<dd>connection RDMA resources</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iser_tx_desc</span> <span class="pre">*</span> <span class="pre">tx_desc</span></code></dt>
<dd>iSER TX descriptor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">signal</span></code></dt>
<dd>true to send work request as SIGNALED</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -1 on failure</p>
</div>
<div class="section" id="omni-path-opa-virtual-nic-support">
<h3>Omni-Path (OPA) Virtual NIC support<a class="headerlink" href="#omni-path-opa-virtual-nic-support" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.opa_vnic_ctrl_port">
struct <code class="descname">opa_vnic_ctrl_port</code><a class="headerlink" href="#c.opa_vnic_ctrl_port" title="Permalink to this definition">¶</a></dt>
<dd><p>OPA virtual NIC control port</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_vnic_ctrl_port {
  struct ib_device           *ibdev;
  struct opa_vnic_ctrl_ops   *ops;
  u8 num_ports;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ibdev</span></code></dt>
<dd>pointer to ib device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt>
<dd>opa vnic control operations</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ports</span></code></dt>
<dd>number of opa ports</dd>
</dl>
<dl class="type">
<dt id="c.opa_vnic_adapter">
struct <code class="descname">opa_vnic_adapter</code><a class="headerlink" href="#c.opa_vnic_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>OPA VNIC netdev private data structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_vnic_adapter {
  struct net_device             *netdev;
  struct ib_device              *ibdev;
  struct opa_vnic_ctrl_port     *cport;
  const struct net_device_ops   *rn_ops;
  u8 port_num;
  u8 vport_num;
  struct mutex lock;
  struct __opa_veswport_info  info;
  u8 vema_mac_addr[ETH_ALEN];
  u32 umac_hash;
  u32 mmac_hash;
  struct hlist_head  __rcu   *mactbl;
  struct mutex mactbl_lock;
  spinlock_t stats_lock;
  u8 flow_tbl[OPA_VNIC_FLOW_TBL_SIZE];
  unsigned long trap_timeout;
  u8 trap_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">netdev</span></code></dt>
<dd>pointer to associated netdev</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ibdev</span></code></dt>
<dd>ib device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cport</span></code></dt>
<dd>pointer to opa vnic control port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rn_ops</span></code></dt>
<dd>rdma netdev’s net_device_ops</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_num</span></code></dt>
<dd>OPA port number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vport_num</span></code></dt>
<dd>vesw port number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>adapter lock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt>
<dd>virtual ethernet switch port information</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vema_mac_addr</span></code></dt>
<dd>mac address configured by vema</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umac_hash</span></code></dt>
<dd>unicast maclist hash</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmac_hash</span></code></dt>
<dd>multicast maclist hash</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mactbl</span></code></dt>
<dd>hash table of MAC entries</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mactbl_lock</span></code></dt>
<dd>mac table lock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats_lock</span></code></dt>
<dd>statistics lock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flow_tbl</span></code></dt>
<dd>flow to default port redirection table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trap_timeout</span></code></dt>
<dd>trap timeout</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trap_count</span></code></dt>
<dd>no. of traps allowed within timeout period</dd>
</dl>
<dl class="type">
<dt id="c.opa_vnic_mac_tbl_node">
struct <code class="descname">opa_vnic_mac_tbl_node</code><a class="headerlink" href="#c.opa_vnic_mac_tbl_node" title="Permalink to this definition">¶</a></dt>
<dd><p>OPA VNIC mac table node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_vnic_mac_tbl_node {
  struct hlist_node                    hlist;
  u16 index;
  struct __opa_vnic_mactable_entry     entry;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">hlist</span></code></dt>
<dd>hash list handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt>
<dd>index of entry in the mac table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd>entry in the table</dd>
</dl>
<dl class="type">
<dt id="c.opa_vesw_info">
struct <code class="descname">opa_vesw_info</code><a class="headerlink" href="#c.opa_vesw_info" title="Permalink to this definition">¶</a></dt>
<dd><p>OPA vnic switch information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_vesw_info {
  __be16 fabric_id;
  __be16 vesw_id;
  u8 rsvd0[6];
  __be16 def_port_mask;
  u8 rsvd1[2];
  __be16 pkey;
  u8 rsvd2[4];
  __be32 u_mcast_dlid;
  __be32 u_ucast_dlid[OPA_VESW_MAX_NUM_DEF_PORT];
  __be32 rc;
  u8 rsvd3[56];
  __be16 eth_mtu;
  u8 rsvd4[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">fabric_id</span></code></dt>
<dd>10-bit fabric id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vesw_id</span></code></dt>
<dd>12-bit virtual ethernet switch id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">def_port_mask</span></code></dt>
<dd>bitmask of default ports</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pkey</span></code></dt>
<dd>partition key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u_mcast_dlid</span></code></dt>
<dd>unknown multicast dlid</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u_ucast_dlid</span></code></dt>
<dd>array of unknown unicast dlids</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc</span></code></dt>
<dd>routing control</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eth_mtu</span></code></dt>
<dd>Ethernet MTU</dd>
</dl>
<dl class="type">
<dt id="c.opa_per_veswport_info">
struct <code class="descname">opa_per_veswport_info</code><a class="headerlink" href="#c.opa_per_veswport_info" title="Permalink to this definition">¶</a></dt>
<dd><p>OPA vnic per port information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_per_veswport_info {
  __be32 port_num;
  u8 eth_link_status;
  u8 rsvd0[3];
  u8 base_mac_addr[ETH_ALEN];
  u8 config_state;
  u8 oper_state;
  __be16 max_mac_tbl_ent;
  __be16 max_smac_ent;
  __be32 mac_tbl_digest;
  u8 rsvd1[4];
  __be32 encap_slid;
  u8 pcp_to_sc_uc[OPA_VNIC_MAX_NUM_PCP];
  u8 pcp_to_vl_uc[OPA_VNIC_MAX_NUM_PCP];
  u8 pcp_to_sc_mc[OPA_VNIC_MAX_NUM_PCP];
  u8 pcp_to_vl_mc[OPA_VNIC_MAX_NUM_PCP];
  u8 non_vlan_sc_uc;
  u8 non_vlan_vl_uc;
  u8 non_vlan_sc_mc;
  u8 non_vlan_vl_mc;
  u8 rsvd2[48];
  __be16 uc_macs_gen_count;
  __be16 mc_macs_gen_count;
  u8 rsvd3[8];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">port_num</span></code></dt>
<dd>port number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eth_link_status</span></code></dt>
<dd>current ethernet link state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base_mac_addr</span></code></dt>
<dd>base mac address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config_state</span></code></dt>
<dd>configured port state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oper_state</span></code></dt>
<dd>operational port state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_mac_tbl_ent</span></code></dt>
<dd>max number of mac table entries</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_smac_ent</span></code></dt>
<dd>max smac entries in mac table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_tbl_digest</span></code></dt>
<dd>mac table digest</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encap_slid</span></code></dt>
<dd>base slid for the port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcp_to_sc_uc</span></code></dt>
<dd>sc by pcp index for unicast ethernet packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcp_to_vl_uc</span></code></dt>
<dd>vl by pcp index for unicast ethernet packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcp_to_sc_mc</span></code></dt>
<dd>sc by pcp index for multicast ethernet packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcp_to_vl_mc</span></code></dt>
<dd>vl by pcp index for multicast ethernet packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">non_vlan_sc_uc</span></code></dt>
<dd>sc for non-vlan unicast ethernet packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">non_vlan_vl_uc</span></code></dt>
<dd>vl for non-vlan unicast ethernet packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">non_vlan_sc_mc</span></code></dt>
<dd>sc for non-vlan multicast ethernet packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">non_vlan_vl_mc</span></code></dt>
<dd>vl for non-vlan multicast ethernet packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uc_macs_gen_count</span></code></dt>
<dd>generation count for unicast macs list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mc_macs_gen_count</span></code></dt>
<dd>generation count for multicast macs list</dd>
</dl>
<dl class="type">
<dt id="c.opa_veswport_info">
struct <code class="descname">opa_veswport_info</code><a class="headerlink" href="#c.opa_veswport_info" title="Permalink to this definition">¶</a></dt>
<dd><p>OPA vnic port information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_veswport_info {
  struct opa_vesw_info          vesw;
  struct opa_per_veswport_info  vport;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">vesw</span></code></dt>
<dd>OPA vnic switch information</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vport</span></code></dt>
<dd>OPA vnic per port information</dd>
</dl>
<p><strong>Description</strong></p>
<p>On host, each of the virtual ethernet ports belongs
to a different virtual ethernet switches.</p>
<dl class="type">
<dt id="c.opa_veswport_mactable_entry">
struct <code class="descname">opa_veswport_mactable_entry</code><a class="headerlink" href="#c.opa_veswport_mactable_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>single entry in the forwarding table</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_veswport_mactable_entry {
  u8 mac_addr[ETH_ALEN];
  u8 mac_addr_mask[ETH_ALEN];
  __be32 dlid_sd;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">mac_addr</span></code></dt>
<dd>MAC address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_addr_mask</span></code></dt>
<dd>MAC address bit mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dlid_sd</span></code></dt>
<dd>Matching DLID and side data</dd>
</dl>
<p><strong>Description</strong></p>
<p>On the host each virtual ethernet port will have
a forwarding table. These tables are used to
map a MAC to a LID and other data. For more
details see struct opa_veswport_mactable_entries.
This is the structure of a single mactable entry</p>
<dl class="type">
<dt id="c.opa_veswport_mactable">
struct <code class="descname">opa_veswport_mactable</code><a class="headerlink" href="#c.opa_veswport_mactable" title="Permalink to this definition">¶</a></dt>
<dd><p>Forwarding table array</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_veswport_mactable {
  __be16 offset;
  __be16 num_entries;
  __be32 mac_tbl_digest;
  struct opa_veswport_mactable_entry  tbl_entries[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt>
<dd>mac table starting offset</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_entries</span></code></dt>
<dd>Number of entries to get or set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_tbl_digest</span></code></dt>
<dd>mac table digest</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tbl_entries</span></code></dt>
<dd>Array of table entries</dd>
</dl>
<p><strong>Description</strong></p>
<p>The EM sends down this structure in a MAD indicating
the starting offset in the forwarding table that this
entry is to be loaded into and the number of entries
that that this MAD instance contains
The mac_tbl_digest has been added to this MAD structure. It will be set by
the EM and it will be used by the EM to check if there are any
discrepancies with this value and the value
maintained by the EM in the case of VNIC port being deleted or unloaded
A new instantiation of a VNIC will always have a value of zero.
This value is stored as part of the vnic adapter structure and will be
accessed by the GET and SET routines for both the mactable entries and the
veswport info.</p>
<dl class="type">
<dt id="c.opa_veswport_summary_counters">
struct <code class="descname">opa_veswport_summary_counters</code><a class="headerlink" href="#c.opa_veswport_summary_counters" title="Permalink to this definition">¶</a></dt>
<dd><p>summary counters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_veswport_summary_counters {
  __be16 vp_instance;
  __be16 vesw_id;
  __be32 veswport_num;
  __be64 tx_errors;
  __be64 rx_errors;
  __be64 tx_packets;
  __be64 rx_packets;
  __be64 tx_bytes;
  __be64 rx_bytes;
  __be64 tx_unicast;
  __be64 tx_mcastbcast;
  __be64 tx_untagged;
  __be64 tx_vlan;
  __be64 tx_64_size;
  __be64 tx_65_127;
  __be64 tx_128_255;
  __be64 tx_256_511;
  __be64 tx_512_1023;
  __be64 tx_1024_1518;
  __be64 tx_1519_max;
  __be64 rx_unicast;
  __be64 rx_mcastbcast;
  __be64 rx_untagged;
  __be64 rx_vlan;
  __be64 rx_64_size;
  __be64 rx_65_127;
  __be64 rx_128_255;
  __be64 rx_256_511;
  __be64 rx_512_1023;
  __be64 rx_1024_1518;
  __be64 rx_1519_max;
  __be64 reserved[16];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">vp_instance</span></code></dt>
<dd>vport instance on the OPA port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vesw_id</span></code></dt>
<dd>virtual ethernet switch id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">veswport_num</span></code></dt>
<dd>virtual ethernet switch port number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_errors</span></code></dt>
<dd>transmit errors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_errors</span></code></dt>
<dd>receive errors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_packets</span></code></dt>
<dd>transmit packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_packets</span></code></dt>
<dd>receive packets</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_bytes</span></code></dt>
<dd>transmit bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_bytes</span></code></dt>
<dd>receive bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_unicast</span></code></dt>
<dd>unicast packets transmitted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_mcastbcast</span></code></dt>
<dd>multicast/broadcast packets transmitted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_untagged</span></code></dt>
<dd>non-vlan packets transmitted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_vlan</span></code></dt>
<dd>vlan packets transmitted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_64_size</span></code></dt>
<dd>transmit packet length is 64 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_65_127</span></code></dt>
<dd>transmit packet length is &gt;=65 and &lt; 127 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_128_255</span></code></dt>
<dd>transmit packet length is &gt;=128 and &lt; 255 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_256_511</span></code></dt>
<dd>transmit packet length is &gt;=256 and &lt; 511 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_512_1023</span></code></dt>
<dd>transmit packet length is &gt;=512 and &lt; 1023 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_1024_1518</span></code></dt>
<dd>transmit packet length is &gt;=1024 and &lt; 1518 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_1519_max</span></code></dt>
<dd>transmit packet length &gt;= 1519 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_unicast</span></code></dt>
<dd>unicast packets received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_mcastbcast</span></code></dt>
<dd>multicast/broadcast packets received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_untagged</span></code></dt>
<dd>non-vlan packets received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_vlan</span></code></dt>
<dd>vlan packets received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_64_size</span></code></dt>
<dd>received packet length is 64 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_65_127</span></code></dt>
<dd>received packet length is &gt;=65 and &lt; 127 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_128_255</span></code></dt>
<dd>received packet length is &gt;=128 and &lt; 255 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_256_511</span></code></dt>
<dd>received packet length is &gt;=256 and &lt; 511 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_512_1023</span></code></dt>
<dd>received packet length is &gt;=512 and &lt; 1023 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_1024_1518</span></code></dt>
<dd>received packet length is &gt;=1024 and &lt; 1518 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_1519_max</span></code></dt>
<dd>received packet length &gt;= 1519 bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the above are counters of corresponding conditions.</p>
<dl class="type">
<dt id="c.opa_veswport_error_counters">
struct <code class="descname">opa_veswport_error_counters</code><a class="headerlink" href="#c.opa_veswport_error_counters" title="Permalink to this definition">¶</a></dt>
<dd><p>error counters</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_veswport_error_counters {
  __be16 vp_instance;
  __be16 vesw_id;
  __be32 veswport_num;
  __be64 tx_errors;
  __be64 rx_errors;
  __be64 rsvd0;
  __be64 tx_smac_filt;
  __be64 rsvd1;
  __be64 rsvd2;
  __be64 rsvd3;
  __be64 tx_dlid_zero;
  __be64 rsvd4;
  __be64 tx_logic;
  __be64 rsvd5;
  __be64 tx_drop_state;
  __be64 rx_bad_veswid;
  __be64 rsvd6;
  __be64 rx_runt;
  __be64 rx_oversize;
  __be64 rsvd7;
  __be64 rx_eth_down;
  __be64 rx_drop_state;
  __be64 rx_logic;
  __be64 rsvd8;
  __be64 rsvd9[16];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">vp_instance</span></code></dt>
<dd>vport instance on the OPA port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vesw_id</span></code></dt>
<dd>virtual ethernet switch id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">veswport_num</span></code></dt>
<dd>virtual ethernet switch port number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_errors</span></code></dt>
<dd>transmit errors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_errors</span></code></dt>
<dd>receive errors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_smac_filt</span></code></dt>
<dd>smac filter errors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_dlid_zero</span></code></dt>
<dd>transmit packets with invalid dlid</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_logic</span></code></dt>
<dd>other transmit errors</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_drop_state</span></code></dt>
<dd>packet tansmission in non-forward port state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_bad_veswid</span></code></dt>
<dd>received packet with invalid vesw id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_runt</span></code></dt>
<dd>received ethernet packet with length &lt; 64 bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_oversize</span></code></dt>
<dd>received ethernet packet with length &gt; MTU size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_eth_down</span></code></dt>
<dd>received packets when interface is down</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_drop_state</span></code></dt>
<dd>received packets in non-forwarding port state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_logic</span></code></dt>
<dd>other receive errors</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the above are counters of corresponding error conditions.</p>
<dl class="type">
<dt id="c.opa_veswport_trap">
struct <code class="descname">opa_veswport_trap</code><a class="headerlink" href="#c.opa_veswport_trap" title="Permalink to this definition">¶</a></dt>
<dd><p>Trap message sent to EM by VNIC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_veswport_trap {
  __be16 fabric_id;
  __be16 veswid;
  __be32 veswportnum;
  __be16 opaportnum;
  u8 veswportindex;
  u8 opcode;
  __be32 reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">fabric_id</span></code></dt>
<dd>10 bit fabric id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">veswid</span></code></dt>
<dd>12 bit virtual ethernet switch id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">veswportnum</span></code></dt>
<dd>logical port number on the Virtual switch</dd>
<dt><code class="docutils literal notranslate"><span class="pre">opaportnum</span></code></dt>
<dd>physical port num (redundant on host)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">veswportindex</span></code></dt>
<dd>switch port index on opa port 0 based</dd>
<dt><code class="docutils literal notranslate"><span class="pre">opcode</span></code></dt>
<dd>operation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt>
<dd>32 bit for alignment</dd>
</dl>
<p><strong>Description</strong></p>
<p>The VNIC will send trap messages to the Ethernet manager to
inform it about changes to the VNIC config, behaviour etc.
This is the format of the trap payload.</p>
<dl class="type">
<dt id="c.opa_vnic_iface_mac_entry">
struct <code class="descname">opa_vnic_iface_mac_entry</code><a class="headerlink" href="#c.opa_vnic_iface_mac_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>single entry in the mac list</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_vnic_iface_mac_entry {
  u8 mac_addr[ETH_ALEN];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">mac_addr</span></code></dt>
<dd>MAC address</dd>
</dl>
<dl class="type">
<dt id="c.opa_veswport_iface_macs">
struct <code class="descname">opa_veswport_iface_macs</code><a class="headerlink" href="#c.opa_veswport_iface_macs" title="Permalink to this definition">¶</a></dt>
<dd><p>Msg to set globally administered MAC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_veswport_iface_macs {
  __be16 start_idx;
  __be16 num_macs_in_msg;
  __be16 tot_macs_in_lst;
  __be16 gen_count;
  struct opa_vnic_iface_mac_entry entry[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">start_idx</span></code></dt>
<dd>position of first entry (0 based)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_macs_in_msg</span></code></dt>
<dd>number of MACs in this message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tot_macs_in_lst</span></code></dt>
<dd>The total number of MACs the agent has</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gen_count</span></code></dt>
<dd>gen_count to indicate change</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd>The mac list entry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same attribute IDS and attribute modifiers as in locally administered
addresses used to set globally administered addresses</p>
<dl class="type">
<dt id="c.opa_vnic_vema_mad">
struct <code class="descname">opa_vnic_vema_mad</code><a class="headerlink" href="#c.opa_vnic_vema_mad" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic VEMA MAD</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_vnic_vema_mad {
  struct ib_mad_hdr  mad_hdr;
  struct ib_rmpp_hdr rmpp_hdr;
  u8 reserved;
  u8 oui[3];
  u8 data[OPA_VNIC_EMA_DATA];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">mad_hdr</span></code></dt>
<dd>Generic MAD header</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rmpp_hdr</span></code></dt>
<dd>RMPP header for vendor specific MADs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oui</span></code></dt>
<dd>Unique org identifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt>
<dd>MAD data</dd>
</dl>
<dl class="type">
<dt id="c.opa_vnic_notice_attr">
struct <code class="descname">opa_vnic_notice_attr</code><a class="headerlink" href="#c.opa_vnic_notice_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic Notice MAD</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_vnic_notice_attr {
  u8 gen_type;
  u8 oui_1;
  u8 oui_2;
  u8 oui_3;
  __be16 trap_num;
  __be16 toggle_count;
  __be32 issuer_lid;
  __be32 reserved;
  u8 issuer_gid[16];
  u8 raw_data[64];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">gen_type</span></code></dt>
<dd>Generic/Specific bit and type of notice</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oui_1</span></code></dt>
<dd>Vendor ID byte 1</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oui_2</span></code></dt>
<dd>Vendor ID byte 2</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oui_3</span></code></dt>
<dd>Vendor ID byte 3</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trap_num</span></code></dt>
<dd>Trap number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">toggle_count</span></code></dt>
<dd>Notice toggle bit and count value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">issuer_lid</span></code></dt>
<dd>Trap issuer’s lid</dd>
<dt><code class="docutils literal notranslate"><span class="pre">issuer_gid</span></code></dt>
<dd>Issuer GID (only if Report method)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">raw_data</span></code></dt>
<dd>Trap message body</dd>
</dl>
<dl class="type">
<dt id="c.opa_vnic_vema_mad_trap">
struct <code class="descname">opa_vnic_vema_mad_trap</code><a class="headerlink" href="#c.opa_vnic_vema_mad_trap" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic VEMA MAD Trap</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_vnic_vema_mad_trap {
  struct ib_mad_hdr            mad_hdr;
  struct ib_rmpp_hdr           rmpp_hdr;
  u8 reserved;
  u8 oui[3];
  struct opa_vnic_notice_attr  notice;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">mad_hdr</span></code></dt>
<dd>Generic MAD header</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rmpp_hdr</span></code></dt>
<dd>RMPP header for vendor specific MADs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oui</span></code></dt>
<dd>Unique org identifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notice</span></code></dt>
<dd>Notice structure</dd>
</dl>
<dl class="function">
<dt id="c.opa_vnic_vema_report_event">
void <code class="descname">opa_vnic_vema_report_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, u8<em>&nbsp;event</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_vema_report_event" title="Permalink to this definition">¶</a></dt>
<dd><p>sent trap to report the specified event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>vnic port adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">event</span></code></dt>
<dd>event to be reported</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calls vema api to sent a trap for the given event.</p>
<dl class="function">
<dt id="c.opa_vnic_get_summary_counters">
void <code class="descname">opa_vnic_get_summary_counters</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, struct <a class="reference internal" href="#c.opa_veswport_summary_counters" title="opa_veswport_summary_counters">opa_veswport_summary_counters</a> *<em>&nbsp;cntrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_get_summary_counters" title="Permalink to this definition">¶</a></dt>
<dd><p>get summary counters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>vnic port adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_veswport_summary_counters</span> <span class="pre">*</span> <span class="pre">cntrs</span></code></dt>
<dd>pointer to destination summary counters structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function populates the summary counters that is maintained by the
given adapter to destination address provided.</p>
<dl class="function">
<dt id="c.opa_vnic_get_error_counters">
void <code class="descname">opa_vnic_get_error_counters</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, struct <a class="reference internal" href="#c.opa_veswport_error_counters" title="opa_veswport_error_counters">opa_veswport_error_counters</a> *<em>&nbsp;cntrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_get_error_counters" title="Permalink to this definition">¶</a></dt>
<dd><p>get error counters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>vnic port adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_veswport_error_counters</span> <span class="pre">*</span> <span class="pre">cntrs</span></code></dt>
<dd>pointer to destination error counters structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function populates the error counters that is maintained by the
given adapter to destination address provided.</p>
<dl class="function">
<dt id="c.opa_vnic_get_vesw_info">
void <code class="descname">opa_vnic_get_vesw_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, struct <a class="reference internal" href="#c.opa_vesw_info" title="opa_vesw_info">opa_vesw_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_get_vesw_info" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Get the vesw information</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>vnic port adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vesw_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>pointer to destination vesw info structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies the vesw info that is maintained by the
given adapter to destination address provided.</p>
<dl class="function">
<dt id="c.opa_vnic_set_vesw_info">
void <code class="descname">opa_vnic_set_vesw_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, struct <a class="reference internal" href="#c.opa_vesw_info" title="opa_vesw_info">opa_vesw_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_set_vesw_info" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Set the vesw information</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>vnic port adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vesw_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>pointer to vesw info structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function updates the vesw info that is maintained by the
given adapter with vesw info provided. Reserved fields are stored
and returned back to EM as is.</p>
<dl class="function">
<dt id="c.opa_vnic_get_per_veswport_info">
void <code class="descname">opa_vnic_get_per_veswport_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, struct <a class="reference internal" href="#c.opa_per_veswport_info" title="opa_per_veswport_info">opa_per_veswport_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_get_per_veswport_info" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Get the vesw per port information</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>vnic port adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_per_veswport_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>pointer to destination vport info structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies the vesw per port info that is maintained by the
given adapter to destination address provided.
Note that the read only fields are not copied.</p>
<dl class="function">
<dt id="c.opa_vnic_set_per_veswport_info">
void <code class="descname">opa_vnic_set_per_veswport_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, struct <a class="reference internal" href="#c.opa_per_veswport_info" title="opa_per_veswport_info">opa_per_veswport_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_set_per_veswport_info" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Set vesw per port information</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>vnic port adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_per_veswport_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>pointer to vport info structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function updates the vesw per port info that is maintained by the
given adapter with vesw per port info provided. Reserved fields are
stored and returned back to EM as is.</p>
<dl class="function">
<dt id="c.opa_vnic_query_mcast_macs">
void <code class="descname">opa_vnic_query_mcast_macs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, struct <a class="reference internal" href="#c.opa_veswport_iface_macs" title="opa_veswport_iface_macs">opa_veswport_iface_macs</a> *<em>&nbsp;macs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_query_mcast_macs" title="Permalink to this definition">¶</a></dt>
<dd><p>query multicast mac list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>vnic port adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_veswport_iface_macs</span> <span class="pre">*</span> <span class="pre">macs</span></code></dt>
<dd>pointer mac list</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function populates the provided mac list with the configured
multicast addresses in the adapter.</p>
<dl class="function">
<dt id="c.opa_vnic_query_ucast_macs">
void <code class="descname">opa_vnic_query_ucast_macs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, struct <a class="reference internal" href="#c.opa_veswport_iface_macs" title="opa_veswport_iface_macs">opa_veswport_iface_macs</a> *<em>&nbsp;macs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_query_ucast_macs" title="Permalink to this definition">¶</a></dt>
<dd><p>query unicast mac list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>vnic port adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_veswport_iface_macs</span> <span class="pre">*</span> <span class="pre">macs</span></code></dt>
<dd>pointer mac list</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function populates the provided mac list with the configured
unicast addresses in the adapter.</p>
<dl class="type">
<dt id="c.opa_vnic_vema_port">
struct <code class="descname">opa_vnic_vema_port</code><a class="headerlink" href="#c.opa_vnic_vema_port" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>VNIC VEMA port details</li>
</ul>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct opa_vnic_vema_port {
  struct opa_vnic_ctrl_port      *cport;
  struct ib_mad_agent            *mad_agent;
  struct opa_class_port_info      class_port_info;
  u64 tid;
  u8 port_num;
  struct xarray                   vports;
  struct ib_event_handler         event_handler;
  struct mutex                    lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">cport</span></code></dt>
<dd>pointer to port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mad_agent</span></code></dt>
<dd>pointer to mad agent for port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">class_port_info</span></code></dt>
<dd>Class port info information.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid</span></code></dt>
<dd>Transaction id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_num</span></code></dt>
<dd>OPA port number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vports</span></code></dt>
<dd>vnic ports</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event_handler</span></code></dt>
<dd>ib event handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>adapter interface lock</dd>
</dl>
<dl class="function">
<dt id="c.vema_get_vport_num">
u8 <code class="descname">vema_get_vport_num</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get_vport_num" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Get the vnic from the mad</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>Received mad</dd>
</dl>
<p><strong>Return</strong></p>
<p>returns value of the vnic port number</p>
<dl class="function">
<dt id="c.vema_get_vport_adapter">
struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> * <code class="descname">vema_get_vport_adapter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get_vport_adapter" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Get vnic port adapter from recvd mad</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>received mad</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>ptr to port struct on which MAD was recvd</dd>
</dl>
<p><strong>Return</strong></p>
<p>vnic adapter</p>
<dl class="function">
<dt id="c.vema_mac_tbl_req_ok">
bool <code class="descname">vema_mac_tbl_req_ok</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_veswport_mactable" title="opa_veswport_mactable">opa_veswport_mactable</a> *<em>&nbsp;mac_tbl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_mac_tbl_req_ok" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Check if mac request has correct values</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_veswport_mactable</span> <span class="pre">*</span> <span class="pre">mac_tbl</span></code></dt>
<dd>mac table</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks for the validity of the offset and number of
entries required.</p>
<p><strong>Return</strong></p>
<p>true if offset and num_entries are valid</p>
<dl class="function">
<dt id="c.vema_add_vport">
struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> * <code class="descname">vema_add_vport</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, u8<em>&nbsp;vport_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_add_vport" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Add a new vnic port</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>ptr to opa_vnic_vema_port struct</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">vport_num</span></code></dt>
<dd>vnic port number (to be added)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a pointer to the vnic adapter structure</p>
<dl class="function">
<dt id="c.vema_get_class_port_info">
void <code class="descname">vema_get_class_port_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get_class_port_info" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Get class info for port</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>Port on whic MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>pointer to the received mad</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>pointer to respose mad</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies the latest class port info value set for the
port and stores it for generating traps</p>
<dl class="function">
<dt id="c.vema_set_class_port_info">
void <code class="descname">vema_set_class_port_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_set_class_port_info" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Get class info for port</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>Port on whic MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>pointer to the received mad</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>pointer to respose mad</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function updates the port class info for the specific vnic
and sets up the response mad data</p>
<dl class="function">
<dt id="c.vema_get_veswport_info">
void <code class="descname">vema_get_veswport_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get_veswport_info" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Get veswport info</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>pointer to the received mad</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>pointer to respose mad</dd>
</dl>
<dl class="function">
<dt id="c.vema_set_veswport_info">
void <code class="descname">vema_set_veswport_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_set_veswport_info" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Set veswport info</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>pointer to the received mad</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>pointer to respose mad</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets the port class infor for vnic</p>
<dl class="function">
<dt id="c.vema_get_mac_entries">
void <code class="descname">vema_get_mac_entries</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get_mac_entries" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Get MAC entries in VNIC MAC table</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>pointer to the received mad</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>pointer to respose mad</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets the MAC entries that are programmed into
the VNIC MAC forwarding table. It checks for the validity of
the index into the MAC table and the number of entries that
are to be retrieved.</p>
<dl class="function">
<dt id="c.vema_set_mac_entries">
void <code class="descname">vema_set_mac_entries</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_set_mac_entries" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Set MAC entries in VNIC MAC table</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>pointer to the received mad</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>pointer to respose mad</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets the MAC entries in the VNIC forwarding table
It checks for the validity of the index and the number of forwarding
table entries to be programmed.</p>
<dl class="function">
<dt id="c.vema_set_delete_vesw">
void <code class="descname">vema_set_delete_vesw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_set_delete_vesw" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Reset VESW info to POD values</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>pointer to the received mad</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>pointer to respose mad</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function clears all the fields of veswport info for the requested vesw
and sets them back to the power-on default values. It does not delete the
vesw.</p>
<dl class="function">
<dt id="c.vema_get_mac_list">
void <code class="descname">vema_get_mac_list</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em>, u16<em>&nbsp;attr_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get_mac_list" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Get the unicast/multicast macs.</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>Received mad contains fields to set vnic parameters</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>Response mad to be built</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">attr_id</span></code></dt>
<dd>Attribute ID indicating multicast or unicast mac list</dd>
</dl>
<dl class="function">
<dt id="c.vema_get_summary_counters">
void <code class="descname">vema_get_summary_counters</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get_summary_counters" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Gets summary counters.</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>Received mad contains fields to set vnic parameters</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>Response mad to be built</dd>
</dl>
<dl class="function">
<dt id="c.vema_get_error_counters">
void <code class="descname">vema_get_error_counters</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get_error_counters" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Gets summary counters.</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>Received mad contains fields to set vnic parameters</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>Response mad to be built</dd>
</dl>
<dl class="function">
<dt id="c.vema_get">
void <code class="descname">vema_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Process received get MAD</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>Received mad</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>Response mad to be built</dd>
</dl>
<dl class="function">
<dt id="c.vema_set">
void <code class="descname">vema_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> *<em>&nbsp;port</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;recvd_mad</em>, struct <a class="reference internal" href="#c.opa_vnic_vema_mad" title="opa_vnic_vema_mad">opa_vnic_vema_mad</a> *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_set" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Process received set MAD</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_port</span> <span class="pre">*</span> <span class="pre">port</span></code></dt>
<dd>source port on which MAD was received</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">recvd_mad</span></code></dt>
<dd>Received mad contains fields to set vnic parameters</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_vema_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>Response mad to be built</dd>
</dl>
<dl class="function">
<dt id="c.vema_send">
void <code class="descname">vema_send</code><span class="sig-paren">(</span>struct ib_mad_agent *<em>&nbsp;mad_agent</em>, struct ib_mad_send_wc *<em>&nbsp;mad_wc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_send" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Send handler for VEMA MAD agent</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_agent</span> <span class="pre">*</span> <span class="pre">mad_agent</span></code></dt>
<dd>pointer to the mad agent</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_send_wc</span> <span class="pre">*</span> <span class="pre">mad_wc</span></code></dt>
<dd>pointer to mad send work completion information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all the data structures associated with the sent MAD</p>
<dl class="function">
<dt id="c.vema_recv">
void <code class="descname">vema_recv</code><span class="sig-paren">(</span>struct ib_mad_agent *<em>&nbsp;mad_agent</em>, struct ib_mad_send_buf *<em>&nbsp;send_buf</em>, struct ib_mad_recv_wc *<em>&nbsp;mad_wc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_recv" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Recv handler for VEMA MAD agent</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_agent</span> <span class="pre">*</span> <span class="pre">mad_agent</span></code></dt>
<dd>pointer to the mad agent</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_send_buf</span> <span class="pre">*</span> <span class="pre">send_buf</span></code></dt>
<dd>Send buffer if found, else NULL</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_recv_wc</span> <span class="pre">*</span> <span class="pre">mad_wc</span></code></dt>
<dd>pointer to mad send work completion information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle only set and get methods and respond to other methods
as unsupported. Allocate response buffer and address handle
for the response MAD.</p>
<dl class="function">
<dt id="c.vema_get_port">
struct <a class="reference internal" href="#c.opa_vnic_vema_port" title="opa_vnic_vema_port">opa_vnic_vema_port</a> * <code class="descname">vema_get_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_ctrl_port" title="opa_vnic_ctrl_port">opa_vnic_ctrl_port</a> *<em>&nbsp;cport</em>, u8<em>&nbsp;port_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_get_port" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Gets the opa_vnic_vema_port</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_ctrl_port</span> <span class="pre">*</span> <span class="pre">cport</span></code></dt>
<dd>pointer to control dev</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>Port number</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function loops through the ports and returns
the opa_vnic_vema port structure that is associated
with the OPA port number</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>ptr to requested opa_vnic_vema_port strucure</dt>
<dd>if success, NULL if not</dd>
</dl>
<dl class="function">
<dt id="c.opa_vnic_vema_send_trap">
void <code class="descname">opa_vnic_vema_send_trap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_adapter" title="opa_vnic_adapter">opa_vnic_adapter</a> *<em>&nbsp;adapter</em>, struct __opa_veswport_trap *<em>&nbsp;data</em>, u32<em>&nbsp;lid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_vema_send_trap" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This function sends a trap to the EM</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>pointer to vnic adapter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__opa_veswport_trap</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointer to trap data filled by calling function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">lid</span></code></dt>
<dd>issuers lid (encap_slid from vesw_port_info)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from the VNIC driver to send a trap if there
is somethng the EM should be notified about. These events currently
are
1) UNICAST INTERFACE MACADDRESS changes
2) MULTICAST INTERFACE MACADDRESS changes
3) ETHERNET LINK STATUS changes
While allocating the send mad the remote site qpn used is 1
as this is the well known QP.</p>
<dl class="function">
<dt id="c.vema_unregister">
void <code class="descname">vema_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_ctrl_port" title="opa_vnic_ctrl_port">opa_vnic_ctrl_port</a> *<em>&nbsp;cport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_unregister" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Unregisters agent</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_ctrl_port</span> <span class="pre">*</span> <span class="pre">cport</span></code></dt>
<dd>pointer to control port</dd>
</dl>
<p><strong>Description</strong></p>
<p>This deletes the registration by VEMA for MADs</p>
<dl class="function">
<dt id="c.vema_register">
int <code class="descname">vema_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_ctrl_port" title="opa_vnic_ctrl_port">opa_vnic_ctrl_port</a> *<em>&nbsp;cport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vema_register" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Registers agent</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_ctrl_port</span> <span class="pre">*</span> <span class="pre">cport</span></code></dt>
<dd>pointer to control port</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers the handlers for the VEMA MADs</p>
<p><strong>Return</strong></p>
<p>returns 0 on success. non zero otherwise</p>
<dl class="function">
<dt id="c.opa_vnic_ctrl_config_dev">
void <code class="descname">opa_vnic_ctrl_config_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.opa_vnic_ctrl_port" title="opa_vnic_ctrl_port">opa_vnic_ctrl_port</a> *<em>&nbsp;cport</em>, bool<em>&nbsp;en</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_ctrl_config_dev" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>This function sends a trap to the EM by way of ib_modify_port to indicate support for ethernet on the fabric.</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">opa_vnic_ctrl_port</span> <span class="pre">*</span> <span class="pre">cport</span></code></dt>
<dd>pointer to control port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">en</span></code></dt>
<dd>enable or disable ethernet on fabric support</dd>
</dl>
<dl class="function">
<dt id="c.opa_vnic_vema_add_one">
void <code class="descname">opa_vnic_vema_add_one</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_vema_add_one" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Handle new ib device</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>ib device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the vnic control port and initialize it.</p>
<dl class="function">
<dt id="c.opa_vnic_vema_rem_one">
void <code class="descname">opa_vnic_vema_rem_one</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, void *<em>&nbsp;client_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.opa_vnic_vema_rem_one" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Handle ib device removal</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>ib device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">client_data</span></code></dt>
<dd>ib client data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uninitialize and free the vnic control port.</p>
</div>
<div class="section" id="infiniband-scsi-rdma-protocol-target-support">
<h3>InfiniBand SCSI RDMA protocol target support<a class="headerlink" href="#infiniband-scsi-rdma-protocol-target-support" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.srpt_command_state">
enum <code class="descname">srpt_command_state</code><a class="headerlink" href="#c.srpt_command_state" title="Permalink to this definition">¶</a></dt>
<dd><p>SCSI command state managed by SRPT</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">SRPT_STATE_NEW</span></code></dt>
<dd>New command arrived and is being processed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SRPT_STATE_NEED_DATA</span></code></dt>
<dd>Processing a write or bidir command and waiting
for data arrival.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SRPT_STATE_DATA_IN</span></code></dt>
<dd>Data for the write or bidir command arrived and is
being processed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SRPT_STATE_CMD_RSP_SENT</span></code></dt>
<dd>SRP_RSP for SRP_CMD has been sent.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SRPT_STATE_MGMT</span></code></dt>
<dd>Processing a SCSI task management command.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SRPT_STATE_MGMT_RSP_SENT</span></code></dt>
<dd>SRP_RSP for SRP_TSK_MGMT has been sent.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SRPT_STATE_DONE</span></code></dt>
<dd>Command processing finished successfully, command
processing has been aborted or command processing
failed.</dd>
</dl>
<dl class="type">
<dt id="c.srpt_ioctx">
struct <code class="descname">srpt_ioctx</code><a class="headerlink" href="#c.srpt_ioctx" title="Permalink to this definition">¶</a></dt>
<dd><p>shared SRPT I/O context information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_ioctx {
  struct ib_cqe           cqe;
  void *buf;
  dma_addr_t dma;
  uint32_t offset;
  uint32_t index;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">cqe</span></code></dt>
<dd>Completion queue element.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt>
<dd>Pointer to the buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma</span></code></dt>
<dd>DMA address of the buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt>
<dd>Offset of the first byte in <strong>buf</strong> and <strong>dma</strong> that is actually used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt>
<dd>Index of the I/O context in its ioctx_ring array.</dd>
</dl>
<dl class="type">
<dt id="c.srpt_recv_ioctx">
struct <code class="descname">srpt_recv_ioctx</code><a class="headerlink" href="#c.srpt_recv_ioctx" title="Permalink to this definition">¶</a></dt>
<dd><p>SRPT receive I/O context</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_recv_ioctx {
  struct srpt_ioctx       ioctx;
  struct list_head        wait_list;
  int byte_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ioctx</span></code></dt>
<dd>See above.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_list</span></code></dt>
<dd>Node for insertion in srpt_rdma_ch.cmd_wait_list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">byte_len</span></code></dt>
<dd>Number of bytes in <strong>ioctx.buf</strong>.</dd>
</dl>
<dl class="type">
<dt id="c.srpt_send_ioctx">
struct <code class="descname">srpt_send_ioctx</code><a class="headerlink" href="#c.srpt_send_ioctx" title="Permalink to this definition">¶</a></dt>
<dd><p>SRPT send I/O context</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_send_ioctx {
  struct srpt_ioctx       ioctx;
  struct srpt_rdma_ch     *ch;
  struct srpt_recv_ioctx  *recv_ioctx;
  struct srpt_rw_ctx      s_rw_ctx;
  struct srpt_rw_ctx      *rw_ctxs;
  struct scatterlist      imm_sg;
  struct ib_cqe           rdma_cqe;
  enum srpt_command_state state;
  struct se_cmd           cmd;
  u8 n_rdma;
  u8 n_rw_ctx;
  bool queue_status_only;
  u8 sense_data[TRANSPORT_SENSE_BUFFER];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">ioctx</span></code></dt>
<dd>See above.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ch</span></code></dt>
<dd>Channel pointer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">recv_ioctx</span></code></dt>
<dd>Receive I/O context associated with this send I/O context.
Only used for processing immediate data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_rw_ctx</span></code></dt>
<dd><strong>rw_ctxs</strong> points here if only a single rw_ctx is needed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rw_ctxs</span></code></dt>
<dd>RDMA read/write contexts.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">imm_sg</span></code></dt>
<dd>Scatterlist for immediate data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rdma_cqe</span></code></dt>
<dd>RDMA completion queue element.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt>
<dd>I/O context state.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt>
<dd>Target core command data structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_rdma</span></code></dt>
<dd>Number of work requests needed to transfer this ioctx.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_rw_ctx</span></code></dt>
<dd>Size of rw_ctxs array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue_status_only</span></code></dt>
<dd>Send a SCSI status back to the initiator but no data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sense_data</span></code></dt>
<dd>Sense data to be sent to the initiator.</dd>
</dl>
<dl class="type">
<dt id="c.rdma_ch_state">
enum <code class="descname">rdma_ch_state</code><a class="headerlink" href="#c.rdma_ch_state" title="Permalink to this definition">¶</a></dt>
<dd><p>SRP channel state</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">CH_CONNECTING</span></code></dt>
<dd>QP is in RTR state; waiting for RTU.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CH_LIVE</span></code></dt>
<dd>QP is in RTS state.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CH_DISCONNECTING</span></code></dt>
<dd>DREQ has been sent and waiting for DREP or DREQ has
been received.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CH_DRAINING</span></code></dt>
<dd>DREP has been received or waiting for DREP timed out
and last work request has been queued.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CH_DISCONNECTED</span></code></dt>
<dd>Last completion has been received.</dd>
</dl>
<dl class="type">
<dt id="c.srpt_rdma_ch">
struct <code class="descname">srpt_rdma_ch</code><a class="headerlink" href="#c.srpt_rdma_ch" title="Permalink to this definition">¶</a></dt>
<dd><p>RDMA channel</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_rdma_ch {
  struct srpt_nexus       *nexus;
  struct ib_qp            *qp;
  union {
    struct {
      struct ib_cm_id         *cm_id;
    } ib_cm;
    struct {
      struct rdma_cm_id       *cm_id;
    } rdma_cm;
  };
  struct ib_cq            *cq;
  struct ib_cqe           zw_cqe;
  struct rcu_head         rcu;
  struct kref             kref;
  struct completion       *closed;
  int rq_size;
  u32 max_rsp_size;
  atomic_t sq_wr_avail;
  struct srpt_port        *sport;
  int max_ti_iu_len;
  atomic_t req_lim;
  atomic_t req_lim_delta;
  u16 imm_data_offset;
  spinlock_t spinlock;
  enum rdma_ch_state      state;
  struct kmem_cache       *rsp_buf_cache;
  struct srpt_send_ioctx  **ioctx_ring;
  struct kmem_cache       *req_buf_cache;
  struct srpt_recv_ioctx  **ioctx_recv_ring;
  struct list_head        list;
  struct list_head        cmd_wait_list;
  uint16_t pkey;
  bool using_rdma_cm;
  bool processing_wait_list;
  struct se_session       *sess;
  u8 sess_name[40];
  struct work_struct      release_work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">nexus</span></code></dt>
<dd>I_T nexus this channel is associated with.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qp</span></code></dt>
<dd>IB queue pair used for communicating over this channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_cm</span></code></dt>
<dd>See below.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ib_cm.cm_id</span></code></dt>
<dd>IB CM ID associated with the channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rdma_cm</span></code></dt>
<dd>See below.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rdma_cm.cm_id</span></code></dt>
<dd>RDMA CM ID associated with the channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cq</span></code></dt>
<dd>IB completion queue for this channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zw_cqe</span></code></dt>
<dd>Zero-length write CQE.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt>
<dd>RCU head.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt>
<dd>kref for this channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">closed</span></code></dt>
<dd>Completion object that will be signaled as soon as a new
channel object with the same identity can be created.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rq_size</span></code></dt>
<dd>IB receive queue size.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_rsp_size</span></code></dt>
<dd>Maximum size of an RSP response message in bytes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sq_wr_avail</span></code></dt>
<dd>number of work requests available in the send queue.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sport</span></code></dt>
<dd>pointer to the information of the HCA port used by this
channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_ti_iu_len</span></code></dt>
<dd>maximum target-to-initiator information unit length.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_lim</span></code></dt>
<dd>request limit: maximum number of requests that may be sent
by the initiator without having received a response.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_lim_delta</span></code></dt>
<dd>Number of credits not yet sent back to the initiator.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">imm_data_offset</span></code></dt>
<dd>Offset from start of SRP_CMD for immediate data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock</span></code></dt>
<dd>Protects free_list and state.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt>
<dd>channel state. See also enum rdma_ch_state.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsp_buf_cache</span></code></dt>
<dd>kmem_cache for <strong>ioctx_ring</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctx_ring</span></code></dt>
<dd>Send ring.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_buf_cache</span></code></dt>
<dd>kmem_cache for <strong>ioctx_recv_ring</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctx_recv_ring</span></code></dt>
<dd>Receive I/O context ring.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>Node in srpt_nexus.ch_list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd_wait_list</span></code></dt>
<dd>List of SCSI commands that arrived before the RTU event. This
list contains struct srpt_ioctx elements and is protected
against concurrent modification by the cm_id spinlock.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pkey</span></code></dt>
<dd>P_Key of the IB partition for this SRP channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">using_rdma_cm</span></code></dt>
<dd>Whether the RDMA/CM or IB/CM is used for this channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">processing_wait_list</span></code></dt>
<dd>Whether or not cmd_wait_list is being processed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sess</span></code></dt>
<dd>Session information associated with this SRP channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sess_name</span></code></dt>
<dd>Session name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release_work</span></code></dt>
<dd>Allows scheduling of srpt_release_channel().</dd>
</dl>
<dl class="type">
<dt id="c.srpt_nexus">
struct <code class="descname">srpt_nexus</code><a class="headerlink" href="#c.srpt_nexus" title="Permalink to this definition">¶</a></dt>
<dd><p>I_T nexus</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_nexus {
  struct rcu_head         rcu;
  struct list_head        entry;
  struct list_head        ch_list;
  u8 i_port_id[16];
  u8 t_port_id[16];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt>
<dd>RCU head for this data structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd>srpt_port.nexus_list list node.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ch_list</span></code></dt>
<dd>struct srpt_rdma_ch list. Protected by srpt_port.mutex.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i_port_id</span></code></dt>
<dd>128-bit initiator port identifier copied from SRP_LOGIN_REQ.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">t_port_id</span></code></dt>
<dd>128-bit target port identifier copied from SRP_LOGIN_REQ.</dd>
</dl>
<dl class="type">
<dt id="c.srpt_port_attrib">
struct <code class="descname">srpt_port_attrib</code><a class="headerlink" href="#c.srpt_port_attrib" title="Permalink to this definition">¶</a></dt>
<dd><p>attributes for SRPT port</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_port_attrib {
  u32 srp_max_rdma_size;
  u32 srp_max_rsp_size;
  u32 srp_sq_size;
  bool use_srq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">srp_max_rdma_size</span></code></dt>
<dd>Maximum size of SRP RDMA transfers for new connections.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">srp_max_rsp_size</span></code></dt>
<dd>Maximum size of SRP response messages in bytes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">srp_sq_size</span></code></dt>
<dd>Shared receive queue (SRQ) size.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_srq</span></code></dt>
<dd>Whether or not to use SRQ.</dd>
</dl>
<dl class="type">
<dt id="c.srpt_tpg">
struct <code class="descname">srpt_tpg</code><a class="headerlink" href="#c.srpt_tpg" title="Permalink to this definition">¶</a></dt>
<dd><p>information about a single “target portal group”</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_tpg {
  struct list_head        entry;
  struct srpt_port_id     *sport_id;
  struct se_portal_group  tpg;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt>
<dd>Entry in <strong>sport_id-&gt;tpg_list</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sport_id</span></code></dt>
<dd>Port name this TPG is associated with.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tpg</span></code></dt>
<dd>LIO TPG data structure.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero or more target portal groups are associated with each port name
(srpt_port_id). With each TPG an ACL list is associated.</p>
<dl class="type">
<dt id="c.srpt_port_id">
struct <code class="descname">srpt_port_id</code><a class="headerlink" href="#c.srpt_port_id" title="Permalink to this definition">¶</a></dt>
<dd><p>information about an RDMA port name</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_port_id {
  struct mutex            mutex;
  struct list_head        tpg_list;
  struct se_wwn           wwn;
  char name[64];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt>
<dd>Protects <strong>tpg_list</strong> changes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tpg_list</span></code></dt>
<dd>TPGs associated with the RDMA port name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wwn</span></code></dt>
<dd>WWN associated with the RDMA port name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>ASCII representation of the port name.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Multiple sysfs directories can be associated with a single RDMA port. This
data structure represents a single (port, name) pair.</p>
<dl class="type">
<dt id="c.srpt_port">
struct <code class="descname">srpt_port</code><a class="headerlink" href="#c.srpt_port" title="Permalink to this definition">¶</a></dt>
<dd><p>information associated by SRPT with a single IB port</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_port {
  struct srpt_device      *sdev;
  struct ib_mad_agent     *mad_agent;
  bool enabled;
  u8 port;
  u32 sm_lid;
  u32 lid;
  union ib_gid            gid;
  struct work_struct      work;
  struct srpt_port_id     port_guid_id;
  struct srpt_port_id     port_gid_id;
  struct srpt_port_attrib port_attrib;
  atomic_t refcount;
  struct completion       *freed_channels;
  struct mutex            mutex;
  struct list_head        nexus_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sdev</span></code></dt>
<dd>backpointer to the HCA information.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mad_agent</span></code></dt>
<dd>per-port management datagram processing information.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt>
<dd>Whether or not this target port is enabled.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt>
<dd>one-based port number.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sm_lid</span></code></dt>
<dd>cached value of the port’s sm_lid.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lid</span></code></dt>
<dd>cached value of the port’s lid.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gid</span></code></dt>
<dd>cached value of the port’s gid.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt>
<dd>work structure for refreshing the aforementioned cached values.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_guid_id</span></code></dt>
<dd>target port GUID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_gid_id</span></code></dt>
<dd>target port GID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_attrib</span></code></dt>
<dd>Port attributes that can be accessed through configfs.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt>
<dd>Number of objects associated with this port.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freed_channels</span></code></dt>
<dd>Completion that will be signaled once <strong>refcount</strong> becomes 0.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt>
<dd>Protects nexus_list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nexus_list</span></code></dt>
<dd>Nexus list. See also srpt_nexus.entry.</dd>
</dl>
<dl class="type">
<dt id="c.srpt_device">
struct <code class="descname">srpt_device</code><a class="headerlink" href="#c.srpt_device" title="Permalink to this definition">¶</a></dt>
<dd><p>information associated by SRPT with a single HCA</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct srpt_device {
  struct ib_device        *device;
  struct ib_pd            *pd;
  u32 lkey;
  struct ib_srq           *srq;
  struct ib_cm_id         *cm_id;
  int srq_size;
  struct mutex            sdev_mutex;
  bool use_srq;
  struct kmem_cache       *req_buf_cache;
  struct srpt_recv_ioctx  **ioctx_ring;
  struct ib_event_handler event_handler;
  struct list_head        list;
  struct srpt_port        port[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">device</span></code></dt>
<dd>Backpointer to the struct ib_device managed by the IB core.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pd</span></code></dt>
<dd>IB protection domain.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lkey</span></code></dt>
<dd>L_Key (local key) with write access to all local memory.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">srq</span></code></dt>
<dd>Per-HCA SRQ (shared receive queue).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cm_id</span></code></dt>
<dd>Connection identifier.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">srq_size</span></code></dt>
<dd>SRQ size.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sdev_mutex</span></code></dt>
<dd>Serializes use_srq changes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_srq</span></code></dt>
<dd>Whether or not to use SRQ.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_buf_cache</span></code></dt>
<dd>kmem_cache for <strong>ioctx_ring</strong> buffers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctx_ring</span></code></dt>
<dd>Per-HCA SRQ.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event_handler</span></code></dt>
<dd>Per-HCA asynchronous IB event handler.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>Node in srpt_dev_list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt>
<dd>Information about the ports owned by this HCA.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_event_handler">
void <code class="descname">srpt_event_handler</code><span class="sig-paren">(</span>struct ib_event_handler *<em>&nbsp;handler</em>, struct ib_event *<em>&nbsp;event</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_event_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous IB event callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_event_handler</span> <span class="pre">*</span> <span class="pre">handler</span></code></dt>
<dd>IB event handler registered by <a class="reference internal" href="#c.ib_register_event_handler" title="ib_register_event_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_register_event_handler()</span></code></a>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_event</span> <span class="pre">*</span> <span class="pre">event</span></code></dt>
<dd>Description of the event that occurred.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback function called by the InfiniBand core when an asynchronous IB
event occurs. This callback may occur in interrupt context. See also
section 11.5.2, Set Asynchronous Event Handler in the InfiniBand
Architecture Specification.</p>
<dl class="function">
<dt id="c.srpt_srq_event">
void <code class="descname">srpt_srq_event</code><span class="sig-paren">(</span>struct ib_event *<em>&nbsp;event</em>, void *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_srq_event" title="Permalink to this definition">¶</a></dt>
<dd><p>SRQ event callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_event</span> <span class="pre">*</span> <span class="pre">event</span></code></dt>
<dd>Description of the event that occurred.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>Context pointer specified at SRQ creation time.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_qp_event">
void <code class="descname">srpt_qp_event</code><span class="sig-paren">(</span>struct ib_event *<em>&nbsp;event</em>, struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_qp_event" title="Permalink to this definition">¶</a></dt>
<dd><p>QP event callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_event</span> <span class="pre">*</span> <span class="pre">event</span></code></dt>
<dd>Description of the event that occurred.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_set_ioc">
void <code class="descname">srpt_set_ioc</code><span class="sig-paren">(</span>u8 *<em>&nbsp;c_list</em>, u32<em>&nbsp;slot</em>, u8<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_set_ioc" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a IOUnitInfo structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">c_list</span></code></dt>
<dd>controller list.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">slot</span></code></dt>
<dd>one-based slot number.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">value</span></code></dt>
<dd>four-bit value.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies the lowest four bits of value in element slot of the array of four
bit elements called c_list (controller list). The index slot is one-based.</p>
<dl class="function">
<dt id="c.srpt_get_class_port_info">
void <code class="descname">srpt_get_class_port_info</code><span class="sig-paren">(</span>struct ib_dm_mad *<em>&nbsp;mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_get_class_port_info" title="Permalink to this definition">¶</a></dt>
<dd><p>copy ClassPortInfo to a management datagram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_dm_mad</span> <span class="pre">*</span> <span class="pre">mad</span></code></dt>
<dd>Datagram that will be sent as response to DM_ATTR_CLASS_PORT_INFO.</dd>
</dl>
<p><strong>Description</strong></p>
<p>See also section 16.3.3.1 ClassPortInfo in the InfiniBand Architecture
Specification.</p>
<dl class="function">
<dt id="c.srpt_get_iou">
void <code class="descname">srpt_get_iou</code><span class="sig-paren">(</span>struct ib_dm_mad *<em>&nbsp;mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_get_iou" title="Permalink to this definition">¶</a></dt>
<dd><p>write IOUnitInfo to a management datagram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_dm_mad</span> <span class="pre">*</span> <span class="pre">mad</span></code></dt>
<dd>Datagram that will be sent as response to DM_ATTR_IOU_INFO.</dd>
</dl>
<p><strong>Description</strong></p>
<p>See also section 16.3.3.3 IOUnitInfo in the InfiniBand Architecture
Specification. See also section B.7, table B.6 in the SRP r16a document.</p>
<dl class="function">
<dt id="c.srpt_get_ioc">
void <code class="descname">srpt_get_ioc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_port" title="srpt_port">srpt_port</a> *<em>&nbsp;sport</em>, u32<em>&nbsp;slot</em>, struct ib_dm_mad *<em>&nbsp;mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_get_ioc" title="Permalink to this definition">¶</a></dt>
<dd><p>write IOControllerprofile to a management datagram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_port</span> <span class="pre">*</span> <span class="pre">sport</span></code></dt>
<dd>HCA port through which the MAD has been received.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">slot</span></code></dt>
<dd>Slot number specified in DM_ATTR_IOC_PROFILE query.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_dm_mad</span> <span class="pre">*</span> <span class="pre">mad</span></code></dt>
<dd>Datagram that will be sent as response to DM_ATTR_IOC_PROFILE.</dd>
</dl>
<p><strong>Description</strong></p>
<p>See also section 16.3.3.4 IOControllerProfile in the InfiniBand
Architecture Specification. See also section B.7, table B.7 in the SRP
r16a document.</p>
<dl class="function">
<dt id="c.srpt_get_svc_entries">
void <code class="descname">srpt_get_svc_entries</code><span class="sig-paren">(</span>u64<em>&nbsp;ioc_guid</em>, u16<em>&nbsp;slot</em>, u8<em>&nbsp;hi</em>, u8<em>&nbsp;lo</em>, struct ib_dm_mad *<em>&nbsp;mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_get_svc_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>write ServiceEntries to a management datagram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">ioc_guid</span></code></dt>
<dd>I/O controller GUID to use in reply.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">slot</span></code></dt>
<dd>I/O controller number.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">hi</span></code></dt>
<dd>End of the range of service entries to be specified in the reply.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">lo</span></code></dt>
<dd>Start of the range of service entries to be specified in the reply..</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_dm_mad</span> <span class="pre">*</span> <span class="pre">mad</span></code></dt>
<dd>Datagram that will be sent as response to DM_ATTR_SVC_ENTRIES.</dd>
</dl>
<p><strong>Description</strong></p>
<p>See also section 16.3.3.5 ServiceEntries in the InfiniBand Architecture
Specification. See also section B.7, table B.8 in the SRP r16a document.</p>
<dl class="function">
<dt id="c.srpt_mgmt_method_get">
void <code class="descname">srpt_mgmt_method_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_port" title="srpt_port">srpt_port</a> *<em>&nbsp;sp</em>, struct ib_mad *<em>&nbsp;rq_mad</em>, struct ib_dm_mad *<em>&nbsp;rsp_mad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_mgmt_method_get" title="Permalink to this definition">¶</a></dt>
<dd><p>process a received management datagram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_port</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>HCA port through which the MAD has been received.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad</span> <span class="pre">*</span> <span class="pre">rq_mad</span></code></dt>
<dd>received MAD.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_dm_mad</span> <span class="pre">*</span> <span class="pre">rsp_mad</span></code></dt>
<dd>response MAD.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_mad_send_handler">
void <code class="descname">srpt_mad_send_handler</code><span class="sig-paren">(</span>struct ib_mad_agent *<em>&nbsp;mad_agent</em>, struct ib_mad_send_wc *<em>&nbsp;mad_wc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_mad_send_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>MAD send completion callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_agent</span> <span class="pre">*</span> <span class="pre">mad_agent</span></code></dt>
<dd>Return value of ib_register_mad_agent().</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_send_wc</span> <span class="pre">*</span> <span class="pre">mad_wc</span></code></dt>
<dd>Work completion reporting that the MAD has been sent.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_mad_recv_handler">
void <code class="descname">srpt_mad_recv_handler</code><span class="sig-paren">(</span>struct ib_mad_agent *<em>&nbsp;mad_agent</em>, struct ib_mad_send_buf *<em>&nbsp;send_buf</em>, struct ib_mad_recv_wc *<em>&nbsp;mad_wc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_mad_recv_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>MAD reception callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_agent</span> <span class="pre">*</span> <span class="pre">mad_agent</span></code></dt>
<dd>Return value of ib_register_mad_agent().</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_send_buf</span> <span class="pre">*</span> <span class="pre">send_buf</span></code></dt>
<dd>Not used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_mad_recv_wc</span> <span class="pre">*</span> <span class="pre">mad_wc</span></code></dt>
<dd>Work completion reporting that a MAD has been received.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_refresh_port">
int <code class="descname">srpt_refresh_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_port" title="srpt_port">srpt_port</a> *<em>&nbsp;sport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_refresh_port" title="Permalink to this definition">¶</a></dt>
<dd><p>configure a HCA port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_port</span> <span class="pre">*</span> <span class="pre">sport</span></code></dt>
<dd>SRPT HCA port.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable InfiniBand management datagram processing, update the cached sm_lid,
lid and gid values, and register a callback function for processing MADs
on the specified port.</p>
<p><strong>Note</strong></p>
<p>It is safe to call this function more than once for the same port.</p>
<dl class="function">
<dt id="c.srpt_unregister_mad_agent">
void <code class="descname">srpt_unregister_mad_agent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_device" title="srpt_device">srpt_device</a> *<em>&nbsp;sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_unregister_mad_agent" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister MAD callback functions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>SRPT HCA pointer.</dd>
</dl>
<p><strong>Note</strong></p>
<p>It is safe to call this function more than once for the same device.</p>
<dl class="function">
<dt id="c.srpt_alloc_ioctx">
struct <a class="reference internal" href="#c.srpt_ioctx" title="srpt_ioctx">srpt_ioctx</a> * <code class="descname">srpt_alloc_ioctx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_device" title="srpt_device">srpt_device</a> *<em>&nbsp;sdev</em>, int<em>&nbsp;ioctx_size</em>, struct kmem_cache *<em>&nbsp;buf_cache</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_alloc_ioctx" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a SRPT I/O context structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>SRPT HCA pointer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ioctx_size</span></code></dt>
<dd>I/O context size.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">buf_cache</span></code></dt>
<dd>I/O buffer cache.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA data direction.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_free_ioctx">
void <code class="descname">srpt_free_ioctx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_device" title="srpt_device">srpt_device</a> *<em>&nbsp;sdev</em>, struct <a class="reference internal" href="#c.srpt_ioctx" title="srpt_ioctx">srpt_ioctx</a> *<em>&nbsp;ioctx</em>, struct kmem_cache *<em>&nbsp;buf_cache</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_free_ioctx" title="Permalink to this definition">¶</a></dt>
<dd><p>free a SRPT I/O context structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>SRPT HCA pointer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_ioctx</span> <span class="pre">*</span> <span class="pre">ioctx</span></code></dt>
<dd>I/O context pointer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">buf_cache</span></code></dt>
<dd>I/O buffer cache.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA data direction.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_alloc_ioctx_ring">
struct <a class="reference internal" href="#c.srpt_ioctx" title="srpt_ioctx">srpt_ioctx</a> ** <code class="descname">srpt_alloc_ioctx_ring</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_device" title="srpt_device">srpt_device</a> *<em>&nbsp;sdev</em>, int<em>&nbsp;ring_size</em>, int<em>&nbsp;ioctx_size</em>, struct kmem_cache *<em>&nbsp;buf_cache</em>, int<em>&nbsp;alignment_offset</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_alloc_ioctx_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a ring of SRPT I/O context structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>Device to allocate the I/O context ring for.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ring_size</span></code></dt>
<dd>Number of elements in the I/O context ring.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ioctx_size</span></code></dt>
<dd>I/O context size.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">buf_cache</span></code></dt>
<dd>I/O buffer cache.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">alignment_offset</span></code></dt>
<dd>Offset in each ring buffer at which the SRP information
unit starts.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA data direction.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_free_ioctx_ring">
void <code class="descname">srpt_free_ioctx_ring</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_ioctx" title="srpt_ioctx">srpt_ioctx</a> **<em>&nbsp;ioctx_ring</em>, struct <a class="reference internal" href="#c.srpt_device" title="srpt_device">srpt_device</a> *<em>&nbsp;sdev</em>, int<em>&nbsp;ring_size</em>, struct kmem_cache *<em>&nbsp;buf_cache</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_free_ioctx_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>free the ring of SRPT I/O context structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_ioctx</span> <span class="pre">**</span> <span class="pre">ioctx_ring</span></code></dt>
<dd>I/O context ring to be freed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>SRPT HCA pointer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ring_size</span></code></dt>
<dd>Number of ring elements.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">buf_cache</span></code></dt>
<dd>I/O buffer cache.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA data direction.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_set_cmd_state">
enum <a class="reference internal" href="#c.srpt_command_state" title="srpt_command_state">srpt_command_state</a> <code class="descname">srpt_set_cmd_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_send_ioctx" title="srpt_send_ioctx">srpt_send_ioctx</a> *<em>&nbsp;ioctx</em>, enum <a class="reference internal" href="#c.srpt_command_state" title="srpt_command_state">srpt_command_state</a><em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_set_cmd_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set the state of a SCSI command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_send_ioctx</span> <span class="pre">*</span> <span class="pre">ioctx</span></code></dt>
<dd>Send I/O context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">srpt_command_state</span> <span class="pre">new</span></code></dt>
<dd>New I/O context state.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Does not modify the state of aborted commands. Returns the previous command
state.</p>
<dl class="function">
<dt id="c.srpt_test_and_set_cmd_state">
bool <code class="descname">srpt_test_and_set_cmd_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_send_ioctx" title="srpt_send_ioctx">srpt_send_ioctx</a> *<em>&nbsp;ioctx</em>, enum <a class="reference internal" href="#c.srpt_command_state" title="srpt_command_state">srpt_command_state</a><em>&nbsp;old</em>, enum <a class="reference internal" href="#c.srpt_command_state" title="srpt_command_state">srpt_command_state</a><em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_test_and_set_cmd_state" title="Permalink to this definition">¶</a></dt>
<dd><p>test and set the state of a command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_send_ioctx</span> <span class="pre">*</span> <span class="pre">ioctx</span></code></dt>
<dd>Send I/O context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">srpt_command_state</span> <span class="pre">old</span></code></dt>
<dd>Current I/O context state.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">srpt_command_state</span> <span class="pre">new</span></code></dt>
<dd>New I/O context state.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if and only if the previous command state was equal to ‘old’.</p>
<dl class="function">
<dt id="c.srpt_post_recv">
int <code class="descname">srpt_post_recv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_device" title="srpt_device">srpt_device</a> *<em>&nbsp;sdev</em>, struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em>, struct <a class="reference internal" href="#c.srpt_recv_ioctx" title="srpt_recv_ioctx">srpt_recv_ioctx</a> *<em>&nbsp;ioctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_post_recv" title="Permalink to this definition">¶</a></dt>
<dd><p>post an IB receive request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>SRPT HCA pointer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_recv_ioctx</span> <span class="pre">*</span> <span class="pre">ioctx</span></code></dt>
<dd>Receive I/O context pointer.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_zerolength_write">
int <code class="descname">srpt_zerolength_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_zerolength_write" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a zero-length RDMA write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A quote from the InfiniBand specification: C9-88: For an HCA responder
using Reliable Connection service, for each zero-length RDMA READ or WRITE
request, the R_Key shall not be validated, even if the request includes
Immediate data.</p>
<dl class="function">
<dt id="c.srpt_get_desc_tbl">
int <code class="descname">srpt_get_desc_tbl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_recv_ioctx" title="srpt_recv_ioctx">srpt_recv_ioctx</a> *<em>&nbsp;recv_ioctx</em>, struct <a class="reference internal" href="#c.srpt_send_ioctx" title="srpt_send_ioctx">srpt_send_ioctx</a> *<em>&nbsp;ioctx</em>, struct srp_cmd *<em>&nbsp;srp_cmd</em>, enum dma_data_direction *<em>&nbsp;dir</em>, struct scatterlist **<em>&nbsp;sg</em>, unsigned int *<em>&nbsp;sg_cnt</em>, u64 *<em>&nbsp;data_len</em>, u16<em>&nbsp;imm_data_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_get_desc_tbl" title="Permalink to this definition">¶</a></dt>
<dd><p>parse the data descriptors of a SRP_CMD request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_recv_ioctx</span> <span class="pre">*</span> <span class="pre">recv_ioctx</span></code></dt>
<dd>I/O context associated with the received command <strong>srp_cmd</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_send_ioctx</span> <span class="pre">*</span> <span class="pre">ioctx</span></code></dt>
<dd>I/O context that will be used for responding to the initiator.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_cmd</span> <span class="pre">*</span> <span class="pre">srp_cmd</span></code></dt>
<dd>Pointer to the SRP_CMD request data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>Pointer to the variable to which the transfer direction will be
written.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">**</span> <span class="pre">sg</span></code></dt>
<dd>[out] scatterlist for the parsed SRP_CMD.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">sg_cnt</span></code></dt>
<dd>[out] length of <strong>sg</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">data_len</span></code></dt>
<dd>Pointer to the variable to which the total data length of all
descriptors in the SRP_CMD request will be written.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">imm_data_offset</span></code></dt>
<dd>[in] Offset in SRP_CMD requests at which immediate data
starts.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes ioctx-&gt;nrbuf and ioctx-&gt;r_bufs.</p>
<p>Returns -EINVAL when the SRP_CMD request contains inconsistent descriptors;
-ENOMEM when memory allocation fails and zero upon success.</p>
<dl class="function">
<dt id="c.srpt_init_ch_qp">
int <code class="descname">srpt_init_ch_qp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em>, struct ib_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_init_ch_qp" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize queue pair attributes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>Queue pair pointer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialized the attributes of queue pair ‘qp’ by allowing local write,
remote read and remote write. Also transitions ‘qp’ to state IB_QPS_INIT.</p>
<dl class="function">
<dt id="c.srpt_ch_qp_rtr">
int <code class="descname">srpt_ch_qp_rtr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em>, struct ib_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_ch_qp_rtr" title="Permalink to this definition">¶</a></dt>
<dd><p>change the state of a channel to ‘ready to receive’ (RTR)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>channel of the queue pair.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to change the state of.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero upon success and a negative value upon failure.</p>
<p><strong>Note</strong></p>
<p>currently a struct ib_qp_attr takes 136 bytes on a 64-bit system.
If this structure ever becomes larger, it might be necessary to allocate
it dynamically instead of on the stack.</p>
<dl class="function">
<dt id="c.srpt_ch_qp_rts">
int <code class="descname">srpt_ch_qp_rts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em>, struct ib_qp *<em>&nbsp;qp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_ch_qp_rts" title="Permalink to this definition">¶</a></dt>
<dd><p>change the state of a channel to ‘ready to send’ (RTS)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>channel of the queue pair.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_qp</span> <span class="pre">*</span> <span class="pre">qp</span></code></dt>
<dd>queue pair to change the state of.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero upon success and a negative value upon failure.</p>
<p><strong>Note</strong></p>
<p>currently a struct ib_qp_attr takes 136 bytes on a 64-bit system.
If this structure ever becomes larger, it might be necessary to allocate
it dynamically instead of on the stack.</p>
<dl class="function">
<dt id="c.srpt_ch_qp_err">
int <code class="descname">srpt_ch_qp_err</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_ch_qp_err" title="Permalink to this definition">¶</a></dt>
<dd><p>set the channel queue pair state to ‘error’</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_get_send_ioctx">
struct <a class="reference internal" href="#c.srpt_send_ioctx" title="srpt_send_ioctx">srpt_send_ioctx</a> * <code class="descname">srpt_get_send_ioctx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_get_send_ioctx" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an I/O context for sending to the initiator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_abort_cmd">
int <code class="descname">srpt_abort_cmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_send_ioctx" title="srpt_send_ioctx">srpt_send_ioctx</a> *<em>&nbsp;ioctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_abort_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>abort a SCSI command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_send_ioctx</span> <span class="pre">*</span> <span class="pre">ioctx</span></code></dt>
<dd>I/O context associated with the SCSI command.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_rdma_read_done">
void <code class="descname">srpt_rdma_read_done</code><span class="sig-paren">(</span>struct ib_cq *<em>&nbsp;cq</em>, struct ib_wc *<em>&nbsp;wc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_rdma_read_done" title="Permalink to this definition">¶</a></dt>
<dd><p>RDMA read completion callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_cq</span> <span class="pre">*</span> <span class="pre">cq</span></code></dt>
<dd>Completion queue.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_wc</span> <span class="pre">*</span> <span class="pre">wc</span></code></dt>
<dd>Work completion.</dd>
</dl>
<p><strong>Description</strong></p>
<p>XXX: what is now target_execute_cmd used to be asynchronous, and unmapping
the data that has been transferred via IB RDMA had to be postponed until the
check_stop_free() callback.  None of this is necessary anymore and needs to
be cleaned up.</p>
<dl class="function">
<dt id="c.srpt_build_cmd_rsp">
int <code class="descname">srpt_build_cmd_rsp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em>, struct <a class="reference internal" href="#c.srpt_send_ioctx" title="srpt_send_ioctx">srpt_send_ioctx</a> *<em>&nbsp;ioctx</em>, u64<em>&nbsp;tag</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_build_cmd_rsp" title="Permalink to this definition">¶</a></dt>
<dd><p>build a SRP_RSP response</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>RDMA channel through which the request has been received.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_send_ioctx</span> <span class="pre">*</span> <span class="pre">ioctx</span></code></dt>
<dd>I/O context associated with the SRP_CMD request. The response will
be built in the buffer ioctx-&gt;buf points at and hence this function will
overwrite the request data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">tag</span></code></dt>
<dd>tag of the request for which this response is being generated.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>value for the STATUS field of the SRP_RSP information unit.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the size in bytes of the SRP_RSP response.</p>
<p>An SRP_RSP response contains a SCSI status or service response. See also
section 6.9 in the SRP r16a document for the format of an SRP_RSP
response. See also SPC-2 for more information about sense data.</p>
<dl class="function">
<dt id="c.srpt_build_tskmgmt_rsp">
int <code class="descname">srpt_build_tskmgmt_rsp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em>, struct <a class="reference internal" href="#c.srpt_send_ioctx" title="srpt_send_ioctx">srpt_send_ioctx</a> *<em>&nbsp;ioctx</em>, u8<em>&nbsp;rsp_code</em>, u64<em>&nbsp;tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_build_tskmgmt_rsp" title="Permalink to this definition">¶</a></dt>
<dd><p>build a task management response</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>RDMA channel through which the request has been received.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_send_ioctx</span> <span class="pre">*</span> <span class="pre">ioctx</span></code></dt>
<dd>I/O context in which the SRP_RSP response will be built.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">rsp_code</span></code></dt>
<dd>RSP_CODE that will be stored in the response.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">tag</span></code></dt>
<dd>Tag of the request for which this response is being generated.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the size in bytes of the SRP_RSP response.</p>
<p>An SRP_RSP response contains a SCSI status or service response. See also
section 6.9 in the SRP r16a document for the format of an SRP_RSP
response.</p>
<dl class="function">
<dt id="c.srpt_handle_cmd">
void <code class="descname">srpt_handle_cmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em>, struct <a class="reference internal" href="#c.srpt_recv_ioctx" title="srpt_recv_ioctx">srpt_recv_ioctx</a> *<em>&nbsp;recv_ioctx</em>, struct <a class="reference internal" href="#c.srpt_send_ioctx" title="srpt_send_ioctx">srpt_send_ioctx</a> *<em>&nbsp;send_ioctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_handle_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>process a SRP_CMD information unit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_recv_ioctx</span> <span class="pre">*</span> <span class="pre">recv_ioctx</span></code></dt>
<dd>Receive I/O context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_send_ioctx</span> <span class="pre">*</span> <span class="pre">send_ioctx</span></code></dt>
<dd>Send I/O context.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_handle_tsk_mgmt">
void <code class="descname">srpt_handle_tsk_mgmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em>, struct <a class="reference internal" href="#c.srpt_recv_ioctx" title="srpt_recv_ioctx">srpt_recv_ioctx</a> *<em>&nbsp;recv_ioctx</em>, struct <a class="reference internal" href="#c.srpt_send_ioctx" title="srpt_send_ioctx">srpt_send_ioctx</a> *<em>&nbsp;send_ioctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_handle_tsk_mgmt" title="Permalink to this definition">¶</a></dt>
<dd><p>process a SRP_TSK_MGMT information unit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_recv_ioctx</span> <span class="pre">*</span> <span class="pre">recv_ioctx</span></code></dt>
<dd>Receive I/O context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_send_ioctx</span> <span class="pre">*</span> <span class="pre">send_ioctx</span></code></dt>
<dd>Send I/O context.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if and only if the request will be processed by the target core.</p>
<p>For more information about SRP_TSK_MGMT information units, see also section
6.7 in the SRP r16a document.</p>
<dl class="function">
<dt id="c.srpt_handle_new_iu">
bool <code class="descname">srpt_handle_new_iu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em>, struct <a class="reference internal" href="#c.srpt_recv_ioctx" title="srpt_recv_ioctx">srpt_recv_ioctx</a> *<em>&nbsp;recv_ioctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_handle_new_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>process a newly received information unit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>RDMA channel through which the information unit has been received.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_recv_ioctx</span> <span class="pre">*</span> <span class="pre">recv_ioctx</span></code></dt>
<dd>Receive I/O context associated with the information unit.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_send_done">
void <code class="descname">srpt_send_done</code><span class="sig-paren">(</span>struct ib_cq *<em>&nbsp;cq</em>, struct ib_wc *<em>&nbsp;wc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_send_done" title="Permalink to this definition">¶</a></dt>
<dd><p>send completion callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_cq</span> <span class="pre">*</span> <span class="pre">cq</span></code></dt>
<dd>Completion queue.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_wc</span> <span class="pre">*</span> <span class="pre">wc</span></code></dt>
<dd>Work completion.</dd>
</dl>
<p><strong>Note</strong></p>
<p>Although this has not yet been observed during tests, at least in
theory it is possible that the <a class="reference internal" href="#c.srpt_get_send_ioctx" title="srpt_get_send_ioctx"><code class="xref c c-func docutils literal notranslate"><span class="pre">srpt_get_send_ioctx()</span></code></a> call invoked by
<a class="reference internal" href="#c.srpt_handle_new_iu" title="srpt_handle_new_iu"><code class="xref c c-func docutils literal notranslate"><span class="pre">srpt_handle_new_iu()</span></code></a> fails. This is possible because the req_lim_delta
value in each response is set to one, and it is possible that this response
makes the initiator send a new request before the send completion for that
response has been processed. This could e.g. happen if the call to
srpt_put_send_iotcx() is delayed because of a higher priority interrupt or
if IB retransmission causes generation of the send completion to be
delayed. Incoming information units for which <a class="reference internal" href="#c.srpt_get_send_ioctx" title="srpt_get_send_ioctx"><code class="xref c c-func docutils literal notranslate"><span class="pre">srpt_get_send_ioctx()</span></code></a> fails
are queued on cmd_wait_list. The code below processes these delayed
requests one at a time.</p>
<dl class="function">
<dt id="c.srpt_create_ch_ib">
int <code class="descname">srpt_create_ch_ib</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_create_ch_ib" title="Permalink to this definition">¶</a></dt>
<dd><p>create receive and send completion queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_close_ch">
bool <code class="descname">srpt_close_ch</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_close_ch" title="Permalink to this definition">¶</a></dt>
<dd><p>close a RDMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure all resources associated with the channel will be deallocated at
an appropriate time.</p>
<p>Returns true if and only if the channel state has been modified into
CH_DRAINING.</p>
<dl class="function">
<dt id="c.srpt_cm_req_recv">
int <code class="descname">srpt_cm_req_recv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_device" title="srpt_device">srpt_device</a> *const<em>&nbsp;sdev</em>, struct ib_cm_id *<em>&nbsp;ib_cm_id</em>, struct rdma_cm_id *<em>&nbsp;rdma_cm_id</em>, u8<em>&nbsp;port_num</em>, __be16<em>&nbsp;pkey</em>, const struct srp_login_req *<em>&nbsp;req</em>, const char *<em>&nbsp;src_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_cm_req_recv" title="Permalink to this definition">¶</a></dt>
<dd><p>process the event IB_CM_REQ_RECEIVED</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_device</span> <span class="pre">*const</span> <span class="pre">sdev</span></code></dt>
<dd>HCA through which the login request was received.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_cm_id</span> <span class="pre">*</span> <span class="pre">ib_cm_id</span></code></dt>
<dd>IB/CM connection identifier in case of IB/CM.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rdma_cm_id</span> <span class="pre">*</span> <span class="pre">rdma_cm_id</span></code></dt>
<dd>RDMA/CM connection identifier in case of RDMA/CM.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">port_num</span></code></dt>
<dd>Port through which the REQ message was received.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be16</span> <span class="pre">pkey</span></code></dt>
<dd>P_Key of the incoming connection.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">srp_login_req</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>SRP login request.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src_addr</span></code></dt>
<dd>GID (IB/CM) or IP address (RDMA/CM) of the port that submitted
the login request.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ownership of the cm_id is transferred to the target session if this
function returns zero. Otherwise the caller remains the owner of cm_id.</p>
<dl class="function">
<dt id="c.srpt_cm_rtu_recv">
void <code class="descname">srpt_cm_rtu_recv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_rdma_ch" title="srpt_rdma_ch">srpt_rdma_ch</a> *<em>&nbsp;ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_cm_rtu_recv" title="Permalink to this definition">¶</a></dt>
<dd><p>process an IB_CM_RTU_RECEIVED or USER_ESTABLISHED event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_rdma_ch</span> <span class="pre">*</span> <span class="pre">ch</span></code></dt>
<dd>SRPT RDMA channel.</dd>
</dl>
<p><strong>Description</strong></p>
<p>An RTU (ready to use) message indicates that the connection has been
established and that the recipient may begin transmitting.</p>
<dl class="function">
<dt id="c.srpt_cm_handler">
int <code class="descname">srpt_cm_handler</code><span class="sig-paren">(</span>struct ib_cm_id *<em>&nbsp;cm_id</em>, const struct ib_cm_event *<em>&nbsp;event</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_cm_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>IB connection manager callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_cm_id</span> <span class="pre">*</span> <span class="pre">cm_id</span></code></dt>
<dd>IB/CM connection identifier.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ib_cm_event</span> <span class="pre">*</span> <span class="pre">event</span></code></dt>
<dd>IB/CM event.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A non-zero return value will cause the caller destroy the CM ID.</p>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.srpt_cm_handler" title="srpt_cm_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">srpt_cm_handler()</span></code></a> must only return a non-zero value when transferring
ownership of the cm_id to a channel by <a class="reference internal" href="#c.srpt_cm_req_recv" title="srpt_cm_req_recv"><code class="xref c c-func docutils literal notranslate"><span class="pre">srpt_cm_req_recv()</span></code></a> failed. Returning
a non-zero value in any other case will trigger a race with the
ib_destroy_cm_id() call in srpt_release_channel().</p>
<dl class="function">
<dt id="c.srpt_queue_response">
void <code class="descname">srpt_queue_response</code><span class="sig-paren">(</span>struct se_cmd *<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_queue_response" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit the response to a SCSI command</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt>
<dd>SCSI target command.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback function called by the TCM core. Must not block since it can be
invoked on the context of the IB completion handler.</p>
<dl class="function">
<dt id="c.srpt_release_sport">
int <code class="descname">srpt_release_sport</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.srpt_port" title="srpt_port">srpt_port</a> *<em>&nbsp;sport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_release_sport" title="Permalink to this definition">¶</a></dt>
<dd><p>disable login and wait for associated channels</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srpt_port</span> <span class="pre">*</span> <span class="pre">sport</span></code></dt>
<dd>SRPT HCA port.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_add_one">
void <code class="descname">srpt_add_one</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_add_one" title="Permalink to this definition">¶</a></dt>
<dd><p>InfiniBand device addition callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>Describes a HCA.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_remove_one">
void <code class="descname">srpt_remove_one</code><span class="sig-paren">(</span>struct ib_device *<em>&nbsp;device</em>, void *<em>&nbsp;client_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_remove_one" title="Permalink to this definition">¶</a></dt>
<dd><p>InfiniBand device removal callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ib_device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>Describes a HCA.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">client_data</span></code></dt>
<dd>The value passed as the third argument to <a class="reference internal" href="#c.ib_set_client_data" title="ib_set_client_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_set_client_data()</span></code></a>.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_close_session">
void <code class="descname">srpt_close_session</code><span class="sig-paren">(</span>struct se_session *<em>&nbsp;se_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_close_session" title="Permalink to this definition">¶</a></dt>
<dd><p>forcibly close a session</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*</span> <span class="pre">se_sess</span></code></dt>
<dd>SCSI target session.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback function invoked by the TCM core to clean up sessions associated
with a node ACL when the user invokes
rmdir /sys/kernel/config/target/$driver/$port/$tpg/acls/$i_port_id</p>
<dl class="function">
<dt id="c.srpt_sess_get_index">
u32 <code class="descname">srpt_sess_get_index</code><span class="sig-paren">(</span>struct se_session *<em>&nbsp;se_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_sess_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>return the value of scsiAttIntrPortIndex (SCSI-MIB)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*</span> <span class="pre">se_sess</span></code></dt>
<dd>SCSI target session.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A quote from RFC 4455 (SCSI-MIB) about this MIB object:
This object represents an arbitrary integer used to uniquely identify a
particular attached remote initiator port to a particular SCSI target port
within a particular SCSI target device within a particular SCSI instance.</p>
<dl class="function">
<dt id="c.srpt_parse_i_port_id">
int <code class="descname">srpt_parse_i_port_id</code><span class="sig-paren">(</span>u8<em>&nbsp;i_port_id</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_parse_i_port_id" title="Permalink to this definition">¶</a></dt>
<dd><p>parse an initiator port ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">i_port_id</span></code></dt>
<dd>Binary 128-bit port ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>ASCII representation of a 128-bit initiator port ID.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_make_tpg">
struct se_portal_group * <code class="descname">srpt_make_tpg</code><span class="sig-paren">(</span>struct se_wwn *<em>&nbsp;wwn</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_make_tpg" title="Permalink to this definition">¶</a></dt>
<dd><p>configfs callback invoked for mkdir /sys/kernel/config/target/$driver/$port/$tpg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_wwn</span> <span class="pre">*</span> <span class="pre">wwn</span></code></dt>
<dd>Corresponds to $driver/$port.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>$tpg.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_drop_tpg">
void <code class="descname">srpt_drop_tpg</code><span class="sig-paren">(</span>struct se_portal_group *<em>&nbsp;tpg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_drop_tpg" title="Permalink to this definition">¶</a></dt>
<dd><p>configfs callback invoked for rmdir /sys/kernel/config/target/$driver/$port/$tpg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_portal_group</span> <span class="pre">*</span> <span class="pre">tpg</span></code></dt>
<dd>Target portal group to deregister.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_make_tport">
struct se_wwn * <code class="descname">srpt_make_tport</code><span class="sig-paren">(</span>struct target_fabric_configfs *<em>&nbsp;tf</em>, struct config_group *<em>&nbsp;group</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_make_tport" title="Permalink to this definition">¶</a></dt>
<dd><p>configfs callback invoked for mkdir /sys/kernel/config/target/$driver/$port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">target_fabric_configfs</span> <span class="pre">*</span> <span class="pre">tf</span></code></dt>
<dd>Not used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">config_group</span> <span class="pre">*</span> <span class="pre">group</span></code></dt>
<dd>Not used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>$port.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_drop_tport">
void <code class="descname">srpt_drop_tport</code><span class="sig-paren">(</span>struct se_wwn *<em>&nbsp;wwn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_drop_tport" title="Permalink to this definition">¶</a></dt>
<dd><p>configfs callback invoked for rmdir /sys/kernel/config/target/$driver/$port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_wwn</span> <span class="pre">*</span> <span class="pre">wwn</span></code></dt>
<dd>$port.</dd>
</dl>
<dl class="function">
<dt id="c.srpt_init_module">
int <code class="descname">srpt_init_module</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.srpt_init_module" title="Permalink to this definition">¶</a></dt>
<dd><p>kernel module initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Note</strong></p>
<p>Since <a class="reference internal" href="#c.ib_register_client" title="ib_register_client"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_register_client()</span></code></a> registers callback functions, and since at
least one of these callback functions (<a class="reference internal" href="#c.srpt_add_one" title="srpt_add_one"><code class="xref c c-func docutils literal notranslate"><span class="pre">srpt_add_one()</span></code></a>) calls target core
functions, this driver must be registered with the target core before
<a class="reference internal" href="#c.ib_register_client" title="ib_register_client"><code class="xref c c-func docutils literal notranslate"><span class="pre">ib_register_client()</span></code></a> is called.</p>
</div>
<div class="section" id="iscsi-extensions-for-rdma-iser-target-support">
<h3>iSCSI Extensions for RDMA (iSER) target support<a class="headerlink" href="#iscsi-extensions-for-rdma-iser-target-support" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.isert_conn_terminate">
void <code class="descname">isert_conn_terminate</code><span class="sig-paren">(</span>struct isert_conn *<em>&nbsp;isert_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.isert_conn_terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate connection termination</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">isert_conn</span> <span class="pre">*</span> <span class="pre">isert_conn</span></code></dt>
<dd>isert connection struct</dd>
</dl>
<p><strong>Notes</strong></p>
<p>In case the connection state is BOUND, move state
to TEMINATING and start teardown sequence (rdma_disconnect).
In case the connection state is UP, complete flush as well.</p>
<p>This routine must be called with mutex held. Thus it is
safe to call multiple times.</p>
<dl class="function">
<dt id="c.isert_put_unsol_pending_cmds">
void <code class="descname">isert_put_unsol_pending_cmds</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.isert_put_unsol_pending_cmds" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop commands waiting for unsolicitate dataout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi connection</dd>
</dl>
<p><strong>Description</strong></p>
<p>We might still have commands that are waiting for unsolicited
dataouts messages. We must put the extra reference on those
before blocking on the target_wait_for_session_cmds</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>