

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MD Cluster &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>MD Cluster</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/md/md-cluster.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="md-cluster">
<h1>MD Cluster<a class="headerlink" href="#md-cluster" title="Permalink to this headline">¶</a></h1>
<p>The cluster MD is a shared-device RAID for a cluster, it supports
two levels: raid1 and raid10 (limited support).</p>
<div class="section" id="on-disk-format">
<h2>1. On-disk format<a class="headerlink" href="#on-disk-format" title="Permalink to this headline">¶</a></h2>
<p>Separate write-intent-bitmaps are used for each cluster node.
The bitmaps record all writes that may have been started on that node,
and may not yet have finished. The on-disk layout is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0                    4k                     8k                    12k
-------------------------------------------------------------------
| idle                | md super            | bm super [0] + bits |
| bm bits[0, contd]   | bm super[1] + bits  | bm bits[1, contd]   |
| bm super[2] + bits  | bm bits [2, contd]  | bm super[3] + bits  |
| bm bits [3, contd]  |                     |                     |
</pre></div>
</div>
<p>During “normal” functioning we assume the filesystem ensures that only
one node writes to any given block at a time, so a write request will</p>
<blockquote>
<div><ul class="simple">
<li>set the appropriate bit (if not already set)</li>
<li>commit the write to all mirrors</li>
<li>schedule the bit to be cleared after a timeout.</li>
</ul>
</div></blockquote>
<p>Reads are just handled normally. It is up to the filesystem to ensure
one node doesn’t read from a location where another node (or the same
node) is writing.</p>
</div>
<div class="section" id="dlm-locks-for-management">
<h2>2. DLM Locks for management<a class="headerlink" href="#dlm-locks-for-management" title="Permalink to this headline">¶</a></h2>
<p>There are three groups of locks for managing the device:</p>
<div class="section" id="bitmap-lock-resource-bm-lockres">
<h3>2.1 Bitmap lock resource (bm_lockres)<a class="headerlink" href="#bitmap-lock-resource-bm-lockres" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The bm_lockres protects individual node bitmaps. They are named in
the form bitmap000 for node 1, bitmap001 for node 2 and so on. When a
node joins the cluster, it acquires the lock in PW mode and it stays
so during the lifetime the node is part of the cluster. The lock
resource number is based on the slot number returned by the DLM
subsystem. Since DLM starts node count from one and bitmap slots
start from zero, one is subtracted from the DLM slot number to arrive
at the bitmap slot number.</p>
<p>The LVB of the bitmap lock for a particular node records the range
of sectors that are being re-synced by that node.  No other
node may write to those sectors.  This is used when a new nodes
joins the cluster.</p>
</div></blockquote>
</div>
<div class="section" id="message-passing-locks">
<h3>2.2 Message passing locks<a class="headerlink" href="#message-passing-locks" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Each node has to communicate with other nodes when starting or ending
resync, and for metadata superblock updates.  This communication is
managed through three locks: “token”, “message”, and “ack”, together
with the Lock Value Block (LVB) of one of the “message” lock.</div></blockquote>
</div>
<div class="section" id="new-device-management">
<h3>2.3 new-device management<a class="headerlink" href="#new-device-management" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>A single lock: “no-new-dev” is used to co-ordinate the addition of
new devices - this must be synchronized across the array.
Normally all nodes hold a concurrent-read lock on this device.</div></blockquote>
</div>
</div>
<div class="section" id="communication">
<h2>3. Communication<a class="headerlink" href="#communication" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Messages can be broadcast to all nodes, and the sender waits for all
other nodes to acknowledge the message before proceeding.  Only one
message can be processed at a time.</div></blockquote>
<div class="section" id="message-types">
<h3>3.1 Message Types<a class="headerlink" href="#message-types" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>There are six types of messages which are passed:</div></blockquote>
<div class="section" id="metadata-updated">
<h4>3.1.1 METADATA_UPDATED<a class="headerlink" href="#metadata-updated" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>informs other nodes that the metadata has
been updated, and the node must re-read the md superblock. This is
performed synchronously. It is primarily used to signal device
failure.</div></blockquote>
</div>
<div class="section" id="resyncing">
<h4>3.1.2 RESYNCING<a class="headerlink" href="#resyncing" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>informs other nodes that a resync is initiated or
ended so that each node may suspend or resume the region.  Each
RESYNCING message identifies a range of the devices that the
sending node is about to resync. This overrides any previous
notification from that node: only one ranged can be resynced at a
time per-node.</div></blockquote>
</div>
<div class="section" id="newdisk">
<h4>3.1.3 NEWDISK<a class="headerlink" href="#newdisk" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>informs other nodes that a device is being added to
the array. Message contains an identifier for that device.  See
below for further details.</div></blockquote>
</div>
<div class="section" id="remove">
<h4>3.1.4 REMOVE<a class="headerlink" href="#remove" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><blockquote>
<div>A failed or spare device is being removed from the
array. The slot-number of the device is included in the message.</div></blockquote>
<p>3.1.5 RE_ADD:</p>
<blockquote>
<div>A failed device is being re-activated - the assumption
is that it has been determined to be working again.</div></blockquote>
<p>3.1.6 BITMAP_NEEDS_SYNC:</p>
<blockquote>
<div>If a node is stopped locally but the bitmap
isn’t clean, then another node is informed to take the ownership of
resync.</div></blockquote>
</div></blockquote>
</div>
</div>
<div class="section" id="communication-mechanism">
<h3>3.2 Communication mechanism<a class="headerlink" href="#communication-mechanism" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The DLM LVB is used to communicate within nodes of the cluster. There
are three resources used for the purpose:</div></blockquote>
<div class="section" id="token">
<h4>3.2.1 token<a class="headerlink" href="#token" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The resource which protects the entire communication
system. The node having the token resource is allowed to
communicate.</div></blockquote>
</div>
<div class="section" id="message">
<h4>3.2.2 message<a class="headerlink" href="#message" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The lock resource which carries the data to communicate.</div></blockquote>
</div>
<div class="section" id="ack">
<h4>3.2.3 ack<a class="headerlink" href="#ack" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The resource, acquiring which means the message has been
acknowledged by all nodes in the cluster. The BAST of the resource
is used to inform the receiving node that a node wants to
communicate.</div></blockquote>
<p>The algorithm is:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">receive status - all nodes have concurrent-reader lock on “ack”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sender                         receiver                 receiver
&quot;ack&quot;:CR                       &quot;ack&quot;:CR                 &quot;ack&quot;:CR
</pre></div>
</div>
</li>
<li><p class="first">sender get EX on “token”,
sender get EX on “message”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sender                        receiver                 receiver
&quot;token&quot;:EX                    &quot;ack&quot;:CR                 &quot;ack&quot;:CR
&quot;message&quot;:EX
&quot;ack&quot;:CR
</pre></div>
</div>
<p>Sender checks that it still needs to send a message. Messages
received or other events that happened while waiting for the
“token” may have made this message inappropriate or redundant.</p>
</li>
<li><p class="first">sender writes LVB</p>
<p>sender down-convert “message” from EX to CW</p>
<p>sender try to get EX of “ack”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> [ wait until all receivers have *processed* the &quot;message&quot; ]

                                  [ triggered by bast of &quot;ack&quot; ]
                                  receiver get CR on &quot;message&quot;
                                  receiver read LVB
                                  receiver processes the message
                                  [ wait finish ]
                                  receiver releases &quot;ack&quot;
                                  receiver tries to get PR on &quot;message&quot;

sender                         receiver                  receiver
&quot;token&quot;:EX                     &quot;message&quot;:CR              &quot;message&quot;:CR
&quot;message&quot;:CW
&quot;ack&quot;:EX
</pre></div>
</div>
</li>
<li><p class="first">triggered by grant of EX on “ack” (indicating all receivers
have processed message)</p>
<p>sender down-converts “ack” from EX to CR</p>
<p>sender releases “message”</p>
<p>sender releases “token”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                            receiver upconvert to PR on &quot;message&quot;
                            receiver get CR of &quot;ack&quot;
                            receiver release &quot;message&quot;

sender                      receiver                   receiver
&quot;ack&quot;:CR                    &quot;ack&quot;:CR                   &quot;ack&quot;:CR
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="handling-failures">
<h2>4. Handling Failures<a class="headerlink" href="#handling-failures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="node-failure">
<h3>4.1 Node Failure<a class="headerlink" href="#node-failure" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>When a node fails, the DLM informs the cluster with the slot
number. The node starts a cluster recovery thread. The cluster
recovery thread:</p>
<blockquote>
<div><ul class="simple">
<li>acquires the bitmap&lt;number&gt; lock of the failed node</li>
<li>opens the bitmap</li>
<li>reads the bitmap of the failed node</li>
<li>copies the set bitmap to local node</li>
<li>cleans the bitmap of the failed node</li>
<li>releases bitmap&lt;number&gt; lock of the failed node</li>
<li>initiates resync of the bitmap on the current node
md_check_recovery is invoked within recover_bitmaps,
then md_check_recovery -&gt; metadata_update_start/finish,
it will lock the communication by lock_comm.
Which means when one node is resyncing it blocks all
other nodes from writing anywhere on the array.</li>
</ul>
</div></blockquote>
<p>The resync process is the regular md resync. However, in a clustered
environment when a resync is performed, it needs to tell other nodes
of the areas which are suspended. Before a resync starts, the node
send out RESYNCING with the (lo,hi) range of the area which needs to
be suspended. Each node maintains a suspend_list, which contains the
list of ranges which are currently suspended. On receiving RESYNCING,
the node adds the range to the suspend_list. Similarly, when the node
performing resync finishes, it sends RESYNCING with an empty range to
other nodes and other nodes remove the corresponding entry from the
suspend_list.</p>
<p>A helper function, -&gt;area_resyncing() can be used to check if a
particular I/O range should be suspended or not.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="device-failure">
<h2>4.2 Device Failure<a class="headerlink" href="#device-failure" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Device failures are handled and communicated with the metadata update
routine.  When a node detects a device failure it does not allow
any further writes to that device until the failure has been
acknowledged by all other nodes.</div></blockquote>
<div class="section" id="adding-a-new-device">
<h3>5. Adding a new Device<a class="headerlink" href="#adding-a-new-device" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For adding a new device, it is necessary that all nodes “see” the new
device to be added. For this, the following algorithm is used:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Node 1 issues mdadm –manage /dev/mdX –add /dev/sdYY which issues
ioctl(ADD_NEW_DISK with disc.state set to MD_DISK_CLUSTER_ADD)</li>
<li>Node 1 sends a NEWDISK message with uuid and slot number</li>
<li>Other nodes issue kobject_uevent_env with uuid and slot number
(Steps 4,5 could be a udev rule)</li>
<li>In userspace, the node searches for the disk, perhaps
using blkid -t SUB_UUID=””</li>
<li>Other nodes issue either of the following depending on whether
the disk was found:
ioctl(ADD_NEW_DISK with disc.state set to MD_DISK_CANDIDATE and
disc.number set to slot number)
ioctl(CLUSTERED_DISK_NACK)</li>
<li>Other nodes drop lock on “no-new-devs” (CR) if device is found</li>
<li>Node 1 attempts EX lock on “no-new-dev”</li>
<li>If node 1 gets the lock, it sends METADATA_UPDATED after
unmarking the disk as SpareLocal</li>
<li>If not (get “no-new-dev” lock), it fails the operation and sends
METADATA_UPDATED.</li>
<li>Other nodes get the information whether a disk is added or not
by the following METADATA_UPDATED.</li>
</ol>
</div></blockquote>
</div></blockquote>
</div>
</div>
<div class="section" id="module-interface">
<h2>6. Module interface<a class="headerlink" href="#module-interface" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>There are 17 call-backs which the md core can make to the cluster
module.  Understanding these can give a good overview of the whole
process.</div></blockquote>
<div class="section" id="join-nodes-and-leave">
<h3>6.1 join(nodes) and leave()<a class="headerlink" href="#join-nodes-and-leave" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>These are called when an array is started with a clustered bitmap,
and when the array is stopped.  join() ensures the cluster is
available and initializes the various resources.
Only the first ‘nodes’ nodes in the cluster can use the array.</div></blockquote>
</div>
<div class="section" id="slot-number">
<h3>6.2 slot_number()<a class="headerlink" href="#slot-number" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Reports the slot number advised by the cluster infrastructure.
Range is from 0 to nodes-1.</div></blockquote>
</div>
<div class="section" id="resync-info-update">
<h3>6.3 resync_info_update()<a class="headerlink" href="#resync-info-update" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This updates the resync range that is stored in the bitmap lock.
The starting point is updated as the resync progresses.  The
end point is always the end of the array.
It does <em>not</em> send a RESYNCING message.</div></blockquote>
</div>
<div class="section" id="resync-start-resync-finish">
<h3>6.4 resync_start(), resync_finish()<a class="headerlink" href="#resync-start-resync-finish" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>These are called when resync/recovery/reshape starts or stops.
They update the resyncing range in the bitmap lock and also
send a RESYNCING message.  resync_start reports the whole
array as resyncing, resync_finish reports none of it.</p>
<p>resync_finish() also sends a BITMAP_NEEDS_SYNC message which
allows some other node to take over.</p>
</div></blockquote>
</div>
<div class="section" id="metadata-update-start-metadata-update-finish-metadata-update-cancel">
<h3>6.5 metadata_update_start(), metadata_update_finish(), metadata_update_cancel()<a class="headerlink" href="#metadata-update-start-metadata-update-finish-metadata-update-cancel" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>metadata_update_start is used to get exclusive access to
the metadata.  If a change is still needed once that access is
gained, metadata_update_finish() will send a METADATA_UPDATE
message to all other nodes, otherwise metadata_update_cancel()
can be used to release the lock.</div></blockquote>
</div>
<div class="section" id="area-resyncing">
<h3>6.6 area_resyncing()<a class="headerlink" href="#area-resyncing" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>This combines two elements of functionality.</p>
<p>Firstly, it will check if any node is currently resyncing
anything in a given range of sectors.  If any resync is found,
then the caller will avoid writing or read-balancing in that
range.</p>
<p>Secondly, while node recovery is happening it reports that
all areas are resyncing for READ requests.  This avoids races
between the cluster-filesystem and the cluster-RAID handling
a node failure.</p>
</div></blockquote>
</div>
<div class="section" id="add-new-disk-start-add-new-disk-finish-new-disk-ack">
<h3>6.7 add_new_disk_start(), add_new_disk_finish(), new_disk_ack()<a class="headerlink" href="#add-new-disk-start-add-new-disk-finish-new-disk-ack" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>These are used to manage the new-disk protocol described above.
When a new device is added, add_new_disk_start() is called before
it is bound to the array and, if that succeeds, add_new_disk_finish()
is called the device is fully added.</p>
<p>When a device is added in acknowledgement to a previous
request, or when the device is declared “unavailable”,
new_disk_ack() is called.</p>
</div></blockquote>
</div>
<div class="section" id="remove-disk">
<h3>6.8 remove_disk()<a class="headerlink" href="#remove-disk" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This is called when a spare or failed device is removed from
the array.  It causes a REMOVE message to be send to other nodes.</div></blockquote>
</div>
<div class="section" id="gather-bitmaps">
<h3>6.9 gather_bitmaps()<a class="headerlink" href="#gather-bitmaps" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This sends a RE_ADD message to all other nodes and then
gathers bitmap information from all bitmaps.  This combined
bitmap is then used to recovery the re-added device.</div></blockquote>
</div>
<div class="section" id="lock-all-bitmaps-and-unlock-all-bitmaps">
<h3>6.10 lock_all_bitmaps() and unlock_all_bitmaps()<a class="headerlink" href="#lock-all-bitmaps-and-unlock-all-bitmaps" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>These are called when change bitmap to none. If a node plans
to clear the cluster raid’s bitmap, it need to make sure no other
nodes are using the raid which is achieved by lock all bitmap
locks within the cluster, and also those locks are unlocked
accordingly.</div></blockquote>
</div>
</div>
<div class="section" id="unsupported-features">
<h2>7. Unsupported features<a class="headerlink" href="#unsupported-features" title="Permalink to this headline">¶</a></h2>
<p>There are somethings which are not supported by cluster MD yet.</p>
<ul class="simple">
<li>change array_sectors.</li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>