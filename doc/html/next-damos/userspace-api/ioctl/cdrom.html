

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Summary of CDROM ioctl calls &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Summary of CDROM ioctl calls</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/userspace-api/ioctl/cdrom.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="summary-of-cdrom-ioctl-calls">
<h1>Summary of CDROM ioctl calls<a class="headerlink" href="#summary-of-cdrom-ioctl-calls" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>Edward A. Falk &lt;<a class="reference external" href="mailto:efalk&#37;&#52;&#48;google&#46;com">efalk<span>&#64;</span>google<span>&#46;</span>com</a>&gt;</li>
</ul>
<p>November, 2004</p>
<p>This document attempts to describe the ioctl(2) calls supported by
the CDROM layer.  These are by-and-large implemented (as of Linux 2.6)
in drivers/cdrom/cdrom.c and drivers/block/scsi_ioctl.c</p>
<p>ioctl values are listed in &lt;linux/cdrom.h&gt;.  As of this writing, they
are as follows:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>CDROMPAUSE</td>
<td>Pause Audio Operation</td>
</tr>
<tr class="row-even"><td>CDROMRESUME</td>
<td>Resume paused Audio Operation</td>
</tr>
<tr class="row-odd"><td>CDROMPLAYMSF</td>
<td>Play Audio MSF (struct cdrom_msf)</td>
</tr>
<tr class="row-even"><td>CDROMPLAYTRKIND</td>
<td>Play Audio Track/index (struct cdrom_ti)</td>
</tr>
<tr class="row-odd"><td>CDROMREADTOCHDR</td>
<td>Read TOC header (struct cdrom_tochdr)</td>
</tr>
<tr class="row-even"><td>CDROMREADTOCENTRY</td>
<td>Read TOC entry (struct cdrom_tocentry)</td>
</tr>
<tr class="row-odd"><td>CDROMSTOP</td>
<td>Stop the cdrom drive</td>
</tr>
<tr class="row-even"><td>CDROMSTART</td>
<td>Start the cdrom drive</td>
</tr>
<tr class="row-odd"><td>CDROMEJECT</td>
<td>Ejects the cdrom media</td>
</tr>
<tr class="row-even"><td>CDROMVOLCTRL</td>
<td>Control output volume (struct cdrom_volctrl)</td>
</tr>
<tr class="row-odd"><td>CDROMSUBCHNL</td>
<td>Read subchannel data (struct cdrom_subchnl)</td>
</tr>
<tr class="row-even"><td>CDROMREADMODE2</td>
<td>Read CDROM mode 2 data (2336 Bytes)
(struct cdrom_read)</td>
</tr>
<tr class="row-odd"><td>CDROMREADMODE1</td>
<td>Read CDROM mode 1 data (2048 Bytes)
(struct cdrom_read)</td>
</tr>
<tr class="row-even"><td>CDROMREADAUDIO</td>
<td>(struct cdrom_read_audio)</td>
</tr>
<tr class="row-odd"><td>CDROMEJECT_SW</td>
<td>enable(1)/disable(0) auto-ejecting</td>
</tr>
<tr class="row-even"><td>CDROMMULTISESSION</td>
<td>Obtain the start-of-last-session
address of multi session disks
(struct cdrom_multisession)</td>
</tr>
<tr class="row-odd"><td>CDROM_GET_MCN</td>
<td>Obtain the “Universal Product Code”
if available (struct cdrom_mcn)</td>
</tr>
<tr class="row-even"><td>CDROM_GET_UPC</td>
<td>Deprecated, use CDROM_GET_MCN instead.</td>
</tr>
<tr class="row-odd"><td>CDROMRESET</td>
<td>hard-reset the drive</td>
</tr>
<tr class="row-even"><td>CDROMVOLREAD</td>
<td>Get the drive’s volume setting
(struct cdrom_volctrl)</td>
</tr>
<tr class="row-odd"><td>CDROMREADRAW</td>
<td>read data in raw mode (2352 Bytes)
(struct cdrom_read)</td>
</tr>
<tr class="row-even"><td>CDROMREADCOOKED</td>
<td>read data in cooked mode</td>
</tr>
<tr class="row-odd"><td>CDROMSEEK</td>
<td>seek msf address</td>
</tr>
<tr class="row-even"><td>CDROMPLAYBLK</td>
<td>scsi-cd only, (struct cdrom_blk)</td>
</tr>
<tr class="row-odd"><td>CDROMREADALL</td>
<td>read all 2646 bytes</td>
</tr>
<tr class="row-even"><td>CDROMGETSPINDOWN</td>
<td>return 4-bit spindown value</td>
</tr>
<tr class="row-odd"><td>CDROMSETSPINDOWN</td>
<td>set 4-bit spindown value</td>
</tr>
<tr class="row-even"><td>CDROMCLOSETRAY</td>
<td>pendant of CDROMEJECT</td>
</tr>
<tr class="row-odd"><td>CDROM_SET_OPTIONS</td>
<td>Set behavior options</td>
</tr>
<tr class="row-even"><td>CDROM_CLEAR_OPTIONS</td>
<td>Clear behavior options</td>
</tr>
<tr class="row-odd"><td>CDROM_SELECT_SPEED</td>
<td>Set the CD-ROM speed</td>
</tr>
<tr class="row-even"><td>CDROM_SELECT_DISC</td>
<td>Select disc (for juke-boxes)</td>
</tr>
<tr class="row-odd"><td>CDROM_MEDIA_CHANGED</td>
<td>Check is media changed</td>
</tr>
<tr class="row-even"><td>CDROM_DRIVE_STATUS</td>
<td>Get tray position, etc.</td>
</tr>
<tr class="row-odd"><td>CDROM_DISC_STATUS</td>
<td>Get disc type, etc.</td>
</tr>
<tr class="row-even"><td>CDROM_CHANGER_NSLOTS</td>
<td>Get number of slots</td>
</tr>
<tr class="row-odd"><td>CDROM_LOCKDOOR</td>
<td>lock or unlock door</td>
</tr>
<tr class="row-even"><td>CDROM_DEBUG</td>
<td>Turn debug messages on/off</td>
</tr>
<tr class="row-odd"><td>CDROM_GET_CAPABILITY</td>
<td>get capabilities</td>
</tr>
<tr class="row-even"><td>CDROMAUDIOBUFSIZ</td>
<td>set the audio buffer size</td>
</tr>
<tr class="row-odd"><td>DVD_READ_STRUCT</td>
<td>Read structure</td>
</tr>
<tr class="row-even"><td>DVD_WRITE_STRUCT</td>
<td>Write structure</td>
</tr>
<tr class="row-odd"><td>DVD_AUTH</td>
<td>Authentication</td>
</tr>
<tr class="row-even"><td>CDROM_SEND_PACKET</td>
<td>send a packet to the drive</td>
</tr>
<tr class="row-odd"><td>CDROM_NEXT_WRITABLE</td>
<td>get next writable block</td>
</tr>
<tr class="row-even"><td>CDROM_LAST_WRITTEN</td>
<td>get last block written on disc</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The information that follows was determined from reading kernel source
code.  It is likely that some corrections will be made over time.</p>
<hr class="docutils" />
<p>General:</p>
<blockquote>
<div><p>Unless otherwise specified, all ioctl calls return 0 on success
and -1 with errno set to an appropriate value on error.  (Some
ioctls return non-negative data values.)</p>
<p>Unless otherwise specified, all ioctl calls return -1 and set
errno to EFAULT on a failed attempt to copy data to or from user
address space.</p>
<p>Individual drivers may return error codes not listed here.</p>
<p>Unless otherwise specified, all data structures and constants
are defined in &lt;linux/cdrom.h&gt;</p>
</div></blockquote>
<hr class="docutils" />
<dl class="docutils">
<dt>CDROMPAUSE</dt>
<dd><p class="first">Pause Audio Operation</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMPAUSE, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMRESUME</dt>
<dd><p class="first">Resume paused Audio Operation</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMRESUME, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMPLAYMSF</dt>
<dd><p class="first">Play Audio MSF</p>
<p>(struct cdrom_msf)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_msf msf;

ioctl(fd, CDROMPLAYMSF, &amp;msf);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>cdrom_msf structure, describing a segment of music to play</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last simple">
<li>MSF stands for minutes-seconds-frames</li>
<li>LBA stands for logical block address</li>
<li>Segment is described as start and end times, where each time
is described as minutes:seconds:frames.
A frame is 1/75 of a second.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMPLAYTRKIND</dt>
<dd><p class="first">Play Audio Track/index</p>
<p>(struct cdrom_ti)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_ti ti;

ioctl(fd, CDROMPLAYTRKIND, &amp;ti);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>cdrom_ti structure, describing a segment of music to play</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last simple">
<li>Segment is described as start and end times, where each time
is described as a track and an index.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADTOCHDR</dt>
<dd><p class="first">Read TOC header</p>
<p>(struct cdrom_tochdr)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cdrom_tochdr header;

ioctl(fd, CDROMREADTOCHDR, &amp;header);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>cdrom_tochdr structure</dd>
<dt>outputs:</dt>
<dd>cdrom_tochdr structure</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADTOCENTRY</dt>
<dd><p class="first">Read TOC entry</p>
<p>(struct cdrom_tocentry)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_tocentry entry;

ioctl(fd, CDROMREADTOCENTRY, &amp;entry);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>cdrom_tocentry structure</dd>
<dt>outputs:</dt>
<dd>cdrom_tocentry structure</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
<li>EINVAL      entry.cdte_format not CDROM_MSF or CDROM_LBA</li>
<li>EINVAL      requested track out of bounds</li>
<li>EIO         I/O error reading TOC</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last simple">
<li>TOC stands for Table Of Contents</li>
<li>MSF stands for minutes-seconds-frames</li>
<li>LBA stands for logical block address</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMSTOP</dt>
<dd><p class="first">Stop the cdrom drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMSTOP, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last simple">
<li>Exact interpretation of this ioctl depends on the device,
but most seem to spin the drive down.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMSTART</dt>
<dd><p class="first">Start the cdrom drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMSTART, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last simple">
<li>Exact interpretation of this ioctl depends on the device,
but most seem to spin the drive up and/or close the tray.
Other devices ignore the ioctl completely.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMEJECT</dt>
<dd><ul class="first simple">
<li>Ejects the cdrom media</li>
</ul>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMEJECT, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not capable of ejecting</li>
<li>EBUSY       other processes are accessing drive, or door is locked</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last simple">
<li>See CDROM_LOCKDOOR, below.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMCLOSETRAY</dt>
<dd><p class="first">pendant of CDROMEJECT</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMCLOSETRAY, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not capable of closing the tray</li>
<li>EBUSY       other processes are accessing drive, or door is locked</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last simple">
<li>See CDROM_LOCKDOOR, below.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMVOLCTRL</dt>
<dd><p class="first">Control output volume (struct cdrom_volctrl)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_volctrl volume;

ioctl(fd, CDROMVOLCTRL, &amp;volume);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>cdrom_volctrl structure containing volumes for up to 4
channels.</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMVOLREAD</dt>
<dd><p class="first">Get the drive’s volume setting</p>
<p>(struct cdrom_volctrl)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_volctrl volume;

ioctl(fd, CDROMVOLREAD, &amp;volume);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The current volume settings.</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMSUBCHNL</dt>
<dd><p class="first">Read subchannel data</p>
<p>(struct cdrom_subchnl)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_subchnl q;

ioctl(fd, CDROMSUBCHNL, &amp;q);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>cdrom_subchnl structure</dd>
<dt>outputs:</dt>
<dd>cdrom_subchnl structure</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      cd drive not audio-capable.</li>
<li>EINVAL      format not CDROM_MSF or CDROM_LBA</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last simple">
<li>Format is converted to CDROM_MSF or CDROM_LBA
as per user request on return</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADRAW</dt>
<dd><p class="first">read data in raw mode (2352 Bytes)</p>
<p>(struct cdrom_read)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union {

  struct cdrom_msf msf;               /* input */
  char buffer[CD_FRAMESIZE_RAW];      /* return */
} arg;
ioctl(fd, CDROMREADRAW, &amp;arg);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd><p class="first">cdrom_msf structure indicating an address to read.</p>
<p class="last">Only the start values are significant.</p>
</dd>
<dt>outputs:</dt>
<dd>Data written to address provided by user.</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      address less than 0, or msf less than 0:2:0</li>
<li>ENOMEM      out of memory</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last">
<li><p class="first">As of 2.6.8.1, comments in &lt;linux/cdrom.h&gt; indicate that this
ioctl accepts a cdrom_read structure, but actual source code
reads a cdrom_msf structure and writes a buffer of data to
the same address.</p>
</li>
<li><p class="first">MSF values are converted to LBA values via this formula:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lba = (((m * CD_SECS) + s) * CD_FRAMES + f) - CD_MSF_OFFSET;
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADMODE1</dt>
<dd><p class="first">Read CDROM mode 1 data (2048 Bytes)</p>
<p>(struct cdrom_read)</p>
<dl class="last docutils">
<dt>notes:</dt>
<dd>Identical to CDROMREADRAW except that block size is
CD_FRAMESIZE (2048) bytes</dd>
</dl>
</dd>
<dt>CDROMREADMODE2</dt>
<dd><p class="first">Read CDROM mode 2 data (2336 Bytes)</p>
<p>(struct cdrom_read)</p>
<dl class="last docutils">
<dt>notes:</dt>
<dd>Identical to CDROMREADRAW except that block size is
CD_FRAMESIZE_RAW0 (2336) bytes</dd>
</dl>
</dd>
<dt>CDROMREADAUDIO</dt>
<dd><p class="first">(struct cdrom_read_audio)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_read_audio ra;

ioctl(fd, CDROMREADAUDIO, &amp;ra);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>cdrom_read_audio structure containing read start
point and length</dd>
<dt>outputs:</dt>
<dd>audio data, returned to buffer indicated by ra</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      format not CDROM_MSF or CDROM_LBA</li>
<li>EINVAL      nframes not in range [1 75]</li>
<li>ENXIO       drive has no queue (probably means invalid fd)</li>
<li>ENOMEM      out of memory</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMEJECT_SW</dt>
<dd><p class="first">enable(1)/disable(0) auto-ejecting</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val;

ioctl(fd, CDROMEJECT_SW, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>Flag specifying auto-eject flag.</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      Drive is not capable of ejecting.</li>
<li>EBUSY       Door is locked</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMMULTISESSION</dt>
<dd><p class="first">Obtain the start-of-last-session address of multi session disks</p>
<p>(struct cdrom_multisession)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_multisession ms_info;

ioctl(fd, CDROMMULTISESSION, &amp;ms_info);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd><blockquote class="first">
<div>cdrom_multisession structure containing desired</div></blockquote>
<p class="last">format.</p>
</dd>
<dt>outputs:</dt>
<dd>cdrom_multisession structure is filled with last_session
information.</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      format not CDROM_MSF or CDROM_LBA</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_GET_MCN</dt>
<dd><p class="first">Obtain the “Universal Product Code”
if available</p>
<p>(struct cdrom_mcn)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_mcn mcn;

ioctl(fd, CDROM_GET_MCN, &amp;mcn);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>Universal Product Code</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      Drive is not capable of reading MCN data.</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><ul class="first last">
<li><p class="first">Source code comments state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The following function is implemented, although very few
audio discs give Universal Product Code information, which
should just be the Medium Catalog Number on the box.  Note,
that the way the code is written on the CD is /not/ uniform
across all discs!
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_GET_UPC</dt>
<dd><p class="first">CDROM_GET_MCN  (deprecated)</p>
<p class="last">Not implemented, as of 2.6.8.1</p>
</dd>
<dt>CDROMRESET</dt>
<dd><p class="first">hard-reset the drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROMRESET, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
<li>ENOSYS      Drive is not capable of resetting.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROMREADCOOKED</dt>
<dd><p class="first">read data in cooked mode</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u8 buffer[CD_FRAMESIZE]

ioctl(fd, CDROMREADCOOKED, buffer);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>2048 bytes of data, “cooked” mode.</dd>
<dt>notes:</dt>
<dd>Not implemented on all drives.</dd>
</dl>
</dd>
<dt>CDROMREADALL</dt>
<dd><p class="first">read all 2646 bytes</p>
<p class="last">Same as CDROMREADCOOKED, but reads 2646 bytes.</p>
</dd>
<dt>CDROMSEEK</dt>
<dd><p class="first">seek msf address</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_msf msf;

ioctl(fd, CDROMSEEK, &amp;msf);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>MSF address to seek to.</dd>
<dt>outputs:</dt>
<dd>none</dd>
</dl>
</dd>
<dt>CDROMPLAYBLK</dt>
<dd><p class="first">scsi-cd only</p>
<p>(struct cdrom_blk)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_blk blk;

ioctl(fd, CDROMPLAYBLK, &amp;blk);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>Region to play</dd>
<dt>outputs:</dt>
<dd>none</dd>
</dl>
</dd>
<dt>CDROMGETSPINDOWN</dt>
<dd><p class="first">usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char spindown;

ioctl(fd, CDROMGETSPINDOWN, &amp;spindown);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The value of the current 4-bit spindown value.</dd>
</dl>
</dd>
<dt>CDROMSETSPINDOWN</dt>
<dd><p class="first">usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char spindown

ioctl(fd, CDROMSETSPINDOWN, &amp;spindown);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>4-bit value used to control spindown (TODO: more detail here)</dd>
<dt>outputs:</dt>
<dd>none</dd>
</dl>
</dd>
<dt>CDROM_SET_OPTIONS</dt>
<dd><p class="first">Set behavior options</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int options;

ioctl(fd, CDROM_SET_OPTIONS, options);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd><blockquote class="first">
<div>New values for drive options.  The logical ‘or’ of:</div></blockquote>
<table border="1" class="last docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>CDO_AUTO_CLOSE</td>
<td>close tray on first open(2)</td>
</tr>
<tr class="row-even"><td>CDO_AUTO_EJECT</td>
<td>open tray on last release</td>
</tr>
<tr class="row-odd"><td>CDO_USE_FFLAGS</td>
<td>use O_NONBLOCK information on open</td>
</tr>
<tr class="row-even"><td>CDO_LOCK</td>
<td>lock tray on open files</td>
</tr>
<tr class="row-odd"><td>CDO_CHECK_TYPE</td>
<td>check type on open for data</td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt>
<dd>Returns the resulting options settings in the
ioctl return value.  Returns -1 on error.</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      selected option(s) not supported by drive.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_CLEAR_OPTIONS</dt>
<dd><p class="first">Clear behavior options</p>
<p class="last">Same as CDROM_SET_OPTIONS, except that selected options are
turned off.</p>
</dd>
<dt>CDROM_SELECT_SPEED</dt>
<dd><p class="first">Set the CD-ROM speed</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int speed;

ioctl(fd, CDROM_SELECT_SPEED, speed);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New drive speed.</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      speed selection not supported by drive.</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_SELECT_DISC</dt>
<dd><p class="first">Select disc (for juke-boxes)</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int disk;

ioctl(fd, CDROM_SELECT_DISC, disk);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>Disk to load into drive.</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EINVAL      Disk number beyond capacity of drive</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_MEDIA_CHANGED</dt>
<dd><p class="first">Check is media changed</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int slot;

ioctl(fd, CDROM_MEDIA_CHANGED, slot);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd><p class="first">Slot number to be tested, always zero except for jukeboxes.</p>
<p class="last">May also be special values CDSL_NONE or CDSL_CURRENT</p>
</dd>
<dt>outputs:</dt>
<dd><blockquote class="first">
<div>Ioctl return value is 0 or 1 depending on whether the media</div></blockquote>
<p class="last">has been changed, or -1 on error.</p>
</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      Drive can’t detect media change</li>
<li>EINVAL      Slot number beyond capacity of drive</li>
<li>ENOMEM      Out of memory</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_DRIVE_STATUS</dt>
<dd><p class="first">Get tray position, etc.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int slot;

ioctl(fd, CDROM_DRIVE_STATUS, slot);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd><p class="first">Slot number to be tested, always zero except for jukeboxes.</p>
<p class="last">May also be special values CDSL_NONE or CDSL_CURRENT</p>
</dd>
<dt>outputs:</dt>
<dd><blockquote class="first">
<div>Ioctl return value will be one of the following values</div></blockquote>
<p>from &lt;linux/cdrom.h&gt;:</p>
<blockquote class="last">
<div><table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>CDS_NO_INFO</td>
<td>Information not available.</td>
</tr>
<tr class="row-even"><td>CDS_NO_DISC</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>CDS_TRAY_OPEN</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>CDS_DRIVE_NOT_READY</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>CDS_DISC_OK</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>-1</td>
<td>error</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      Drive can’t detect drive status</li>
<li>EINVAL      Slot number beyond capacity of drive</li>
<li>ENOMEM      Out of memory</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_DISC_STATUS</dt>
<dd><p class="first">Get disc type, etc.</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROM_DISC_STATUS, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd><blockquote class="first">
<div>Ioctl return value will be one of the following values</div></blockquote>
<p>from &lt;linux/cdrom.h&gt;:</p>
<blockquote class="last">
<div><ul class="simple">
<li>CDS_NO_INFO</li>
<li>CDS_AUDIO</li>
<li>CDS_MIXED</li>
<li>CDS_XA_2_2</li>
<li>CDS_XA_2_1</li>
<li>CDS_DATA_1</li>
</ul>
</div></blockquote>
</dd>
<dt>error returns:</dt>
<dd>none at present</dd>
<dt>notes:</dt>
<dd><ul class="first last">
<li><p class="first">Source code comments state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ok, this is where problems start.  The current interface for
the CDROM_DISC_STATUS ioctl is flawed.  It makes the false
assumption that CDs are all CDS_DATA_1 or all CDS_AUDIO, etc.
Unfortunately, while this is often the case, it is also
very common for CDs to have some tracks with data, and some
tracks with audio.      Just because I feel like it, I declare
the following to be the best way to cope.  If the CD has
ANY data tracks on it, it will be returned as a data CD.
If it has any XA tracks, I will return it as that.      Now I
could simplify this interface by combining these returns with
the above, but this more clearly demonstrates the problem
with the current interface.  Too bad this wasn&#39;t designed
to use bitmasks...             -Erik

Well, now we have the option CDS_MIXED: a mixed-type CD.
User level programmers might feel the ioctl is not very
useful.
                ---david
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_CHANGER_NSLOTS</dt>
<dd><p class="first">Get number of slots</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROM_CHANGER_NSLOTS, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The ioctl return value will be the number of slots in a
CD changer.  Typically 1 for non-multi-disk devices.</dd>
<dt>error returns:</dt>
<dd>none</dd>
</dl>
</dd>
<dt>CDROM_LOCKDOOR</dt>
<dd><p class="first">lock or unlock door</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int lock;

ioctl(fd, CDROM_LOCKDOOR, lock);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>Door lock flag, 1=lock, 0=unlock</dd>
<dt>outputs:</dt>
<dd>none</dd>
<dt>error returns:</dt>
<dd><ul class="first last">
<li><p class="first">EDRIVE_CANT_DO_THIS</p>
<blockquote>
<div><p>Door lock function not supported.</p>
</div></blockquote>
</li>
<li><p class="first">EBUSY</p>
<blockquote>
<div><p>Attempt to unlock when multiple users
have the drive open and not CAP_SYS_ADMIN</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt>notes:</dt>
<dd><p class="first">As of 2.6.8.1, the lock flag is a global lock, meaning that
all CD drives will be locked or unlocked together.  This is
probably a bug.</p>
<p class="last">The EDRIVE_CANT_DO_THIS value is defined in &lt;linux/cdrom.h&gt;
and is currently (2.6.8.1) the same as EOPNOTSUPP</p>
</dd>
</dl>
</dd>
<dt>CDROM_DEBUG</dt>
<dd><p class="first">Turn debug messages on/off</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int debug;

ioctl(fd, CDROM_DEBUG, debug);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>Cdrom debug flag, 0=disable, 1=enable</dd>
<dt>outputs:</dt>
<dd>The ioctl return value will be the new debug flag.</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>EACCES      Access denied:  requires CAP_SYS_ADMIN</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_GET_CAPABILITY</dt>
<dd><p class="first">get capabilities</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, CDROM_GET_CAPABILITY, 0);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The ioctl return value is the current device capability
flags.  See CDC_CLOSE_TRAY, CDC_OPEN_TRAY, etc.</dd>
</dl>
</dd>
<dt>CDROMAUDIOBUFSIZ</dt>
<dd><p class="first">set the audio buffer size</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int arg;

ioctl(fd, CDROMAUDIOBUFSIZ, val);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>New audio buffer size</dd>
<dt>outputs:</dt>
<dd>The ioctl return value is the new audio buffer size, or -1
on error.</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOSYS      Not supported by this driver.</li>
</ul>
</dd>
<dt>notes:</dt>
<dd>Not supported by all drivers.</dd>
</dl>
</dd>
</dl>
<p>DVD_READ_STRUCT                 Read structure</p>
<blockquote>
<div><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dvd_struct s;

ioctl(fd, DVD_READ_STRUCT, &amp;s);
</pre></div>
</div>
<dl class="docutils">
<dt>inputs:</dt>
<dd><blockquote class="first">
<div>dvd_struct structure, containing:</div></blockquote>
<table border="1" class="last docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>type</td>
<td>specifies the information desired, one of
DVD_STRUCT_PHYSICAL, DVD_STRUCT_COPYRIGHT,
DVD_STRUCT_DISCKEY, DVD_STRUCT_BCA,
DVD_STRUCT_MANUFACT</td>
</tr>
<tr class="row-even"><td>physical.layer_num</td>
<td>desired layer, indexed from 0</td>
</tr>
<tr class="row-odd"><td>copyright.layer_num</td>
<td>desired layer, indexed from 0</td>
</tr>
<tr class="row-even"><td>disckey.agid</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd>
<dt>outputs:</dt>
<dd><blockquote class="first">
<div>dvd_struct structure, containing:</div></blockquote>
<table border="1" class="last docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>physical</td>
<td>for type == DVD_STRUCT_PHYSICAL</td>
</tr>
<tr class="row-even"><td>copyright</td>
<td>for type == DVD_STRUCT_COPYRIGHT</td>
</tr>
<tr class="row-odd"><td>disckey.value</td>
<td>for type == DVD_STRUCT_DISCKEY</td>
</tr>
<tr class="row-even"><td>bca.{len,value}</td>
<td>for type == DVD_STRUCT_BCA</td>
</tr>
<tr class="row-odd"><td>manufact.{len,valu}</td>
<td>for type == DVD_STRUCT_MANUFACT</td>
</tr>
</tbody>
</table>
</dd>
<dt>error returns:</dt>
<dd><ul class="first last simple">
<li>EINVAL      physical.layer_num exceeds number of layers</li>
<li>EIO         Received invalid response from drive</li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>DVD_WRITE_STRUCT                Write structure</p>
<blockquote>
<div>Not implemented, as of 2.6.8.1</div></blockquote>
<p>DVD_AUTH                        Authentication</p>
<blockquote>
<div><p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dvd_authinfo ai;

ioctl(fd, DVD_AUTH, &amp;ai);
</pre></div>
</div>
<dl class="docutils">
<dt>inputs:</dt>
<dd>dvd_authinfo structure.  See &lt;linux/cdrom.h&gt;</dd>
<dt>outputs:</dt>
<dd>dvd_authinfo structure.</dd>
<dt>error return:</dt>
<dd><ul class="first last simple">
<li>ENOTTY      ai.type not recognized.</li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>CDROM_SEND_PACKET</dt>
<dd><p class="first">send a packet to the drive</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdrom_generic_command cgc;

ioctl(fd, CDROM_SEND_PACKET, &amp;cgc);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>cdrom_generic_command structure containing the packet to send.</dd>
<dt>outputs:</dt>
<dd><blockquote class="first">
<div>none</div></blockquote>
<p class="last">cdrom_generic_command structure containing results.</p>
</dd>
<dt>error return:</dt>
<dd><ul class="first last">
<li><p class="first">EIO</p>
<blockquote>
<div><p>command failed.</p>
</div></blockquote>
</li>
<li><p class="first">EPERM</p>
<blockquote>
<div><p>Operation not permitted, either because a
write command was attempted on a drive which
is opened read-only, or because the command
requires CAP_SYS_RAWIO</p>
</div></blockquote>
</li>
<li><p class="first">EINVAL</p>
<blockquote>
<div><p>cgc.data_direction not set</p>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>CDROM_NEXT_WRITABLE</dt>
<dd><p class="first">get next writable block</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long next;

ioctl(fd, CDROM_NEXT_WRITABLE, &amp;next);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The next writable block.</dd>
<dt>notes:</dt>
<dd><blockquote class="first">
<div>If the device does not support this ioctl directly, the</div></blockquote>
<p class="last">ioctl will return CDROM_LAST_WRITTEN + 7.</p>
</dd>
</dl>
</dd>
<dt>CDROM_LAST_WRITTEN</dt>
<dd><p class="first">get last block written on disc</p>
<p>usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long last;

ioctl(fd, CDROM_LAST_WRITTEN, &amp;last);
</pre></div>
</div>
<dl class="last docutils">
<dt>inputs:</dt>
<dd>none</dd>
<dt>outputs:</dt>
<dd>The last block written on disc</dd>
<dt>notes:</dt>
<dd>If the device does not support this ioctl directly, the
result is derived from the disc’s table of contents.  If the
table of contents can’t be read, this ioctl returns an
error.</dd>
</dl>
</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>