

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Adjunct Processor (AP) facility &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/mm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Adjunct Processor (AP) facility</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/s390/vfio-ap.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="adjunct-processor-ap-facility">
<h1>Adjunct Processor (AP) facility<a class="headerlink" href="#adjunct-processor-ap-facility" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Adjunct Processor (AP) facility is an IBM Z cryptographic facility comprised
of three AP instructions and from 1 up to 256 PCIe cryptographic adapter cards.
The AP devices provide cryptographic functions to all CPUs assigned to a
linux system running in an IBM Z system LPAR.</p>
<p>The AP adapter cards are exposed via the AP bus. The motivation for vfio-ap
is to make AP cards available to KVM guests using the VFIO mediated device
framework. This implementation relies considerably on the s390 virtualization
facilities which do most of the hard work of providing direct access to AP
devices.</p>
</div>
<div class="section" id="ap-architectural-overview">
<h2>AP Architectural Overview<a class="headerlink" href="#ap-architectural-overview" title="Permalink to this headline">¶</a></h2>
<p>To facilitate the comprehension of the design, let’s start with some
definitions:</p>
<ul>
<li><p class="first">AP adapter</p>
<p>An AP adapter is an IBM Z adapter card that can perform cryptographic
functions. There can be from 0 to 256 adapters assigned to an LPAR. Adapters
assigned to the LPAR in which a linux host is running will be available to
the linux host. Each adapter is identified by a number from 0 to 255; however,
the maximum adapter number is determined by machine model and/or adapter type.
When installed, an AP adapter is accessed by AP instructions executed by any
CPU.</p>
<p>The AP adapter cards are assigned to a given LPAR via the system’s Activation
Profile which can be edited via the HMC. When the linux host system is IPL’d
in the LPAR, the AP bus detects the AP adapter cards assigned to the LPAR and
creates a sysfs device for each assigned adapter. For example, if AP adapters
4 and 10 (0x0a) are assigned to the LPAR, the AP bus will create the following
sysfs device entries:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/ap/card04
/sys/devices/ap/card0a
</pre></div>
</div>
<p>Symbolic links to these devices will also be created in the AP bus devices
sub-directory:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/bus/ap/devices/[card04]
/sys/bus/ap/devices/[card04]
</pre></div>
</div>
</li>
<li><p class="first">AP domain</p>
<p>An adapter is partitioned into domains. An adapter can hold up to 256 domains
depending upon the adapter type and hardware configuration. A domain is
identified by a number from 0 to 255; however, the maximum domain number is
determined by machine model and/or adapter type.. A domain can be thought of
as a set of hardware registers and memory used for processing AP commands. A
domain can be configured with a secure private key used for clear key
encryption. A domain is classified in one of two ways depending upon how it
may be accessed:</p>
<blockquote>
<div><ul class="simple">
<li>Usage domains are domains that are targeted by an AP instruction to
process an AP command.</li>
<li>Control domains are domains that are changed by an AP command sent to a
usage domain; for example, to set the secure private key for the control
domain.</li>
</ul>
</div></blockquote>
<p>The AP usage and control domains are assigned to a given LPAR via the system’s
Activation Profile which can be edited via the HMC. When a linux host system
is IPL’d in the LPAR, the AP bus module detects the AP usage and control
domains assigned to the LPAR. The domain number of each usage domain and
adapter number of each AP adapter are combined to create AP queue devices
(see AP Queue section below). The domain number of each control domain will be
represented in a bitmask and stored in a sysfs file
/sys/bus/ap/ap_control_domain_mask. The bits in the mask, from most to least
significant bit, correspond to domains 0-255.</p>
</li>
<li><p class="first">AP Queue</p>
<p>An AP queue is the means by which an AP command is sent to a usage domain
inside a specific adapter. An AP queue is identified by a tuple
comprised of an AP adapter ID (APID) and an AP queue index (APQI). The
APQI corresponds to a given usage domain number within the adapter. This tuple
forms an AP Queue Number (APQN) uniquely identifying an AP queue. AP
instructions include a field containing the APQN to identify the AP queue to
which the AP command is to be sent for processing.</p>
<p>The AP bus will create a sysfs device for each APQN that can be derived from
the cross product of the AP adapter and usage domain numbers detected when the
AP bus module is loaded. For example, if adapters 4 and 10 (0x0a) and usage
domains 6 and 71 (0x47) are assigned to the LPAR, the AP bus will create the
following sysfs entries:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/ap/card04/04.0006
/sys/devices/ap/card04/04.0047
/sys/devices/ap/card0a/0a.0006
/sys/devices/ap/card0a/0a.0047
</pre></div>
</div>
<p>The following symbolic links to these devices will be created in the AP bus
devices subdirectory:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/bus/ap/devices/[04.0006]
/sys/bus/ap/devices/[04.0047]
/sys/bus/ap/devices/[0a.0006]
/sys/bus/ap/devices/[0a.0047]
</pre></div>
</div>
</li>
<li><p class="first">AP Instructions:</p>
<p>There are three AP instructions:</p>
<ul class="simple">
<li>NQAP: to enqueue an AP command-request message to a queue</li>
<li>DQAP: to dequeue an AP command-reply message from a queue</li>
<li>PQAP: to administer the queues</li>
</ul>
<p>AP instructions identify the domain that is targeted to process the AP
command; this must be one of the usage domains. An AP command may modify a
domain that is not one of the usage domains, but the modified domain
must be one of the control domains.</p>
</li>
</ul>
</div>
<div class="section" id="ap-and-sie">
<h2>AP and SIE<a class="headerlink" href="#ap-and-sie" title="Permalink to this headline">¶</a></h2>
<p>Let’s now take a look at how AP instructions executed on a guest are interpreted
by the hardware.</p>
<p>A satellite control block called the Crypto Control Block (CRYCB) is attached to
our main hardware virtualization control block. The CRYCB contains three fields
to identify the adapters, usage domains and control domains assigned to the KVM
guest:</p>
<ul class="simple">
<li>The AP Mask (APM) field is a bit mask that identifies the AP adapters assigned
to the KVM guest. Each bit in the mask, from left to right (i.e. from most
significant to least significant bit in big endian order), corresponds to
an APID from 0-255. If a bit is set, the corresponding adapter is valid for
use by the KVM guest.</li>
<li>The AP Queue Mask (AQM) field is a bit mask identifying the AP usage domains
assigned to the KVM guest. Each bit in the mask, from left to right (i.e. from
most significant to least significant bit in big endian order), corresponds to
an AP queue index (APQI) from 0-255. If a bit is set, the corresponding queue
is valid for use by the KVM guest.</li>
<li>The AP Domain Mask field is a bit mask that identifies the AP control domains
assigned to the KVM guest. The ADM bit mask controls which domains can be
changed by an AP command-request message sent to a usage domain from the
guest. Each bit in the mask, from left to right (i.e. from most significant to
least significant bit in big endian order), corresponds to a domain from
0-255. If a bit is set, the corresponding domain can be modified by an AP
command-request message sent to a usage domain.</li>
</ul>
<p>If you recall from the description of an AP Queue, AP instructions include
an APQN to identify the AP queue to which an AP command-request message is to be
sent (NQAP and PQAP instructions), or from which a command-reply message is to
be received (DQAP instruction). The validity of an APQN is defined by the matrix
calculated from the APM and AQM; it is the cross product of all assigned adapter
numbers (APM) with all assigned queue indexes (AQM). For example, if adapters 1
and 2 and usage domains 5 and 6 are assigned to a guest, the APQNs (1,5), (1,6),
(2,5) and (2,6) will be valid for the guest.</p>
<p>The APQNs can provide secure key functionality - i.e., a private key is stored
on the adapter card for each of its domains - so each APQN must be assigned to
at most one guest or to the linux host:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Example 1: Valid configuration:
------------------------------
Guest1: adapters 1,2  domains 5,6
Guest2: adapter  1,2  domain 7

This is valid because both guests have a unique set of APQNs:
   Guest1 has APQNs (1,5), (1,6), (2,5), (2,6);
   Guest2 has APQNs (1,7), (2,7)

Example 2: Valid configuration:
------------------------------
Guest1: adapters 1,2 domains 5,6
Guest2: adapters 3,4 domains 5,6

This is also valid because both guests have a unique set of APQNs:
   Guest1 has APQNs (1,5), (1,6), (2,5), (2,6);
   Guest2 has APQNs (3,5), (3,6), (4,5), (4,6)

Example 3: Invalid configuration:
--------------------------------
Guest1: adapters 1,2  domains 5,6
Guest2: adapter  1    domains 6,7

This is an invalid configuration because both guests have access to
APQN (1,6).
</pre></div>
</div>
</div>
<div class="section" id="the-design">
<h2>The Design<a class="headerlink" href="#the-design" title="Permalink to this headline">¶</a></h2>
<p>The design introduces three new objects:</p>
<ol class="arabic simple">
<li>AP matrix device</li>
<li>VFIO AP device driver (vfio_ap.ko)</li>
<li>VFIO AP mediated matrix pass-through device</li>
</ol>
<div class="section" id="the-vfio-ap-device-driver">
<h3>The VFIO AP device driver<a class="headerlink" href="#the-vfio-ap-device-driver" title="Permalink to this headline">¶</a></h3>
<p>The VFIO AP (vfio_ap) device driver serves the following purposes:</p>
<ol class="arabic simple">
<li>Provides the interfaces to secure APQNs for exclusive use of KVM guests.</li>
<li>Sets up the VFIO mediated device interfaces to manage a mediated matrix
device and creates the sysfs interfaces for assigning adapters, usage
domains, and control domains comprising the matrix for a KVM guest.</li>
<li>Configures the APM, AQM and ADM in the CRYCB referenced by a KVM guest’s
SIE state description to grant the guest access to a matrix of AP devices</li>
</ol>
</div>
<div class="section" id="reserve-apqns-for-exclusive-use-of-kvm-guests">
<h3>Reserve APQNs for exclusive use of KVM guests<a class="headerlink" href="#reserve-apqns-for-exclusive-use-of-kvm-guests" title="Permalink to this headline">¶</a></h3>
<p>The following block diagram illustrates the mechanism by which APQNs are
reserved:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                              +------------------+
               7 remove       |                  |
         +--------------------&gt; cex4queue driver |
         |                    |                  |
         |                    +------------------+
         |
         |
         |                    +------------------+          +----------------+
         |  5 register driver |                  | 3 create |                |
         |   +----------------&gt;   Device core    +----------&gt;  matrix device |
         |   |                |                  |          |                |
         |   |                +--------^---------+          +----------------+
         |   |                         |
         |   |                         +-------------------+
         |   | +-----------------------------------+       |
         |   | |      4 register AP driver         |       | 2 register device
         |   | |                                   |       |
+--------+---+-v---+                      +--------+-------+-+
|                  |                      |                  |
|      ap_bus      +--------------------- &gt;  vfio_ap driver  |
|                  |       8 probe        |                  |
+--------^---------+                      +--^--^------------+
6 edit   |                                   |  |
  apmask |     +-----------------------------+  | 9 mdev create
  aqmask |     |           1 modprobe           |
+--------+-----+---+           +----------------+-+         +----------------+
|                  |           |                  |8 create |     mediated   |
|      admin       |           | VFIO device core |---------&gt;     matrix     |
|                  +           |                  |         |     device     |
+------+-+---------+           +--------^---------+         +--------^-------+
       | |                              |                            |
       | | 9 create vfio_ap-passthrough |                            |
       | +------------------------------+                            |
       +-------------------------------------------------------------+
                   10  assign adapter/domain/control domain
</pre></div>
</div>
<p>The process for reserving an AP queue for use by a KVM guest is:</p>
<ol class="arabic simple">
<li>The administrator loads the vfio_ap device driver</li>
<li>The vfio-ap driver during its initialization will register a single ‘matrix’
device with the device core. This will serve as the parent device for
all mediated matrix devices used to configure an AP matrix for a guest.</li>
<li>The /sys/devices/vfio_ap/matrix device is created by the device core</li>
<li>The vfio_ap device driver will register with the AP bus for AP queue devices
of type 10 and higher (CEX4 and newer). The driver will provide the vfio_ap
driver’s probe and remove callback interfaces. Devices older than CEX4 queues
are not supported to simplify the implementation by not needlessly
complicating the design by supporting older devices that will go out of
service in the relatively near future, and for which there are few older
systems around on which to test.</li>
<li>The AP bus registers the vfio_ap device driver with the device core</li>
<li>The administrator edits the AP adapter and queue masks to reserve AP queues
for use by the vfio_ap device driver.</li>
<li>The AP bus removes the AP queues reserved for the vfio_ap driver from the
default zcrypt cex4queue driver.</li>
<li>The AP bus probes the vfio_ap device driver to bind the queues reserved for
it.</li>
<li>The administrator creates a passthrough type mediated matrix device to be
used by a guest</li>
<li>The administrator assigns the adapters, usage domains and control domains
to be exclusively used by a guest.</li>
</ol>
</div>
<div class="section" id="set-up-the-vfio-mediated-device-interfaces">
<h3>Set up the VFIO mediated device interfaces<a class="headerlink" href="#set-up-the-vfio-mediated-device-interfaces" title="Permalink to this headline">¶</a></h3>
<p>The VFIO AP device driver utilizes the common interface of the VFIO mediated
device core driver to:</p>
<ul class="simple">
<li>Register an AP mediated bus driver to add a mediated matrix device to and
remove it from a VFIO group.</li>
<li>Create and destroy a mediated matrix device</li>
<li>Add a mediated matrix device to and remove it from the AP mediated bus driver</li>
<li>Add a mediated matrix device to and remove it from an IOMMU group</li>
</ul>
<p>The following high-level block diagram shows the main components and interfaces
of the VFIO AP mediated matrix device driver:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-------------+
|             |
| +---------+ | mdev_register_driver() +--------------+
| |  Mdev   | +&lt;-----------------------+              |
| |  bus    | |                        | vfio_mdev.ko |
| | driver  | +-----------------------&gt;+              |&lt;-&gt; VFIO user
| +---------+ |    probe()/remove()    +--------------+    APIs
|             |
|  MDEV CORE  |
|   MODULE    |
|   mdev.ko   |
| +---------+ | mdev_register_device() +--------------+
| |Physical | +&lt;-----------------------+              |
| | device  | |                        |  vfio_ap.ko  |&lt;-&gt; matrix
| |interface| +-----------------------&gt;+              |    device
| +---------+ |       callback         +--------------+
+-------------+
</pre></div>
</div>
<p>During initialization of the vfio_ap module, the matrix device is registered
with an ‘mdev_parent_ops’ structure that provides the sysfs attribute
structures, mdev functions and callback interfaces for managing the mediated
matrix device.</p>
<ul>
<li><p class="first">sysfs attribute structures:</p>
<dl class="docutils">
<dt>supported_type_groups</dt>
<dd><p class="first">The VFIO mediated device framework supports creation of user-defined
mediated device types. These mediated device types are specified
via the ‘supported_type_groups’ structure when a device is registered
with the mediated device framework. The registration process creates the
sysfs structures for each mediated device type specified in the
‘mdev_supported_types’ sub-directory of the device being registered. Along
with the device type, the sysfs attributes of the mediated device type are
provided.</p>
<p>The VFIO AP device driver will register one mediated device type for
passthrough devices:</p>
<blockquote>
<div><p>/sys/devices/vfio_ap/matrix/mdev_supported_types/vfio_ap-passthrough</p>
</div></blockquote>
<p>Only the read-only attributes required by the VFIO mdev framework will
be provided:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>... name
... device_api
... available_instances
... device_api
</pre></div>
</div>
<p>Where:</p>
<blockquote class="last">
<div><ul class="simple">
<li><dl class="first docutils">
<dt>name:</dt>
<dd>specifies the name of the mediated device type</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>device_api:</dt>
<dd>the mediated device type’s API</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>available_instances:</dt>
<dd>the number of mediated matrix passthrough devices
that can be created</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>device_api:</dt>
<dd>specifies the VFIO API</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd>
<dt>mdev_attr_groups</dt>
<dd><p class="first">This attribute group identifies the user-defined sysfs attributes of the
mediated device. When a device is registered with the VFIO mediated device
framework, the sysfs attribute files identified in the ‘mdev_attr_groups’
structure will be created in the mediated matrix device’s directory. The
sysfs attributes for a mediated matrix device are:</p>
<dl class="last docutils">
<dt>assign_adapter / unassign_adapter:</dt>
<dd><p class="first last">Write-only attributes for assigning/unassigning an AP adapter to/from the
mediated matrix device. To assign/unassign an adapter, the APID of the
adapter is echoed to the respective attribute file.</p>
</dd>
<dt>assign_domain / unassign_domain:</dt>
<dd><p class="first last">Write-only attributes for assigning/unassigning an AP usage domain to/from
the mediated matrix device. To assign/unassign a domain, the domain
number of the the usage domain is echoed to the respective attribute
file.</p>
</dd>
<dt>matrix:</dt>
<dd><p class="first last">A read-only file for displaying the APQNs derived from the cross product
of the adapter and domain numbers assigned to the mediated matrix device.</p>
</dd>
<dt>assign_control_domain / unassign_control_domain:</dt>
<dd><p class="first last">Write-only attributes for assigning/unassigning an AP control domain
to/from the mediated matrix device. To assign/unassign a control domain,
the ID of the domain to be assigned/unassigned is echoed to the respective
attribute file.</p>
</dd>
<dt>control_domains:</dt>
<dd><p class="first last">A read-only file for displaying the control domain numbers assigned to the
mediated matrix device.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><p class="first">functions:</p>
<dl class="docutils">
<dt>create:</dt>
<dd><p class="first">allocates the ap_matrix_mdev structure used by the vfio_ap driver to:</p>
<ul class="last simple">
<li>Store the reference to the KVM structure for the guest using the mdev</li>
<li>Store the AP matrix configuration for the adapters, domains, and control
domains assigned via the corresponding sysfs attributes files</li>
</ul>
</dd>
<dt>remove:</dt>
<dd><p class="first last">deallocates the mediated matrix device’s ap_matrix_mdev structure. This will
be allowed only if a running guest is not using the mdev.</p>
</dd>
</dl>
</li>
<li><p class="first">callback interfaces</p>
<dl class="docutils">
<dt>open:</dt>
<dd><p class="first last">The vfio_ap driver uses this callback to register a
VFIO_GROUP_NOTIFY_SET_KVM notifier callback function for the mdev matrix
device. The open is invoked when QEMU connects the VFIO iommu group
for the mdev matrix device to the MDEV bus. Access to the KVM structure used
to configure the KVM guest is provided via this callback. The KVM structure,
is used to configure the guest’s access to the AP matrix defined via the
mediated matrix device’s sysfs attribute files.</p>
</dd>
<dt>release:</dt>
<dd><p class="first last">unregisters the VFIO_GROUP_NOTIFY_SET_KVM notifier callback function for the
mdev matrix device and deconfigures the guest’s AP matrix.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="configure-the-apm-aqm-and-adm-in-the-crycb">
<h3>Configure the APM, AQM and ADM in the CRYCB<a class="headerlink" href="#configure-the-apm-aqm-and-adm-in-the-crycb" title="Permalink to this headline">¶</a></h3>
<p>Configuring the AP matrix for a KVM guest will be performed when the
VFIO_GROUP_NOTIFY_SET_KVM notifier callback is invoked. The notifier
function is called when QEMU connects to KVM. The guest’s AP matrix is
configured via it’s CRYCB by:</p>
<ul class="simple">
<li>Setting the bits in the APM corresponding to the APIDs assigned to the
mediated matrix device via its ‘assign_adapter’ interface.</li>
<li>Setting the bits in the AQM corresponding to the domains assigned to the
mediated matrix device via its ‘assign_domain’ interface.</li>
<li>Setting the bits in the ADM corresponding to the domain dIDs assigned to the
mediated matrix device via its ‘assign_control_domains’ interface.</li>
</ul>
</div>
<div class="section" id="the-cpu-model-features-for-ap">
<h3>The CPU model features for AP<a class="headerlink" href="#the-cpu-model-features-for-ap" title="Permalink to this headline">¶</a></h3>
<p>The AP stack relies on the presence of the AP instructions as well as two
facilities: The AP Facilities Test (APFT) facility; and the AP Query
Configuration Information (QCI) facility. These features/facilities are made
available to a KVM guest via the following CPU model features:</p>
<ol class="arabic simple">
<li>ap: Indicates whether the AP instructions are installed on the guest. This
feature will be enabled by KVM only if the AP instructions are installed
on the host.</li>
<li>apft: Indicates the APFT facility is available on the guest. This facility
can be made available to the guest only if it is available on the host (i.e.,
facility bit 15 is set).</li>
<li>apqci: Indicates the AP QCI facility is available on the guest. This facility
can be made available to the guest only if it is available on the host (i.e.,
facility bit 12 is set).</li>
</ol>
<p>Note: If the user chooses to specify a CPU model different than the ‘host’
model to QEMU, the CPU model features and facilities need to be turned on
explicitly; for example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/usr/bin/qemu-system-s390x ... -cpu z13,ap=on,apqci=on,apft=on
</pre></div>
</div>
<p>A guest can be precluded from using AP features/facilities by turning them off
explicitly; for example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/usr/bin/qemu-system-s390x ... -cpu host,ap=off,apqci=off,apft=off
</pre></div>
</div>
<p>Note: If the APFT facility is turned off (apft=off) for the guest, the guest
will not see any AP devices. The zcrypt device drivers that register for type 10
and newer AP devices - i.e., the cex4card and cex4queue device drivers - need
the APFT facility to ascertain the facilities installed on a given AP device. If
the APFT facility is not installed on the guest, then the probe of device
drivers will fail since only type 10 and newer devices can be configured for
guest use.</p>
</div>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Let’s now provide an example to illustrate how KVM guests may be given
access to AP facilities. For this example, we will show how to configure
three guests such that executing the lszcrypt command on the guests would
look like this:</p>
<div class="section" id="guest1">
<h3>Guest1<a class="headerlink" href="#guest1" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="18%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">CARD.DOMAIN</th>
<th class="head">TYPE</th>
<th class="head">MODE</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>05</td>
<td>CEX5C</td>
<td>CCA-Coproc</td>
</tr>
<tr class="row-odd"><td>05.0004</td>
<td>CEX5C</td>
<td>CCA-Coproc</td>
</tr>
<tr class="row-even"><td>05.00ab</td>
<td>CEX5C</td>
<td>CCA-Coproc</td>
</tr>
<tr class="row-odd"><td>06</td>
<td>CEX5A</td>
<td>Accelerator</td>
</tr>
<tr class="row-even"><td>06.0004</td>
<td>CEX5A</td>
<td>Accelerator</td>
</tr>
<tr class="row-odd"><td>06.00ab</td>
<td>CEX5C</td>
<td>CCA-Coproc</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="guest2">
<h3>Guest2<a class="headerlink" href="#guest2" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="18%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">CARD.DOMAIN</th>
<th class="head">TYPE</th>
<th class="head">MODE</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>05</td>
<td>CEX5A</td>
<td>Accelerator</td>
</tr>
<tr class="row-odd"><td>05.0047</td>
<td>CEX5A</td>
<td>Accelerator</td>
</tr>
<tr class="row-even"><td>05.00ff</td>
<td>CEX5A</td>
<td>Accelerator</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id1">
<h3>Guest2<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="18%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">CARD.DOMAIN</th>
<th class="head">TYPE</th>
<th class="head">MODE</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>06</td>
<td>CEX5A</td>
<td>Accelerator</td>
</tr>
<tr class="row-odd"><td>06.0047</td>
<td>CEX5A</td>
<td>Accelerator</td>
</tr>
<tr class="row-even"><td>06.00ff</td>
<td>CEX5A</td>
<td>Accelerator</td>
</tr>
</tbody>
</table>
<p>These are the steps:</p>
<ol class="arabic">
<li><p class="first">Install the vfio_ap module on the linux host. The dependency chain for the
vfio_ap module is:
* iommu
* s390
* zcrypt
* vfio
* vfio_mdev
* vfio_mdev_device
* KVM</p>
<p>To build the vfio_ap module, the kernel build must be configured with the
following Kconfig elements selected:
* IOMMU_SUPPORT
* S390
* ZCRYPT
* S390_AP_IOMMU
* VFIO
* VFIO_MDEV
* VFIO_MDEV_DEVICE
* KVM</p>
<p>If using make menuconfig select the following to build the vfio_ap module:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-&gt; Device Drivers
   -&gt; IOMMU Hardware Support
      select S390 AP IOMMU Support
   -&gt; VFIO Non-Privileged userspace driver framework
      -&gt; Mediated device driver frramework
         -&gt; VFIO driver for Mediated devices
-&gt; I/O subsystem
   -&gt; VFIO support for AP devices
</pre></div>
</div>
</li>
<li><p class="first">Secure the AP queues to be used by the three guests so that the host can not
access them. To secure them, there are two sysfs files that specify
bitmasks marking a subset of the APQN range as ‘usable by the default AP
queue device drivers’ or ‘not usable by the default device drivers’ and thus
available for use by the vfio_ap device driver’. The location of the sysfs
files containing the masks are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/bus/ap/apmask
/sys/bus/ap/aqmask
</pre></div>
</div>
<p>The ‘apmask’ is a 256-bit mask that identifies a set of AP adapter IDs
(APID). Each bit in the mask, from left to right (i.e., from most significant
to least significant bit in big endian order), corresponds to an APID from
0-255. If a bit is set, the APID is marked as usable only by the default AP
queue device drivers; otherwise, the APID is usable by the vfio_ap
device driver.</p>
<p>The ‘aqmask’ is a 256-bit mask that identifies a set of AP queue indexes
(APQI). Each bit in the mask, from left to right (i.e., from most significant
to least significant bit in big endian order), corresponds to an APQI from
0-255. If a bit is set, the APQI is marked as usable only by the default AP
queue device drivers; otherwise, the APQI is usable by the vfio_ap device
driver.</p>
<p>Take, for example, the following mask:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  0x7dffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

It indicates:

  1, 2, 3, 4, 5, and 7-255 belong to the default drivers&#39; pool, and 0 and 6
  belong to the vfio_ap device driver&#39;s pool.
</pre></div>
</div>
<p>The APQN of each AP queue device assigned to the linux host is checked by the
AP bus against the set of APQNs derived from the cross product of APIDs
and APQIs marked as usable only by the default AP queue device drivers. If a
match is detected,  only the default AP queue device drivers will be probed;
otherwise, the vfio_ap device driver will be probed.</p>
<p>By default, the two masks are set to reserve all APQNs for use by the default
AP queue device drivers. There are two ways the default masks can be changed:</p>
<ol class="arabic">
<li><p class="first">The sysfs mask files can be edited by echoing a string into the
respective sysfs mask file in one of two formats:</p>
<ul>
<li><p class="first">An absolute hex string starting with 0x - like “0x12345678” - sets
the mask. If the given string is shorter than the mask, it is padded
with 0s on the right; for example, specifying a mask value of 0x41 is
the same as specifying:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x4100000000000000000000000000000000000000000000000000000000000000
</pre></div>
</div>
<p>Keep in mind that the mask reads from left to right (i.e., most
significant to least significant bit in big endian order), so the mask
above identifies device numbers 1 and 7 (01000001).</p>
<p>If the string is longer than the mask, the operation is terminated with
an error (EINVAL).</p>
</li>
<li><p class="first">Individual bits in the mask can be switched on and off by specifying
each bit number to be switched in a comma separated list. Each bit
number string must be prepended with a (‘+’) or minus (‘-‘) to indicate
the corresponding bit is to be switched on (‘+’) or off (‘-‘). Some
valid values are:</p>
<blockquote>
<div><ul class="simple">
<li>“+0”    switches bit 0 on</li>
<li>“-13”   switches bit 13 off</li>
<li>“+0x41” switches bit 65 on</li>
<li>“-0xff” switches bit 255 off</li>
</ul>
</div></blockquote>
<p>The following example:</p>
<blockquote>
<div><p>+0,-6,+0x47,-0xf0</p>
</div></blockquote>
<p>Switches bits 0 and 71 (0x47) on</p>
<p>Switches bits 6 and 240 (0xf0) off</p>
<p>Note that the bits not specified in the list remain as they were before
the operation.</p>
</li>
</ul>
</li>
<li><p class="first">The masks can also be changed at boot time via parameters on the kernel
command line like this:</p>
<blockquote>
<div><p>ap.apmask=0xffff ap.aqmask=0x40</p>
<p>This would create the following masks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>apmask:
0xffff000000000000000000000000000000000000000000000000000000000000

aqmask:
0x4000000000000000000000000000000000000000000000000000000000000000
</pre></div>
</div>
<p>Resulting in these two pools:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>default drivers pool:    adapter 0-15, domain 1
alternate drivers pool:  adapter 16-255, domains 0, 2-255
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="securing-the-apqns-for-our-example">
<h3>Securing the APQNs for our example<a class="headerlink" href="#securing-the-apqns-for-our-example" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>To secure the AP queues 05.0004, 05.0047, 05.00ab, 05.00ff, 06.0004, 06.0047,
06.00ab, and 06.00ff for use by the vfio_ap device driver, the corresponding
APQNs can either be removed from the default masks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo -5,-6 &gt; /sys/bus/ap/apmask

echo -4,-0x47,-0xab,-0xff &gt; /sys/bus/ap/aqmask
</pre></div>
</div>
<p>Or the masks can be set as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 0xf9ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
&gt; apmask

echo 0xf7fffffffffffffffeffffffffffffffffffffffffeffffffffffffffffffffe \
&gt; aqmask
</pre></div>
</div>
<p>This will result in AP queues 05.0004, 05.0047, 05.00ab, 05.00ff, 06.0004,
06.0047, 06.00ab, and 06.00ff getting bound to the vfio_ap device driver. The
sysfs directory for the vfio_ap device driver will now contain symbolic links
to the AP queue devices bound to it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/bus/ap
... [drivers]
...... [vfio_ap]
......... [05.0004]
......... [05.0047]
......... [05.00ab]
......... [05.00ff]
......... [06.0004]
......... [06.0047]
......... [06.00ab]
......... [06.00ff]
</pre></div>
</div>
<p>Keep in mind that only type 10 and newer adapters (i.e., CEX4 and later)
can be bound to the vfio_ap device driver. The reason for this is to
simplify the implementation by not needlessly complicating the design by
supporting older devices that will go out of service in the relatively near
future and for which there are few older systems on which to test.</p>
<p>The administrator, therefore, must take care to secure only AP queues that
can be bound to the vfio_ap device driver. The device type for a given AP
queue device can be read from the parent card’s sysfs directory. For example,
to see the hardware type of the queue 05.0004:</p>
<blockquote>
<div>cat /sys/bus/ap/devices/card05/hwtype</div></blockquote>
<p>The hwtype must be 10 or higher (CEX4 or newer) in order to be bound to the
vfio_ap device driver.</p>
</div></blockquote>
<ol class="arabic" start="3">
<li><p class="first">Create the mediated devices needed to configure the AP matrixes for the
three guests and to provide an interface to the vfio_ap driver for
use by the guests:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/vfio_ap/matrix/
--- [mdev_supported_types]
------ [vfio_ap-passthrough] (passthrough mediated matrix device type)
--------- create
--------- [devices]
</pre></div>
</div>
<p>To create the mediated devices for the three guests:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>uuidgen &gt; create
uuidgen &gt; create
uuidgen &gt; create

or

echo $uuid1 &gt; create
echo $uuid2 &gt; create
echo $uuid3 &gt; create
</pre></div>
</div>
<p>This will create three mediated devices in the [devices] subdirectory named
after the UUID written to the create attribute file. We call them $uuid1,
$uuid2 and $uuid3 and this is the sysfs directory structure after creation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/vfio_ap/matrix/
--- [mdev_supported_types]
------ [vfio_ap-passthrough]
--------- [devices]
------------ [$uuid1]
--------------- assign_adapter
--------------- assign_control_domain
--------------- assign_domain
--------------- matrix
--------------- unassign_adapter
--------------- unassign_control_domain
--------------- unassign_domain

------------ [$uuid2]
--------------- assign_adapter
--------------- assign_control_domain
--------------- assign_domain
--------------- matrix
--------------- unassign_adapter
----------------unassign_control_domain
----------------unassign_domain

------------ [$uuid3]
--------------- assign_adapter
--------------- assign_control_domain
--------------- assign_domain
--------------- matrix
--------------- unassign_adapter
----------------unassign_control_domain
----------------unassign_domain
</pre></div>
</div>
</li>
<li><p class="first">The administrator now needs to configure the matrixes for the mediated
devices $uuid1 (for Guest1), $uuid2 (for Guest2) and $uuid3 (for Guest3).</p>
<p>This is how the matrix is configured for Guest1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 5 &gt; assign_adapter
echo 6 &gt; assign_adapter
echo 4 &gt; assign_domain
echo 0xab &gt; assign_domain
</pre></div>
</div>
<p>Control domains can similarly be assigned using the assign_control_domain
sysfs file.</p>
<p>If a mistake is made configuring an adapter, domain or control domain,
you can use the unassign_xxx files to unassign the adapter, domain or
control domain.</p>
<p>To display the matrix configuration for Guest1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat matrix
</pre></div>
</div>
<p>This is how the matrix is configured for Guest2:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 5 &gt; assign_adapter
echo 0x47 &gt; assign_domain
echo 0xff &gt; assign_domain
</pre></div>
</div>
<p>This is how the matrix is configured for Guest3:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 6 &gt; assign_adapter
echo 0x47 &gt; assign_domain
echo 0xff &gt; assign_domain
</pre></div>
</div>
<p>In order to successfully assign an adapter:</p>
<ul>
<li><p class="first">The adapter number specified must represent a value from 0 up to the
maximum adapter number configured for the system. If an adapter number
higher than the maximum is specified, the operation will terminate with
an error (ENODEV).</p>
</li>
<li><p class="first">All APQNs that can be derived from the adapter ID and the IDs of
the previously assigned domains must be bound to the vfio_ap device
driver. If no domains have yet been assigned, then there must be at least
one APQN with the specified APID bound to the vfio_ap driver. If no such
APQNs are bound to the driver, the operation will terminate with an
error (EADDRNOTAVAIL).</p>
<p>No APQN that can be derived from the adapter ID and the IDs of the
previously assigned domains can be assigned to another mediated matrix
device. If an APQN is assigned to another mediated matrix device, the
operation will terminate with an error (EADDRINUSE).</p>
</li>
</ul>
<p>In order to successfully assign a domain:</p>
<ul>
<li><p class="first">The domain number specified must represent a value from 0 up to the
maximum domain number configured for the system. If a domain number
higher than the maximum is specified, the operation will terminate with
an error (ENODEV).</p>
</li>
<li><p class="first">All APQNs that can be derived from the domain ID and the IDs of
the previously assigned adapters must be bound to the vfio_ap device
driver. If no domains have yet been assigned, then there must be at least
one APQN with the specified APQI bound to the vfio_ap driver. If no such
APQNs are bound to the driver, the operation will terminate with an
error (EADDRNOTAVAIL).</p>
<p>No APQN that can be derived from the domain ID and the IDs of the
previously assigned adapters can be assigned to another mediated matrix
device. If an APQN is assigned to another mediated matrix device, the
operation will terminate with an error (EADDRINUSE).</p>
</li>
</ul>
<p>In order to successfully assign a control domain, the domain number
specified must represent a value from 0 up to the maximum domain number
configured for the system. If a control domain number higher than the maximum
is specified, the operation will terminate with an error (ENODEV).</p>
</li>
<li><p class="first">Start Guest1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/usr/bin/qemu-system-s390x ... -cpu host,ap=on,apqci=on,apft=on \
   -device vfio-ap,sysfsdev=/sys/devices/vfio_ap/matrix/$uuid1 ...
</pre></div>
</div>
</li>
</ol>
<ol class="arabic" start="7">
<li><p class="first">Start Guest2:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/usr/bin/qemu-system-s390x ... -cpu host,ap=on,apqci=on,apft=on \
   -device vfio-ap,sysfsdev=/sys/devices/vfio_ap/matrix/$uuid2 ...
</pre></div>
</div>
</li>
</ol>
<ol class="arabic" start="7">
<li><p class="first">Start Guest3:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/usr/bin/qemu-system-s390x ... -cpu host,ap=on,apqci=on,apft=on \
   -device vfio-ap,sysfsdev=/sys/devices/vfio_ap/matrix/$uuid3 ...
</pre></div>
</div>
</li>
</ol>
<p>When the guest is shut down, the mediated matrix devices may be removed.</p>
<p>Using our example again, to remove the mediated matrix device $uuid1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/vfio_ap/matrix/
   --- [mdev_supported_types]
   ------ [vfio_ap-passthrough]
   --------- [devices]
   ------------ [$uuid1]
   --------------- remove
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 1 &gt; remove
</pre></div>
</div>
<p>This will remove all of the mdev matrix device’s sysfs structures including
the mdev device itself. To recreate and reconfigure the mdev matrix device,
all of the steps starting with step 3 will have to be performed again. Note
that the remove will fail if a guest using the mdev is still running.</p>
<p>It is not necessary to remove an mdev matrix device, but one may want to
remove it if no guest will use it during the remaining lifetime of the linux
host. If the mdev matrix device is removed, one may want to also reconfigure
the pool of adapters and queues reserved for use by the default drivers.</p>
</div>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>The KVM/kernel interfaces do not provide a way to prevent restoring an APQN
to the default drivers pool of a queue that is still assigned to a mediated
device in use by a guest. It is incumbent upon the administrator to
ensure there is no mediated device in use by a guest to which the APQN is
assigned lest the host be given access to the private data of the AP queue
device such as a private key configured specifically for the guest.</li>
<li>Dynamically modifying the AP matrix for a running guest (which would amount to
hot(un)plug of AP devices for the guest) is currently not supported</li>
<li>Live guest migration is not supported for guests using AP devices.</li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>