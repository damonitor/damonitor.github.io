

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>User Mode Linux HOWTO &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/mm/damon/index.html">Monitoring Data Accesses</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../vm/damon/index.html">DAMON: Data Access MONitor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>User Mode Linux HOWTO</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/virt/uml/user_mode_linux.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="user-mode-linux-howto">
<h1>User Mode Linux HOWTO<a class="headerlink" href="#user-mode-linux-howto" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">User Mode Linux Core Team</td>
</tr>
<tr class="field-even field"><th class="field-name">Last-updated:</th><td class="field-body">Sat Jan 25 16:07:55 CET 2020</td>
</tr>
</tbody>
</table>
<p>This document describes the use and abuse of Jeff Dike’s User Mode
Linux: a port of the Linux kernel as a normal Intel Linux process.</p>
<div class="section" id="introduction">
<h2>1.  Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Welcome to User Mode Linux.  It’s going to be fun.</div></blockquote>
<div class="section" id="how-is-user-mode-linux-different">
<h3>1.1.  How is User Mode Linux Different?<a class="headerlink" href="#how-is-user-mode-linux-different" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Normally, the Linux Kernel talks straight to your hardware (video
card, keyboard, hard drives, etc), and any programs which run ask the
kernel to operate the hardware, like so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-----------+-----------+----+
| Process 1 | Process 2 | ...|
+-----------+-----------+----+
|       Linux Kernel         |
+----------------------------+
|         Hardware           |
+----------------------------+
</pre></div>
</div>
<p>The User Mode Linux Kernel is different; instead of talking to the
hardware, it talks to a <cite>real</cite> Linux kernel (called the <cite>host kernel</cite>
from now on), like any other program.  Programs can then run inside
User-Mode Linux as if they were running under a normal kernel, like
so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            +----------------+
            | Process 2 | ...|
+-----------+----------------+
| Process 1 | User-Mode Linux|
+----------------------------+
|       Linux Kernel         |
+----------------------------+
|         Hardware           |
+----------------------------+
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="why-would-i-want-user-mode-linux">
<h3>1.2.  Why Would I Want User Mode Linux?<a class="headerlink" href="#why-would-i-want-user-mode-linux" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ol class="arabic simple">
<li>If User Mode Linux crashes, your host kernel is still fine.</li>
<li>You can run a usermode kernel as a non-root user.</li>
<li>You can debug the User Mode Linux like any normal process.</li>
<li>You can run gprof (profiling) and gcov (coverage testing).</li>
<li>You can play with your kernel without breaking things.</li>
<li>You can use it as a sandbox for testing new apps.</li>
<li>You can try new development kernels safely.</li>
<li>You can run different distributions simultaneously.</li>
<li>It’s extremely fun.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="compiling-the-kernel-and-modules">
<span id="id1"></span><h2>2.  Compiling the kernel and modules<a class="headerlink" href="#compiling-the-kernel-and-modules" title="Permalink to this headline">¶</a></h2>
<div class="section" id="compiling-the-kernel">
<h3>2.1.  Compiling the kernel<a class="headerlink" href="#compiling-the-kernel" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Compiling the user mode kernel is just like compiling any other
kernel.</p>
<ol class="arabic">
<li><p class="first">Download the latest kernel from your favourite kernel mirror,
such as:</p>
<p><a class="reference external" href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.14.tar.xz">https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.14.tar.xz</a></p>
</li>
<li><p class="first">Make a directory and unpack the kernel into it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host%
mkdir ~/uml

host%
cd ~/uml

host%
tar xvf linux-5.4.14.tar.xz
</pre></div>
</div>
</li>
<li><p class="first">Run your favorite config; <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">xconfig</span> <span class="pre">ARCH=um</span></code> is the most
convenient.  <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">config</span> <span class="pre">ARCH=um</span></code> and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">menuconfig</span> <span class="pre">ARCH=um</span></code>
will work as well.  The defaults will give you a useful kernel.  If
you want to change something, go ahead, it probably won’t hurt
anything.</p>
<p>Note:  If the host is configured with a 2G/2G address space split
rather than the usual 3G/1G split, then the packaged UML binaries
will not run.  They will immediately segfault.  See
<a class="reference internal" href="#uml-on-2g-2g-hosts"><span class="std std-ref">4.  UML on 2G/2G hosts</span></a>  for the scoop on running UML on your system.</p>
</li>
<li><p class="first">Finish with <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">linux</span> <span class="pre">ARCH=um</span></code>: the result is a file called
<code class="docutils literal notranslate"><span class="pre">linux</span></code> in the top directory of your source tree.</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="compiling-and-installing-kernel-modules">
<h3>2.2.  Compiling and installing kernel modules<a class="headerlink" href="#compiling-and-installing-kernel-modules" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>UML modules are built in the same way as the native kernel (with the
exception of the ‘ARCH=um’ that you always need for UML):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% make modules ARCH=um
</pre></div>
</div>
<p>Any modules that you want to load into this kernel need to be built in
the user-mode pool.  Modules from the native kernel won’t work.</p>
<p>You can install them by using ftp or something to copy them into the
virtual machine and dropping them into <code class="docutils literal notranslate"><span class="pre">/lib/modules/$(uname</span> <span class="pre">-r)</span></code>.</p>
<p>You can also get the kernel build process to install them as follows:</p>
<ol class="arabic">
<li><p class="first">with the kernel not booted, mount the root filesystem in the top
level of the kernel pool:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% mount root_fs mnt -o loop
</pre></div>
</div>
</li>
<li><p class="first">run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host%
make modules_install INSTALL_MOD_PATH=`pwd`/mnt ARCH=um
</pre></div>
</div>
</li>
<li><p class="first">unmount the filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% umount mnt
</pre></div>
</div>
</li>
<li><p class="first">boot the kernel on it</p>
</li>
</ol>
<p>When the system is booted, you can use insmod as usual to get the
modules into the kernel.  A number of things have been loaded into UML
as modules, especially filesystems and network protocols and filters,
so most symbols which need to be exported probably already are.
However, if you do find symbols that need exporting, let  us
know at <a class="reference external" href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</a>, and
they’ll be “taken care of”.</p>
</div></blockquote>
</div>
<div class="section" id="compiling-and-installing-uml-utilities">
<h3>2.3.  Compiling and installing uml_utilities<a class="headerlink" href="#compiling-and-installing-uml-utilities" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Many features of the UML kernel require a user-space helper program,
so a uml_utilities package is distributed separately from the kernel
patch which provides these helpers. Included within this is:</p>
<ul>
<li><p class="first">port-helper - Used by consoles which connect to xterms or ports</p>
</li>
<li><p class="first">tunctl - Configuration tool to create and delete tap devices</p>
</li>
<li><p class="first">uml_net - Setuid binary for automatic tap device configuration</p>
</li>
<li><p class="first">uml_switch - User-space virtual switch required for daemon
transport</p>
<p>The uml_utilities tree is compiled with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#
make &amp;&amp; make install
</pre></div>
</div>
</li>
</ul>
<p>Note that UML kernel patches may require a specific version of the
uml_utilities distribution. If you don’t keep up with the mailing
lists, ensure that you have the latest release of uml_utilities if you
are experiencing problems with your UML kernel, particularly when
dealing with consoles or command-line switches to the helper programs</p>
</div></blockquote>
</div>
</div>
<div class="section" id="running-uml-and-logging-in">
<h2>3.  Running UML and logging in<a class="headerlink" href="#running-uml-and-logging-in" title="Permalink to this headline">¶</a></h2>
<div class="section" id="running-uml">
<h3>3.1.  Running UML<a class="headerlink" href="#running-uml" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>It runs on 2.2.15 or later, and all kernel versions since 2.4.</p>
<p>Booting UML is straightforward.  Simply run ‘linux’: it will try to
mount the file <code class="docutils literal notranslate"><span class="pre">root_fs</span></code> in the current directory.  You do not need to
run it as root.  If your root filesystem is not named <code class="docutils literal notranslate"><span class="pre">root_fs</span></code>, then
you need to put a <code class="docutils literal notranslate"><span class="pre">ubd0=root_fs_whatever</span></code> switch on the linux command
line.</p>
<p>You will need a filesystem to boot UML from.  There are a number
available for download from <a class="reference external" href="http://user-mode-linux.sourceforge.net">http://user-mode-linux.sourceforge.net</a>.
There are also  several tools at
<a class="reference external" href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</a>  which can be
used to generate UML-compatible filesystem images from media.
The kernel will boot up and present you with a login prompt.</p>
</div></blockquote>
<dl class="docutils">
<dt>Note:</dt>
<dd>If the host is configured with a 2G/2G address space split
rather than the usual 3G/1G split, then the packaged UML binaries will
not run.  They will immediately segfault.  See <a class="reference internal" href="#uml-on-2g-2g-hosts"><span class="std std-ref">4.  UML on 2G/2G hosts</span></a>
for the scoop on running UML on your system.</dd>
</dl>
</div>
<div class="section" id="logging-in">
<h3>3.2.  Logging in<a class="headerlink" href="#logging-in" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The prepackaged filesystems have a root account with password ‘root’
and a user account with password ‘user’.  The login banner will
generally tell you how to log in.  So, you log in and you will find
yourself inside a little virtual machine. Our filesystems have a
variety of commands and utilities installed (and it is fairly easy to
add more), so you will have a lot of tools with which to poke around
the system.</p>
<p>There are a couple of other ways to log in:</p>
<ul>
<li><p class="first">On a virtual console</p>
<p>Each virtual console that is configured (i.e. the device exists in
/dev and /etc/inittab runs a getty on it) will come up in its own
xterm.  If you get tired of the xterms, read
<a class="reference internal" href="#setting-up-serial-lines-and-consoles"><span class="std std-ref">5.  Setting up serial lines and consoles</span></a> to see how to attach
the consoles to something else, like host ptys.</p>
</li>
<li><p class="first">Over the serial line</p>
<p>In the boot output, find a line that looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>serial line 0 assigned pty /dev/ptyp1
</pre></div>
</div>
</li>
</ul>
<p>Attach your favorite terminal program to the corresponding tty.  I.e.
for minicom, the command would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% minicom -o -p /dev/ttyp1
</pre></div>
</div>
<ul>
<li><p class="first">Over the net</p>
<p>If the network is running, then you can telnet to the virtual
machine and log in to it.  See <a class="reference internal" href="#setting-up-the-network"><span class="std std-ref">6.  Setting up the network</span></a>  to learn
about setting up a virtual network.</p>
</li>
</ul>
<p>When you’re done using it, run halt, and the kernel will bring itself
down and the process will exit.</p>
</div></blockquote>
</div>
<div class="section" id="examples">
<h3>3.3.  Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Here are some examples of UML in action:</p>
<ul class="simple">
<li>A login session <a class="reference external" href="http://user-mode-linux.sourceforge.net/old/login.html">http://user-mode-linux.sourceforge.net/old/login.html</a></li>
<li>A virtual network <a class="reference external" href="http://user-mode-linux.sourceforge.net/old/net.html">http://user-mode-linux.sourceforge.net/old/net.html</a></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="uml-on-2g-2g-hosts">
<span id="id2"></span><h2>4.  UML on 2G/2G hosts<a class="headerlink" href="#uml-on-2g-2g-hosts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>4.1.  Introduction<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Most Linux machines are configured so that the kernel occupies the
upper 1G (0xc0000000 - 0xffffffff) of the 4G address space and
processes use the lower 3G (0x00000000 - 0xbfffffff).  However, some
machine are configured with a 2G/2G split, with the kernel occupying
the upper 2G (0x80000000 - 0xffffffff) and processes using the lower
2G (0x00000000 - 0x7fffffff).</div></blockquote>
</div>
<div class="section" id="the-problem">
<h3>4.2.  The problem<a class="headerlink" href="#the-problem" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The prebuilt UML binaries on this site will not run on 2G/2G hosts
because UML occupies the upper .5G of the 3G process address space
(0xa0000000 - 0xbfffffff).  Obviously, on 2G/2G hosts, this is right
in the middle of the kernel address space, so UML won’t even load - it
will immediately segfault.</div></blockquote>
</div>
<div class="section" id="the-solution">
<h3>4.3.  The solution<a class="headerlink" href="#the-solution" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The fix for this is to rebuild UML from source after enabling
CONFIG_HOST_2G_2G (under ‘General Setup’).  This will cause UML to
load itself in the top .5G of that smaller process address space,
where it will run fine.  See <a class="reference internal" href="#compiling-the-kernel-and-modules"><span class="std std-ref">2.  Compiling the kernel and modules</span></a>  if
you need help building UML from source.</div></blockquote>
</div>
</div>
<div class="section" id="setting-up-serial-lines-and-consoles">
<span id="id4"></span><h2>5.  Setting up serial lines and consoles<a class="headerlink" href="#setting-up-serial-lines-and-consoles" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>It is possible to attach UML serial lines and consoles to many types
of host I/O channels by specifying them on the command line.</p>
<p>You can attach them to host ptys, ttys, file descriptors, and ports.
This allows you to do things like:</p>
<ul class="simple">
<li>have a UML console appear on an unused host console,</li>
<li>hook two virtual machines together by having one attach to a pty
and having the other attach to the corresponding tty</li>
<li>make a virtual machine accessible from the net by attaching a
console to a port on the host.</li>
</ul>
<p>The general format of the command line option is <code class="docutils literal notranslate"><span class="pre">device=channel</span></code>.</p>
</div></blockquote>
<div class="section" id="specifying-the-device">
<h3>5.1.  Specifying the device<a class="headerlink" href="#specifying-the-device" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Devices are specified with “con” or “ssl” (console or serial line,
respectively), optionally with a device number if you are talking
about a specific device.</p>
<p>Using just “con” or “ssl” describes all of the consoles or serial
lines.  If you want to talk about console #3 or serial line #10, they
would be “con3” and “ssl10”, respectively.</p>
<p>A specific device name will override a less general “con=” or “ssl=”.
So, for example, you can assign a pty to each of the serial lines
except for the first two like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssl=pty ssl0=tty:/dev/tty0 ssl1=tty:/dev/tty1
</pre></div>
</div>
<p>The specificity of the device name is all that matters; order on the
command line is irrelevant.</p>
</div></blockquote>
</div>
<div class="section" id="specifying-the-channel">
<h3>5.2.  Specifying the channel<a class="headerlink" href="#specifying-the-channel" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>There are a number of different types of channels to attach a UML
device to, each with a different way of specifying exactly what to
attach to.</p>
<ul>
<li><p class="first">pseudo-terminals - device=pty pts terminals - device=pts</p>
<p>This will cause UML to allocate a free host pseudo-terminal for the
device.  The terminal that it got will be announced in the boot
log.  You access it by attaching a terminal program to the
corresponding tty:</p>
</li>
<li><p class="first">screen /dev/pts/n</p>
</li>
<li><p class="first">screen /dev/ttyxx</p>
</li>
<li><p class="first">minicom -o -p /dev/ttyxx - minicom seems not able to handle pts
devices</p>
</li>
<li><p class="first">kermit - start it up, ‘open’ the device, then ‘connect’</p>
</li>
<li><p class="first">terminals - device=tty:tty device file</p>
<p>This will make UML attach the device to the specified tty (i.e:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>con1=tty:/dev/tty3
</pre></div>
</div>
</li>
</ul>
<p>will attach UML’s console 1 to the host’s /dev/tty3).  If the tty that
you specify is the slave end of a tty/pty pair, something else must
have already opened the corresponding pty in order for this to work.</p>
<ul>
<li><p class="first">xterms - device=xterm</p>
<p>UML will run an xterm and the device will be attached to it.</p>
</li>
<li><p class="first">Port - device=port:port number</p>
<p>This will attach the UML devices to the specified host port.
Attaching console 1 to the host’s port 9000 would be done like
this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>con1=port:9000
</pre></div>
</div>
</li>
</ul>
<p>Attaching all the serial lines to that port would be done similarly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssl=port:9000
</pre></div>
</div>
<p>You access these devices by telnetting to that port.  Each active
telnet session gets a different device.  If there are more telnets to a
port than UML devices attached to it, then the extra telnet sessions
will block until an existing telnet detaches, or until another device
becomes active (i.e. by being activated in /etc/inittab).</p>
<p>This channel has the advantage that you can both attach multiple UML
devices to it and know how to access them without reading the UML boot
log.  It is also unique in allowing access to a UML from remote
machines without requiring that the UML be networked.  This could be
useful in allowing public access to UMLs because they would be
accessible from the net, but wouldn’t need any kind of network
filtering or access control because they would have no network access.</p>
<p>If you attach the main console to a portal, then the UML boot will
appear to hang.  In reality, it’s waiting for a telnet to connect, at
which point the boot will proceed.</p>
<ul>
<li><p class="first">already-existing file descriptors - device=file descriptor</p>
<p>If you set up a file descriptor on the UML command line, you can
attach a UML device to it.  This is most commonly used to put the
main console back on stdin and stdout after assigning all the other
consoles to something else:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>con0=fd:0,fd:1 con=pts
</pre></div>
</div>
</li>
<li><p class="first">Nothing - device=null</p>
<p>This allows the device to be opened, in contrast to ‘none’, but
reads will block, and writes will succeed and the data will be
thrown out.</p>
</li>
<li><p class="first">None - device=none</p>
<p>This causes the device to disappear.</p>
</li>
</ul>
<p>You can also specify different input and output channels for a device
by putting a comma between them:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssl3=tty:/dev/tty2,xterm
</pre></div>
</div>
<p>will cause serial line 3 to accept input on the host’s /dev/tty2 and
display output on an xterm.  That’s a silly example - the most common
use of this syntax is to reattach the main console to stdin and stdout
as shown above.</p>
<p>If you decide to move the main console away from stdin/stdout, the
initial boot output will appear in the terminal that you’re running
UML in.  However, once the console driver has been officially
initialized, then the boot output will start appearing wherever you
specified that console 0 should be.  That device will receive all
subsequent output.</p>
</div></blockquote>
</div>
<div class="section" id="id5">
<h3>5.3.  Examples<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>There are a number of interesting things you can do with this
capability.</p>
<p>First, this is how you get rid of those bleeding console xterms by
attaching them to host ptys:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>con=pty con0=fd:0,fd:1
</pre></div>
</div>
<p>This will make a UML console take over an unused host virtual console,
so that when you switch to it, you will see the UML login prompt
rather than the host login prompt:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>con1=tty:/dev/tty6
</pre></div>
</div>
<p>You can attach two virtual machines together with what amounts to a
serial line as follows:</p>
<p>Run one UML with a serial line attached to a pty:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssl1=pty
</pre></div>
</div>
<p>Look at the boot log to see what pty it got (this example will assume
that it got /dev/ptyp1).</p>
<p>Boot the other UML with a serial line attached to the corresponding
tty:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssl1=tty:/dev/ttyp1
</pre></div>
</div>
<p>Log in, make sure that it has no getty on that serial line, attach a
terminal program like minicom to it, and you should see the login
prompt of the other virtual machine.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="setting-up-the-network">
<span id="id6"></span><h2>6.  Setting up the network<a class="headerlink" href="#setting-up-the-network" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This page describes how to set up the various transports and to
provide a UML instance with network access to the host, other machines
on the local net, and the rest of the net.</p>
<p>As of 2.4.5, UML networking has been completely redone to make it much
easier to set up, fix bugs, and add new features.</p>
<p>There is a new helper, uml_net, which does the host setup that
requires root privileges.</p>
<p>There are currently five transport types available for a UML virtual
machine to exchange packets with other hosts:</p>
<ul>
<li><p class="first">ethertap</p>
</li>
<li><p class="first">TUN/TAP</p>
</li>
<li><p class="first">Multicast</p>
</li>
<li><p class="first">a switch daemon</p>
</li>
<li><p class="first">slip</p>
</li>
<li><p class="first">slirp</p>
</li>
<li><p class="first">pcap</p>
<p>The TUN/TAP, ethertap, slip, and slirp transports allow a UML
instance to exchange packets with the host.  They may be directed
to the host or the host may just act as a router to provide access
to other physical or virtual machines.</p>
</li>
</ul>
<p>The pcap transport is a synthetic read-only interface, using the
libpcap binary to collect packets from interfaces on the host and
filter them.  This is useful for building preconfigured traffic
monitors or sniffers.</p>
<p>The daemon and multicast transports provide a completely virtual
network to other virtual machines.  This network is completely
disconnected from the physical network unless one of the virtual
machines on it is acting as a gateway.</p>
<p>With so many host transports, which one should you use?  Here’s when
you should use each one:</p>
<ul>
<li><p class="first">ethertap - if you want access to the host networking and it is
running 2.2</p>
</li>
<li><p class="first">TUN/TAP - if you want access to the host networking and it is
running 2.4.  Also, the TUN/TAP transport is able to use a
preconfigured device, allowing it to avoid using the setuid uml_net
helper, which is a security advantage.</p>
</li>
<li><p class="first">Multicast - if you want a purely virtual network and you don’t want
to set up anything but the UML</p>
</li>
<li><p class="first">a switch daemon - if you want a purely virtual network and you
don’t mind running the daemon in order to get somewhat better
performance</p>
</li>
<li><p class="first">slip - there is no particular reason to run the slip backend unless
ethertap and TUN/TAP are just not available for some reason</p>
</li>
<li><p class="first">slirp - if you don’t have root access on the host to setup
networking, or if you don’t want to allocate an IP to your UML</p>
</li>
<li><p class="first">pcap - not much use for actual network connectivity, but great for
monitoring traffic on the host</p>
<p>Ethertap is available on 2.4 and works fine.  TUN/TAP is preferred
to it because it has better performance and ethertap is officially
considered obsolete in 2.4.  Also, the root helper only needs to
run occasionally for TUN/TAP, rather than handling every packet, as
it does with ethertap.  This is a slight security advantage since
it provides fewer opportunities for a nasty UML user to somehow
exploit the helper’s root privileges.</p>
</li>
</ul>
</div></blockquote>
<div class="section" id="general-setup">
<h3>6.1.  General setup<a class="headerlink" href="#general-setup" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>First, you must have the virtual network enabled in your UML.  If are
running a prebuilt kernel from this site, everything is already
enabled.  If you build the kernel yourself, under the “Network device
support” menu, enable “Network device support”, and then the three
transports.</p>
<p>The next step is to provide a network device to the virtual machine.
This is done by describing it on the kernel command line.</p>
<p>The general format is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth &lt;n&gt; = &lt;transport&gt; , &lt;transport args&gt;
</pre></div>
</div>
<p>For example, a virtual ethernet device may be attached to a host
ethertap device as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth0=ethertap,tap0,fe:fd:0:0:0:1,192.168.0.254
</pre></div>
</div>
<p>This sets up eth0 inside the virtual machine to attach itself to the
host /dev/tap0, assigns it an ethernet address, and assigns the host
tap0 interface an IP address.</p>
<p>Note that the IP address you assign to the host end of the tap device
must be different than the IP you assign to the eth device inside UML.
If you are short on IPs and don’t want to consume two per UML, then
you can reuse the host’s eth IP address for the host ends of the tap
devices.  Internally, the UMLs must still get unique IPs for their eth
devices.  You can also give the UMLs non-routable IPs (192.168.x.x or
10.x.x.x) and have the host masquerade them.  This will let outgoing
connections work, but incoming connections won’t without more work,
such as port forwarding from the host.
Also note that when you configure the host side of an interface, it is
only acting as a gateway.  It will respond to pings sent to it
locally, but is not useful to do that since it’s a host interface.
You are not talking to the UML when you ping that interface and get a
response.</p>
<p>You can also add devices to a UML and remove them at runtime.  See the
<a class="reference internal" href="#the-management-console"><span class="std std-ref">10.  The Management Console</span></a>  page for details.</p>
<p>The sections below describe this in more detail.</p>
<p>Once you’ve decided how you’re going to set up the devices, you boot
UML, log in, configure the UML side of the devices, and set up routes
to the outside world.  At that point, you will be able to talk to any
other machines, physical or virtual, on the net.</p>
<p>If ifconfig inside UML fails and the network refuses to come up, run
tell you what went wrong.</p>
</div></blockquote>
</div>
<div class="section" id="userspace-daemons">
<h3>6.2.  Userspace daemons<a class="headerlink" href="#userspace-daemons" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>You will likely need the setuid helper, or the switch daemon, or both.
They are both installed with the RPM and deb, so if you’ve installed
either, you can skip the rest of this section.</p>
<p>If not, then you need to check them out of CVS, build them, and
install them.  The helper is uml_net, in CVS /tools/uml_net, and the
daemon is uml_switch, in CVS /tools/uml_router.  They are both built
with a plain ‘make’.  Both need to be installed in a directory that’s
in your path - /usr/bin is recommend.  On top of that, uml_net needs
to be setuid root.</p>
</div></blockquote>
</div>
<div class="section" id="specifying-ethernet-addresses">
<h3>6.3.  Specifying ethernet addresses<a class="headerlink" href="#specifying-ethernet-addresses" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Below, you will see that the TUN/TAP, ethertap, and daemon interfaces
allow you to specify hardware addresses for the virtual ethernet
devices.  This is generally not necessary.  If you don’t have a
specific reason to do it, you probably shouldn’t.  If one is not
specified on the command line, the driver will assign one based on the
device IP address.  It will provide the address fe:fd:nn:nn:nn:nn
where nn.nn.nn.nn is the device IP address.  This is nearly always
sufficient to guarantee a unique hardware address for the device.  A
couple of exceptions are:</p>
<ul>
<li><p class="first">Another set of virtual ethernet devices are on the same network and
they are assigned hardware addresses using a different scheme which
may conflict with the UML IP address-based scheme</p>
</li>
<li><p class="first">You aren’t going to use the device for IP networking, so you don’t
assign the device an IP address</p>
<p>If you let the driver provide the hardware address, you should make
sure that the device IP address is known before the interface is
brought up.  So, inside UML, this will guarantee that:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML#
ifconfig eth0 192.168.0.250 up
</pre></div>
</div>
</li>
</ul>
<p>If you decide to assign the hardware address yourself, make sure that
the first byte of the address is even.  Addresses with an odd first
byte are broadcast addresses, which you don’t want assigned to a
device.</p>
</div></blockquote>
</div>
<div class="section" id="uml-interface-setup">
<h3>6.4.  UML interface setup<a class="headerlink" href="#uml-interface-setup" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Once the network devices have been described on the command line, you
should boot UML and log in.</p>
<p>The first thing to do is bring the interface up:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML# ifconfig ethn ip-address up
</pre></div>
</div>
<p>You should be able to ping the host at this point.</p>
<p>To reach the rest of the world, you should set a default route to the
host:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML# route add default gw host ip
</pre></div>
</div>
<p>Again, with host ip of 192.168.0.4:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML# route add default gw 192.168.0.4
</pre></div>
</div>
<p>This page used to recommend setting a network route to your local net.
This is wrong, because it will cause UML to try to figure out hardware
addresses of the local machines by arping on the interface to the
host.  Since that interface is basically a single strand of ethernet
with two nodes on it (UML and the host) and arp requests don’t cross
networks, they will fail to elicit any responses.  So, what you want
is for UML to just blindly throw all packets at the host and let it
figure out what to do with them, which is what leaving out the network
route and adding the default route does.</p>
<p>Note: If you can’t communicate with other hosts on your physical
ethernet, it’s probably because of a network route that’s
automatically set up.  If you run ‘route -n’ and see a route that
looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.0.0     0.0.0.0         255.255.255.0   U     0      0      0   eth0
</pre></div>
</div>
<p>with a mask that’s not 255.255.255.255, then replace it with a route
to your host:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML#
route del -net 192.168.0.0 dev eth0 netmask 255.255.255.0


UML#
route add -host 192.168.0.4 dev eth0
</pre></div>
</div>
<p>This, plus the default route to the host, will allow UML to exchange
packets with any machine on your ethernet.</p>
</div></blockquote>
</div>
<div class="section" id="multicast">
<h3>6.5.  Multicast<a class="headerlink" href="#multicast" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The simplest way to set up a virtual network between multiple UMLs is
to use the mcast transport.  This was written by Harald Welte and is
present in UML version 2.4.5-5um and later.  Your system must have
multicast enabled in the kernel and there must be a multicast-capable
network device on the host.  Normally, this is eth0, but if there is
no ethernet card on the host, then you will likely get strange error
messages when you bring the device up inside UML.</p>
<p>To use it, run two UMLs with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth0=mcast
</pre></div>
</div>
<p>on their command lines.  Log in, configure the ethernet device in each
machine with different IP addresses:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML1# ifconfig eth0 192.168.0.254


UML2# ifconfig eth0 192.168.0.253
</pre></div>
</div>
<p>and they should be able to talk to each other.</p>
<p>The full set of command line options for this transport are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ethn=mcast,ethernet address,multicast
address,multicast port,ttl
</pre></div>
</div>
<p>There is also a related point-to-point only “ucast” transport.
This is useful when your network does not support multicast, and
all network connections are simple point to point links.</p>
<p>The full set of command line options for this transport are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ethn=ucast,ethernet address,remote address,listen port,remote port
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tun-tap-with-the-uml-net-helper">
<h3>6.6.  TUN/TAP with the uml_net helper<a class="headerlink" href="#tun-tap-with-the-uml-net-helper" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>TUN/TAP is the preferred mechanism on 2.4 to exchange packets with the
host.  The TUN/TAP backend has been in UML since 2.4.9-3um.</p>
<p>The easiest way to get up and running is to let the setuid uml_net
helper do the host setup for you.  This involves insmod-ing the tun.o
module if necessary, configuring the device, and setting up IP
forwarding, routing, and proxy arp.  If you are new to UML networking,
do this first.  If you’re concerned about the security implications of
the setuid helper, use it to get up and running, then read the next
section to see how to have UML use a preconfigured tap device, which
avoids the use of uml_net.</p>
<p>If you specify an IP address for the host side of the device, the
uml_net helper will do all necessary setup on the host - the only
requirement is that TUN/TAP be available, either built in to the host
kernel or as the tun.o module.</p>
<p>The format of the command line switch to attach a device to a TUN/TAP
device is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth &lt;n&gt; =tuntap,,, &lt;IP address&gt;
</pre></div>
</div>
<p>For example, this argument will attach the UML’s eth0 to the next
available tap device and assign an ethernet address to it based on its
IP address:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth0=tuntap,,,192.168.0.254
</pre></div>
</div>
<p>Note that the IP address that must be used for the eth device inside
UML is fixed by the routing and proxy arp that is set up on the
TUN/TAP device on the host.  You can use a different one, but it won’t
work because reply packets won’t reach the UML.  This is a feature.
It prevents a nasty UML user from doing things like setting the UML IP
to the same as the network’s nameserver or mail server.</p>
<p>There are a couple potential problems with running the TUN/TAP
transport on a 2.4 host kernel</p>
<ul>
<li><p class="first">TUN/TAP seems not to work on 2.4.3 and earlier.  Upgrade the host
kernel or use the ethertap transport.</p>
</li>
<li><p class="first">With an upgraded kernel, TUN/TAP may fail with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>File descriptor in bad state
</pre></div>
</div>
</li>
</ul>
<p>This is due to a header mismatch between the upgraded kernel and the
kernel that was originally installed on the machine.  The fix is to
make sure that /usr/src/linux points to the headers for the running
kernel.</p>
<p>These were pointed out by Tim Robinson &lt;timro at trkr dot net&gt; in the past.</p>
</div></blockquote>
</div>
<div class="section" id="tun-tap-with-a-preconfigured-tap-device">
<h3>6.7.  TUN/TAP with a preconfigured tap device<a class="headerlink" href="#tun-tap-with-a-preconfigured-tap-device" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If you prefer not to have UML use uml_net (which is somewhat
insecure), with UML 2.4.17-11, you can set up a TUN/TAP device
beforehand.  The setup needs to be done as root, but once that’s done,
there is no need for root assistance.  Setting up the device is done
as follows:</p>
<ul>
<li><p class="first">Create the device with tunctl (available from the UML utilities
tarball):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  tunctl -u uid
</pre></div>
</div>
</li>
</ul>
<p>where uid is the user id or username that UML will be run as.  This
will tell you what device was created.</p>
<ul>
<li><p class="first">Configure the device IP (change IP addresses and device name to
suit):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  ifconfig tap0 192.168.0.254 up
</pre></div>
</div>
</li>
<li><p class="first">Set up routing and arping if desired - this is my recipe, there are
other ways of doing the same thing:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#
bash -c &#39;echo 1 &gt; /proc/sys/net/ipv4/ip_forward&#39;

host#
route add -host 192.168.0.253 dev tap0

host#
bash -c &#39;echo 1 &gt; /proc/sys/net/ipv4/conf/tap0/proxy_arp&#39;

host#
arp -Ds 192.168.0.253 eth0 pub
</pre></div>
</div>
</li>
</ul>
<p>Note that this must be done every time the host boots - this configu-
ration is not stored across host reboots.  So, it’s probably a good
idea to stick it in an rc file.  An even better idea would be a little
utility which reads the information from a config file and sets up
devices at boot time.</p>
<ul>
<li><p class="first">Rather than using up two IPs and ARPing for one of them, you can
also provide direct access to your LAN by the UML by using a
bridge:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#
brctl addbr br0


host#
ifconfig eth0 0.0.0.0 promisc up


host#
ifconfig tap0 0.0.0.0 promisc up


host#
ifconfig br0 192.168.0.1 netmask 255.255.255.0 up


host#
brctl stp br0 off


host#
brctl setfd br0 1


host#
brctl sethello br0 1


host#
brctl addif br0 eth0


host#
brctl addif br0 tap0
</pre></div>
</div>
</li>
</ul>
<p>Note that ‘br0’ should be setup using ifconfig with the existing IP
address of eth0, as eth0 no longer has its own IP.</p>
<ul>
<li><p class="first">Also, the /dev/net/tun device must be writable by the user running
UML in order for the UML to use the device that’s been configured
for it.  The simplest thing to do is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  chmod 666 /dev/net/tun
</pre></div>
</div>
</li>
</ul>
<p>Making it world-writable looks bad, but it seems not to be
exploitable as a security hole.  However, it does allow anyone to cre-
ate useless tap devices (useless because they can’t configure them),
which is a DOS attack.  A somewhat more secure alternative would to be
to create a group containing all the users who have preconfigured tap
devices and chgrp /dev/net/tun to that group with mode 664 or 660.</p>
<ul>
<li><p class="first">Once the device is set up, run UML with ‘eth0=tuntap,device name’
(i.e. ‘eth0=tuntap,tap0’) on the command line (or do it with the
mconsole config command).</p>
</li>
<li><p class="first">Bring the eth device up in UML and you’re in business.</p>
<p>If you don’t want that tap device any more, you can make it non-
persistent with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  tunctl -d tap device
</pre></div>
</div>
</li>
</ul>
<p>Finally, tunctl has a -b (for brief mode) switch which causes it to
output only the name of the tap device it created.  This makes it
suitable for capture by a script:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  TAP=`tunctl -u 1000 -b`
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="ethertap">
<h3>6.8.  Ethertap<a class="headerlink" href="#ethertap" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Ethertap is the general mechanism on 2.2 for userspace processes to
exchange packets with the kernel.</p>
<p>To use this transport, you need to describe the virtual network device
on the UML command line.  The general format for this is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth &lt;n&gt; =ethertap, &lt;device&gt; , &lt;ethernet address&gt; , &lt;tap IP address&gt;
</pre></div>
</div>
<p>So, the previous example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth0=ethertap,tap0,fe:fd:0:0:0:1,192.168.0.254
</pre></div>
</div>
<p>attaches the UML eth0 device to the host /dev/tap0, assigns it the
ethernet address fe:fd:0:0:0:1, and assigns the IP address
192.168.0.254 to the tap device.</p>
<p>The tap device is mandatory, but the others are optional.  If the
ethernet address is omitted, one will be assigned to it.</p>
<p>The presence of the tap IP address will cause the helper to run and do
whatever host setup is needed to allow the virtual machine to
communicate with the outside world.  If you’re not sure you know what
you’re doing, this is the way to go.</p>
<p>If it is absent, then you must configure the tap device and whatever
arping and routing you will need on the host.  However, even in this
case, the uml_net helper still needs to be in your path and it must be
setuid root if you’re not running UML as root.  This is because the
tap device doesn’t support SIGIO, which UML needs in order to use
something as a source of input.  So, the helper is used as a
convenient asynchronous IO thread.</p>
<p>If you’re using the uml_net helper, you can ignore the following host
setup - uml_net will do it for you.  You just need to make sure you
have ethertap available, either built in to the host kernel or
available as a module.</p>
<p>If you want to set things up yourself, you need to make sure that the
appropriate /dev entry exists.  If it doesn’t, become root and create
it as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mknod /dev/tap &lt;minor&gt;  c 36  &lt;minor&gt;  + 16
</pre></div>
</div>
<p>For example, this is how to create /dev/tap0:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mknod /dev/tap0 c 36 0 + 16
</pre></div>
</div>
<p>You also need to make sure that the host kernel has ethertap support.
If ethertap is enabled as a module, you apparently need to insmod
ethertap once for each ethertap device you want to enable.  So,:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#
insmod ethertap
</pre></div>
</div>
<p>will give you the tap0 interface.  To get the tap1 interface, you need
to run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#
insmod ethertap unit=1 -o ethertap1
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="the-switch-daemon">
<h3>6.9.  The switch daemon<a class="headerlink" href="#the-switch-daemon" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Note: This is the daemon formerly known as uml_router, but which was
renamed so the network weenies of the world would stop growling at me.</p>
<p>The switch daemon, uml_switch, provides a mechanism for creating a
totally virtual network.  By default, it provides no connection to the
host network (but see -tap, below).</p>
<p>The first thing you need to do is run the daemon.  Running it with no
arguments will make it listen on a default pair of unix domain
sockets.</p>
<p>If you want it to listen on a different pair of sockets, use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-unix control socket data socket
</pre></div>
</div>
<p>If you want it to act as a hub rather than a switch, use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-hub
</pre></div>
</div>
<p>If you want the switch to be connected to host networking (allowing
the umls to get access to the outside world through the host), use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-tap tap0
</pre></div>
</div>
<p>Note that the tap device must be preconfigured (see “TUN/TAP with a
preconfigured tap device”, above).  If you’re using a different tap
device than tap0, specify that instead of tap0.</p>
<p>uml_switch can be backgrounded as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host%
uml_switch [ options ] &lt; /dev/null &gt; /dev/null
</pre></div>
</div>
<p>The reason it doesn’t background by default is that it listens to
stdin for EOF.  When it sees that, it exits.</p>
<p>The general format of the kernel command line switch is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ethn=daemon,ethernet address,socket
type,control socket,data socket
</pre></div>
</div>
<p>You can leave off everything except the ‘daemon’.  You only need to
specify the ethernet address if the one that will be assigned to it
isn’t acceptable for some reason.  The rest of the arguments describe
how to communicate with the daemon.  You should only specify them if
you told the daemon to use different sockets than the default.  So, if
you ran the daemon with no arguments, running the UML on the same
machine with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth0=daemon
</pre></div>
</div>
<p>will cause the eth0 driver to attach itself to the daemon correctly.</p>
</div></blockquote>
</div>
<div class="section" id="slip">
<h3>6.10.  Slip<a class="headerlink" href="#slip" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Slip is another, less general, mechanism for a process to communicate
with the host networking.  In contrast to the ethertap interface,
which exchanges ethernet frames with the host and can be used to
transport any higher-level protocol, it can only be used to transport
IP.</p>
<p>The general format of the command line switch is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ethn=slip,slip IP
</pre></div>
</div>
<p>The slip IP argument is the IP address that will be assigned to the
host end of the slip device.  If it is specified, the helper will run
and will set up the host so that the virtual machine can reach it and
the rest of the network.</p>
<p>There are some oddities with this interface that you should be aware
of.  You should only specify one slip device on a given virtual
machine, and its name inside UML will be ‘umn’, not ‘eth0’ or whatever
you specified on the command line.  These problems will be fixed at
some point.</p>
</div></blockquote>
</div>
<div class="section" id="slirp">
<h3>6.11.  Slirp<a class="headerlink" href="#slirp" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>slirp uses an external program, usually /usr/bin/slirp, to provide IP
only networking connectivity through the host. This is similar to IP
masquerading with a firewall, although the translation is performed in
user-space, rather than by the kernel.  As slirp does not set up any
interfaces on the host, or changes routing, slirp does not require
root access or setuid binaries on the host.</p>
<p>The general format of the command line switch for slirp is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ethn=slirp,ethernet address,slirp path
</pre></div>
</div>
<p>The ethernet address is optional, as UML will set up the interface
with an ethernet address based upon the initial IP address of the
interface.  The slirp path is generally /usr/bin/slirp, although it
will depend on distribution.</p>
<p>The slirp program can have a number of options passed to the command
line and we can’t add them to the UML command line, as they will be
parsed incorrectly.  Instead, a wrapper shell script can be written or
the options inserted into the  /.slirprc file.  More information on
all of the slirp options can be found in its man pages.</p>
<p>The eth0 interface on UML should be set up with the IP 10.2.0.15,
although you can use anything as long as it is not used by a network
you will be connecting to. The default route on UML should be set to
use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML#
route add default dev eth0
</pre></div>
</div>
<p>slirp provides a number of useful IP addresses which can be used by
UML, such as 10.0.2.3 which is an alias for the DNS server specified
in /etc/resolv.conf on the host or the IP given in the ‘dns’ option
for slirp.</p>
<p>Even with a baudrate setting higher than 115200, the slirp connection
is limited to 115200. If you need it to go faster, the slirp binary
needs to be compiled with FULL_BOLT defined in config.h.</p>
</div></blockquote>
</div>
<div class="section" id="pcap">
<h3>6.12.  pcap<a class="headerlink" href="#pcap" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The pcap transport is attached to a UML ethernet device on the command
line or with uml_mconsole with the following syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ethn=pcap,host interface,filter
expression,option1,option2
</pre></div>
</div>
<p>The expression and options are optional.</p>
<p>The interface is whatever network device on the host you want to
sniff.  The expression is a pcap filter expression, which is also what
tcpdump uses, so if you know how to specify tcpdump filters, you will
use the same expressions here.  The options are up to two of
‘promisc’, control whether pcap puts the host interface into
promiscuous mode. ‘optimize’ and ‘nooptimize’ control whether the pcap
expression optimizer is used.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth0=pcap,eth0,tcp

eth1=pcap,eth0,!tcp
</pre></div>
</div>
<p>will cause the UML eth0 to emit all tcp packets on the host eth0 and
the UML eth1 to emit all non-tcp packets on the host eth0.</p>
</div></blockquote>
</div>
<div class="section" id="setting-up-the-host-yourself">
<h3>6.13.  Setting up the host yourself<a class="headerlink" href="#setting-up-the-host-yourself" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If you don’t specify an address for the host side of the ethertap or
slip device, UML won’t do any setup on the host.  So this is what is
needed to get things working (the examples use a host-side IP of
192.168.0.251 and a UML-side IP of 192.168.0.250 - adjust to suit your
own network):</p>
<ul>
<li><p class="first">The device needs to be configured with its IP address.  Tap devices
are also configured with an mtu of 1484.  Slip devices are
configured with a point-to-point address pointing at the UML ip
address:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  ifconfig tap0 arp mtu 1484 192.168.0.251 up


host#
ifconfig sl0 192.168.0.251 pointopoint 192.168.0.250 up
</pre></div>
</div>
</li>
<li><p class="first">If a tap device is being set up, a route is set to the UML IP:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML# route add -host 192.168.0.250 gw 192.168.0.251
</pre></div>
</div>
</li>
<li><p class="first">To allow other hosts on your network to see the virtual machine,
proxy arp is set up for it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  arp -Ds 192.168.0.250 eth0 pub
</pre></div>
</div>
</li>
<li><p class="first">Finally, the host is set up to route packets:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="sharing-filesystems-between-virtual-machines">
<h2>7.  Sharing Filesystems between Virtual Machines<a class="headerlink" href="#sharing-filesystems-between-virtual-machines" title="Permalink to this headline">¶</a></h2>
<div class="section" id="a-warning">
<h3>7.1.  A warning<a class="headerlink" href="#a-warning" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Don’t attempt to share filesystems simply by booting two UMLs from the
same file.  That’s the same thing as booting two physical machines
from a shared disk.  It will result in filesystem corruption.</div></blockquote>
</div>
<div class="section" id="using-layered-block-devices">
<h3>7.2.  Using layered block devices<a class="headerlink" href="#using-layered-block-devices" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The way to share a filesystem between two virtual machines is to use
the copy-on-write (COW) layering capability of the ubd block driver.
As of 2.4.6-2um, the driver supports layering a read-write private
device over a read-only shared device.  A machine’s writes are stored
in the private device, while reads come from either device - the
private one if the requested block is valid in it, the shared one if
not.  Using this scheme, the majority of data which is unchanged is
shared between an arbitrary number of virtual machines, each of which
has a much smaller file containing the changes that it has made.  With
a large number of UMLs booting from a large root filesystem, this
leads to a huge disk space saving.  It will also help performance,
since the host will be able to cache the shared data using a much
smaller amount of memory, so UML disk requests will be served from the
host’s memory rather than its disks.</p>
<p>To add a copy-on-write layer to an existing block device file, simply
add the name of the COW file to the appropriate ubd switch:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ubd0=root_fs_cow,root_fs_debian_22
</pre></div>
</div>
<p>where ‘root_fs_cow’ is the private COW file and ‘root_fs_debian_22’ is
the existing shared filesystem.  The COW file need not exist.  If it
doesn’t, the driver will create and initialize it.  Once the COW file
has been initialized, it can be used on its own on the command line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ubd0=root_fs_cow
</pre></div>
</div>
<p>The name of the backing file is stored in the COW file header, so it
would be redundant to continue specifying it on the command line.</p>
</div></blockquote>
</div>
<div class="section" id="note">
<h3>7.3.  Note!<a class="headerlink" href="#note" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>When checking the size of the COW file in order to see the gobs of
space that you’re saving, make sure you use ‘ls -ls’ to see the actual
disk consumption rather than the length of the file.  The COW file is
sparse, so the length will be very different from the disk usage.
Here is a ‘ls -l’ of a COW file and backing file from one boot and
shutdown:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% ls -l cow.debian debian2.2
-rw-r--r--    1 jdike    jdike    492504064 Aug  6 21:16 cow.debian
-rwxrw-rw-    1 jdike    jdike    537919488 Aug  6 20:42 debian2.2
</pre></div>
</div>
<p>Doesn’t look like much saved space, does it?  Well, here’s ‘ls -ls’:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% ls -ls cow.debian debian2.2
   880 -rw-r--r--    1 jdike    jdike    492504064 Aug  6 21:16 cow.debian
525832 -rwxrw-rw-    1 jdike    jdike    537919488 Aug  6 20:42 debian2.2
</pre></div>
</div>
<p>Now, you can see that the COW file has less than a meg of disk, rather
than 492 meg.</p>
</div></blockquote>
</div>
<div class="section" id="another-warning">
<h3>7.4.  Another warning<a class="headerlink" href="#another-warning" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Once a filesystem is being used as a readonly backing file for a COW
file, do not boot directly from it or modify it in any way.  Doing so
will invalidate any COW files that are using it.  The mtime and size
of the backing file are stored in the COW file header at its creation,
and they must continue to match.  If they don’t, the driver will
refuse to use the COW file.</p>
<p>If you attempt to evade this restriction by changing either the
backing file or the COW header by hand, you will get a corrupted
filesystem.</p>
<p>Among other things, this means that upgrading the distribution in a
backing file and expecting that all of the COW files using it will see
the upgrade will not work.</p>
</div></blockquote>
</div>
<div class="section" id="uml-moo-merging-a-cow-file-with-its-backing-file">
<h3>7.5.  uml_moo : Merging a COW file with its backing file<a class="headerlink" href="#uml-moo-merging-a-cow-file-with-its-backing-file" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Depending on how you use UML and COW devices, it may be advisable to
merge the changes in the COW file into the backing file every once in
a while.</p>
<p>The utility that does this is uml_moo.  Its usage is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% uml_moo COW file new backing file
</pre></div>
</div>
<p>There’s no need to specify the backing file since that information is
already in the COW file header.  If you’re paranoid, boot the new
merged file, and if you’re happy with it, move it over the old backing
file.</p>
<p>uml_moo creates a new backing file by default as a safety measure.  It
also has a destructive merge option which will merge the COW file
directly into its current backing file.  This is really only usable
when the backing file only has one COW file associated with it.  If
there are multiple COWs associated with a backing file, a -d merge of
one of them will invalidate all of the others.  However, it is
convenient if you’re short of disk space, and it should also be
noticeably faster than a non-destructive merge.</p>
<p>uml_moo is installed with the UML deb and RPM.  If you didn’t install
UML from one of those packages, you can also get it from the UML
utilities <a class="reference external" href="http://user-mode-linux.sourceforge.net/utilities">http://user-mode-linux.sourceforge.net/utilities</a> tar file
in tools/moo.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="creating-filesystems">
<h2>8.  Creating filesystems<a class="headerlink" href="#creating-filesystems" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>You may want to create and mount new UML filesystems, either because
your root filesystem isn’t large enough or because you want to use a
filesystem other than ext2.</p>
<p>This was written on the occasion of reiserfs being included in the
2.4.1 kernel pool, and therefore the 2.4.1 UML, so the examples will
talk about reiserfs.  This information is generic, and the examples
should be easy to translate to the filesystem of your choice.</p>
</div></blockquote>
</div>
<div class="section" id="create-the-filesystem-file">
<h2>8.1.  Create the filesystem file<a class="headerlink" href="#create-the-filesystem-file" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>dd is your friend.  All you need to do is tell dd to create an empty
file of the appropriate size.  I usually make it sparse to save time
and to avoid allocating disk space until it’s actually used.  For
example, the following command will create a sparse 100 meg file full
of zeroes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host%
dd if=/dev/zero of=new_filesystem seek=100 count=1 bs=1M
</pre></div>
</div>
<p>8.2.  Assign the file to a UML device</p>
<p>Add an argument like the following to the UML command line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ubd4=new_filesystem
</pre></div>
</div>
<p>making sure that you use an unassigned ubd device number.</p>
<p>8.3.  Creating and mounting the filesystem</p>
<p>Make sure that the filesystem is available, either by being built into
the kernel, or available as a module, then boot up UML and log in.  If
the root filesystem doesn’t have the filesystem utilities (mkfs, fsck,
etc), then get them into UML by way of the net or hostfs.</p>
<p>Make the new filesystem on the device assigned to the new file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  mkreiserfs /dev/ubd/4


&lt;----------- MKREISERFSv2 -----------&gt;

ReiserFS version 3.6.25
Block size 4096 bytes
Block count 25856
Used blocks 8212
        Journal - 8192 blocks (18-8209), journal header is in block 8210
        Bitmaps: 17
        Root block 8211
Hash function &quot;r5&quot;
ATTENTION: ALL DATA WILL BE LOST ON &#39;/dev/ubd/4&#39;! (y/n)y
journal size 8192 (from 18)
Initializing journal - 0%....20%....40%....60%....80%....100%
Syncing..done.
</pre></div>
</div>
<p>Now, mount it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML#
mount /dev/ubd/4 /mnt
</pre></div>
</div>
<p>and you’re in business.</p>
</div></blockquote>
</div>
<div class="section" id="host-file-access">
<h2>9.  Host file access<a class="headerlink" href="#host-file-access" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>If you want to access files on the host machine from inside UML, you
can treat it as a separate machine and either nfs mount directories
from the host or copy files into the virtual machine with scp or rcp.
However, since UML is running on the host, it can access those
files just like any other process and make them available inside the
virtual machine without needing to use the network.</p>
<p>This is now possible with the hostfs virtual filesystem.  With it, you
can mount a host directory into the UML filesystem and access the
files contained in it just as you would on the host.</p>
</div></blockquote>
<div class="section" id="using-hostfs">
<h3>9.1.  Using hostfs<a class="headerlink" href="#using-hostfs" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>To begin with, make sure that hostfs is available inside the virtual
machine with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML# cat /proc/filesystems
</pre></div>
</div>
<p>.  hostfs should be listed.  If it’s not, either rebuild the kernel
with hostfs configured into it or make sure that hostfs is built as a
module and available inside the virtual machine, and insmod it.</p>
<p>Now all you need to do is run mount:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML# mount none /mnt/host -t hostfs
</pre></div>
</div>
<p>will mount the host’s / on the virtual machine’s /mnt/host.</p>
<p>If you don’t want to mount the host root directory, then you can
specify a subdirectory to mount with the -o switch to mount:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML# mount none /mnt/home -t hostfs -o /home
</pre></div>
</div>
<p>will mount the hosts’s /home on the virtual machine’s /mnt/home.</p>
</div></blockquote>
</div>
<div class="section" id="hostfs-as-the-root-filesystem">
<h3>9.2.  hostfs as the root filesystem<a class="headerlink" href="#hostfs-as-the-root-filesystem" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>It’s possible to boot from a directory hierarchy on the host using
hostfs rather than using the standard filesystem in a file.</p>
<p>To start, you need that hierarchy.  The easiest way is to loop mount
an existing root_fs file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  mount root_fs uml_root_dir -o loop
</pre></div>
</div>
<p>You need to change the filesystem type of / in etc/fstab to be
‘hostfs’, so that line looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/dev/ubd/0       /        hostfs      defaults          1   1
</pre></div>
</div>
<p>Then you need to chown to yourself all the files in that directory
that are owned by root.  This worked for me:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host#  find . -uid 0 -exec chown jdike {} \;
</pre></div>
</div>
<p>Next, make sure that your UML kernel has hostfs compiled in, not as a
module.  Then run UML with the boot device pointing at that directory:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ubd0=/path/to/uml/root/directory
</pre></div>
</div>
<p>UML should then boot as it does normally.</p>
</div></blockquote>
</div>
<div class="section" id="building-hostfs">
<h3>9.3.  Building hostfs<a class="headerlink" href="#building-hostfs" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If you need to build hostfs because it’s not in your kernel, you have
two choices:</p>
<ul>
<li><p class="first">Compiling hostfs into the kernel:</p>
<p>Reconfigure the kernel and set the ‘Host filesystem’ option under</p>
</li>
<li><p class="first">Compiling hostfs as a module:</p>
<p>Reconfigure the kernel and set the ‘Host filesystem’ option under
be in arch/um/fs/hostfs/hostfs.o.  Install that in
<code class="docutils literal notranslate"><span class="pre">/lib/modules/$(uname</span> <span class="pre">-r)/fs</span></code> in the virtual machine, boot it up, and:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML# insmod hostfs
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="the-management-console">
<span id="id7"></span><h2>10.  The Management Console<a class="headerlink" href="#the-management-console" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The UML management console is a low-level interface to the kernel,
somewhat like the i386 SysRq interface.  Since there is a full-blown
operating system under UML, there is much greater flexibility possible
than with the SysRq mechanism.</p>
<p>There are a number of things you can do with the mconsole interface:</p>
<ul class="simple">
<li>get the kernel version</li>
<li>add and remove devices</li>
<li>halt or reboot the machine</li>
<li>Send SysRq commands</li>
<li>Pause and resume the UML</li>
</ul>
<p>You need the mconsole client (uml_mconsole) which is present in CVS
(/tools/mconsole) in 2.4.5-9um and later, and will be in the RPM in
2.4.6.</p>
<p>You also need CONFIG_MCONSOLE (under ‘General Setup’) enabled in UML.
When you boot UML, you’ll see a line like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mconsole initialized on /home/jdike/.uml/umlNJ32yL/mconsole
</pre></div>
</div>
<p>If you specify a unique machine id one the UML command line, i.e.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>umid=debian
</pre></div>
</div>
<p>you’ll see this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mconsole initialized on /home/jdike/.uml/debian/mconsole
</pre></div>
</div>
<p>That file is the socket that uml_mconsole will use to communicate with
UML.  Run it with either the umid or the full path as its argument:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% uml_mconsole debian
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% uml_mconsole /home/jdike/.uml/debian/mconsole
</pre></div>
</div>
<p>You’ll get a prompt, at which you can run one of these commands:</p>
<ul class="simple">
<li>version</li>
<li>halt</li>
<li>reboot</li>
<li>config</li>
<li>remove</li>
<li>sysrq</li>
<li>help</li>
<li>cad</li>
<li>stop</li>
<li>go</li>
</ul>
</div></blockquote>
<div class="section" id="version">
<h3>10.1.  version<a class="headerlink" href="#version" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>This takes no arguments.  It prints the UML version:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(mconsole)  version
OK Linux usermode 2.4.5-9um #1 Wed Jun 20 22:47:08 EDT 2001 i686
</pre></div>
</div>
<p>There are a couple actual uses for this.  It’s a simple no-op which
can be used to check that a UML is running.  It’s also a way of
sending an interrupt to the UML.  This is sometimes useful on SMP
hosts, where there’s a bug which causes signals to UML to be lost,
often causing it to appear to hang.  Sending such a UML the mconsole
version command is a good way to ‘wake it up’ before networking has
been enabled, as it does not do anything to the function of the UML.</p>
</div></blockquote>
</div>
<div class="section" id="halt-and-reboot">
<h3>10.2.  halt and reboot<a class="headerlink" href="#halt-and-reboot" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>These take no arguments.  They shut the machine down immediately, with
no syncing of disks and no clean shutdown of userspace.  So, they are
pretty close to crashing the machine:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(mconsole)  halt
OK
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="config">
<h3>10.3.  config<a class="headerlink" href="#config" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>“config” adds a new device to the virtual machine.  Currently the ubd
and network drivers support this.  It takes one argument, which is the
device to add, with the same syntax as the kernel command line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(mconsole)
config ubd3=/home/jdike/incoming/roots/root_fs_debian22

OK
(mconsole)  config eth1=mcast
OK
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="remove">
<h3>10.4.  remove<a class="headerlink" href="#remove" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>“remove” deletes a device from the system.  Its argument is just the
name of the device to be removed. The device must be idle in whatever
sense the driver considers necessary.  In the case of the ubd driver,
the removed block device must not be mounted, swapped on, or otherwise
open, and in the case of the network driver, the device must be down:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(mconsole)  remove ubd3
OK
(mconsole)  remove eth1
OK
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="sysrq">
<h3>10.5.  sysrq<a class="headerlink" href="#sysrq" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This takes one argument, which is a single letter.  It calls the
generic kernel’s SysRq driver, which does whatever is called for by
that argument.  See the SysRq documentation in
Documentation/admin-guide/sysrq.rst in your favorite kernel tree to
see what letters are valid and what they do.</div></blockquote>
</div>
<div class="section" id="help">
<h3>10.6.  help<a class="headerlink" href="#help" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>“help” returns a string listing the valid commands and what each one
does.</div></blockquote>
</div>
<div class="section" id="cad">
<h3>10.7.  cad<a class="headerlink" href="#cad" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>This invokes the Ctl-Alt-Del action on init.  What exactly this ends
up doing is up to /etc/inittab.  Normally, it reboots the machine.
With UML, this is usually not desired, so if a halt would be better,
then find the section of inittab that looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># What to do when CTRL-ALT-DEL is pressed.
ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now
</pre></div>
</div>
<p>and change the command to halt.</p>
</div></blockquote>
</div>
<div class="section" id="stop">
<h3>10.8.  stop<a class="headerlink" href="#stop" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>This puts the UML in a loop reading mconsole requests until a ‘go’
mconsole command is received. This is very useful for making backups
of UML filesystems, as the UML can be stopped, then synced via ‘sysrq
s’, so that everything is written to the filesystem. You can then copy
the filesystem and then send the UML ‘go’ via mconsole.</p>
<p>Note that a UML running with more than one CPU will have problems
after you send the ‘stop’ command, as only one CPU will be held in a
mconsole loop and all others will continue as normal.  This is a bug,
and will be fixed.</p>
</div></blockquote>
</div>
<div class="section" id="go">
<h3>10.9.  go<a class="headerlink" href="#go" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This resumes a UML after being paused by a ‘stop’ command. Note that
when the UML has resumed, TCP connections may have timed out and if
the UML is paused for a long period of time, crond might go a little
crazy, running all the jobs it didn’t do earlier.</div></blockquote>
</div>
</div>
<div class="section" id="kernel-debugging">
<span id="id8"></span><h2>11.  Kernel debugging<a class="headerlink" href="#kernel-debugging" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Note: The interface that makes debugging, as described here, possible
is present in 2.4.0-test6 kernels and later.</p>
<p>Since the user-mode kernel runs as a normal Linux process, it is
possible to debug it with gdb almost like any other process.  It is
slightly different because the kernel’s threads are already being
ptraced for system call interception, so gdb can’t ptrace them.
However, a mechanism has been added to work around that problem.</p>
<p>In order to debug the kernel, you need build it from source.  See
<a class="reference internal" href="#compiling-the-kernel-and-modules"><span class="std std-ref">2.  Compiling the kernel and modules</span></a>  for information on doing that.
Make sure that you enable CONFIG_DEBUGSYM and CONFIG_PT_PROXY during
the config.  These will compile the kernel with <code class="docutils literal notranslate"><span class="pre">-g</span></code>, and enable the
ptrace proxy so that gdb works with UML, respectively.</p>
</div></blockquote>
<div class="section" id="starting-the-kernel-under-gdb">
<h3>11.1.  Starting the kernel under gdb<a class="headerlink" href="#starting-the-kernel-under-gdb" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>You can have the kernel running under the control of gdb from the
beginning by putting ‘debug’ on the command line.  You will get an
xterm with gdb running inside it.  The kernel will send some commands
to gdb which will leave it stopped at the beginning of start_kernel.
At this point, you can get things going with ‘next’, ‘step’, or
‘cont’.</p>
<p>There is a transcript of a debugging session  here &lt;debug-
session.html&gt; , with breakpoints being set in the scheduler and in an
interrupt handler.</p>
</div></blockquote>
</div>
<div class="section" id="examining-sleeping-processes">
<h3>11.2.  Examining sleeping processes<a class="headerlink" href="#examining-sleeping-processes" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Not every bug is evident in the currently running process.  Sometimes,
processes hang in the kernel when they shouldn’t because they’ve
deadlocked on a semaphore or something similar.  In this case, when
you ^C gdb and get a backtrace, you will see the idle thread, which
isn’t very relevant.</p>
<p>What you want is the stack of whatever process is sleeping when it
shouldn’t be.  You need to figure out which process that is, which is
generally fairly easy.  Then you need to get its host process id,
which you can do either by looking at ps on the host or at
task.thread.extern_pid in gdb.</p>
<p>Now what you do is this:</p>
<ul>
<li><p class="first">detach from the current thread:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)  det
</pre></div>
</div>
</li>
<li><p class="first">attach to the thread you are interested in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)  att &lt;host pid&gt;
</pre></div>
</div>
</li>
<li><p class="first">look at its stack and anything else of interest:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)  bt
</pre></div>
</div>
</li>
</ul>
<p>Note that you can’t do anything at this point that requires that a
process execute, e.g. calling a function</p>
<ul>
<li><p class="first">when you’re done looking at that process, reattach to the current
thread and continue it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)
att 1


(UML gdb)
c
</pre></div>
</div>
</li>
</ul>
<p>Here, specifying any pid which is not the process id of a UML thread
will cause gdb to reattach to the current thread.  I commonly use 1,
but any other invalid pid would work.</p>
</div></blockquote>
</div>
<div class="section" id="running-ddd-on-uml">
<h3>11.3.  Running ddd on UML<a class="headerlink" href="#running-ddd-on-uml" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>ddd works on UML, but requires a special kludge.  The process goes
like this:</p>
<ul>
<li><p class="first">Start ddd:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% ddd linux
</pre></div>
</div>
</li>
<li><p class="first">With ps, get the pid of the gdb that ddd started.  You can ask the
gdb to tell you, but for some reason that confuses things and
causes a hang.</p>
</li>
<li><p class="first">run UML with ‘debug=parent gdb-pid=&lt;pid&gt;’ added to the command line
- it will just sit there after you hit return</p>
</li>
<li><p class="first">type ‘att 1’ to the ddd gdb and you will see something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0xa013dc51 in __kill ()


(gdb)
</pre></div>
</div>
</li>
<li><p class="first">At this point, type ‘c’, UML will boot up, and you can use ddd just
as you do on any other process.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="debugging-modules">
<h3>11.4.  Debugging modules<a class="headerlink" href="#debugging-modules" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>gdb has support for debugging code which is dynamically loaded into
the process.  This support is what is needed to debug kernel modules
under UML.</p>
<p>Using that support is somewhat complicated.  You have to tell gdb what
object file you just loaded into UML and where in memory it is.  Then,
it can read the symbol table, and figure out where all the symbols are
from the load address that you provided.  It gets more interesting
when you load the module again (i.e. after an rmmod).  You have to
tell gdb to forget about all its symbols, including the main UML ones
for some reason, then load then all back in again.</p>
<p>There’s an easy way and a hard way to do this.  The easy way is to use
the umlgdb expect script written by Chandan Kudige.  It basically
automates the process for you.</p>
<p>First, you must tell it where your modules are.  There is a list in
the script that looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set MODULE_PATHS {
&quot;fat&quot; &quot;/usr/src/uml/linux-2.4.18/fs/fat/fat.o&quot;
&quot;isofs&quot; &quot;/usr/src/uml/linux-2.4.18/fs/isofs/isofs.o&quot;
&quot;minix&quot; &quot;/usr/src/uml/linux-2.4.18/fs/minix/minix.o&quot;
}
</pre></div>
</div>
<p>You change that to list the names and paths of the modules that you
are going to debug.  Then you run it from the toplevel directory of
your UML pool and it basically tells you what to do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            ******** GDB pid is 21903 ********
Start UML as: ./linux &lt;kernel switches&gt; debug gdb-pid=21903



GNU gdb 5.0rh-5 Red Hat Linux 7.1
Copyright 2001 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &quot;show copying&quot; to see the conditions.
There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.
This GDB was configured as &quot;i386-redhat-linux&quot;...
(gdb) b sys_init_module
Breakpoint 1 at 0xa0011923: file module.c, line 349.
(gdb) att 1
</pre></div>
</div>
<p>After you run UML and it sits there doing nothing, you hit return at
the ‘att 1’ and continue it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Attaching to program: /home/jdike/linux/2.4/um/./linux, process 1
0xa00f4221 in __kill ()
(UML gdb)  c
Continuing.
</pre></div>
</div>
<p>At this point, you debug normally.  When you insmod something, the
expect magic will kick in and you’ll see something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> *** Module hostfs loaded ***
Breakpoint 1, sys_init_module (name_user=0x805abb0 &quot;hostfs&quot;,
    mod_user=0x8070e00) at module.c:349
349             char *name, *n_name, *name_tmp = NULL;
(UML gdb)  finish
Run till exit from #0  sys_init_module (name_user=0x805abb0 &quot;hostfs&quot;,
    mod_user=0x8070e00) at module.c:349
0xa00e2e23 in execute_syscall (r=0xa8140284) at syscall_kern.c:411
411             else res = EXECUTE_SYSCALL(syscall, regs);
Value returned is $1 = 0
(UML gdb)
p/x (int)module_list + module_list-&gt;size_of_struct

$2 = 0xa9021054
(UML gdb)  symbol-file ./linux
Load new symbol table from &quot;./linux&quot;? (y or n) y
Reading symbols from ./linux...
done.
(UML gdb)
add-symbol-file /home/jdike/linux/2.4/um/arch/um/fs/hostfs/hostfs.o 0xa9021054

add symbol table from file &quot;/home/jdike/linux/2.4/um/arch/um/fs/hostfs/hostfs.o&quot; at
        .text_addr = 0xa9021054
 (y or n) y

Reading symbols from /home/jdike/linux/2.4/um/arch/um/fs/hostfs/hostfs.o...
done.
(UML gdb)  p *module_list
$1 = {size_of_struct = 84, next = 0xa0178720, name = 0xa9022de0 &quot;hostfs&quot;,
  size = 9016, uc = {usecount = {counter = 0}, pad = 0}, flags = 1,
  nsyms = 57, ndeps = 0, syms = 0xa9023170, deps = 0x0, refs = 0x0,
  init = 0xa90221f0 &lt;init_hostfs&gt;, cleanup = 0xa902222c &lt;exit_hostfs&gt;,
  ex_table_start = 0x0, ex_table_end = 0x0, persist_start = 0x0,
  persist_end = 0x0, can_unload = 0, runsize = 0, kallsyms_start = 0x0,
  kallsyms_end = 0x0,
  archdata_start = 0x1b855 &lt;Address 0x1b855 out of bounds&gt;,
  archdata_end = 0xe5890000 &lt;Address 0xe5890000 out of bounds&gt;,
  kernel_data = 0xf689c35d &lt;Address 0xf689c35d out of bounds&gt;}
&gt;&gt; Finished loading symbols for hostfs ...
</pre></div>
</div>
<p>That’s the easy way.  It’s highly recommended.  The hard way is
described below in case you’re interested in what’s going on.</p>
<p>Boot the kernel under the debugger and load the module with insmod or
modprobe.  With gdb, do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)  p module_list
</pre></div>
</div>
<p>This is a list of modules that have been loaded into the kernel, with
the most recently loaded module first.  Normally, the module you want
is at module_list.  If it’s not, walk down the next links, looking at
the name fields until find the module you want to debug.  Take the
address of that structure, and add module.size_of_struct (which in
2.4.10 kernels is 96 (0x60)) to it.  Gdb can make this hard addition
for you :-):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)
printf &quot;%#x\n&quot;, (int)module_list module_list-&gt;size_of_struct
</pre></div>
</div>
<p>The offset from the module start occasionally changes (before 2.4.0,
it was module.size_of_struct + 4), so it’s a good idea to check the
init and cleanup addresses once in a while, as describe below.  Now
do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)
add-symbol-file /path/to/module/on/host that_address
</pre></div>
</div>
<p>Tell gdb you really want to do it, and you’re in business.</p>
<p>If there’s any doubt that you got the offset right, like breakpoints
appear not to work, or they’re appearing in the wrong place, you can
check it by looking at the module structure.  The init and cleanup
fields should look like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>init = 0x588066b0 &lt;init_hostfs&gt;, cleanup = 0x588066c0 &lt;exit_hostfs&gt;
</pre></div>
</div>
<p>with no offsets on the symbol names.  If the names are right, but they
are offset, then the offset tells you how much you need to add to the
address you gave to add-symbol-file.</p>
<p>When you want to load in a new version of the module, you need to get
gdb to forget about the old one.  The only way I’ve found to do that
is to tell gdb to forget about all symbols that it knows about:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)  symbol-file
</pre></div>
</div>
<p>Then reload the symbols from the kernel binary:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)  symbol-file /path/to/kernel
</pre></div>
</div>
<p>and repeat the process above.  You’ll also need to re-enable break-
points.  They were disabled when you dumped all the symbols because
gdb couldn’t figure out where they should go.</p>
</div></blockquote>
</div>
<div class="section" id="attaching-gdb-to-the-kernel">
<h3>11.5.  Attaching gdb to the kernel<a class="headerlink" href="#attaching-gdb-to-the-kernel" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If you don’t have the kernel running under gdb, you can attach gdb to
it later by sending the tracing thread a SIGUSR1.  The first line of
the console output identifies its pid:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tracing thread pid = 20093
</pre></div>
</div>
<p>When you send it the signal:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% kill -USR1 20093
</pre></div>
</div>
<p>you will get an xterm with gdb running in it.</p>
<p>If you have the mconsole compiled into UML, then the mconsole client
can be used to start gdb:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(mconsole)  (mconsole) config gdb=xterm
</pre></div>
</div>
<p>will fire up an xterm with gdb running in it.</p>
</div></blockquote>
</div>
<div class="section" id="using-alternate-debuggers">
<h3>11.6.  Using alternate debuggers<a class="headerlink" href="#using-alternate-debuggers" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>UML has support for attaching to an already running debugger rather
than starting gdb itself.  This is present in CVS as of 17 Apr 2001.
I sent it to Alan for inclusion in the ac tree, and it will be in my
2.4.4 release.</p>
<p>This is useful when gdb is a subprocess of some UI, such as emacs or
ddd.  It can also be used to run debuggers other than gdb on UML.
Below is an example of using strace as an alternate debugger.</p>
<p>To do this, you need to get the pid of the debugger and pass it in
with the</p>
<p>If you are using gdb under some UI, then tell it to ‘att 1’, and
you’ll find yourself attached to UML.</p>
<p>If you are using something other than gdb as your debugger, then
you’ll need to get it to do the equivalent of ‘att 1’ if it doesn’t do
it automatically.</p>
<p>An example of an alternate debugger is strace.  You can strace the
actual kernel as follows:</p>
<ul>
<li><p class="first">Run the following in a shell:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host%
sh -c &#39;echo pid=$$; echo -n hit return; read x; exec strace -p 1 -o strace.out&#39;
</pre></div>
</div>
</li>
<li><p class="first">Run UML with ‘debug’ and ‘gdb-pid=&lt;pid&gt;’ with the pid printed out
by the previous command</p>
</li>
<li><p class="first">Hit return in the shell, and UML will start running, and strace
output will start accumulating in the output file.</p>
<p>Note that this is different from running:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% strace ./linux
</pre></div>
</div>
</li>
</ul>
<p>That will strace only the main UML thread, the tracing thread, which
doesn’t do any of the actual kernel work.  It just oversees the vir-
tual machine.  In contrast, using strace as described above will show
you the low-level activity of the virtual machine.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="kernel-debugging-examples">
<h2>12.  Kernel debugging examples<a class="headerlink" href="#kernel-debugging-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-case-of-the-hung-fsck">
<h3>12.1.  The case of the hung fsck<a class="headerlink" href="#the-case-of-the-hung-fsck" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>When booting up the kernel, fsck failed, and dropped me into a shell
to fix things up.  I ran fsck -y, which hung:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Setting hostname uml                    [ OK ]
Checking root filesystem
/dev/fhd0 was not cleanly unmounted, check forced.
Error reading block 86894 (Attempt to read block from filesystem resulted in short read) while reading indirect blocks of inode 19780.

/dev/fhd0: UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY.
        (i.e., without -a or -p options)
[ FAILED ]

*** An error occurred during the file system check.
*** Dropping you to a shell; the system will reboot
*** when you leave the shell.
Give root password for maintenance
(or type Control-D for normal startup):

[root@uml /root]# fsck -y /dev/fhd0
fsck -y /dev/fhd0
Parallelizing fsck version 1.14 (9-Jan-1999)
e2fsck 1.14, 9-Jan-1999 for EXT2 FS 0.5b, 95/08/09
/dev/fhd0 contains a file system with errors, check forced.
Pass 1: Checking inodes, blocks, and sizes
Error reading block 86894 (Attempt to read block from filesystem resulted in short read) while reading indirect blocks of inode 19780.  Ignore error? yes

Inode 19780, i_blocks is 1548, should be 540.  Fix? yes

Pass 2: Checking directory structure
Error reading block 49405 (Attempt to read block from filesystem resulted in short read).  Ignore error? yes

Directory inode 11858, block 0, offset 0: directory corrupted
Salvage? yes

Missing &#39;.&#39; in directory inode 11858.
Fix? yes

Missing &#39;..&#39; in directory inode 11858.
Fix? yes
</pre></div>
</div>
<p>The standard drill in this sort of situation is to fire up gdb on the
signal thread, which, in this case, was pid 1935.  In another window,
I run gdb and attach pid 1935:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>~/linux/2.3.26/um 1016: gdb linux
GNU gdb 4.17.0.11 with Linux support
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &quot;show copying&quot; to see the conditions.
There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.
This GDB was configured as &quot;i386-redhat-linux&quot;...

(gdb) att 1935
Attaching to program `/home/dike/linux/2.3.26/um/linux&#39;, Pid 1935
0x100756d9 in __wait4 ()
</pre></div>
</div>
<p>Let’s see what’s currently running:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p current_task.pid
$1 = 0
</pre></div>
</div>
<p>It’s the idle thread, which means that fsck went to sleep for some
reason and never woke up.</p>
<p>Let’s guess that the last process in the process list is fsck:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p current_task.prev_task.comm
$13 = &quot;fsck.ext2\000\000\000\000\000\000&quot;
</pre></div>
</div>
<p>It is, so let’s see what it thinks it’s up to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p current_task.prev_task.thread
$14 = {extern_pid = 1980, tracing = 0, want_tracing = 0, forking = 0,
  kernel_stack_page = 0, signal_stack = 1342627840, syscall = {id = 4, args = {
      3, 134973440, 1024, 0, 1024}, have_result = 0, result = 50590720},
  request = {op = 2, u = {exec = {ip = 1350467584, sp = 2952789424}, fork = {
        regs = {1350467584, 2952789424, 0 &lt;repeats 15 times&gt;}, sigstack = 0,
        pid = 0}, switch_to = 0x507e8000, thread = {proc = 0x507e8000,
        arg = 0xaffffdb0, flags = 0, new_pid = 0}, input_request = {
        op = 1350467584, fd = -1342177872, proc = 0, pid = 0}}}}
</pre></div>
</div>
<p>The interesting things here are the fact that its .thread.syscall.id
is __NR_write (see the big switch in arch/um/kernel/syscall_kern.c or
the defines in include/asm-um/arch/unistd.h), and that it never
returned.  Also, its .request.op is OP_SWITCH (see
arch/um/include/user_util.h).  These mean that it went into a write,
and, for some reason, called schedule().</p>
<p>The fact that it never returned from write means that its stack should
be fairly interesting.  Its pid is 1980 (.thread.extern_pid).  That
process is being ptraced by the signal thread, so it must be detached
before gdb can attach it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) call detach(1980)

Program received signal SIGSEGV, Segmentation fault.
&lt;function called from gdb&gt;
The program being debugged stopped while in a function called from GDB.
When the function (detach) is done executing, GDB will silently
stop (instead of continuing to evaluate the expression containing
the function call).
(gdb) call detach(1980)
$15 = 0
</pre></div>
</div>
<p>The first detach segfaults for some reason, and the second one
succeeds.</p>
<p>Now I detach from the signal thread, attach to the fsck thread, and
look at its stack:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) det
Detaching from program: /home/dike/linux/2.3.26/um/linux Pid 1935
(gdb) att 1980
Attaching to program `/home/dike/linux/2.3.26/um/linux&#39;, Pid 1980
0x10070451 in __kill ()
(gdb) bt
#0  0x10070451 in __kill ()
#1  0x10068ccd in usr1_pid (pid=1980) at process.c:30
#2  0x1006a03f in _switch_to (prev=0x50072000, next=0x507e8000)
    at process_kern.c:156
#3  0x1006a052 in switch_to (prev=0x50072000, next=0x507e8000, last=0x50072000)
    at process_kern.c:161
#4  0x10001d12 in schedule () at core.c:777
#5  0x1006a744 in __down (sem=0x507d241c) at semaphore.c:71
#6  0x1006aa10 in __down_failed () at semaphore.c:157
#7  0x1006c5d8 in segv_handler (sc=0x5006e940) at trap_user.c:174
#8  0x1006c5ec in kern_segv_handler (sig=11) at trap_user.c:182
#9  &lt;signal handler called&gt;
#10 0x10155404 in errno ()
#11 0x1006c0aa in segv (address=1342179328, is_write=2) at trap_kern.c:50
#12 0x1006c5d8 in segv_handler (sc=0x5006eaf8) at trap_user.c:174
#13 0x1006c5ec in kern_segv_handler (sig=11) at trap_user.c:182
#14 &lt;signal handler called&gt;
#15 0xc0fd in ?? ()
#16 0x10016647 in sys_write (fd=3,
    buf=0x80b8800 &lt;Address 0x80b8800 out of bounds&gt;, count=1024)
    at read_write.c:159
#17 0x1006d5b3 in execute_syscall (syscall=4, args=0x5006ef08)
    at syscall_kern.c:254
#18 0x1006af87 in really_do_syscall (sig=12) at syscall_user.c:35
#19 &lt;signal handler called&gt;
#20 0x400dc8b0 in ?? ()
</pre></div>
</div>
<p>The interesting things here are:</p>
<ul>
<li><p class="first">There are two segfaults on this stack (frames 9 and 14)</p>
</li>
<li><p class="first">The first faulting address (frame 11) is 0x50000800:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p (void *)1342179328
$16 = (void *) 0x50000800
</pre></div>
</div>
</li>
</ul>
<p>The initial faulting address is interesting because it is on the idle
thread’s stack.  I had been seeing the idle thread segfault for no
apparent reason, and the cause looked like stack corruption.  In hopes
of catching the culprit in the act, I had turned off all protections
to that stack while the idle thread wasn’t running.  This apparently
tripped that trap.</p>
<p>However, the more immediate problem is that second segfault and I’m
going to concentrate on that.  First, I want to see where the fault
happened, so I have to go look at the sigcontent struct in frame 8:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) up
#1  0x10068ccd in usr1_pid (pid=1980) at process.c:30
30        kill(pid, SIGUSR1);
(gdb)
#2  0x1006a03f in _switch_to (prev=0x50072000, next=0x507e8000)
    at process_kern.c:156
156       usr1_pid(getpid());
(gdb)
#3  0x1006a052 in switch_to (prev=0x50072000, next=0x507e8000, last=0x50072000)
    at process_kern.c:161
161       _switch_to(prev, next);
(gdb)
#4  0x10001d12 in schedule () at core.c:777
777             switch_to(prev, next, prev);
(gdb)
#5  0x1006a744 in __down (sem=0x507d241c) at semaphore.c:71
71                      schedule();
(gdb)
#6  0x1006aa10 in __down_failed () at semaphore.c:157
157     }
(gdb)
#7  0x1006c5d8 in segv_handler (sc=0x5006e940) at trap_user.c:174
174       segv(sc-&gt;cr2, sc-&gt;err &amp; 2);
(gdb)
#8  0x1006c5ec in kern_segv_handler (sig=11) at trap_user.c:182
182       segv_handler(sc);
(gdb) p *sc
Cannot access memory at address 0x0.
</pre></div>
</div>
<p>That’s not very useful, so I’ll try a more manual method:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p *((struct sigcontext *) (&amp;sig + 1))
$19 = {gs = 0, __gsh = 0, fs = 0, __fsh = 0, es = 43, __esh = 0, ds = 43,
  __dsh = 0, edi = 1342179328, esi = 1350378548, ebp = 1342630440,
  esp = 1342630420, ebx = 1348150624, edx = 1280, ecx = 0, eax = 0,
  trapno = 14, err = 4, eip = 268480945, cs = 35, __csh = 0, eflags = 66118,
  esp_at_signal = 1342630420, ss = 43, __ssh = 0, fpstate = 0x0, oldmask = 0,
  cr2 = 1280}
</pre></div>
</div>
<p>The ip is in handle_mm_fault:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p (void *)268480945
$20 = (void *) 0x1000b1b1
(gdb) i sym $20
handle_mm_fault + 57 in section .text
</pre></div>
</div>
<p>Specifically, it’s in pte_alloc:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) i line *$20
Line 124 of &quot;/home/dike/linux/2.3.26/um/include/asm/pgalloc.h&quot;
   starts at address 0x1000b1b1 &lt;handle_mm_fault+57&gt;
   and ends at 0x1000b1b7 &lt;handle_mm_fault+63&gt;.
</pre></div>
</div>
<p>To find where in handle_mm_fault this is, I’ll jump forward in the
code until I see an address in that procedure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) i line *0x1000b1c0
Line 126 of &quot;/home/dike/linux/2.3.26/um/include/asm/pgalloc.h&quot;
   starts at address 0x1000b1b7 &lt;handle_mm_fault+63&gt;
   and ends at 0x1000b1c3 &lt;handle_mm_fault+75&gt;.
(gdb) i line *0x1000b1d0
Line 131 of &quot;/home/dike/linux/2.3.26/um/include/asm/pgalloc.h&quot;
   starts at address 0x1000b1d0 &lt;handle_mm_fault+88&gt;
   and ends at 0x1000b1da &lt;handle_mm_fault+98&gt;.
(gdb) i line *0x1000b1e0
Line 61 of &quot;/home/dike/linux/2.3.26/um/include/asm/pgalloc.h&quot;
   starts at address 0x1000b1da &lt;handle_mm_fault+98&gt;
   and ends at 0x1000b1e1 &lt;handle_mm_fault+105&gt;.
(gdb) i line *0x1000b1f0
Line 134 of &quot;/home/dike/linux/2.3.26/um/include/asm/pgalloc.h&quot;
   starts at address 0x1000b1f0 &lt;handle_mm_fault+120&gt;
   and ends at 0x1000b200 &lt;handle_mm_fault+136&gt;.
(gdb) i line *0x1000b200
Line 135 of &quot;/home/dike/linux/2.3.26/um/include/asm/pgalloc.h&quot;
   starts at address 0x1000b200 &lt;handle_mm_fault+136&gt;
   and ends at 0x1000b208 &lt;handle_mm_fault+144&gt;.
(gdb) i line *0x1000b210
Line 139 of &quot;/home/dike/linux/2.3.26/um/include/asm/pgalloc.h&quot;
   starts at address 0x1000b210 &lt;handle_mm_fault+152&gt;
   and ends at 0x1000b219 &lt;handle_mm_fault+161&gt;.
(gdb) i line *0x1000b220
Line 1168 of &quot;memory.c&quot; starts at address 0x1000b21e &lt;handle_mm_fault+166&gt;
   and ends at 0x1000b222 &lt;handle_mm_fault+170&gt;.
</pre></div>
</div>
<p>Something is apparently wrong with the page tables or vma_structs, so
lets go back to frame 11 and have a look at them:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#11 0x1006c0aa in segv (address=1342179328, is_write=2) at trap_kern.c:50
50        handle_mm_fault(current, vma, address, is_write);
(gdb) call pgd_offset_proc(vma-&gt;vm_mm, address)
$22 = (pgd_t *) 0x80a548c
</pre></div>
</div>
<p>That’s pretty bogus.  Page tables aren’t supposed to be in process
text or data areas.  Let’s see what’s in the vma:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p *vma
$23 = {vm_mm = 0x507d2434, vm_start = 0, vm_end = 134512640,
  vm_next = 0x80a4f8c, vm_page_prot = {pgprot = 0}, vm_flags = 31200,
  vm_avl_height = 2058, vm_avl_left = 0x80a8c94, vm_avl_right = 0x80d1000,
  vm_next_share = 0xaffffdb0, vm_pprev_share = 0xaffffe63,
  vm_ops = 0xaffffe7a, vm_pgoff = 2952789626, vm_file = 0xafffffec,
  vm_private_data = 0x62}
(gdb) p *vma.vm_mm
$24 = {mmap = 0x507d2434, mmap_avl = 0x0, mmap_cache = 0x8048000,
  pgd = 0x80a4f8c, mm_users = {counter = 0}, mm_count = {counter = 134904288},
  map_count = 134909076, mmap_sem = {count = {counter = 135073792},
    sleepers = -1342177872, wait = {lock = &lt;optimized out or zero length&gt;,
      task_list = {next = 0xaffffe63, prev = 0xaffffe7a},
      __magic = -1342177670, __creator = -1342177300}, __magic = 98},
  page_table_lock = {}, context = 138, start_code = 0, end_code = 0,
  start_data = 0, end_data = 0, start_brk = 0, brk = 0, start_stack = 0,
  arg_start = 0, arg_end = 0, env_start = 0, env_end = 0, rss = 1350381536,
  total_vm = 0, locked_vm = 0, def_flags = 0, cpu_vm_mask = 0, swap_cnt = 0,
  swap_address = 0, segments = 0x0}
</pre></div>
</div>
<p>This also pretty bogus.  With all of the 0x80xxxxx and 0xaffffxxx
addresses, this is looking like a stack was plonked down on top of
these structures.  Maybe it’s a stack overflow from the next page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p vma
$25 = (struct vm_area_struct *) 0x507d2434
</pre></div>
</div>
<p>That’s towards the lower quarter of the page, so that would have to
have been pretty heavy stack overflow:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) x/100x $25
0x507d2434:     0x507d2434      0x00000000      0x08048000      0x080a4f8c
0x507d2444:     0x00000000      0x080a79e0      0x080a8c94      0x080d1000
0x507d2454:     0xaffffdb0      0xaffffe63      0xaffffe7a      0xaffffe7a
0x507d2464:     0xafffffec      0x00000062      0x0000008a      0x00000000
0x507d2474:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2484:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2494:     0x00000000      0x00000000      0x507d2fe0      0x00000000
0x507d24a4:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d24b4:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d24c4:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d24d4:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d24e4:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d24f4:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2504:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2514:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2524:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2534:     0x00000000      0x00000000      0x507d25dc      0x00000000
0x507d2544:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2554:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2564:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2574:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2584:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d2594:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d25a4:     0x00000000      0x00000000      0x00000000      0x00000000
0x507d25b4:     0x00000000      0x00000000      0x00000000      0x00000000
</pre></div>
</div>
<p>It’s not stack overflow.  The only “stack-like” piece of this data is
the vma_struct itself.</p>
<p>At this point, I don’t see any avenues to pursue, so I just have to
admit that I have no idea what’s going on.  What I will do, though, is
stick a trap on the segfault handler which will stop if it sees any
writes to the idle thread’s stack.  That was the thing that happened
first, and it may be that if I can catch it immediately, what’s going
on will be somewhat clearer.</p>
</div></blockquote>
</div>
<div class="section" id="episode-2-the-case-of-the-hung-fsck">
<h3>12.2.  Episode 2: The case of the hung fsck<a class="headerlink" href="#episode-2-the-case-of-the-hung-fsck" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>After setting a trap in the SEGV handler for accesses to the signal
thread’s stack, I reran the kernel.</p>
<p>fsck hung again, this time by hitting the trap:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Setting hostname uml                            [ OK ]
Checking root filesystem
/dev/fhd0 contains a file system with errors, check forced.
Error reading block 86894 (Attempt to read block from filesystem resulted in short read) while reading indirect blocks of inode 19780.

/dev/fhd0: UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY.
        (i.e., without -a or -p options)
[ FAILED ]

*** An error occurred during the file system check.
*** Dropping you to a shell; the system will reboot
*** when you leave the shell.
Give root password for maintenance
(or type Control-D for normal startup):

[root@uml /root]# fsck -y /dev/fhd0
fsck -y /dev/fhd0
Parallelizing fsck version 1.14 (9-Jan-1999)
e2fsck 1.14, 9-Jan-1999 for EXT2 FS 0.5b, 95/08/09
/dev/fhd0 contains a file system with errors, check forced.
Pass 1: Checking inodes, blocks, and sizes
Error reading block 86894 (Attempt to read block from filesystem resulted in short read) while reading indirect blocks of inode 19780.  Ignore error? yes

Pass 2: Checking directory structure
Error reading block 49405 (Attempt to read block from filesystem resulted in short read).  Ignore error? yes

Directory inode 11858, block 0, offset 0: directory corrupted
Salvage? yes

Missing &#39;.&#39; in directory inode 11858.
Fix? yes

Missing &#39;..&#39; in directory inode 11858.
Fix? yes

Untested (4127) [100fe44c]: trap_kern.c line 31
</pre></div>
</div>
<p>I need to get the signal thread to detach from pid 4127 so that I can
attach to it with gdb.  This is done by sending it a SIGUSR1, which is
caught by the signal thread, which detaches the process:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kill -USR1 4127
</pre></div>
</div>
<p>Now I can run gdb on it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>~/linux/2.3.26/um 1034: gdb linux
GNU gdb 4.17.0.11 with Linux support
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &quot;show copying&quot; to see the conditions.
There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.
This GDB was configured as &quot;i386-redhat-linux&quot;...
(gdb) att 4127
Attaching to program `/home/dike/linux/2.3.26/um/linux&#39;, Pid 4127
0x10075891 in __libc_nanosleep ()
</pre></div>
</div>
<p>The backtrace shows that it was in a write and that the fault address
(address in frame 3) is 0x50000800, which is right in the middle of
the signal thread’s stack page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) bt
#0  0x10075891 in __libc_nanosleep ()
#1  0x1007584d in __sleep (seconds=1000000)
    at ../sysdeps/unix/sysv/linux/sleep.c:78
#2  0x1006ce9a in stop () at user_util.c:191
#3  0x1006bf88 in segv (address=1342179328, is_write=2) at trap_kern.c:31
#4  0x1006c628 in segv_handler (sc=0x5006eaf8) at trap_user.c:174
#5  0x1006c63c in kern_segv_handler (sig=11) at trap_user.c:182
#6  &lt;signal handler called&gt;
#7  0xc0fd in ?? ()
#8  0x10016647 in sys_write (fd=3, buf=0x80b8800 &quot;R.&quot;, count=1024)
    at read_write.c:159
#9  0x1006d603 in execute_syscall (syscall=4, args=0x5006ef08)
    at syscall_kern.c:254
#10 0x1006af87 in really_do_syscall (sig=12) at syscall_user.c:35
#11 &lt;signal handler called&gt;
#12 0x400dc8b0 in ?? ()
#13 &lt;signal handler called&gt;
#14 0x400dc8b0 in ?? ()
#15 0x80545fd in ?? ()
#16 0x804daae in ?? ()
#17 0x8054334 in ?? ()
#18 0x804d23e in ?? ()
#19 0x8049632 in ?? ()
#20 0x80491d2 in ?? ()
#21 0x80596b5 in ?? ()
(gdb) p (void *)1342179328
$3 = (void *) 0x50000800
</pre></div>
</div>
<p>Going up the stack to the segv_handler frame and looking at where in
the code the access happened shows that it happened near line 110 of
block_dev.c:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) up
#1  0x1007584d in __sleep (seconds=1000000)
    at ../sysdeps/unix/sysv/linux/sleep.c:78
../sysdeps/unix/sysv/linux/sleep.c:78: No such file or directory.
(gdb)
#2  0x1006ce9a in stop () at user_util.c:191
191       while(1) sleep(1000000);
(gdb)
#3  0x1006bf88 in segv (address=1342179328, is_write=2) at trap_kern.c:31
31          KERN_UNTESTED();
(gdb)
#4  0x1006c628 in segv_handler (sc=0x5006eaf8) at trap_user.c:174
174       segv(sc-&gt;cr2, sc-&gt;err &amp; 2);
(gdb) p *sc
$1 = {gs = 0, __gsh = 0, fs = 0, __fsh = 0, es = 43, __esh = 0, ds = 43,
    __dsh = 0, edi = 1342179328, esi = 134973440, ebp = 1342631484,
    esp = 1342630864, ebx = 256, edx = 0, ecx = 256, eax = 1024, trapno = 14,
    err = 6, eip = 268550834, cs = 35, __csh = 0, eflags = 66070,
    esp_at_signal = 1342630864, ss = 43, __ssh = 0, fpstate = 0x0, oldmask = 0,
    cr2 = 1342179328}
(gdb) p (void *)268550834
$2 = (void *) 0x1001c2b2
(gdb) i sym $2
block_write + 1090 in section .text
(gdb) i line *$2
Line 209 of &quot;/home/dike/linux/2.3.26/um/include/asm/arch/string.h&quot;
    starts at address 0x1001c2a1 &lt;block_write+1073&gt;
    and ends at 0x1001c2bf &lt;block_write+1103&gt;.
(gdb) i line *0x1001c2c0
Line 110 of &quot;block_dev.c&quot; starts at address 0x1001c2bf &lt;block_write+1103&gt;
    and ends at 0x1001c2e3 &lt;block_write+1139&gt;.
</pre></div>
</div>
<p>Looking at the source shows that the fault happened during a call to
copy_from_user to copy the data into the kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>107             count -= chars;
108             copy_from_user(p,buf,chars);
109             p += chars;
110             buf += chars;
</pre></div>
</div>
<p>p is the pointer which must contain 0x50000800, since buf contains
0x80b8800 (frame 8 above).  It is defined as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>p = offset + bh-&gt;b_data;
</pre></div>
</div>
<p>I need to figure out what bh is, and it just so happens that bh is
passed as an argument to mark_buffer_uptodate and mark_buffer_dirty a
few lines later, so I do a little disassembly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) disas 0x1001c2bf 0x1001c2e0
Dump of assembler code from 0x1001c2bf to 0x1001c2d0:
0x1001c2bf &lt;block_write+1103&gt;:  addl   %eax,0xc(%ebp)
0x1001c2c2 &lt;block_write+1106&gt;:  movl   0xfffffdd4(%ebp),%edx
0x1001c2c8 &lt;block_write+1112&gt;:  btsl   $0x0,0x18(%edx)
0x1001c2cd &lt;block_write+1117&gt;:  btsl   $0x1,0x18(%edx)
0x1001c2d2 &lt;block_write+1122&gt;:  sbbl   %ecx,%ecx
0x1001c2d4 &lt;block_write+1124&gt;:  testl  %ecx,%ecx
0x1001c2d6 &lt;block_write+1126&gt;:  jne    0x1001c2e3 &lt;block_write+1139&gt;
0x1001c2d8 &lt;block_write+1128&gt;:  pushl  $0x0
0x1001c2da &lt;block_write+1130&gt;:  pushl  %edx
0x1001c2db &lt;block_write+1131&gt;:  call   0x1001819c &lt;__mark_buffer_dirty&gt;
End of assembler dump.
</pre></div>
</div>
<p>At that point, bh is in %edx (address 0x1001c2da), which is calculated
at 0x1001c2c2 as %ebp + 0xfffffdd4, so I figure exactly what that is,
taking %ebp from the sigcontext_struct above:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p (void *)1342631484
$5 = (void *) 0x5006ee3c
(gdb) p 0x5006ee3c+0xfffffdd4
$6 = 1342630928
(gdb) p (void *)$6
$7 = (void *) 0x5006ec10
(gdb) p *((void **)$7)
$8 = (void *) 0x50100200
</pre></div>
</div>
<p>Now, I look at the structure to see what’s in it, and particularly,
what its b_data field contains:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p *((struct buffer_head *)0x50100200)
$13 = {b_next = 0x50289380, b_blocknr = 49405, b_size = 1024, b_list = 0,
  b_dev = 15872, b_count = {counter = 1}, b_rdev = 15872, b_state = 24,
  b_flushtime = 0, b_next_free = 0x501001a0, b_prev_free = 0x50100260,
  b_this_page = 0x501001a0, b_reqnext = 0x0, b_pprev = 0x507fcf58,
  b_data = 0x50000800 &quot;&quot;, b_page = 0x50004000,
  b_end_io = 0x10017f60 &lt;end_buffer_io_sync&gt;, b_dev_id = 0x0,
  b_rsector = 98810, b_wait = {lock = &lt;optimized out or zero length&gt;,
    task_list = {next = 0x50100248, prev = 0x50100248}, __magic = 1343226448,
    __creator = 0}, b_kiobuf = 0x0}
</pre></div>
</div>
<p>The b_data field is indeed 0x50000800, so the question becomes how
that happened.  The rest of the structure looks fine, so this probably
is not a case of data corruption.  It happened on purpose somehow.</p>
<p>The b_page field is a pointer to the page_struct representing the
0x50000000 page.  Looking at it shows the kernel’s idea of the state
of that page:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p *$13.b_page
$17 = {list = {next = 0x50004a5c, prev = 0x100c5174}, mapping = 0x0,
    index = 0, next_hash = 0x0, count = {counter = 1}, flags = 132, lru = {
    next = 0x50008460, prev = 0x50019350}, wait = {
    lock = &lt;optimized out or zero length&gt;, task_list = {next = 0x50004024,
        prev = 0x50004024}, __magic = 1342193708, __creator = 0},
    pprev_hash = 0x0, buffers = 0x501002c0, virtual = 1342177280,
    zone = 0x100c5160}
</pre></div>
</div>
<p>Some sanity-checking: the virtual field shows the “virtual” address of
this page, which in this kernel is the same as its “physical” address,
and the page_struct itself should be mem_map[0], since it represents
the first page of memory:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p (void *)1342177280
$18 = (void *) 0x50000000
(gdb) p mem_map
$19 = (mem_map_t *) 0x50004000
</pre></div>
</div>
<p>These check out fine.</p>
<p>Now to check out the page_struct itself.  In particular, the flags
field shows whether the page is considered free or not:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p (void *)132
$21 = (void *) 0x84
</pre></div>
</div>
<p>The “reserved” bit is the high bit, which is definitely not set, so
the kernel considers the signal stack page to be free and available to
be used.</p>
<p>At this point, I jump to conclusions and start looking at my early
boot code, because that’s where that page is supposed to be reserved.</p>
<p>In my setup_arch procedure, I have the following code which looks just
fine:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bootmap_size = init_bootmem(start_pfn, end_pfn - start_pfn);
free_bootmem(__pa(low_physmem) + bootmap_size, high_physmem - low_physmem);
</pre></div>
</div>
<p>Two stack pages have already been allocated, and low_physmem points to
the third page, which is the beginning of free memory.
The init_bootmem call declares the entire memory to the boot memory
manager, which marks it all reserved.  The free_bootmem call frees up
all of it, except for the first two pages.  This looks correct to me.</p>
<p>So, I decide to see init_bootmem run and make sure that it is marking
those first two pages as reserved.  I never get that far.</p>
<p>Stepping into init_bootmem, and looking at bootmem_map before looking
at what it contains shows the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p bootmem_map
$3 = (void *) 0x50000000
</pre></div>
</div>
<p>Aha!  The light dawns.  That first page is doing double duty as a
stack and as the boot memory map.  The last thing that the boot memory
manager does is to free the pages used by its memory map, so this page
is getting freed even its marked as reserved.</p>
<p>The fix was to initialize the boot memory manager before allocating
those two stack pages, and then allocate them through the boot memory
manager.  After doing this, and fixing a couple of subsequent buglets,
the stack corruption problem disappeared.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="what-to-do-when-uml-doesn-t-work">
<h2>13.  What to do when UML doesn’t work<a class="headerlink" href="#what-to-do-when-uml-doesn-t-work" title="Permalink to this headline">¶</a></h2>
<div class="section" id="strange-compilation-errors-when-you-build-from-source">
<h3>13.1.  Strange compilation errors when you build from source<a class="headerlink" href="#strange-compilation-errors-when-you-build-from-source" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>As of test11, it is necessary to have “ARCH=um” in the environment or
on the make command line for all steps in building UML, including
clean, distclean, or mrproper, config, menuconfig, or xconfig, dep,
and linux.  If you forget for any of them, the i386 build seems to
contaminate the UML build.  If this happens, start from scratch with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host%
make mrproper ARCH=um
</pre></div>
</div>
<p>and repeat the build process with ARCH=um on all the steps.</p>
<p>See <a class="reference internal" href="#compiling-the-kernel-and-modules"><span class="std std-ref">2.  Compiling the kernel and modules</span></a>  for more details.</p>
<p>Another cause of strange compilation errors is building UML in
/usr/src/linux.  If you do this, the first thing you need to do is
clean up the mess you made.  The /usr/src/linux/asm link will now
point to /usr/src/linux/asm-um.  Make it point back to
/usr/src/linux/asm-i386.  Then, move your UML pool someplace else and
build it there.  Also see below, where a more specific set of symptoms
is described.</p>
</div></blockquote>
</div>
<div class="section" id="a-variety-of-panics-and-hangs-with-tmp-on-a-reiserfs-filesystem">
<h3>13.3.  A variety of panics and hangs with /tmp on a reiserfs filesystem<a class="headerlink" href="#a-variety-of-panics-and-hangs-with-tmp-on-a-reiserfs-filesystem" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>I saw this on reiserfs 3.5.21 and it seems to be fixed in 3.5.27.
Panics preceded by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Detaching pid nnnn
</pre></div>
</div>
<p>are diagnostic of this problem.  This is a reiserfs bug which causes a
thread to occasionally read stale data from a mmapped page shared with
another thread.  The fix is to upgrade the filesystem or to have /tmp
be an ext2 filesystem.</p>
<p>13.4.  The compile fails with errors about conflicting types for
‘open’, ‘dup’, and ‘waitpid’</p>
<p>This happens when you build in /usr/src/linux.  The UML build makes
the include/asm link point to include/asm-um.  /usr/include/asm points
to /usr/src/linux/include/asm, so when that link gets moved, files
which need to include the asm-i386 versions of headers get the
incompatible asm-um versions.  The fix is to move the include/asm link
back to include/asm-i386 and to do UML builds someplace else.</p>
</div></blockquote>
</div>
<div class="section" id="uml-doesn-t-work-when-tmp-is-an-nfs-filesystem">
<h3>13.5.  UML doesn’t work when /tmp is an NFS filesystem<a class="headerlink" href="#uml-doesn-t-work-when-tmp-is-an-nfs-filesystem" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This seems to be a similar situation with the ReiserFS problem above.
Some versions of NFS seems not to handle mmap correctly, which UML
depends on.  The workaround is have /tmp be a non-NFS directory.</div></blockquote>
</div>
<div class="section" id="uml-hangs-on-boot-when-compiled-with-gprof-support">
<h3>13.6.  UML hangs on boot when compiled with gprof support<a class="headerlink" href="#uml-hangs-on-boot-when-compiled-with-gprof-support" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If you build UML with gprof support and, early in the boot, it does
this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kernel BUG at page_alloc.c:100!
</pre></div>
</div>
<p>you have a buggy gcc.  You can work around the problem by removing
UM_FASTCALL from CFLAGS in arch/um/Makefile-i386.  This will open up
another bug, but that one is fairly hard to reproduce.</p>
</div></blockquote>
</div>
<div class="section" id="syslogd-dies-with-a-sigterm-on-startup">
<h3>13.7.  syslogd dies with a SIGTERM on startup<a class="headerlink" href="#syslogd-dies-with-a-sigterm-on-startup" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The exact boot error depends on the distribution that you’re booting,
but Debian produces this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/etc/rc2.d/S10sysklogd: line 49:    93 Terminated
start-stop-daemon --start --quiet --exec /sbin/syslogd -- $SYSLOGD
</pre></div>
</div>
<p>This is a syslogd bug.  There’s a race between a parent process
installing a signal handler and its child sending the signal.</p>
</div></blockquote>
</div>
<div class="section" id="tun-tap-networking-doesn-t-work-on-a-2-4-host">
<h3>13.8.  TUN/TAP networking doesn’t work on a 2.4 host<a class="headerlink" href="#tun-tap-networking-doesn-t-work-on-a-2-4-host" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>There are a couple of problems which were reported by
Tim Robinson &lt;timro at trkr dot net&gt;</p>
<ul>
<li><p class="first">It doesn’t work on hosts running 2.4.7 (or thereabouts) or earlier.
The fix is to upgrade to something more recent and then read the
next item.</p>
</li>
<li><p class="first">If you see:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>File descriptor in bad state
</pre></div>
</div>
</li>
</ul>
<p>when you bring up the device inside UML, you have a header mismatch
between the original kernel and the upgraded one.  Make /usr/src/linux
point at the new headers.  This will only be a problem if you build
uml_net yourself.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="you-can-network-to-the-host-but-not-to-other-machines-on-the-net">
<h2>13.9.  You can network to the host but not to other machines on the net<a class="headerlink" href="#you-can-network-to-the-host-but-not-to-other-machines-on-the-net" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>If you can connect to the host, and the host can connect to UML, but
you cannot connect to any other machines, then you may need to enable
IP Masquerading on the host.  Usually this is only experienced when
using private IP addresses (192.168.x.x or 10.x.x.x) for host/UML
networking, rather than the public address space that your host is
connected to.  UML does not enable IP Masquerading, so you will need
to create a static rule to enable it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host%
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</pre></div>
</div>
<p>Replace eth0 with the interface that you use to talk to the rest of
the world.</p>
<p>Documentation on IP Masquerading, and SNAT, can be found at
<a class="reference external" href="http://www.netfilter.org">http://www.netfilter.org</a>.</p>
<p>If you can reach the local net, but not the outside Internet, then
that is usually a routing problem.  The UML needs a default route:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UML#
route add default gw gateway IP
</pre></div>
</div>
<p>The gateway IP can be any machine on the local net that knows how to
reach the outside world.  Usually, this is the host or the local net-
work’s gateway.</p>
<p>Occasionally, we hear from someone who can reach some machines, but
not others on the same net, or who can reach some ports on other
machines, but not others.  These are usually caused by strange
firewalling somewhere between the UML and the other box.  You track
this down by running tcpdump on every interface the packets travel
over and see where they disappear.  When you find a machine that takes
the packets in, but does not send them onward, that’s the culprit.</p>
</div></blockquote>
</div>
<div class="section" id="i-have-no-root-and-i-want-to-scream">
<h2>13.10.  I have no root and I want to scream<a class="headerlink" href="#i-have-no-root-and-i-want-to-scream" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Thanks to Birgit Wahlich for telling me about this strange one.  It
turns out that there’s a limit of six environment variables on the
kernel command line.  When that limit is reached or exceeded, argument
processing stops, which means that the ‘root=’ argument that UML
usually adds is not seen.  So, the filesystem has no idea what the
root device is, so it panics.</p>
<p>The fix is to put less stuff on the command line.  Glomming all your
setup variables into one is probably the best way to go.</p>
</div></blockquote>
</div>
<div class="section" id="uml-build-conflict-between-ptrace-h-and-ucontext-h">
<h2>13.11.  UML build conflict between ptrace.h and ucontext.h<a class="headerlink" href="#uml-build-conflict-between-ptrace-h-and-ucontext-h" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>On some older systems, /usr/include/asm/ptrace.h and
/usr/include/sys/ucontext.h define the same names.  So, when they’re
included together, the defines from one completely mess up the parsing
of the other, producing errors like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/usr/include/sys/ucontext.h:47: parse error before
`10`
</pre></div>
</div>
<p>plus a pile of warnings.</p>
<p>This is a libc botch, which has since been fixed, and I don’t see any
way around it besides upgrading.</p>
</div></blockquote>
<div class="section" id="the-uml-bogomips-is-exactly-half-the-host-s-bogomips">
<h3>13.12.  The UML BogoMips is exactly half the host’s BogoMips<a class="headerlink" href="#the-uml-bogomips-is-exactly-half-the-host-s-bogomips" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>On i386 kernels, there are two ways of running the loop that is used
to calculate the BogoMips rating, using the TSC if it’s there or using
a one-instruction loop.  The TSC produces twice the BogoMips as the
loop.  UML uses the loop, since it has nothing resembling a TSC, and
will get almost exactly the same BogoMips as a host using the loop.
However, on a host with a TSC, its BogoMips will be double the loop
BogoMips, and therefore double the UML BogoMips.</div></blockquote>
</div>
<div class="section" id="when-you-run-uml-it-immediately-segfaults">
<h3>13.13.  When you run UML, it immediately segfaults<a class="headerlink" href="#when-you-run-uml-it-immediately-segfaults" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>If the host is configured with the 2G/2G address space split, that’s
why.  See ref:<cite>UML_on_2G/2G_hosts</cite>  for the details on getting UML to
run on your host.</div></blockquote>
</div>
<div class="section" id="xterms-appear-then-immediately-disappear">
<h3>13.14.  xterms appear, then immediately disappear<a class="headerlink" href="#xterms-appear-then-immediately-disappear" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>If you’re running an up to date kernel with an old release of
uml_utilities, the port-helper program will not work properly, so
xterms will exit straight after they appear. The solution is to
upgrade to the latest release of uml_utilities.  Usually this problem
occurs when you have installed a packaged release of UML then compiled
your own development kernel without upgrading the uml_utilities from
the source distribution.</div></blockquote>
</div>
<div class="section" id="any-other-panic-hang-or-strange-behavior">
<h3>13.15.  Any other panic, hang, or strange behavior<a class="headerlink" href="#any-other-panic-hang-or-strange-behavior" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If you’re seeing truly strange behavior, such as hangs or panics that
happen in random places, or you try running the debugger to see what’s
happening and it acts strangely, then it could be a problem in the
host kernel.  If you’re not running a stock Linus or -ac kernel, then
try that.  An early version of the preemption patch and a 2.4.10 SuSE
kernel have caused very strange problems in UML.</p>
<p>Otherwise, let me know about it.  Send a message to one of the UML
mailing lists - either the developer list - user-mode-linux-devel at
lists dot sourceforge dot net (subscription info) or the user list -
user-mode-linux-user at lists dot sourceforge do net (subscription
info), whichever you prefer.  Don’t assume that everyone knows about
it and that a fix is imminent.</p>
<p>If you want to be super-helpful, read <a class="reference internal" href="#diagnosing-problems"><span class="std std-ref">14.  Diagnosing Problems</span></a> and
follow the instructions contained therein.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="diagnosing-problems">
<span id="id9"></span><h2>14.  Diagnosing Problems<a class="headerlink" href="#diagnosing-problems" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>If you get UML to crash, hang, or otherwise misbehave, you should
report this on one of the project mailing lists, either the developer
list - user-mode-linux-devel at lists dot sourceforge dot net
(subscription info) or the user list - user-mode-linux-user at lists
dot sourceforge dot net (subscription info).  When you do, it is
likely that I will want more information.  So, it would be helpful to
read the stuff below, do whatever is applicable in your case, and
report the results to the list.</p>
<p>For any diagnosis, you’re going to need to build a debugging kernel.
The binaries from this site aren’t debuggable.  If you haven’t done
this before, read about <a class="reference internal" href="#compiling-the-kernel-and-modules"><span class="std std-ref">2.  Compiling the kernel and modules</span></a>  and
<a class="reference internal" href="#kernel-debugging"><span class="std std-ref">11.  Kernel debugging</span></a> UML first.</p>
</div></blockquote>
<div class="section" id="case-1-normal-kernel-panics">
<h3>14.1.  Case 1 : Normal kernel panics<a class="headerlink" href="#case-1-normal-kernel-panics" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The most common case is for a normal thread to panic.  To debug this,
you will need to run it under the debugger (add ‘debug’ to the command
line).  An xterm will start up with gdb running inside it.  Continue
it when it stops in start_kernel and make it crash.  Now <code class="docutils literal notranslate"><span class="pre">^C</span> <span class="pre">gdb</span></code> and</p>
<p>If the panic was a “Kernel mode fault”, then there will be a segv
frame on the stack and I’m going to want some more information.  The
stack might look something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)  backtrace
#0  0x1009bf76 in __sigprocmask (how=1, set=0x5f347940, oset=0x0)
    at ../sysdeps/unix/sysv/linux/sigprocmask.c:49
#1  0x10091411 in change_sig (signal=10, on=1) at process.c:218
#2  0x10094785 in timer_handler (sig=26) at time_kern.c:32
#3  0x1009bf38 in __restore ()
    at ../sysdeps/unix/sysv/linux/i386/sigaction.c:125
#4  0x1009534c in segv (address=8, ip=268849158, is_write=2, is_user=0)
    at trap_kern.c:66
#5  0x10095c04 in segv_handler (sig=11) at trap_user.c:285
#6  0x1009bf38 in __restore ()
</pre></div>
</div>
<p>I’m going to want to see the symbol and line information for the value
of ip in the segv frame.  In this case, you would do the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)  i sym 268849158
</pre></div>
</div>
<p>and:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(UML gdb)  i line *268849158
</pre></div>
</div>
<p>The reason for this is the __restore frame right above the segv_han-
dler frame is hiding the frame that actually segfaulted.  So, I have
to get that information from the faulting ip.</p>
</div></blockquote>
</div>
<div class="section" id="case-2-tracing-thread-panics">
<h3>14.2.  Case 2 : Tracing thread panics<a class="headerlink" href="#case-2-tracing-thread-panics" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The less common and more painful case is when the tracing thread
panics.  In this case, the kernel debugger will be useless because it
needs a healthy tracing thread in order to work.  The first thing to
do is get a backtrace from the tracing thread.  This is done by
figuring out what its pid is, firing up gdb, and attaching it to that
pid.  You can figure out the tracing thread pid by looking at the
first line of the console output, which will look like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tracing thread pid = 15851
</pre></div>
</div>
<p>or by running ps on the host and finding the line that looks like
this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>jdike 15851 4.5 0.4 132568 1104 pts/0 S 21:34 0:05 ./linux [(tracing thread)]
</pre></div>
</div>
<p>If the panic was ‘segfault in signals’, then follow the instructions
above for collecting information about the location of the seg fault.</p>
<p>If the tracing thread flaked out all by itself, then send that
backtrace in and wait for our crack debugging team to fix the problem.</p>
<p>14.3.  Case 3 : Tracing thread panics caused by other threads</p>
<p>However, there are cases where the misbehavior of another thread
caused the problem.  The most common panic of this type is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>wait_for_stop failed to wait for  &lt;pid&gt;  to stop with  &lt;signal number&gt;
</pre></div>
</div>
<p>In this case, you’ll need to get a backtrace from the process men-
tioned in the panic, which is complicated by the fact that the kernel
debugger is defunct and without some fancy footwork, another gdb can’t
attach to it.  So, this is how the fancy footwork goes:</p>
<p>In a shell:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host% kill -STOP pid
</pre></div>
</div>
<p>Run gdb on the tracing thread as described in case 2 and do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(host gdb)  call detach(pid)
</pre></div>
</div>
<p>If you get a segfault, do it again.  It always works the second time.</p>
<p>Detach from the tracing thread and attach to that other thread:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(host gdb)  detach






(host gdb)  attach pid
</pre></div>
</div>
<p>If gdb hangs when attaching to that process, go back to a shell and
do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host%
kill -CONT pid
</pre></div>
</div>
<p>And then get the backtrace:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(host gdb)  backtrace
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="case-4-hangs">
<h3>14.4.  Case 4 : Hangs<a class="headerlink" href="#case-4-hangs" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Hangs seem to be fairly rare, but they sometimes happen.  When a hang
happens, we need a backtrace from the offending process.  Run the
kernel debugger as described in case 1 and get a backtrace.  If the
current process is not the idle thread, then send in the backtrace.
You can tell that it’s the idle thread if the stack looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#0  0x100b1401 in __libc_nanosleep ()
#1  0x100a2885 in idle_sleep (secs=10) at time.c:122
#2  0x100a546f in do_idle () at process_kern.c:445
#3  0x100a5508 in cpu_idle () at process_kern.c:471
#4  0x100ec18f in start_kernel () at init/main.c:592
#5  0x100a3e10 in start_kernel_proc (unused=0x0) at um_arch.c:71
#6  0x100a383f in signal_tramp (arg=0x100a3dd8) at trap_user.c:50
</pre></div>
</div>
<p>If this is the case, then some other process is at fault, and went to
sleep when it shouldn’t have.  Run ps on the host and figure out which
process should not have gone to sleep and stayed asleep.  Then attach
to it with gdb and get a backtrace as described in case 3.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="thanks">
<h2>15.  Thanks<a class="headerlink" href="#thanks" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A number of people have helped this project in various ways, and this
page gives recognition where recognition is due.</p>
<p>If you’re listed here and you would prefer a real link on your name,
or no link at all, instead of the despammed email address pseudo-link,
let me know.</p>
<p>If you’re not listed here and you think maybe you should be, please
let me know that as well.  I try to get everyone, but sometimes my
bookkeeping lapses and I forget about contributions.</p>
</div></blockquote>
<div class="section" id="code-and-documentation">
<h3>15.1.  Code and Documentation<a class="headerlink" href="#code-and-documentation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Rusty Russell &lt;rusty at linuxcare.com.au&gt;  -</p>
<ul class="simple">
<li>wrote the  HOWTO
<a class="reference external" href="http://user-mode-linux.sourceforge.net/old/UserModeLinux-HOWTO.html">http://user-mode-linux.sourceforge.net/old/UserModeLinux-HOWTO.html</a></li>
<li>prodded me into making this project official and putting it on
SourceForge</li>
<li>came up with the way cool UML logo
<a class="reference external" href="http://user-mode-linux.sourceforge.net/uml-small.png">http://user-mode-linux.sourceforge.net/uml-small.png</a></li>
<li>redid the config process</li>
</ul>
<p>Peter Moulder &lt;reiter at netspace.net.au&gt;  - Fixed my config and build
processes, and added some useful code to the block driver</p>
<p>Bill Stearns &lt;wstearns at pobox.com&gt;  -</p>
<ul class="simple">
<li>HOWTO updates</li>
<li>lots of bug reports</li>
<li>lots of testing</li>
<li>dedicated a box (uml.ists.dartmouth.edu) to support UML development</li>
<li>wrote the mkrootfs script, which allows bootable filesystems of
RPM-based distributions to be cranked out</li>
<li>cranked out a large number of filesystems with said script</li>
</ul>
<p>Jim Leu &lt;jleu at mindspring.com&gt;  - Wrote the virtual ethernet driver
and associated usermode tools</p>
<p>Lars Brinkhoff <a class="reference external" href="http://lars.nocrew.org/">http://lars.nocrew.org/</a>  - Contributed the ptrace
proxy from his own  project to allow easier kernel debugging</p>
<p>Andrea Arcangeli &lt;andrea at suse.de&gt;  - Redid some of the early boot
code so that it would work on machines with Large File Support</p>
<p>Chris Emerson - Did the first UML port to Linux/ppc</p>
<p>Harald Welte &lt;laforge at gnumonks.org&gt;  - Wrote the multicast
transport for the network driver</p>
<p>Jorgen Cederlof - Added special file support to hostfs</p>
<p>Greg Lonnon  &lt;glonnon at ridgerun dot com&gt;  - Changed the ubd driver
to allow it to layer a COW file on a shared read-only filesystem and
wrote the iomem emulation support</p>
<p>Henrik Nordstrom <a class="reference external" href="http://hem.passagen.se/hno/">http://hem.passagen.se/hno/</a>  - Provided a variety
of patches, fixes, and clues</p>
<p>Lennert Buytenhek - Contributed various patches, a rewrite of the
network driver, the first implementation of the mconsole driver, and
did the bulk of the work needed to get SMP working again.</p>
<p>Yon Uriarte - Fixed the TUN/TAP network backend while I slept.</p>
<p>Adam Heath - Made a bunch of nice cleanups to the initialization code,
plus various other small patches.</p>
<p>Matt Zimmerman - Matt volunteered to be the UML Debian maintainer and
is doing a real nice job of it.  He also noticed and fixed a number of
actually and potentially exploitable security holes in uml_net.  Plus
the occasional patch.  I like patches.</p>
<p>James McMechan - James seems to have taken over maintenance of the ubd
driver and is doing a nice job of it.</p>
<p>Chandan Kudige - wrote the umlgdb script which automates the reloading
of module symbols.</p>
<p>Steve Schmidtke - wrote the UML slirp transport and hostaudio drivers,
enabling UML processes to access audio devices on the host. He also
submitted patches for the slip transport and lots of other things.</p>
<p>David Coulson <a class="reference external" href="http://davidcoulson.net">http://davidcoulson.net</a>  -</p>
<ul class="simple">
<li>Set up the <a class="reference external" href="http://usermodelinux.org">http://usermodelinux.org</a>  site,
which is a great way of keeping the UML user community on top of
UML goings-on.</li>
<li>Site documentation and updates</li>
<li>Nifty little UML management daemon  UMLd</li>
<li>Lots of testing and bug reports</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="flushing-out-bugs">
<h3>15.2.  Flushing out bugs<a class="headerlink" href="#flushing-out-bugs" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>Yuri Pudgorodsky</li>
<li>Gerald Britton</li>
<li>Ian Wehrman</li>
<li>Gord Lamb</li>
<li>Eugene Koontz</li>
<li>John H. Hartman</li>
<li>Anders Karlsson</li>
<li>Daniel Phillips</li>
<li>John Fremlin</li>
<li>Rainer Burgstaller</li>
<li>James Stevenson</li>
<li>Matt Clay</li>
<li>Cliff Jefferies</li>
<li>Geoff Hoff</li>
<li>Lennert Buytenhek</li>
<li>Al Viro</li>
<li>Frank Klingenhoefer</li>
<li>Livio Baldini Soares</li>
<li>Jon Burgess</li>
<li>Petru Paler</li>
<li>Paul</li>
<li>Chris Reahard</li>
<li>Sverker Nilsson</li>
<li>Gong Su</li>
<li>johan verrept</li>
<li>Bjorn Eriksson</li>
<li>Lorenzo Allegrucci</li>
<li>Muli Ben-Yehuda</li>
<li>David Mansfield</li>
<li>Howard Goff</li>
<li>Mike Anderson</li>
<li>John Byrne</li>
<li>Sapan J. Batia</li>
<li>Iris Huang</li>
<li>Jan Hudec</li>
<li>Voluspa</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="buglets-and-clean-ups">
<h3>15.3.  Buglets and clean-ups<a class="headerlink" href="#buglets-and-clean-ups" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>Dave Zarzycki</li>
<li>Adam Lazur</li>
<li>Boria Feigin</li>
<li>Brian J. Murrell</li>
<li>JS</li>
<li>Roman Zippel</li>
<li>Wil Cooley</li>
<li>Ayelet Shemesh</li>
<li>Will Dyson</li>
<li>Sverker Nilsson</li>
<li>dvorak</li>
<li>v.naga srinivas</li>
<li>Shlomi Fish</li>
<li>Roger Binns</li>
<li>johan verrept</li>
<li>MrChuoi</li>
<li>Peter Cleve</li>
<li>Vincent Guffens</li>
<li>Nathan Scott</li>
<li>Patrick Caulfield</li>
<li>jbearce</li>
<li>Catalin Marinas</li>
<li>Shane Spencer</li>
<li>Zou Min</li>
<li>Ryan Boder</li>
<li>Lorenzo Colitti</li>
<li>Gwendal Grignou</li>
<li>Andre’ Breiler</li>
<li>Tsutomu Yasuda</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="case-studies">
<h3>15.4.  Case Studies<a class="headerlink" href="#case-studies" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>Jon Wright</li>
<li>William McEwan</li>
<li>Michael Richardson</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="other-contributions">
<h3>15.5.  Other contributions<a class="headerlink" href="#other-contributions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Bill Carr &lt;Bill.Carr at compaq.com&gt;  made the Red Hat mkrootfs script
work with RH 6.2.</p>
<p>Michael Jennings &lt;mikejen at hevanet.com&gt;  sent in some material which
is now gracing the top of the  index  page
<a class="reference external" href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</a>  of this site.</p>
<p>SGI (and more specifically Ralf Baechle &lt;ralf at
uni-koblenz.de&gt; ) gave me an account on oss.sgi.com.
The bandwidth there made it possible to
produce most of the filesystems available on the project download
page.</p>
<p>Laurent Bonnaud &lt;Laurent.Bonnaud at inpg.fr&gt;  took the old grotty
Debian filesystem that I’ve been distributing and updated it to 2.2.
It is now available by itself here.</p>
<p>Rik van Riel gave me some ftp space on ftp.nl.linux.org so I can make
releases even when Sourceforge is broken.</p>
<p>Rodrigo de Castro looked at my broken pte code and told me what was
wrong with it, letting me fix a long-standing (several weeks) and
serious set of bugs.</p>
<p>Chris Reahard built a specialized root filesystem for running a DNS
server jailed inside UML.  It’s available from the download
<a class="reference external" href="http://user-mode-linux.sourceforge.net/old/dl-sf.html">http://user-mode-linux.sourceforge.net/old/dl-sf.html</a>  page in the Jail
Filesystems section.</p>
</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>